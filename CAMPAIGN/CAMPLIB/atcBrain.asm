; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\CAMPAIGN\CAMPLIB\atcBrain.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B ; std::ios_base::failure::_Stream_err
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
_DATA	SEGMENT
_matrix33_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	ORG $+4
_cloudPntList DD 0c5bcc000r			; -6040
	DD	0c4070000r			; -540
	DD	0c694ac00r			; -19030
	DD	0c6de1c00r			; -28430
	DD	0c4dfc000r			; -1790
	DD	046dcc800r			; 28260
	DD	047104200r			; 36930
	DD	045732000r			; 3890
	DD	04744ea00r			; 50410
	DD	045336000r			; 2870
	DD	0c4d48000r			; -1700
	DD	04736da00r			; 46810
	DD	0c763ee00r			; -58350
	DD	0c4d48000r			; -1700
	DD	0c64c1000r			; -13060
	DD	046f2bc00r			; 31070
	DD	045480000r			; 3200
	DD	0c7293800r			; -43320
	DD	0c7bdc400r			; -97160
	DD	0c4d48000r			; -1700
	DD	04576e000r			; 3950
	DD	0c792e000r			; -75200
	DD	0c4bb8000r			; -1500
	DD	047957400r			; 76520
	DD	04759ee00r			; 55790
	DD	0c5a1e000r			; -5180
	DD	0c7a24e00r			; -83100
	DD	0c7473800r			; -51000
	DD	0c3a00000r			; -320
	DD	0c7829100r			; -66850
	DD	047733400r			; 62260
	DD	0c3a00000r			; -320
	DD	047708200r			; 61570
	DD	0c7710e00r			; -61710
	DD	0c550c000r			; -3340
	DD	046fb7c00r			; 32190
	DD	0c7719a00r			; -61850
	DD	0c7483200r			; -51250
	DD	047543a00r			; 54330
	DD	0c5bcc000r			; -6040
	DD	0c7495400r			; -51540
	DD	0c694ac00r			; -19030
	DD	0c6a7a800r			; -21460
	DD	0c74b0200r			; -51970
	DD	0468e8000r			; 18240
	DD	047298800r			; 43400
	DD	0c74bf200r			; -52210
	DD	046bc7000r			; 24120
	DD	0c749f400r			; -51700
	DD	0c74bc000r			; -52160
	DD	046948400r			; 19010
	DD	0c605e800r			; -8570
	DD	0c7488200r			; -51330
	DD	0c74ca600r			; -52390
	DD	04731bc00r			; 45500
	DD	0c7509800r			; -53400
	DD	0c6725800r			; -15510
	DD	0c7719a00r			; -61850
	DD	0c7483200r			; -51250
	DD	047543a00r			; 54330
	DD	047553400r			; 54580
	DD	0c74ddc00r			; -52700
	DD	0479a5600r			; 79020
	DD	047a7e400r			; 85960
	DD	0c74c5600r			; -52310
	DD	0477d4800r			; 64840
	DD	0c7c44500r			; -100490
	DD	0c74d1400r			; -52500
	DD	047ac2600r			; 88140
	DD	0c7a1ae00r			; -82780
	DD	0c749ea00r			; -51690
	DD	0c7bce300r			; -96710
	DD	0c6126800r			; -9370
	DD	0c7495400r			; -51540
	DD	043cd0000r			; 410
	DD	0c6a7a800r			; -21460
	DD	0c74a8a00r			; -51850
	DD	0473fae00r			; 49070
	DD	0457c8000r			; 4040
	DD	0c74e4a00r			; -52810
	DD	047871e00r			; 69180
	DD	0c6cbc000r			; -26080
	DD	0c74bc000r			; -52160
	DD	046984400r			; 19490
	DD	0452fa000r			; 2810
	DD	0c7488200r			; -51330
	DD	0c7081800r			; -34840
	DD	0c7719a00r			; -61850
	DD	0c749d600r			; -51670
	DD	047b17600r			; 90860
	DD	047553400r			; 54580
	DD	0c74ddc00r			; -52700
	DD	0479a5600r			; 79020
	DD	047a7e400r			; 85960
	DD	0c74c5600r			; -52310
	DD	0477d4800r			; 64840
	DD	0c7c44500r			; -100490
	DD	0c74d1400r			; -52500
	DD	047ac2600r			; 88140
	DD	047c04e00r			; 98460
	DD	0c74d1400r			; -52500
	DD	0c732a200r			; -45730
	DD	0467b9000r			; 16100
	DD	0c7487800r			; -51320
	DD	0c749a400r			; -51620
	DD	047636c00r			; 58220
	DD	0c74e0400r			; -52740
	DD	0c760b000r			; -57520
	DD	0c6126800r			; -9370
	DD	0c4070000r			; -540
	DD	043cd0000r			; 410
	DD	0c4e60000r			; -1840
	DD	0c6a30c00r			; -20870
	DD	0470a6600r			; 35430
	DD	0c7230c00r			; -41740
	DD	046924000r			; 18720
	DD	04797d600r			; 77740
	DD	0460d9000r			; 9060
	DD	0c616c800r			; -9650
	DD	0c7921300r			; -74790
_lightningPosList DD 041300000r			; 11
	DD	000000000r			; 0
	DD	040e00000r			; 7
	DD	040a00000r			; 5
	DD	041100000r			; 9
	DD	041000000r			; 8
	DD	041000000r			; 8
	DD	041600000r			; 14
	DD	041800000r			; 16
	DD	041a00000r			; 20
	DD	041200000r			; 10
	DD	041c00000r			; 24
	DD	041300000r			; 11
	DD	041d80000r			; 27
	DD	040c00000r			; 6
	DD	041f00000r			; 30
	DD	040e00000r			; 7
	DD	042040000r			; 33
	DD	03f800000r			; 1
	DD	042180000r			; 38
	DD	040a00000r			; 5
	DD	042280000r			; 42
	DD	040a00000r			; 5
	DD	042340000r			; 45
	DD	041400000r			; 12
	DD	042400000r			; 48
	DD	041a00000r			; 20
	DD	042500000r			; 52
	DD	041a00000r			; 20
	DD	042680000r			; 58
	DD	041b80000r			; 23
	DD	042740000r			; 61
	DD	041b00000r			; 22
	DD	0427c0000r			; 63
	DD	041b00000r			; 22
	DD	042840000r			; 66
	DD	041c80000r			; 25
	DD	042880000r			; 68
	DD	041a00000r			; 20
	DD	0428c0000r			; 70
	DD	041c00000r			; 24
	DD	042960000r			; 75
	DD	041c00000r			; 24
	DD	0429a0000r			; 77
	DD	041f80000r			; 31
	DD	042a00000r			; 80
	DD	041f80000r			; 31
	DD	042a60000r			; 83
	DD	042040000r			; 33
	DD	042b00000r			; 88
	DD	041f80000r			; 31
	DD	042b80000r			; 92
	DD	0423c0000r			; 47
	DD	042ce0000r			; 103
	DD	042380000r			; 46
	DD	042d20000r			; 105
	DD	0423c0000r			; 47
	DD	042d60000r			; 107
	DD	042340000r			; 45
	DD	042e00000r			; 112
	DD	042400000r			; 48
	DD	042e40000r			; 114
	DD	042380000r			; 46
	DD	042ea0000r			; 117
	DD	0422c0000r			; 43
	DD	043000000r			; 128
_matrix44_ident DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
_DATA	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
_NEAR_CLIP DD	03f800000r			; 1
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B
CONST	SEGMENT
?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B DD 01H ; std::ios_base::failure::_Stream_err
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	_fabsf
PUBLIC	_acosf
PUBLIC	?acos@@YAMM@Z					; acos
PUBLIC	?fabs@@YAMM@Z					; fabs
PUBLIC	??0VU_SESSION_ID@@QAE@K@Z			; VU_SESSION_ID::VU_SESSION_ID
PUBLIC	??8VU_SESSION_ID@@QBEHABV0@@Z			; VU_SESSION_ID::operator==
PUBLIC	??0VU_ID@@QAE@XZ				; VU_ID::VU_ID
PUBLIC	??8VU_ID@@QBE_NABV0@@Z				; VU_ID::operator==
PUBLIC	??9VU_ID@@QBE_NABV0@@Z				; VU_ID::operator!=
PUBLIC	?Id@VuEntity@@QBE?AVVU_ID@@XZ			; VuEntity::Id
PUBLIC	?XPos@VuEntity@@QBEMXZ				; VuEntity::XPos
PUBLIC	?YPos@VuEntity@@QBEMXZ				; VuEntity::YPos
PUBLIC	?ZPos@VuEntity@@QBEMXZ				; VuEntity::ZPos
PUBLIC	?XDelta@VuEntity@@QBEMXZ			; VuEntity::XDelta
PUBLIC	?YDelta@VuEntity@@QBEMXZ			; VuEntity::YDelta
PUBLIC	?Yaw@VuEntity@@QBEMXZ				; VuEntity::Yaw
PUBLIC	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ	; VuEntity::EntityType
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ		; VuBin<VuSessionEntity>::operator bool
PUBLIC	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
PUBLIC	?IsSetFalcFlag@FalconEntity@@QAEHH@Z		; FalconEntity::IsSetFalcFlag
PUBLIC	?IsPlayer@FalconEntity@@QAEHXZ			; FalconEntity::IsPlayer
PUBLIC	?mlSinCos@@YAXPAUmlTrig@@M@Z			; mlSinCos
PUBLIC	?checked_atan2@@YANNN@Z				; checked_atan2
PUBLIC	??0runwayQueueStruct@@QAE@XZ			; runwayQueueStruct::runwayQueueStruct
PUBLIC	??0runwayStatsStruct@@QAE@XZ			; runwayStatsStruct::runwayStatsStruct
PUBLIC	?ProcessInbound@ATCBrain@@AAEXXZ		; ATCBrain::ProcessInbound
PUBLIC	?ProcessRunways@ATCBrain@@AAEXXZ		; ATCBrain::ProcessRunways
PUBLIC	?ProcessPlayers@ATCBrain@@AAEXXZ		; ATCBrain::ProcessPlayers
PUBLIC	?ProcessQueue@ATCBrain@@AAEXH@Z			; ATCBrain::ProcessQueue
PUBLIC	?CheckFinalApproach@ATCBrain@@AAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::CheckFinalApproach
PUBLIC	?ReschedulePlanes@ATCBrain@@AAEXH@Z		; ATCBrain::ReschedulePlanes
PUBLIC	?RescheduleFlightTakeoff@ATCBrain@@AAEXHPAVFlightClass@@@Z ; ATCBrain::RescheduleFlightTakeoff
PUBLIC	?ReorderFlight@ATCBrain@@AAEXHPAVFlightClass@@W4AtcStatusEnum@@@Z ; ATCBrain::ReorderFlight
PUBLIC	?NextToTakeoff@ATCBrain@@AAEPAUrunwayQueueStruct@@H@Z ; ATCBrain::NextToTakeoff
PUBLIC	?NextToLand@ATCBrain@@AAEPAUrunwayQueueStruct@@H@Z ; ATCBrain::NextToLand
PUBLIC	?CalcRunwayDimensions@ATCBrain@@AAEXH@Z		; ATCBrain::CalcRunwayDimensions
PUBLIC	?CheckList@ATCBrain@@AAEXPAUrunwayQueueStruct@@@Z ; ATCBrain::CheckList
PUBLIC	??0ATCBrain@@QAE@PAVObjectiveClass@@@Z		; ATCBrain::ATCBrain
PUBLIC	??1ATCBrain@@QAE@XZ				; ATCBrain::~ATCBrain
PUBLIC	?Exec@ATCBrain@@QAEXXZ				; ATCBrain::Exec
PUBLIC	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage
PUBLIC	?NumOperableRunways@ATCBrain@@QAEHXZ		; ATCBrain::NumOperableRunways
PUBLIC	?InList@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@@Z ; ATCBrain::InList
PUBLIC	?RequestClearance@ATCBrain@@QAEXPAVAircraftClass@@H@Z ; ATCBrain::RequestClearance
PUBLIC	?RequestEmerClearance@ATCBrain@@QAEXPAVAircraftClass@@@Z ; ATCBrain::RequestEmerClearance
PUBLIC	?RequestTakeoff@ATCBrain@@QAEXPAVAircraftClass@@@Z ; ATCBrain::RequestTakeoff
PUBLIC	?RequestTaxi@ATCBrain@@QAEXPAVAircraftClass@@@Z	; ATCBrain::RequestTaxi
PUBLIC	?AbortApproach@ATCBrain@@QAEXPAVAircraftClass@@@Z ; ATCBrain::AbortApproach
PUBLIC	?AddInbound@ATCBrain@@QAEXPAVAircraftClass@@@Z	; ATCBrain::AddInbound
PUBLIC	?AddInboundFlight@ATCBrain@@QAEXPAVFlightClass@@@Z ; ATCBrain::AddInboundFlight
PUBLIC	?AddTraffic@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@W4AtcStatusEnum@@HJ@Z ; ATCBrain::AddTraffic
PUBLIC	?AddToList@ATCBrain@@QAEPAUrunwayQueueStruct@@PAU2@0@Z ; ATCBrain::AddToList
PUBLIC	?RemoveTraffic@ATCBrain@@QAEXVVU_ID@@H@Z	; ATCBrain::RemoveTraffic
PUBLIC	?RemoveFromList@ATCBrain@@QAEPAUrunwayQueueStruct@@PAU2@0@Z ; ATCBrain::RemoveFromList
PUBLIC	?RemoveInbound@ATCBrain@@QAEXPAUrunwayQueueStruct@@@Z ; ATCBrain::RemoveInbound
PUBLIC	?RemoveFromAllOtherATCs@ATCBrain@@QAEXPAVAircraftClass@@@Z ; ATCBrain::RemoveFromAllOtherATCs
PUBLIC	?RemoveFromAllATCs@ATCBrain@@QAEXPAVAircraftClass@@@Z ; ATCBrain::RemoveFromAllATCs
PUBLIC	?RemovePlaceHolders@ATCBrain@@QAEKVVU_ID@@@Z	; ATCBrain::RemovePlaceHolders
PUBLIC	?SetEmergency@ATCBrain@@QAEXH@Z			; ATCBrain::SetEmergency
PUBLIC	?GetRunwayTexture@ATCBrain@@QAEHH@Z		; ATCBrain::GetRunwayTexture
PUBLIC	?GetRunwayName@ATCBrain@@QAEHH@Z		; ATCBrain::GetRunwayName
PUBLIC	?GetTextureIdFromHdg@ATCBrain@@QAEFHH@Z		; ATCBrain::GetTextureIdFromHdg
PUBLIC	?GetOppositeRunway@ATCBrain@@QAEHH@Z		; ATCBrain::GetOppositeRunway
PUBLIC	?FindNextEmergency@ATCBrain@@QAEXH@Z		; ATCBrain::FindNextEmergency
PUBLIC	?FindFlightTakeoffTime@ATCBrain@@QAEKPAVFlightClass@@H@Z ; ATCBrain::FindFlightTakeoffTime
PUBLIC	?FindBestTakeoffRunway@ATCBrain@@QAEHH@Z	; ATCBrain::FindBestTakeoffRunway
PUBLIC	?FindBestLandingRunway@ATCBrain@@QAEHPAVFalconEntity@@H@Z ; ATCBrain::FindBestLandingRunway
PUBLIC	?FindEmergencyLandingRunway@ATCBrain@@QAEXPAH0PAVFalconEntity@@@Z ; ATCBrain::FindEmergencyLandingRunway
PUBLIC	?FindAbortPt@ATCBrain@@QAEXPAVAircraftClass@@PAM11@Z ; ATCBrain::FindAbortPt
PUBLIC	?FindTakeoffPt@ATCBrain@@QAEHPAVFlightClass@@HHPAM1@Z ; ATCBrain::FindTakeoffPt
PUBLIC	?FindRunwayPt@ATCBrain@@QAEHPAVFlightClass@@HHPAM1@Z ; ATCBrain::FindRunwayPt
PUBLIC	?FindFinalPt@ATCBrain@@QAEXPAVAircraftClass@@HPAM1@Z ; ATCBrain::FindFinalPt
PUBLIC	?FindBasePt@ATCBrain@@QAE?AW4AtcStatusEnum@@PAVAircraftClass@@HMMPAM1@Z ; ATCBrain::FindBasePt
PUBLIC	?FindFirstLegPt@ATCBrain@@QAE?AW4AtcStatusEnum@@PAVAircraftClass@@HKMMHPAM1@Z ; ATCBrain::FindFirstLegPt
PUBLIC	?GetNextAvailRunwayTime@ATCBrain@@QAEKHKK@Z	; ATCBrain::GetNextAvailRunwayTime
PUBLIC	?DetermineAngle@ATCBrain@@QAEMPAVAircraftClass@@HW4AtcStatusEnum@@@Z ; ATCBrain::DetermineAngle
PUBLIC	?GetAltitude@ATCBrain@@QAEMPAVAircraftClass@@W4AtcStatusEnum@@@Z ; ATCBrain::GetAltitude
PUBLIC	?CalculateMinMaxTime@ATCBrain@@QAEXPAVAircraftClass@@HW4AtcStatusEnum@@PAK2M@Z ; ATCBrain::CalculateMinMaxTime
PUBLIC	?CalculateStandRateTurnToPt@ATCBrain@@QAEHPAVAircraftClass@@MMPAM@Z ; ATCBrain::CalculateStandRateTurnToPt
PUBLIC	?IsOnRunway@ATCBrain@@QAEHMM@Z			; ATCBrain::IsOnRunway
PUBLIC	?IsOnRunway@ATCBrain@@QAEHPAVAircraftClass@@@Z	; ATCBrain::IsOnRunway
PUBLIC	?IsOnRunway@ATCBrain@@QAEHH@Z			; ATCBrain::IsOnRunway
PUBLIC	?IsOverRunway@ATCBrain@@QAEHPAVAircraftClass@@@Z ; ATCBrain::IsOverRunway
PUBLIC	?UseSectionTakeoff@ATCBrain@@QAEHPAVFlightClass@@H@Z ; ATCBrain::UseSectionTakeoff
PUBLIC	?MakeVectorCall@ATCBrain@@QAEXPAVAircraftClass@@PAVVuTargetEntity@@@Z ; ATCBrain::MakeVectorCall
PUBLIC	?GetLandingNumber@ATCBrain@@QAEHPAUrunwayQueueStruct@@@Z ; ATCBrain::GetLandingNumber
PUBLIC	?GetTakeoffNumber@ATCBrain@@QAEHPAUrunwayQueueStruct@@@Z ; ATCBrain::GetTakeoffNumber
PUBLIC	?CheckVector@ATCBrain@@QAEHPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::CheckVector
PUBLIC	?CheckLanding@ATCBrain@@QAEHPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::CheckLanding
PUBLIC	?CheckTakeoff@ATCBrain@@QAEHPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::CheckTakeoff
PUBLIC	?CheckIfBlockingRunway@ATCBrain@@QAEHPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::CheckIfBlockingRunway
PUBLIC	?GiveOrderToSection@ATCBrain@@QAEXPAVAircraftClass@@W4AtcStatusEnum@@H@Z ; ATCBrain::GiveOrderToSection
PUBLIC	?GiveOrderToWingman@ATCBrain@@QAEXPAVAircraftClass@@W4AtcStatusEnum@@@Z ; ATCBrain::GiveOrderToWingman
PUBLIC	?CheckForTraffic@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::CheckForTraffic
PUBLIC	?CheckPointGlobal@@YAPAVSimBaseClass@@PAVAircraftClass@@MM@Z ; CheckPointGlobal
PUBLIC	?CheckTaxiPointGlobal@@YAPAVSimBaseClass@@PAVAircraftClass@@MM@Z ; CheckTaxiPointGlobal
PUBLIC	?CheckPointGlobal@@YAPAVSimBaseClass@@PAVCampBaseClass@@MM@Z ; CheckPointGlobal
PUBLIC	?GetWPAction@WayPointClass@@QAEHXZ		; WayPointClass::GetWPAction
PUBLIC	?GetWPDepartureTime@WayPointClass@@QAEKXZ	; WayPointClass::GetWPDepartureTime
PUBLIC	?GetCampId@CampBaseClass@@QBEFXZ		; CampBaseClass::GetCampId
PUBLIC	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
PUBLIC	?GetType@CampBaseClass@@QBEEXZ			; CampBaseClass::GetType
PUBLIC	?GetSType@CampBaseClass@@QBEEXZ			; CampBaseClass::GetSType
PUBLIC	?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ; VuBin<CampBaseClass>::get
PUBLIC	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
PUBLIC	?GetPlayerEntity@FalconSessionEntity@@QBEPAVFalconEntity@@XZ ; FalconSessionEntity::GetPlayerEntity
PUBLIC	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
PUBLIC	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
PUBLIC	?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ ; AircraftClass::AutopilotType
PUBLIC	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ	; AircraftClass::DBrain
PUBLIC	?SetTaxiPoint@DigitalBrain@@QAEXH@Z		; DigitalBrain::SetTaxiPoint
PUBLIC	?SetTrackPoint@DigitalBrain@@QAEXMM@Z		; DigitalBrain::SetTrackPoint
PUBLIC	?SetTrackPoint@DigitalBrain@@QAEXMMM@Z		; DigitalBrain::SetTrackPoint
PUBLIC	?SetATCFlag@DigitalBrain@@QAEXH@Z		; DigitalBrain::SetATCFlag
PUBLIC	?ClearATCFlag@DigitalBrain@@QAEXH@Z		; DigitalBrain::ClearATCFlag
PUBLIC	?IsSetATC@DigitalBrain@@QAEHH@Z			; DigitalBrain::IsSetATC
PUBLIC	?SetATCStatus@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SetATCStatus
PUBLIC	?ATCStatus@DigitalBrain@@QAE?AW4AtcStatusEnum@@XZ ; DigitalBrain::ATCStatus
PUBLIC	?SetWaitTimer@DigitalBrain@@QAEXK@Z		; DigitalBrain::SetWaitTimer
PUBLIC	?WaitTime@DigitalBrain@@QAEKXZ			; DigitalBrain::WaitTime
PUBLIC	?Airbase@DigitalBrain@@QAE?AVVU_ID@@XZ		; DigitalBrain::Airbase
PUBLIC	?Runway@DigitalBrain@@QAEHXZ			; DigitalBrain::Runway
PUBLIC	?RwTime@DigitalBrain@@QAEKXZ			; DigitalBrain::RwTime
PUBLIC	?TurnDistance@DigitalBrain@@QAEMXZ		; DigitalBrain::TurnDistance
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?Radius@DrawableObject@@QBEMXZ			; DrawableObject::Radius
PUBLIC	?GetPosition@DrawableObject@@QAEXPAUTpoint@@@Z	; DrawableObject::GetPosition
PUBLIC	?MinVcas@AirframeClass@@QAEMXZ			; AirframeClass::MinVcas
PUBLIC	?MaxVcas@AirframeClass@@QAEMXZ			; AirframeClass::MaxVcas
PUBLIC	?Fuel@AirframeClass@@QAEMXZ			; AirframeClass::Fuel
PUBLIC	?IsSet@AirframeClass@@QBEHH@Z			; AirframeClass::IsSet
PUBLIC	?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ ; SimulationDriver::GetPlayerEntity
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3c8efa34
PUBLIC	__real@3d56a98a
PUBLIC	__real@3db2b8c1
PUBLIC	__real@3e32b8c1
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3e99999a
PUBLIC	__real@3eb2b8c2
PUBLIC	__real@3ecccccd
PUBLIC	__real@3f000000
PUBLIC	__real@3f17ac60
PUBLIC	__real@3f19999a
PUBLIC	__real@3f266666
PUBLIC	__real@3f2b851f
PUBLIC	__real@3f333333
PUBLIC	__real@3f34fdf4
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f666666
PUBLIC	__real@3f708fa8
PUBLIC	__real@3f7746dc
PUBLIC	__real@3f7d70a4
PUBLIC	__real@3f800000
PUBLIC	__real@3f9c61a9
PUBLIC	__real@3fb50481
PUBLIC	__real@3fc90fd9
PUBLIC	__real@3fd80b03
PUBLIC	__real@3ff08fb2
PUBLIC	__real@3ff921fb54442d18
PUBLIC	__real@40000000
PUBLIC	__real@400921fb54442d18
PUBLIC	__real@40400000
PUBLIC	__real@40490fdb
PUBLIC	__real@40800000
PUBLIC	__real@40a00000
PUBLIC	__real@40c90fdb
PUBLIC	__real@41000000
PUBLIC	__real@410706e2
PUBLIC	__real@41200000
PUBLIC	__real@41428963
PUBLIC	__real@41a00000
PUBLIC	__real@41f00000
PUBLIC	__real@4211e70a
PUBLIC	__real@42200000
PUBLIC	__real@42480000
PUBLIC	__real@424a8a53
PUBLIC	__real@42652ee1
PUBLIC	__real@42700000
PUBLIC	__real@4297e7be
PUBLIC	__real@42b40000
PUBLIC	__real@42c80000
PUBLIC	__real@42ec4c0b
PUBLIC	__real@42f00000
PUBLIC	__real@430706e2
PUBLIC	__real@43348000
PUBLIC	__real@43b40000
PUBLIC	__real@43fa0000
PUBLIC	__real@44480000
PUBLIC	__real@447a0000
PUBLIC	__real@451c4000
PUBLIC	__real@457a0000
PUBLIC	__real@45bb8000
PUBLIC	__real@45bde1b0
PUBLIC	__real@463b8000
PUBLIC	__real@468e6944
PUBLIC	__real@476a6000
PUBLIC	__real@47afc800
PUBLIC	__real@47bb8000
PUBLIC	__real@47ea6000
PUBLIC	__real@48185800
PUBLIC	__real@4852f000
PUBLIC	__real@49742400
PUBLIC	__real@50abec79
PUBLIC	__real@50f791f7
PUBLIC	__real@515c0ff8
PUBLIC	__real@8000000000000000
PUBLIC	__real@bf350481
PUBLIC	__real@bf5db22d
PUBLIC	__real@bff921fb54442d18
PUBLIC	__real@c0490fdb
PUBLIC	__real@c1200000
PUBLIC	__real@c2700000
PUBLIC	__real@c2b40000
PUBLIC	__real@c5bde1b0
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	_abs:PROC
EXTRN	_acos:PROC
EXTRN	_atan:PROC
EXTRN	_fabs:PROC
EXTRN	_rand:PROC
EXTRN	_memcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	?F4IsBadReadPtr@@YA_NPBXI@Z:PROC		; F4IsBadReadPtr
EXTRN	?IsLocal@VuEntity@@QBEEXZ:PROC			; VuEntity::IsLocal
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z:PROC ; VuDatabase::Find
EXTRN	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ:PROC ; VuSessionEntity::Game
EXTRN	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z:PROC	; VuListIterator::VuListIterator
EXTRN	??1VuListIterator@@UAE@XZ:PROC			; VuListIterator::~VuListIterator
EXTRN	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ:PROC ; VuListIterator::GetFirst
EXTRN	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ:PROC ; VuListIterator::GetNext
EXTRN	??0VuSessionsIterator@@QAE@PAVVuGroupEntity@@@Z:PROC ; VuSessionsIterator::VuSessionsIterator
EXTRN	??1VuSessionsIterator@@UAE@XZ:PROC		; VuSessionsIterator::~VuSessionsIterator
EXTRN	?GetFirst@VuSessionsIterator@@QAEPAVVuSessionEntity@@XZ:PROC ; VuSessionsIterator::GetFirst
EXTRN	?GetNext@VuSessionsIterator@@QAEPAVVuSessionEntity@@XZ:PROC ; VuSessionsIterator::GetNext
EXTRN	?FalconSendMessage@@YAXPAVVuMessage@@H@Z:PROC	; FalconSendMessage
EXTRN	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z:PROC ; CampBaseClass::GetComponentIndex
EXTRN	?GetComponentNumber@CampBaseClass@@QAEPAVSimBaseClass@@H@Z:PROC ; CampBaseClass::GetComponentNumber
EXTRN	?NumberOfComponents@CampBaseClass@@QAEHXZ:PROC	; CampBaseClass::NumberOfComponents
EXTRN	??0FalconATCCmdMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z:PROC ; FalconATCCmdMessage::FalconATCCmdMessage
EXTRN	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z:PROC ; CreateCallFromATC
EXTRN	?SendCallFromATC@@YAXPAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z:PROC ; SendCallFromATC
EXTRN	?GetTotalVehicles@UnitClass@@QAEHXZ:PROC	; UnitClass::GetTotalVehicles
EXTRN	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ:PROC ; UnitClass::GetCurrentUnitWP
EXTRN	?GetObjectiveClassData@ObjectiveClass@@QAEPAUObjClassDataType@@XZ:PROC ; ObjectiveClass::GetObjectiveClassData
EXTRN	?FindNearbyAirbase@@YAPAVObjectiveClass@@FF@Z:PROC ; FindNearbyAirbase
EXTRN	?SimToGrid@@YAFM@Z:PROC				; SimToGrid
EXTRN	?ConvertSimToGrid@@YAXPAUvector@@PAF1@Z:PROC	; ConvertSimToGrid
EXTRN	?RegroupAircraft@@YAXPAVAircraftClass@@@Z:PROC	; RegroupAircraft
EXTRN	?GetFirstPt@@YAHH@Z:PROC			; GetFirstPt
EXTRN	?GetNextPt@@YAHH@Z:PROC				; GetNextPt
EXTRN	?GetNextTaxiPt@@YAHH@Z:PROC			; GetNextTaxiPt
EXTRN	?GetNextPtLoop@@YAHH@Z:PROC			; GetNextPtLoop
EXTRN	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z:PROC ; TranslatePointData
EXTRN	?CheckHeaderStatus@@YAHPAVCampBaseClass@@H@Z:PROC ; CheckHeaderStatus
EXTRN	?GetQueue@@YAHH@Z:PROC				; GetQueue
EXTRN	?GetTrackPoint@DigitalBrain@@QAEXAAM00@Z:PROC	; DigitalBrain::GetTrackPoint
EXTRN	?CalculateNextTurnDistance@DigitalBrain@@QAEMXZ:PROC ; DigitalBrain::CalculateNextTurnDistance
EXTRN	?IsMyWingman@DigitalBrain@@QAEHVVU_ID@@@Z:PROC	; DigitalBrain::IsMyWingman
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	?CalcDesSpeed@AirframeClass@@QAEMM@Z:PROC	; AirframeClass::CalcDesSpeed
EXTRN	?GetParkType@AirframeClass@@QAEHXZ:PROC		; AirframeClass::GetParkType
EXTRN	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z:PROC ; OTWDriverClass::GetGroundLevel
EXTRN	?ExitMenu@OTWDriverClass@@QAEXK@Z:PROC		; OTWDriverClass::ExitMenu
EXTRN	?PickVoice@VoiceMapper@@QAEHHH@Z:PROC		; VoiceMapper::PickVoice
EXTRN	?FindNearestTraffic@SimulationDriver@@QAEPAVSimBaseClass@@PAVAircraftClass@@PAVObjectiveClass@@PAM@Z:PROC ; SimulationDriver::FindNearestTraffic
EXTRN	?GetCallsignFromCampID@TacanList@@QAEHFPAH@Z:PROC ; TacanList::GetCallsignFromCampID
EXTRN	?GetTTRelations@@YAHEE@Z:PROC			; GetTTRelations
EXTRN	?get_air_speed@@YAMMH@Z:PROC			; get_air_speed
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?vuDatabase@@3PAVVuDatabase@@A:DWORD		; vuDatabase
EXTRN	?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A:DWORD ; vuLocalSessionEntity
EXTRN	?FalconNullId@@3VVU_ID@@A:QWORD			; FalconNullId
EXTRN	?SimLibElapsedTime@@3KA:DWORD			; SimLibElapsedTime
EXTRN	?PtHeaderDataTable@@3PAUPtHeaderDataType@@A:DWORD ; PtHeaderDataTable
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?WingmanTable@@3PAHA:BYTE			; WingmanTable
EXTRN	?realWeather@@3PAVRealWeather@@A:DWORD		; realWeather
EXTRN	?OTWDriver@@3VOTWDriverClass@@A:BYTE		; OTWDriver
EXTRN	?g_voicemap@@3VVoiceMapper@@A:QWORD		; g_voicemap
EXTRN	?SimDriver@@3VSimulationDriver@@A:BYTE		; SimDriver
EXTRN	?gTacanList@@3PAVTacanList@@A:DWORD		; gTacanList
EXTRN	?gBumpTime@@3KA:DWORD				; gBumpTime
EXTRN	?gBumpFlag@@3HA:DWORD				; gBumpFlag
EXTRN	?g_nATCTaxiOrderFix@@3HA:DWORD			; g_nATCTaxiOrderFix
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@c5bde1b0
CONST	SEGMENT
__real@c5bde1b0 DD 0c5bde1b0r			; -6076.21
CONST	ENDS
;	COMDAT __real@c2b40000
CONST	SEGMENT
__real@c2b40000 DD 0c2b40000r			; -90
CONST	ENDS
;	COMDAT __real@c2700000
CONST	SEGMENT
__real@c2700000 DD 0c2700000r			; -60
CONST	ENDS
;	COMDAT __real@c1200000
CONST	SEGMENT
__real@c1200000 DD 0c1200000r			; -10
CONST	ENDS
;	COMDAT __real@c0490fdb
CONST	SEGMENT
__real@c0490fdb DD 0c0490fdbr			; -3.14159
CONST	ENDS
;	COMDAT __real@bff921fb54442d18
CONST	SEGMENT
__real@bff921fb54442d18 DQ 0bff921fb54442d18r	; -1.5708
CONST	ENDS
;	COMDAT __real@bf5db22d
CONST	SEGMENT
__real@bf5db22d DD 0bf5db22dr			; -0.866
CONST	ENDS
;	COMDAT __real@bf350481
CONST	SEGMENT
__real@bf350481 DD 0bf350481r			; -0.7071
CONST	ENDS
;	COMDAT __real@8000000000000000
CONST	SEGMENT
__real@8000000000000000 DQ 08000000000000000r	; -0
CONST	ENDS
;	COMDAT __real@515c0ff8
CONST	SEGMENT
__real@515c0ff8 DD 0515c0ff8r			; 5.90725e+010
CONST	ENDS
;	COMDAT __real@50f791f7
CONST	SEGMENT
__real@50f791f7 DD 050f791f7r			; 3.32283e+010
CONST	ENDS
;	COMDAT __real@50abec79
CONST	SEGMENT
__real@50abec79 DD 050abec79r			; 2.30752e+010
CONST	ENDS
;	COMDAT __real@49742400
CONST	SEGMENT
__real@49742400 DD 049742400r			; 1e+006
CONST	ENDS
;	COMDAT __real@4852f000
CONST	SEGMENT
__real@4852f000 DD 04852f000r			; 216000
CONST	ENDS
;	COMDAT __real@48185800
CONST	SEGMENT
__real@48185800 DD 048185800r			; 156000
CONST	ENDS
;	COMDAT __real@47ea6000
CONST	SEGMENT
__real@47ea6000 DD 047ea6000r			; 120000
CONST	ENDS
;	COMDAT __real@47bb8000
CONST	SEGMENT
__real@47bb8000 DD 047bb8000r			; 96000
CONST	ENDS
;	COMDAT __real@47afc800
CONST	SEGMENT
__real@47afc800 DD 047afc800r			; 90000
CONST	ENDS
;	COMDAT __real@476a6000
CONST	SEGMENT
__real@476a6000 DD 0476a6000r			; 60000
CONST	ENDS
;	COMDAT __real@468e6944
CONST	SEGMENT
__real@468e6944 DD 0468e6944r			; 18228.6
CONST	ENDS
;	COMDAT __real@463b8000
CONST	SEGMENT
__real@463b8000 DD 0463b8000r			; 12000
CONST	ENDS
;	COMDAT __real@45bde1b0
CONST	SEGMENT
__real@45bde1b0 DD 045bde1b0r			; 6076.21
CONST	ENDS
;	COMDAT __real@45bb8000
CONST	SEGMENT
__real@45bb8000 DD 045bb8000r			; 6000
CONST	ENDS
;	COMDAT __real@457a0000
CONST	SEGMENT
__real@457a0000 DD 0457a0000r			; 4000
CONST	ENDS
;	COMDAT __real@451c4000
CONST	SEGMENT
__real@451c4000 DD 0451c4000r			; 2500
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@44480000
CONST	SEGMENT
__real@44480000 DD 044480000r			; 800
CONST	ENDS
;	COMDAT __real@43fa0000
CONST	SEGMENT
__real@43fa0000 DD 043fa0000r			; 500
CONST	ENDS
;	COMDAT __real@43b40000
CONST	SEGMENT
__real@43b40000 DD 043b40000r			; 360
CONST	ENDS
;	COMDAT __real@43348000
CONST	SEGMENT
__real@43348000 DD 043348000r			; 180.5
CONST	ENDS
;	COMDAT __real@430706e2
CONST	SEGMENT
__real@430706e2 DD 0430706e2r			; 135.027
CONST	ENDS
;	COMDAT __real@42f00000
CONST	SEGMENT
__real@42f00000 DD 042f00000r			; 120
CONST	ENDS
;	COMDAT __real@42ec4c0b
CONST	SEGMENT
__real@42ec4c0b DD 042ec4c0br			; 118.149
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42b40000
CONST	SEGMENT
__real@42b40000 DD 042b40000r			; 90
CONST	ENDS
;	COMDAT __real@4297e7be
CONST	SEGMENT
__real@4297e7be DD 04297e7ber			; 75.9526
CONST	ENDS
;	COMDAT __real@42700000
CONST	SEGMENT
__real@42700000 DD 042700000r			; 60
CONST	ENDS
;	COMDAT __real@42652ee1
CONST	SEGMENT
__real@42652ee1 DD 042652ee1r			; 57.2958
CONST	ENDS
;	COMDAT __real@424a8a53
CONST	SEGMENT
__real@424a8a53 DD 0424a8a53r			; 50.6351
CONST	ENDS
;	COMDAT __real@42480000
CONST	SEGMENT
__real@42480000 DD 042480000r			; 50
CONST	ENDS
;	COMDAT __real@42200000
CONST	SEGMENT
__real@42200000 DD 042200000r			; 40
CONST	ENDS
;	COMDAT __real@4211e70a
CONST	SEGMENT
__real@4211e70a DD 04211e70ar			; 36.4756
CONST	ENDS
;	COMDAT __real@41f00000
CONST	SEGMENT
__real@41f00000 DD 041f00000r			; 30
CONST	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@41428963
CONST	SEGMENT
__real@41428963 DD 041428963r			; 12.1585
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@410706e2
CONST	SEGMENT
__real@410706e2 DD 0410706e2r			; 8.43918
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@40c90fdb
CONST	SEGMENT
__real@40c90fdb DD 040c90fdbr			; 6.28319
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40490fdb
CONST	SEGMENT
__real@40490fdb DD 040490fdbr			; 3.14159
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@400921fb54442d18
CONST	SEGMENT
__real@400921fb54442d18 DQ 0400921fb54442d18r	; 3.14159
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff921fb54442d18
CONST	SEGMENT
__real@3ff921fb54442d18 DQ 03ff921fb54442d18r	; 1.5708
CONST	ENDS
;	COMDAT __real@3ff08fb2
CONST	SEGMENT
__real@3ff08fb2 DD 03ff08fb2r			; 1.87939
CONST	ENDS
;	COMDAT __real@3fd80b03
CONST	SEGMENT
__real@3fd80b03 DD 03fd80b03r			; 1.68784
CONST	ENDS
;	COMDAT __real@3fc90fd9
CONST	SEGMENT
__real@3fc90fd9 DD 03fc90fd9r			; 1.5708
CONST	ENDS
;	COMDAT __real@3fb50481
CONST	SEGMENT
__real@3fb50481 DD 03fb50481r			; 1.4142
CONST	ENDS
;	COMDAT __real@3f9c61a9
CONST	SEGMENT
__real@3f9c61a9 DD 03f9c61a9r			; 1.22173
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f7d70a4
CONST	SEGMENT
__real@3f7d70a4 DD 03f7d70a4r			; 0.99
CONST	ENDS
;	COMDAT __real@3f7746dc
CONST	SEGMENT
__real@3f7746dc DD 03f7746dcr			; 0.965925
CONST	ENDS
;	COMDAT __real@3f708fa8
CONST	SEGMENT
__real@3f708fa8 DD 03f708fa8r			; 0.939692
CONST	ENDS
;	COMDAT __real@3f666666
CONST	SEGMENT
__real@3f666666 DD 03f666666r			; 0.9
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f34fdf4
CONST	SEGMENT
__real@3f34fdf4 DD 03f34fdf4r			; 0.707
CONST	ENDS
;	COMDAT __real@3f333333
CONST	SEGMENT
__real@3f333333 DD 03f333333r			; 0.7
CONST	ENDS
;	COMDAT __real@3f2b851f
CONST	SEGMENT
__real@3f2b851f DD 03f2b851fr			; 0.67
CONST	ENDS
;	COMDAT __real@3f266666
CONST	SEGMENT
__real@3f266666 DD 03f266666r			; 0.65
CONST	ENDS
;	COMDAT __real@3f19999a
CONST	SEGMENT
__real@3f19999a DD 03f19999ar			; 0.6
CONST	ENDS
;	COMDAT __real@3f17ac60
CONST	SEGMENT
__real@3f17ac60 DD 03f17ac60r			; 0.592474
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3ecccccd
CONST	SEGMENT
__real@3ecccccd DD 03ecccccdr			; 0.4
CONST	ENDS
;	COMDAT __real@3eb2b8c2
CONST	SEGMENT
__real@3eb2b8c2 DD 03eb2b8c2r			; 0.349066
CONST	ENDS
;	COMDAT __real@3e99999a
CONST	SEGMENT
__real@3e99999a DD 03e99999ar			; 0.3
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3e32b8c1
CONST	SEGMENT
__real@3e32b8c1 DD 03e32b8c1r			; 0.174533
CONST	ENDS
;	COMDAT __real@3db2b8c1
CONST	SEGMENT
__real@3db2b8c1 DD 03db2b8c1r			; 0.0872665
CONST	ENDS
;	COMDAT __real@3d56a98a
CONST	SEGMENT
__real@3d56a98a DD 03d56a98ar			; 0.0524078
CONST	ENDS
;	COMDAT __real@3c8efa34
CONST	SEGMENT
__real@3c8efa34 DD 03c8efa34r			; 0.0174533
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
_DATA	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?CheckTaxiPointGlobal@@YAPAVSimBaseClass@@PAVAircraftClass@@MM@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CheckTaxiPointGlobal@@YAPAVSimBaseClass@@PAVAircraftClass@@MM@Z$0
__unwindtable$?CheckPointGlobal@@YAPAVSimBaseClass@@PAVAircraftClass@@MM@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CheckPointGlobal@@YAPAVSimBaseClass@@PAVAircraftClass@@MM@Z$0
__unwindtable$?GetAltitude@ATCBrain@@QAEMPAVAircraftClass@@W4AtcStatusEnum@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetAltitude@ATCBrain@@QAEMPAVAircraftClass@@W4AtcStatusEnum@@@Z$0
__unwindtable$?RemoveFromAllATCs@ATCBrain@@QAEXPAVAircraftClass@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RemoveFromAllATCs@ATCBrain@@QAEXPAVAircraftClass@@@Z$0
__unwindtable$?RemoveFromAllOtherATCs@ATCBrain@@QAEXPAVAircraftClass@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RemoveFromAllOtherATCs@ATCBrain@@QAEXPAVAircraftClass@@@Z$0
__unwindtable$?AddTraffic@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@W4AtcStatusEnum@@HJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddTraffic@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@W4AtcStatusEnum@@HJ@Z$0
__unwindtable$?AddInboundFlight@ATCBrain@@QAEXPAVFlightClass@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddInboundFlight@ATCBrain@@QAEXPAVFlightClass@@@Z$0
__unwindtable$?AddInbound@ATCBrain@@QAEXPAVAircraftClass@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddInbound@ATCBrain@@QAEXPAVAircraftClass@@@Z$0
__unwindtable$?RequestEmerClearance@ATCBrain@@QAEXPAVAircraftClass@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RequestEmerClearance@ATCBrain@@QAEXPAVAircraftClass@@@Z$0
__unwindtable$?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z$0
__unwindtable$??0ATCBrain@@QAE@PAVObjectiveClass@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ATCBrain@@QAE@PAVObjectiveClass@@@Z$0
__unwindtable$?RescheduleFlightTakeoff@ATCBrain@@AAEXHPAVFlightClass@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RescheduleFlightTakeoff@ATCBrain@@AAEXHPAVFlightClass@@@Z$0
__unwindtable$?ProcessRunways@ATCBrain@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessRunways@ATCBrain@@AAEXXZ$0
__unwindtable$?CheckPointGlobal@@YAPAVSimBaseClass@@PAVCampBaseClass@@MM@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CheckPointGlobal@@YAPAVSimBaseClass@@PAVCampBaseClass@@MM@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CheckPointGlobal@@YAPAVSimBaseClass@@PAVCampBaseClass@@MM@Z$1
__unwindtable$?RequestTakeoff@ATCBrain@@QAEXPAVAircraftClass@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RequestTakeoff@ATCBrain@@QAEXPAVAircraftClass@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?RequestTakeoff@ATCBrain@@QAEXPAVAircraftClass@@@Z$1
__unwindtable$?RequestClearance@ATCBrain@@QAEXPAVAircraftClass@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RequestClearance@ATCBrain@@QAEXPAVAircraftClass@@H@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?RequestClearance@ATCBrain@@QAEXPAVAircraftClass@@H@Z$1
__unwindtable$?ProcessPlayers@ATCBrain@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessPlayers@ATCBrain@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ProcessPlayers@ATCBrain@@AAEXXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?ProcessPlayers@ATCBrain@@AAEXXZ$2
__ehfuncinfo$?CheckPointGlobal@@YAPAVSimBaseClass@@PAVCampBaseClass@@MM@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?CheckPointGlobal@@YAPAVSimBaseClass@@PAVCampBaseClass@@MM@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?CheckTaxiPointGlobal@@YAPAVSimBaseClass@@PAVAircraftClass@@MM@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CheckTaxiPointGlobal@@YAPAVSimBaseClass@@PAVAircraftClass@@MM@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?CheckPointGlobal@@YAPAVSimBaseClass@@PAVAircraftClass@@MM@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CheckPointGlobal@@YAPAVSimBaseClass@@PAVAircraftClass@@MM@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?GetAltitude@ATCBrain@@QAEMPAVAircraftClass@@W4AtcStatusEnum@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetAltitude@ATCBrain@@QAEMPAVAircraftClass@@W4AtcStatusEnum@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?RemoveFromAllATCs@ATCBrain@@QAEXPAVAircraftClass@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RemoveFromAllATCs@ATCBrain@@QAEXPAVAircraftClass@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?RemoveFromAllOtherATCs@ATCBrain@@QAEXPAVAircraftClass@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RemoveFromAllOtherATCs@ATCBrain@@QAEXPAVAircraftClass@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?AddTraffic@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@W4AtcStatusEnum@@HJ@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddTraffic@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@W4AtcStatusEnum@@HJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?AddInboundFlight@ATCBrain@@QAEXPAVFlightClass@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddInboundFlight@ATCBrain@@QAEXPAVFlightClass@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?AddInbound@ATCBrain@@QAEXPAVAircraftClass@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddInbound@ATCBrain@@QAEXPAVAircraftClass@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?RequestTakeoff@ATCBrain@@QAEXPAVAircraftClass@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?RequestTakeoff@ATCBrain@@QAEXPAVAircraftClass@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?RequestEmerClearance@ATCBrain@@QAEXPAVAircraftClass@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RequestEmerClearance@ATCBrain@@QAEXPAVAircraftClass@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?RequestClearance@ATCBrain@@QAEXPAVAircraftClass@@H@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?RequestClearance@ATCBrain@@QAEXPAVAircraftClass@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0ATCBrain@@QAE@PAVObjectiveClass@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0ATCBrain@@QAE@PAVObjectiveClass@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?RescheduleFlightTakeoff@ATCBrain@@AAEXHPAVFlightClass@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RescheduleFlightTakeoff@ATCBrain@@AAEXHPAVFlightClass@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?ProcessPlayers@ATCBrain@@AAEXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?ProcessPlayers@ATCBrain@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?ProcessRunways@ATCBrain@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ProcessRunways@ATCBrain@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@D@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<char>::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@_W@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<wchar_t>::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<wchar_t>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<wchar_t>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 758  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 910  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simdrive.h
;	COMDAT ?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ PROC ; SimulationDriver::GetPlayerEntity, COMDAT
; _this$ = ecx

; 76   : 	SimMoverClass *GetPlayerEntity() const { return const_cast<SimMoverClass*>(playerEntity); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+56]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ ENDP ; SimulationDriver::GetPlayerEntity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?IsSet@AirframeClass@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_testFlag$ = 8						; size = 4
?IsSet@AirframeClass@@QBEHH@Z PROC			; AirframeClass::IsSet, COMDAT
; _this$ = ecx

; 1216 : 	int IsSet (int testFlag) const {return flags & testFlag ? 1 : 0;}

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	and	ecx, DWORD PTR _testFlag$[ebp]
	je	SHORT $LN3@IsSet
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@IsSet
$LN3@IsSet:
	mov	DWORD PTR tv67[ebp], 0
$LN4@IsSet:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSet@AirframeClass@@QBEHH@Z ENDP			; AirframeClass::IsSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?Fuel@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Fuel@AirframeClass@@QAEMXZ PROC			; AirframeClass::Fuel, COMDAT
; _this$ = ecx

; 1183 : 	float Fuel (void) {return fuel;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+20]
	mov	esp, ebp
	pop	ebp
	ret	0
?Fuel@AirframeClass@@QAEMXZ ENDP			; AirframeClass::Fuel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?MaxVcas@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?MaxVcas@AirframeClass@@QAEMXZ PROC			; AirframeClass::MaxVcas, COMDAT
; _this$ = ecx

; 1176 : 	float MaxVcas(void) {return maxVcas;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+80]
	mov	esp, ebp
	pop	ebp
	ret	0
?MaxVcas@AirframeClass@@QAEMXZ ENDP			; AirframeClass::MaxVcas
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\airframe.h
;	COMDAT ?MinVcas@AirframeClass@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?MinVcas@AirframeClass@@QAEMXZ PROC			; AirframeClass::MinVcas, COMDAT
; _this$ = ecx

; 1175 : 	float MinVcas(void) {return minVcas;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+76]
	mov	esp, ebp
	pop	ebp
	ret	0
?MinVcas@AirframeClass@@QAEMXZ ENDP			; AirframeClass::MinVcas
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\drawobj.h
;	COMDAT ?GetPosition@DrawableObject@@QAEXPAUTpoint@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pos$ = 8						; size = 4
?GetPosition@DrawableObject@@QAEXPAUTpoint@@@Z PROC	; DrawableObject::GetPosition, COMDAT
; _this$ = ecx

; 28   : 	void GetPosition(Tpoint* pos){ *pos = position; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?GetPosition@DrawableObject@@QAEXPAUTpoint@@@Z ENDP	; DrawableObject::GetPosition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\graphics\include\drawobj.h
;	COMDAT ?Radius@DrawableObject@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Radius@DrawableObject@@QBEMXZ PROC			; DrawableObject::Radius, COMDAT
; _this$ = ecx

; 27   : 	float Radius() const { return radius; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+16]
	mov	esp, ebp
	pop	ebp
	ret	0
?Radius@DrawableObject@@QBEMXZ ENDP			; DrawableObject::Radius
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 641  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@default_er

; 643  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 644  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 645  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	edx, DWORD PTR __Errval$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 646  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 634  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 635  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 636  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 637  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 629  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 630  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 631  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 624  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 625  : 		{	// default constructor
; 626  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 611  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 612  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 613  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 614  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 615  : 			return (_Generic_error_category::message(_Errcode));

	mov	ecx, DWORD PTR __Errcode$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 616  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 606  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 607  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 601  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 602  : 		{	// default constructor
; 603  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 590  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 591  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 593  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 585  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 580  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 581  : 		{	// default constructor
; 582  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 376  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 379  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 354  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 356  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 349  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 350  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 351  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 316  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax

; 317  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 256  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 257  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 258  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 251  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 184  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 415  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 408  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 410  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 401  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 403  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 167  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 162  : 	error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 163  : 		{	// default constructor
; 164  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 679  : 	{	// get system_category

	push	ebp
	mov	ebp, esp

; 680  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 681  : 	}

	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 669  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp

; 670  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 671  : 	}

	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 75   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
;	COMDAT ?TurnDistance@DigitalBrain@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?TurnDistance@DigitalBrain@@QAEMXZ PROC			; DigitalBrain::TurnDistance, COMDAT
; _this$ = ecx

; 774  : 	float	TurnDistance(void)			{return turnDist;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+340]
	mov	esp, ebp
	pop	ebp
	ret	0
?TurnDistance@DigitalBrain@@QAEMXZ ENDP			; DigitalBrain::TurnDistance
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
;	COMDAT ?RwTime@DigitalBrain@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RwTime@DigitalBrain@@QAEKXZ PROC			; DigitalBrain::RwTime, COMDAT
; _this$ = ecx

; 772  : 	VU_TIME RwTime(void)	{return rwtime;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+316]
	mov	esp, ebp
	pop	ebp
	ret	0
?RwTime@DigitalBrain@@QAEKXZ ENDP			; DigitalBrain::RwTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
;	COMDAT ?Runway@DigitalBrain@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Runway@DigitalBrain@@QAEHXZ PROC			; DigitalBrain::Runway, COMDAT
; _this$ = ecx

; 771  : 	int		Runway(void)		{return rwIndex;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+304]
	mov	esp, ebp
	pop	ebp
	ret	0
?Runway@DigitalBrain@@QAEHXZ ENDP			; DigitalBrain::Runway
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
;	COMDAT ?Airbase@DigitalBrain@@QAE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?Airbase@DigitalBrain@@QAE?AVVU_ID@@XZ PROC		; DigitalBrain::Airbase, COMDAT
; _this$ = ecx

; 770  : 	VU_ID	Airbase(void)	{return airbase;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+308]
	mov	edx, DWORD PTR [eax+312]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?Airbase@DigitalBrain@@QAE?AVVU_ID@@XZ ENDP		; DigitalBrain::Airbase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
;	COMDAT ?WaitTime@DigitalBrain@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?WaitTime@DigitalBrain@@QAEKXZ PROC			; DigitalBrain::WaitTime, COMDAT
; _this$ = ecx

; 767  : 	VU_TIME	WaitTime(void)							{return waittimer;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+344]
	mov	esp, ebp
	pop	ebp
	ret	0
?WaitTime@DigitalBrain@@QAEKXZ ENDP			; DigitalBrain::WaitTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
;	COMDAT ?SetWaitTimer@DigitalBrain@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_timer$ = 8						; size = 4
?SetWaitTimer@DigitalBrain@@QAEXK@Z PROC		; DigitalBrain::SetWaitTimer, COMDAT
; _this$ = ecx

; 766  : 	void			SetWaitTimer(VU_TIME timer)		{waittimer = timer;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _timer$[ebp]
	mov	DWORD PTR [eax+344], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetWaitTimer@DigitalBrain@@QAEXK@Z ENDP		; DigitalBrain::SetWaitTimer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
;	COMDAT ?ATCStatus@DigitalBrain@@QAE?AW4AtcStatusEnum@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ATCStatus@DigitalBrain@@QAE?AW4AtcStatusEnum@@XZ PROC	; DigitalBrain::ATCStatus, COMDAT
; _this$ = ecx

; 765  : 	AtcStatusEnum	ATCStatus(void)							{return atcstatus;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+328]
	mov	esp, ebp
	pop	ebp
	ret	0
?ATCStatus@DigitalBrain@@QAE?AW4AtcStatusEnum@@XZ ENDP	; DigitalBrain::ATCStatus
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
;	COMDAT ?SetATCStatus@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_status$ = 8						; size = 4
?SetATCStatus@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z PROC ; DigitalBrain::SetATCStatus, COMDAT
; _this$ = ecx

; 764  : 	void			SetATCStatus(AtcStatusEnum status)		{atcstatus = status;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [eax+328], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetATCStatus@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ENDP ; DigitalBrain::SetATCStatus
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
;	COMDAT ?IsSetATC@DigitalBrain@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
_flag$ = 8						; size = 4
?IsSetATC@DigitalBrain@@QAEHH@Z PROC			; DigitalBrain::IsSetATC, COMDAT
; _this$ = ecx

; 709  : 	int		IsSetATC(int flag)								{return (atcFlags & flag) && TRUE;}

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+300]
	and	ecx, DWORD PTR _flag$[ebp]
	je	SHORT $LN3@IsSetATC
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN3@IsSetATC
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@IsSetATC
$LN3@IsSetATC:
	mov	DWORD PTR tv68[ebp], 0
$LN4@IsSetATC:
	mov	eax, DWORD PTR tv68[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSetATC@DigitalBrain@@QAEHH@Z ENDP			; DigitalBrain::IsSetATC
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
;	COMDAT ?ClearATCFlag@DigitalBrain@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flag$ = 8						; size = 4
?ClearATCFlag@DigitalBrain@@QAEXH@Z PROC		; DigitalBrain::ClearATCFlag, COMDAT
; _this$ = ecx

; 708  : 	void	ClearATCFlag(int flag)							{atcFlags &= ~flag;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _flag$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+300]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+300], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?ClearATCFlag@DigitalBrain@@QAEXH@Z ENDP		; DigitalBrain::ClearATCFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
;	COMDAT ?SetATCFlag@DigitalBrain@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flag$ = 8						; size = 4
?SetATCFlag@DigitalBrain@@QAEXH@Z PROC			; DigitalBrain::SetATCFlag, COMDAT
; _this$ = ecx

; 707  : 	void	SetATCFlag(int flag)							{atcFlags |= flag;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+300]
	or	ecx, DWORD PTR _flag$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+300], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetATCFlag@DigitalBrain@@QAEXH@Z ENDP			; DigitalBrain::SetATCFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
;	COMDAT ?SetTrackPoint@DigitalBrain@@QAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
?SetTrackPoint@DigitalBrain@@QAEXMMM@Z PROC		; DigitalBrain::SetTrackPoint, COMDAT
; _this$ = ecx

; 699  : 	void	SetTrackPoint(float x, float y, float z){ SetTrackPoint(x, y); trackZ = z; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTrackPoint@DigitalBrain@@QAEXMM@Z	; DigitalBrain::SetTrackPoint
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _z$[ebp]
	movss	DWORD PTR [eax+156], xmm0
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetTrackPoint@DigitalBrain@@QAEXMMM@Z ENDP		; DigitalBrain::SetTrackPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
;	COMDAT ?SetTrackPoint@DigitalBrain@@QAEXMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?SetTrackPoint@DigitalBrain@@QAEXMM@Z PROC		; DigitalBrain::SetTrackPoint, COMDAT
; _this$ = ecx

; 698  : 	void	SetTrackPoint(float x, float y){ trackX = x; trackY=y; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [eax+148], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [ecx+152], xmm0
	mov	esp, ebp
	pop	ebp
	ret	8
?SetTrackPoint@DigitalBrain@@QAEXMM@Z ENDP		; DigitalBrain::SetTrackPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\digi.h
;	COMDAT ?SetTaxiPoint@DigitalBrain@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pt$ = 8						; size = 4
?SetTaxiPoint@DigitalBrain@@QAEXH@Z PROC		; DigitalBrain::SetTaxiPoint, COMDAT
; _this$ = ecx

; 690  : 	void	SetTaxiPoint(int pt)							{curTaxiPoint = pt;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pt$[ebp]
	mov	DWORD PTR [eax+332], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetTaxiPoint@DigitalBrain@@QAEXH@Z ENDP		; DigitalBrain::SetTaxiPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ PROC	; AircraftClass::DBrain, COMDAT
; _this$ = ecx

; 624  : 	DigitalBrain *DBrain(void)			{return (DigitalBrain *)theBrain;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+672]
	mov	esp, ebp
	pop	ebp
	ret	0
?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ENDP	; AircraftClass::DBrain
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\aircrft.h
;	COMDAT ?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ PROC ; AircraftClass::AutopilotType, COMDAT
; _this$ = ecx

; 329  : 	AutoPilotType	AutopilotType (void) {return autopilotType;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+968]
	mov	esp, ebp
	pop	ebp
	ret	0
?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ ENDP ; AircraftClass::AutopilotType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\sim\include\simbase.h
;	COMDAT ?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ PROC ; SimBaseClass::GetCampaignObject, COMDAT
; _this$ = ecx

; 212  : 	CampBaseClass *GetCampaignObject (void) { return campaignObject.get(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 144				; 00000090H
	call	?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ; VuBin<CampBaseClass>::get
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ENDP ; SimBaseClass::GetCampaignObject
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
;	COMDAT ?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ PROC ; FalconSessionEntity::GetGame, COMDAT
; _this$ = ecx

; 154  : 	FalconGameEntity* GetGame (void)              { return (FalconGameEntity*)VuSessionEntity::Game(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ ; VuSessionEntity::Game
	mov	esp, ebp
	pop	ebp
	ret	0
?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ENDP ; FalconSessionEntity::GetGame
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
;	COMDAT ?GetPlayerEntity@FalconSessionEntity@@QBEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPlayerEntity@FalconSessionEntity@@QBEPAVFalconEntity@@XZ PROC ; FalconSessionEntity::GetPlayerEntity, COMDAT
; _this$ = ecx

; 138  : 	FalconEntity* GetPlayerEntity(void) const     { return playerEntityPtr.get(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 484				; 000001e4H
	call	?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ; VuBin<FalconEntity>::get
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPlayerEntity@FalconSessionEntity@@QBEPAVFalconEntity@@XZ ENDP ; FalconSessionEntity::GetPlayerEntity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ PROC ; VuBin<FalconEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VFalconEntity@@@@QBEPAVFalconEntity@@XZ ENDP ; VuBin<FalconEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ PROC ; VuBin<CampBaseClass>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VCampBaseClass@@@@QBEPAVCampBaseClass@@XZ ENDP ; VuBin<CampBaseClass>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetSType@CampBaseClass@@QBEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSType@CampBaseClass@@QBEEXZ PROC			; CampBaseClass::GetSType, COMDAT
; _this$ = ecx

; 290  : 	uchar GetSType (void)	const						{	return (EntityType())->classInfo_[VU_STYPE]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ; VuEntity::EntityType
	mov	ecx, 1
	imul	ecx, 3
	mov	al, BYTE PTR [eax+ecx+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSType@CampBaseClass@@QBEEXZ ENDP			; CampBaseClass::GetSType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetType@CampBaseClass@@QBEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetType@CampBaseClass@@QBEEXZ PROC			; CampBaseClass::GetType, COMDAT
; _this$ = ecx

; 289  : 	uchar GetType()	const						{	return (EntityType())->classInfo_[VU_TYPE]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ; VuEntity::EntityType
	mov	ecx, 1
	shl	ecx, 1
	mov	al, BYTE PTR [eax+ecx+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetType@CampBaseClass@@QBEEXZ ENDP			; CampBaseClass::GetType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ PROC ; CampBaseClass::GetComponents, COMDAT
; _this$ = ecx

; 141  : 	TailInsertList *GetComponents() const		{	return components; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+160]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ENDP ; CampBaseClass::GetComponents
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetCampId@CampBaseClass@@QBEFXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCampId@CampBaseClass@@QBEFXZ PROC			; CampBaseClass::GetCampId, COMDAT
; _this$ = ecx

; 139  : 	short GetCampId() const						{	return camp_id; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+152]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCampId@CampBaseClass@@QBEFXZ ENDP			; CampBaseClass::GetCampId
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetWPDepartureTime@WayPointClass@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWPDepartureTime@WayPointClass@@QAEKXZ PROC		; WayPointClass::GetWPDepartureTime, COMDAT
; _this$ = ecx

; 203  : 	CampaignTime GetWPDepartureTime()				{ return Depart; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWPDepartureTime@WayPointClass@@QAEKXZ ENDP		; WayPointClass::GetWPDepartureTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campwp.h
;	COMDAT ?GetWPAction@WayPointClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWPAction@WayPointClass@@QAEHXZ PROC			; WayPointClass::GetWPAction, COMDAT
; _this$ = ecx

; 170  : 	int GetWPAction(void)							{ return (int)Action; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+24]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWPAction@WayPointClass@@QAEHXZ ENDP			; WayPointClass::GetWPAction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_cit$2 = -84						; size = 12
_unitWalker$3 = -72					; size = 12
$T4 = -60						; size = 4
tv246 = -56						; size = 4
tv242 = -52						; size = 4
$T5 = -48						; size = 4
tv229 = -44						; size = 4
tv223 = -40						; size = 4
tv219 = -36						; size = 4
_myRad$ = -32						; size = 4
_tmpY$ = -28						; size = 4
_tmpX$ = -24						; size = 4
_testRad$ = -20						; size = 4
_testObject$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_unit$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
?CheckPointGlobal@@YAPAVSimBaseClass@@PAVCampBaseClass@@MM@Z PROC ; CheckPointGlobal

; 4526 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CheckPointGlobal@@YAPAVSimBaseClass@@PAVCampBaseClass@@MM@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 4527 : 	float tmpX, tmpY;
; 4528 : 	SimBaseClass* testObject;
; 4529 : 	float myRad, testRad; 
; 4530 : 
; 4531 : 	myRad = 40.0f;

	movss	xmm0, DWORD PTR __real@42200000
	movss	DWORD PTR _myRad$[ebp], xmm0

; 4532 : 
; 4533 : 	{
; 4534 : 		// destroy iterator here
; 4535 : 		VuListIterator	unitWalker(SimDriver.objectList);

	mov	eax, DWORD PTR ?SimDriver@@3VSimulationDriver@@A
	push	eax
	lea	ecx, DWORD PTR _unitWalker$3[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4536 : 		testObject = (SimBaseClass*) unitWalker.GetFirst();

	lea	ecx, DWORD PTR _unitWalker$3[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _testObject$[ebp], eax
$LN15@CheckPoint:

; 4537 : 		while (testObject)

	cmp	DWORD PTR _testObject$[ebp], 0
	je	$LN9@CheckPoint

; 4538 : 		{
; 4539 : 			// ignore objects under these conditions:
; 4540 : 			//		Ourself
; 4541 : 			//		Not on ground
; 4542 : 			if ( !testObject->OnGround() )

	mov	ecx, DWORD PTR _testObject$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _testObject$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	jne	SHORT $LN8@CheckPoint

; 4543 : 			{
; 4544 : 				testObject = (SimBaseClass*) unitWalker.GetNext();

	lea	ecx, DWORD PTR _unitWalker$3[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _testObject$[ebp], eax

; 4545 : 				continue;

	jmp	SHORT $LN15@CheckPoint
$LN8@CheckPoint:

; 4546 : 			}
; 4547 : 
; 4548 : 			tmpX = testObject->XPos() - x;

	mov	ecx, DWORD PTR _testObject$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv219[ebp]
	movss	xmm0, DWORD PTR tv219[ebp]
	subss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR _tmpX$[ebp], xmm0

; 4549 : 			tmpY = testObject->YPos() - y;

	mov	ecx, DWORD PTR _testObject$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv223[ebp]
	movss	xmm0, DWORD PTR tv223[ebp]
	subss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR _tmpY$[ebp], xmm0

; 4550 : 
; 4551 : 			if ( testObject->drawPointer )

	mov	ecx, DWORD PTR _testObject$[ebp]
	cmp	DWORD PTR [ecx+332], 0
	je	SHORT $LN7@CheckPoint

; 4552 : 				testRad = testObject->drawPointer->Radius() + myRad ;

	mov	edx, DWORD PTR _testObject$[ebp]
	mov	ecx, DWORD PTR [edx+332]
	call	?Radius@DrawableObject@@QBEMXZ		; DrawableObject::Radius
	fstp	DWORD PTR tv229[ebp]
	movss	xmm0, DWORD PTR tv229[ebp]
	addss	xmm0, DWORD PTR _myRad$[ebp]
	movss	DWORD PTR _testRad$[ebp], xmm0

; 4553 : 			else

	jmp	SHORT $LN6@CheckPoint
$LN7@CheckPoint:

; 4554 : 				testRad = 40.0f + myRad;

	movss	xmm0, DWORD PTR __real@42200000
	addss	xmm0, DWORD PTR _myRad$[ebp]
	movss	DWORD PTR _testRad$[ebp], xmm0
$LN6@CheckPoint:

; 4555 : 			
; 4556 : 			// if object is within a given range of the point return object
; 4557 : 			if ( tmpX*tmpX + tmpY*tmpY < testRad * testRad )

	movss	xmm0, DWORD PTR _tmpX$[ebp]
	mulss	xmm0, DWORD PTR _tmpX$[ebp]
	movss	xmm1, DWORD PTR _tmpY$[ebp]
	mulss	xmm1, DWORD PTR _tmpY$[ebp]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR _testRad$[ebp]
	mulss	xmm1, DWORD PTR _testRad$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN5@CheckPoint

; 4558 : 			{
; 4559 : 				return testObject;

	mov	eax, DWORD PTR _testObject$[ebp]
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _unitWalker$3[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
	mov	eax, DWORD PTR $T5[ebp]
	jmp	$LN11@CheckPoint
$LN5@CheckPoint:

; 4560 : 			}
; 4561 : 			testObject = (SimBaseClass*) unitWalker.GetNext();

	lea	ecx, DWORD PTR _unitWalker$3[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _testObject$[ebp], eax

; 4562 : 		}

	jmp	$LN15@CheckPoint
$LN9@CheckPoint:

; 4563 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _unitWalker$3[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator

; 4564 : 
; 4565 : 	if(unit)

	cmp	DWORD PTR _unit$[ebp], 0
	je	$LN4@CheckPoint

; 4566 : 	{
; 4567 : 		VuListIterator	cit(unit->GetComponents());

	mov	ecx, DWORD PTR _unit$[ebp]
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	push	eax
	lea	ecx, DWORD PTR _cit$2[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 4568 : 		testObject = (SimBaseClass*)cit.GetFirst();

	lea	ecx, DWORD PTR _cit$2[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _testObject$[ebp], eax
$LN3@CheckPoint:

; 4569 : 		while(testObject)

	cmp	DWORD PTR _testObject$[ebp], 0
	je	$LN2@CheckPoint

; 4570 : 		{
; 4571 : 			tmpX = testObject->XPos() - x;

	mov	ecx, DWORD PTR _testObject$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv242[ebp]
	movss	xmm0, DWORD PTR tv242[ebp]
	subss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR _tmpX$[ebp], xmm0

; 4572 : 			tmpY = testObject->YPos() - y;

	mov	ecx, DWORD PTR _testObject$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv246[ebp]
	movss	xmm0, DWORD PTR tv246[ebp]
	subss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR _tmpY$[ebp], xmm0

; 4573 : 
; 4574 : 			testRad = 40.0f + myRad; // FRB - Increase search dist. due to new parking spot locations ????

	movss	xmm0, DWORD PTR __real@42200000
	addss	xmm0, DWORD PTR _myRad$[ebp]
	movss	DWORD PTR _testRad$[ebp], xmm0

; 4575 : 			
; 4576 : 			// if object is within a given range of the point return object
; 4577 : 			if ( tmpX*tmpX + tmpY*tmpY < testRad * testRad )

	movss	xmm0, DWORD PTR _tmpX$[ebp]
	mulss	xmm0, DWORD PTR _tmpX$[ebp]
	movss	xmm1, DWORD PTR _tmpY$[ebp]
	mulss	xmm1, DWORD PTR _tmpY$[ebp]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR _testRad$[ebp]
	mulss	xmm1, DWORD PTR _testRad$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN1@CheckPoint

; 4578 : 			{
; 4579 : 				return testObject;

	mov	ecx, DWORD PTR _testObject$[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cit$2[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
	mov	eax, DWORD PTR $T4[ebp]
	jmp	SHORT $LN11@CheckPoint
$LN1@CheckPoint:

; 4580 : 			}
; 4581 : 			testObject = (SimBaseClass*)cit.GetNext();

	lea	ecx, DWORD PTR _cit$2[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _testObject$[ebp], eax

; 4582 : 		}

	jmp	$LN3@CheckPoint
$LN2@CheckPoint:

; 4583 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cit$2[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
$LN4@CheckPoint:

; 4584 : 	return NULL;

	xor	eax, eax
$LN11@CheckPoint:

; 4585 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?CheckPointGlobal@@YAPAVSimBaseClass@@PAVCampBaseClass@@MM@Z$0:
	lea	ecx, DWORD PTR _unitWalker$3[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__unwindfunclet$?CheckPointGlobal@@YAPAVSimBaseClass@@PAVCampBaseClass@@MM@Z$1:
	lea	ecx, DWORD PTR _cit$2[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__ehhandler$?CheckPointGlobal@@YAPAVSimBaseClass@@PAVCampBaseClass@@MM@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?CheckPointGlobal@@YAPAVSimBaseClass@@PAVCampBaseClass@@MM@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CheckPointGlobal@@YAPAVSimBaseClass@@PAVCampBaseClass@@MM@Z ENDP ; CheckPointGlobal
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_unitWalker$ = -92					; size = 12
$T2 = -80						; size = 4
$T3 = -76						; size = 4
tv282 = -72						; size = 4
tv269 = -68						; size = 4
tv263 = -64						; size = 4
tv255 = -60						; size = 4
tv245 = -56						; size = 4
tv241 = -52						; size = 4
_tmpY$ = -48						; size = 4
_tmpX$ = -44						; size = 4
_minDist$ = -40						; size = 4
_testRad$ = -36						; size = 4
_closest$ = -32						; size = 4
_myRad$ = -28						; size = 4
_testDist$ = -24					; size = 4
_testObject$ = -20					; size = 4
_BigBoy$ = -13						; size = 1
__$EHRec$ = -12						; size = 12
_self$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
?CheckTaxiPointGlobal@@YAPAVSimBaseClass@@PAVAircraftClass@@MM@Z PROC ; CheckTaxiPointGlobal

; 4589 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CheckTaxiPointGlobal@@YAPAVSimBaseClass@@PAVAircraftClass@@MM@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 4590 : 	float tmpX, tmpY;
; 4591 : 	bool BigBoy = false;

	mov	BYTE PTR _BigBoy$[ebp], 0

; 4592 : 	SimBaseClass* testObject;
; 4593 : 	SimBaseClass* closest = NULL;

	mov	DWORD PTR _closest$[ebp], 0

; 4594 : 	float myRad, testRad, testDist, minDist =  1000000.0F; //square of 1000

	movss	xmm0, DWORD PTR __real@49742400
	movss	DWORD PTR _minDist$[ebp], xmm0

; 4595 : 
; 4596 : 
; 4597 : 	// Cobra - "large" aircraft?
; 4598 : 	if (self->af->GetParkType() == LargeParkPt)

	mov	eax, DWORD PTR _self$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?GetParkType@AirframeClass@@QAEHXZ	; AirframeClass::GetParkType
	cmp	eax, 12					; 0000000cH
	jne	SHORT $LN16@CheckTaxiP

; 4599 : 		BigBoy = true;

	mov	BYTE PTR _BigBoy$[ebp], 1
$LN16@CheckTaxiP:

; 4600 : 
; 4601 : 	if ( self && self->drawPointer )

	cmp	DWORD PTR _self$[ebp], 0
	je	SHORT $LN15@CheckTaxiP
	mov	ecx, DWORD PTR _self$[ebp]
	cmp	DWORD PTR [ecx+332], 0
	je	SHORT $LN15@CheckTaxiP

; 4602 : 		myRad = self->drawPointer->Radius();

	mov	edx, DWORD PTR _self$[ebp]
	mov	ecx, DWORD PTR [edx+332]
	call	?Radius@DrawableObject@@QBEMXZ		; DrawableObject::Radius
	fstp	DWORD PTR _myRad$[ebp]

; 4603 : 	else

	jmp	SHORT $LN14@CheckTaxiP
$LN15@CheckTaxiP:

; 4604 : 		myRad = 40.0f;

	movss	xmm0, DWORD PTR __real@42200000
	movss	DWORD PTR _myRad$[ebp], xmm0
$LN14@CheckTaxiP:

; 4605 : 
; 4606 : 	// Cobra - Slim down the Big Boys
; 4607 : 	if (BigBoy)

	movzx	eax, BYTE PTR _BigBoy$[ebp]
	test	eax, eax
	je	SHORT $LN13@CheckTaxiP

; 4608 : 		myRad = 10.f;

	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR _myRad$[ebp], xmm0
$LN13@CheckTaxiP:

; 4609 : 
; 4610 : 	VuListIterator	unitWalker(SimDriver.objectList);

	mov	ecx, DWORD PTR ?SimDriver@@3VSimulationDriver@@A
	push	ecx
	lea	ecx, DWORD PTR _unitWalker$[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4611 : 	testObject = (SimBaseClass*) unitWalker.GetFirst();

	lea	ecx, DWORD PTR _unitWalker$[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _testObject$[ebp], eax
$LN21@CheckTaxiP:

; 4612 : 
; 4613 : 	while (testObject)

	cmp	DWORD PTR _testObject$[ebp], 0
	je	$LN11@CheckTaxiP

; 4614 : 	{		
; 4615 : 		// ignore objects under these conditions:
; 4616 : 		//		Ourself
; 4617 : 		//		Not on ground
; 4618 : 		if ( !testObject->OnGround() ||
; 4619 : 			 testObject == self )

	mov	edx, DWORD PTR _testObject$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _testObject$[ebp]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	test	eax, eax
	je	SHORT $LN9@CheckTaxiP
	mov	eax, DWORD PTR _testObject$[ebp]
	cmp	eax, DWORD PTR _self$[ebp]
	jne	SHORT $LN10@CheckTaxiP
$LN9@CheckTaxiP:

; 4620 : 		{
; 4621 : 			testObject = (SimBaseClass*) unitWalker.GetNext();

	lea	ecx, DWORD PTR _unitWalker$[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _testObject$[ebp], eax

; 4622 : 			continue;

	jmp	SHORT $LN21@CheckTaxiP
$LN10@CheckTaxiP:

; 4623 : 		}
; 4624 : 
; 4625 : 		tmpX = testObject->XPos() - x;

	mov	ecx, DWORD PTR _testObject$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv241[ebp]
	movss	xmm0, DWORD PTR tv241[ebp]
	subss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR _tmpX$[ebp], xmm0

; 4626 : 		tmpY = testObject->YPos() - y;

	mov	ecx, DWORD PTR _testObject$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv245[ebp]
	movss	xmm0, DWORD PTR tv245[ebp]
	subss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR _tmpY$[ebp], xmm0

; 4627 : 
; 4628 : 		testDist = tmpX*tmpX + tmpY*tmpY;

	movss	xmm0, DWORD PTR _tmpX$[ebp]
	mulss	xmm0, DWORD PTR _tmpX$[ebp]
	movss	xmm1, DWORD PTR _tmpY$[ebp]
	mulss	xmm1, DWORD PTR _tmpY$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _testDist$[ebp], xmm0

; 4629 : 
; 4630 : 		// Cobra - Too far away to be in the way
; 4631 : 		if (testDist > 300.f * 300.f)

	movss	xmm0, DWORD PTR _testDist$[ebp]
	comiss	xmm0, DWORD PTR __real@47afc800
	jbe	SHORT $LN8@CheckTaxiP

; 4632 : 		{
; 4633 : 			testObject = (SimBaseClass*) unitWalker.GetNext();

	lea	ecx, DWORD PTR _unitWalker$[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _testObject$[ebp], eax

; 4634 : 			continue;

	jmp	$LN21@CheckTaxiP
$LN8@CheckTaxiP:

; 4635 : 		}
; 4636 : 
; 4637 : 		if ( testObject->drawPointer )

	mov	ecx, DWORD PTR _testObject$[ebp]
	cmp	DWORD PTR [ecx+332], 0
	je	SHORT $LN7@CheckTaxiP

; 4638 : 			testRad = testObject->drawPointer->Radius() + myRad + AVOID_RANGE;	// FRB - decreased AVOID_RANGE

	mov	edx, DWORD PTR _testObject$[ebp]
	mov	ecx, DWORD PTR [edx+332]
	call	?Radius@DrawableObject@@QBEMXZ		; DrawableObject::Radius
	fstp	DWORD PTR tv255[ebp]
	movss	xmm0, DWORD PTR tv255[ebp]
	addss	xmm0, DWORD PTR _myRad$[ebp]
	addss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR _testRad$[ebp], xmm0

; 4639 : 		else

	jmp	SHORT $LN6@CheckTaxiP
$LN7@CheckTaxiP:

; 4640 : 			testRad = 40.0f + myRad + AVOID_RANGE;

	movss	xmm0, DWORD PTR __real@42200000
	addss	xmm0, DWORD PTR _myRad$[ebp]
	addss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR _testRad$[ebp], xmm0
$LN6@CheckTaxiP:

; 4641 : 		
; 4642 : 		// if object is within a given range of the point return object
; 4643 : 		if ( testDist < testRad * testRad && testObject->GetVt() < self->GetVt() + 20.0F)

	movss	xmm0, DWORD PTR _testRad$[ebp]
	mulss	xmm0, DWORD PTR _testRad$[ebp]
	comiss	xmm0, DWORD PTR _testDist$[ebp]
	jbe	$LN2@CheckTaxiP
	mov	eax, DWORD PTR _testObject$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _testObject$[ebp]
	mov	eax, DWORD PTR [edx+220]
	call	eax
	fstp	DWORD PTR tv263[ebp]
	movss	xmm0, DWORD PTR tv263[ebp]
	mov	ecx, DWORD PTR _self$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _self$[ebp]
	mov	eax, DWORD PTR [edx+220]
	movss	DWORD PTR tv282[ebp], xmm0
	call	eax
	fstp	DWORD PTR tv269[ebp]
	movss	xmm0, DWORD PTR tv269[ebp]
	addss	xmm0, DWORD PTR __real@41a00000
	movss	xmm1, DWORD PTR tv282[ebp]
	comiss	xmm0, xmm1
	jbe	SHORT $LN2@CheckTaxiP

; 4644 : 		{
; 4645 : 			if(!closest)

	cmp	DWORD PTR _closest$[ebp], 0
	jne	SHORT $LN4@CheckTaxiP

; 4646 : 			{
; 4647 : 				closest = testObject;

	mov	ecx, DWORD PTR _testObject$[ebp]
	mov	DWORD PTR _closest$[ebp], ecx

; 4648 : 				minDist = testDist;

	movss	xmm0, DWORD PTR _testDist$[ebp]
	movss	DWORD PTR _minDist$[ebp], xmm0
	jmp	SHORT $LN2@CheckTaxiP
$LN4@CheckTaxiP:

; 4649 : 			}
; 4650 : 			else if( testDist < minDist)

	movss	xmm0, DWORD PTR _minDist$[ebp]
	comiss	xmm0, DWORD PTR _testDist$[ebp]
	jbe	SHORT $LN2@CheckTaxiP

; 4651 : 			{
; 4652 : //				if(testDist <  10000.0F) // 100'
; 4653 : 				if(testDist <  2500.0F) // 30JAN04 - FRB - 50'

	movss	xmm0, DWORD PTR __real@451c4000
	comiss	xmm0, DWORD PTR _testDist$[ebp]
	jbe	SHORT $LN1@CheckTaxiP

; 4654 : 					return testObject;

	mov	edx, DWORD PTR _testObject$[ebp]
	mov	DWORD PTR $T3[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _unitWalker$[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
	mov	eax, DWORD PTR $T3[ebp]
	jmp	SHORT $LN17@CheckTaxiP
$LN1@CheckTaxiP:

; 4655 : 				closest = testObject;

	mov	eax, DWORD PTR _testObject$[ebp]
	mov	DWORD PTR _closest$[ebp], eax

; 4656 : 				minDist = testDist;

	movss	xmm0, DWORD PTR _testDist$[ebp]
	movss	DWORD PTR _minDist$[ebp], xmm0
$LN2@CheckTaxiP:

; 4657 : 			}
; 4658 : 		}
; 4659 : 		testObject = (SimBaseClass*) unitWalker.GetNext();

	lea	ecx, DWORD PTR _unitWalker$[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _testObject$[ebp], eax

; 4660 : 	}

	jmp	$LN21@CheckTaxiP
$LN11@CheckTaxiP:

; 4661 : 
; 4662 : 	return closest;

	mov	ecx, DWORD PTR _closest$[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _unitWalker$[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
	mov	eax, DWORD PTR $T2[ebp]
$LN17@CheckTaxiP:

; 4663 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?CheckTaxiPointGlobal@@YAPAVSimBaseClass@@PAVAircraftClass@@MM@Z$0:
	lea	ecx, DWORD PTR _unitWalker$[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__ehhandler$?CheckTaxiPointGlobal@@YAPAVSimBaseClass@@PAVAircraftClass@@MM@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-84]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?CheckTaxiPointGlobal@@YAPAVSimBaseClass@@PAVAircraftClass@@MM@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CheckTaxiPointGlobal@@YAPAVSimBaseClass@@PAVAircraftClass@@MM@Z ENDP ; CheckTaxiPointGlobal
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_unitWalker$ = -64					; size = 12
$T2 = -52						; size = 4
$T3 = -48						; size = 4
tv207 = -44						; size = 4
tv201 = -40						; size = 4
tv197 = -36						; size = 4
_tmpY$ = -32						; size = 4
_tmpX$ = -28						; size = 4
_testRad$ = -24						; size = 4
_myRad$ = -20						; size = 4
_testObject$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_self$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
?CheckPointGlobal@@YAPAVSimBaseClass@@PAVAircraftClass@@MM@Z PROC ; CheckPointGlobal

; 4479 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CheckPointGlobal@@YAPAVSimBaseClass@@PAVAircraftClass@@MM@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 4480 : 	float tmpX, tmpY;
; 4481 : 	SimBaseClass* testObject;
; 4482 : 	float myRad, testRad; 
; 4483 : 
; 4484 : 
; 4485 : 	if ( self && self->drawPointer ){

	cmp	DWORD PTR _self$[ebp], 0
	je	SHORT $LN9@CheckPoint
	mov	eax, DWORD PTR _self$[ebp]
	cmp	DWORD PTR [eax+332], 0
	je	SHORT $LN9@CheckPoint

; 4486 : 		myRad = self->drawPointer->Radius();

	mov	ecx, DWORD PTR _self$[ebp]
	mov	ecx, DWORD PTR [ecx+332]
	call	?Radius@DrawableObject@@QBEMXZ		; DrawableObject::Radius
	fstp	DWORD PTR _myRad$[ebp]

; 4487 : 	}
; 4488 : 	else {

	jmp	SHORT $LN8@CheckPoint
$LN9@CheckPoint:

; 4489 : 		myRad = 40.0f;

	movss	xmm0, DWORD PTR __real@42200000
	movss	DWORD PTR _myRad$[ebp], xmm0
$LN8@CheckPoint:

; 4490 : 	}
; 4491 : 
; 4492 : 	VuListIterator	unitWalker(SimDriver.objectList);

	mov	edx, DWORD PTR ?SimDriver@@3VSimulationDriver@@A
	push	edx
	lea	ecx, DWORD PTR _unitWalker$[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4493 : 	testObject = (SimBaseClass*) unitWalker.GetFirst();

	lea	ecx, DWORD PTR _unitWalker$[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _testObject$[ebp], eax
$LN13@CheckPoint:

; 4494 : 	while (testObject){

	cmp	DWORD PTR _testObject$[ebp], 0
	je	$LN6@CheckPoint

; 4495 : 		// ignore objects under these conditions:
; 4496 : 		//		Ourself
; 4497 : 		//		Not on ground
; 4498 : 		if ( !testObject->OnGround() ||
; 4499 : 			 testObject == self )

	mov	eax, DWORD PTR _testObject$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _testObject$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	SHORT $LN4@CheckPoint
	mov	ecx, DWORD PTR _testObject$[ebp]
	cmp	ecx, DWORD PTR _self$[ebp]
	jne	SHORT $LN5@CheckPoint
$LN4@CheckPoint:

; 4500 : 		{
; 4501 : 			testObject = (SimBaseClass*) unitWalker.GetNext();

	lea	ecx, DWORD PTR _unitWalker$[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _testObject$[ebp], eax

; 4502 : 			continue;

	jmp	SHORT $LN13@CheckPoint
$LN5@CheckPoint:

; 4503 : 		}
; 4504 : 
; 4505 : 		tmpX = testObject->XPos() - x;

	mov	ecx, DWORD PTR _testObject$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv197[ebp]
	movss	xmm0, DWORD PTR tv197[ebp]
	subss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR _tmpX$[ebp], xmm0

; 4506 : 		tmpY = testObject->YPos() - y;

	mov	ecx, DWORD PTR _testObject$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv201[ebp]
	movss	xmm0, DWORD PTR tv201[ebp]
	subss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR _tmpY$[ebp], xmm0

; 4507 : 
; 4508 : 		if ( testObject->drawPointer )

	mov	edx, DWORD PTR _testObject$[ebp]
	cmp	DWORD PTR [edx+332], 0
	je	SHORT $LN3@CheckPoint

; 4509 : 			testRad = testObject->drawPointer->Radius() + myRad ;	// FRB - Increase search dist. due to new parking spot locations ????

	mov	eax, DWORD PTR _testObject$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	call	?Radius@DrawableObject@@QBEMXZ		; DrawableObject::Radius
	fstp	DWORD PTR tv207[ebp]
	movss	xmm0, DWORD PTR tv207[ebp]
	addss	xmm0, DWORD PTR _myRad$[ebp]
	movss	DWORD PTR _testRad$[ebp], xmm0

; 4510 : 		else

	jmp	SHORT $LN2@CheckPoint
$LN3@CheckPoint:

; 4511 : 			testRad = 40.0f + myRad;

	movss	xmm0, DWORD PTR __real@42200000
	addss	xmm0, DWORD PTR _myRad$[ebp]
	movss	DWORD PTR _testRad$[ebp], xmm0
$LN2@CheckPoint:

; 4512 : 		
; 4513 : 		// if object is within a given range of the point return object
; 4514 : 		if ( tmpX*tmpX + tmpY*tmpY < testRad * testRad )

	movss	xmm0, DWORD PTR _tmpX$[ebp]
	mulss	xmm0, DWORD PTR _tmpX$[ebp]
	movss	xmm1, DWORD PTR _tmpY$[ebp]
	mulss	xmm1, DWORD PTR _tmpY$[ebp]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR _testRad$[ebp]
	mulss	xmm1, DWORD PTR _testRad$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN1@CheckPoint

; 4515 : 		{
; 4516 : 			return testObject;

	mov	ecx, DWORD PTR _testObject$[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _unitWalker$[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
	mov	eax, DWORD PTR $T3[ebp]
	jmp	SHORT $LN10@CheckPoint
$LN1@CheckPoint:

; 4517 : 		}
; 4518 : 		testObject = (SimBaseClass*) unitWalker.GetNext();

	lea	ecx, DWORD PTR _unitWalker$[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _testObject$[ebp], eax

; 4519 : 	}

	jmp	$LN13@CheckPoint
$LN6@CheckPoint:

; 4520 : 
; 4521 : 	return NULL;

	mov	DWORD PTR $T2[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _unitWalker$[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
	mov	eax, DWORD PTR $T2[ebp]
$LN10@CheckPoint:

; 4522 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?CheckPointGlobal@@YAPAVSimBaseClass@@PAVAircraftClass@@MM@Z$0:
	lea	ecx, DWORD PTR _unitWalker$[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__ehhandler$?CheckPointGlobal@@YAPAVSimBaseClass@@PAVAircraftClass@@MM@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?CheckPointGlobal@@YAPAVSimBaseClass@@PAVAircraftClass@@MM@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CheckPointGlobal@@YAPAVSimBaseClass@@PAVAircraftClass@@MM@Z ENDP ; CheckPointGlobal
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_oldTrafficRange$1 = -76				; size = 4
tv374 = -72						; size = 4
_ydiff$2 = -68						; size = 4
_xdiff$3 = -64						; size = 4
tv365 = -60						; size = 4
tv414 = -56						; size = 4
tv361 = -52						; size = 4
tv357 = -48						; size = 4
tv412 = -44						; size = 4
tv353 = -40						; size = 4
_altitude$4 = -36					; size = 4
tv173 = -32						; size = 4
tv147 = -28						; size = 4
tv95 = -24						; size = 4
_angle$5 = -20						; size = 4
_navangle$6 = -16					; size = 4
_traffic$7 = -12					; size = 4
_radioMessage$8 = -8					; size = 4
_this$ = -4						; size = 4
_aircraft$ = 8						; size = 4
_playerInfo$ = 12					; size = 4
?CheckForTraffic@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z PROC ; ATCBrain::CheckForTraffic
; _this$ = ecx

; 5132 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	DWORD PTR _this$[ebp], ecx

; 5133 : 	// check 'checkTrafficTime'; if not time, skip traffic routine:  check every 10 seconds
; 5134 : 	if (self->brain->checkTrafficTime < SimLibElapsedTime) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+240]
	mov	eax, DWORD PTR [edx+28]
	cmp	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	$LN3@CheckForTr

; 5135 : 		self->brain->checkTrafficTime = SimLibElapsedTime + 10 * CampaignSeconds;

	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	ecx, 10000				; 00002710H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [eax+240]
	mov	DWORD PTR [edx+28], ecx

; 5136 : 
; 5137 : 		//setup variables
; 5138 : 		FalconRadioChatterMessage	*radioMessage = NULL;

	mov	DWORD PTR _radioMessage$8[ebp], 0

; 5139 : 		float altitude = 0.0F;				// altitude of traffic

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _altitude$4[ebp], xmm0

; 5140 : 		float oldTrafficRange = 0.0F;		// hold range of last traffic call

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _oldTrafficRange$1[ebp], xmm0

; 5141 : 		float xdiff;				// difference in x coord between us and traffic
; 5142 : 		float ydiff;				// difference in y coord between us and traffic
; 5143 : 		float angle;				// computed angle in radians to traffic
; 5144 : 		int navangle;				// computed degrees off nose
; 5145 : 		
; 5146 : 
; 5147 : 		if (self->brain->pLastTraffic != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+240]
	cmp	DWORD PTR [edx+36], 0
	je	SHORT $LN12@CheckForTr

; 5148 : 			self->brain->oldTrafficRange = self->brain->trafficRange;	//store range of last traffic call

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+240]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+240]
	mov	ecx, DWORD PTR [edx+40]
	mov	DWORD PTR [eax+44], ecx
$LN12@CheckForTr:

; 5149 : 		
; 5150 : 		// Check for Traffic
; 5151 : 		SimBaseClass *traffic = SimDriver.FindNearestTraffic(aircraft, self, &altitude);

	lea	edx, DWORD PTR _altitude$4[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _aircraft$[ebp]
	push	edx
	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?FindNearestTraffic@SimulationDriver@@QAEPAVSimBaseClass@@PAVAircraftClass@@PAVObjectiveClass@@PAM@Z ; SimulationDriver::FindNearestTraffic
	mov	DWORD PTR _traffic$7[ebp], eax

; 5152 : 
; 5153 : 		if (traffic == NULL)

	cmp	DWORD PTR _traffic$7[ebp], 0
	jne	SHORT $LN11@CheckForTr

; 5154 : 			self->brain->trafficCheck = noTraffic;		//if no traffic set status to none	

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+240]
	mov	DWORD PTR [edx+52], 0
$LN11@CheckForTr:

; 5155 : 		
; 5156 : 		switch (self->brain->trafficCheck)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+240]
	mov	eax, DWORD PTR [edx+52]
	mov	DWORD PTR tv95[ebp], eax
	cmp	DWORD PTR tv95[ebp], 4
	ja	$LN5@CheckForTr
	mov	ecx, DWORD PTR tv95[ebp]
	jmp	DWORD PTR $LN20@CheckForTr[ecx*4]
$LN8@CheckForTr:

; 5157 : 		{
; 5158 : 		case noTraffic:
; 5159 : 			self->brain->trafficInSightFlag = FALSE;	// no traffic to see

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+240]
	mov	BYTE PTR [ecx+56], 0

; 5160 : 			break;

	jmp	$LN9@CheckForTr
$LN7@CheckForTr:

; 5161 : 
; 5162 : 		case priorityTraffic:		// not used right now, but may use it later
; 5163 : 		case newTraffic:			// traffic not called out last time
; 5164 : 			radioMessage = CreateCallFromATC(self, aircraft, rcATCTRAFFICWARNING, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN16@CheckForTr
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv147[ebp], eax
	jmp	SHORT $LN17@CheckForTr
$LN16@CheckForTr:
	mov	DWORD PTR tv147[ebp], 0
$LN17@CheckForTr:
	mov	eax, DWORD PTR tv147[ebp]
	push	eax
	push	298					; 0000012aH
	mov	ecx, DWORD PTR _aircraft$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$8[ebp], eax

; 5165 : 			self->brain->trafficInSightFlag = FALSE;		// not in sight since it's first call

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+240]
	mov	BYTE PTR [eax+56], 0

; 5166 : 			break;

	jmp	SHORT $LN9@CheckForTr
$LN6@CheckForTr:

; 5167 : 
; 5168 : 		case oldTraffic:			// Same traffic called last time
; 5169 : 			radioMessage = CreateCallFromATC(self, aircraft, rcATCTRAFFICWARNING2, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN18@CheckForTr
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv173[ebp], eax
	jmp	SHORT $LN19@CheckForTr
$LN18@CheckForTr:
	mov	DWORD PTR tv173[ebp], 0
$LN19@CheckForTr:
	mov	edx, DWORD PTR tv173[ebp]
	push	edx
	push	299					; 0000012bH
	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$8[ebp], eax
$LN5@CheckForTr:
$LN9@CheckForTr:

; 5170 : 			break;
; 5171 : 
; 5172 : 		default:
; 5173 : 		//we should never get here
; 5174 : 		ShiWarning("We are in an undefined traffic call state, we shouldn't be here");
; 5175 : 		}
; 5176 : 
; 5177 : 		// Traffic in sight and this traffic has been called out before so return
; 5178 : 		if (self->brain->trafficInSightFlag == TRUE && traffic == self->brain->pLastTraffic)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+240]
	movzx	eax, BYTE PTR [edx+56]
	cmp	eax, 1
	jne	SHORT $LN4@CheckForTr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+240]
	mov	ecx, DWORD PTR _traffic$7[ebp]
	cmp	ecx, DWORD PTR [eax+36]
	jne	SHORT $LN4@CheckForTr

; 5179 : 			return;

	jmp	$LN14@CheckForTr
$LN4@CheckForTr:

; 5180 : 
; 5181 : 		
; 5182 : 		// Begin O'Clock code - convert to compass angle
; 5183 : 		if (self->brain->trafficCheck != noTraffic)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+240]
	cmp	DWORD PTR [ecx+52], 0
	je	$LN3@CheckForTr

; 5184 : 		{
; 5185 : 			xdiff = traffic->XPos() - aircraft->XPos();

	mov	ecx, DWORD PTR _traffic$7[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv353[ebp]
	movss	xmm0, DWORD PTR tv353[ebp]
	mov	ecx, DWORD PTR _aircraft$[ebp]
	movss	DWORD PTR tv412[ebp], xmm0
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv357[ebp]
	movss	xmm0, DWORD PTR tv412[ebp]
	subss	xmm0, DWORD PTR tv357[ebp]
	movss	DWORD PTR _xdiff$3[ebp], xmm0

; 5186 : 			ydiff = traffic->YPos() - aircraft->YPos();

	mov	ecx, DWORD PTR _traffic$7[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv361[ebp]
	movss	xmm0, DWORD PTR tv361[ebp]
	mov	ecx, DWORD PTR _aircraft$[ebp]
	movss	DWORD PTR tv414[ebp], xmm0
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv365[ebp]
	movss	xmm0, DWORD PTR tv414[ebp]
	subss	xmm0, DWORD PTR tv365[ebp]
	movss	DWORD PTR _ydiff$2[ebp], xmm0

; 5187 : 			
; 5188 : 			angle = (float)atan2(ydiff, xdiff);

	cvtss2sd xmm0, DWORD PTR _xdiff$3[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _ydiff$2[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _angle$5[ebp]

; 5189 : 			angle = angle - aircraft->Yaw();

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR tv374[ebp]
	movss	xmm0, DWORD PTR _angle$5[ebp]
	subss	xmm0, DWORD PTR tv374[ebp]
	movss	DWORD PTR _angle$5[ebp], xmm0

; 5190 : 			navangle	=  FloatToInt32 (RTD * angle);

	movss	xmm0, DWORD PTR __real@42652ee1
	mulss	xmm0, DWORD PTR _angle$5[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _navangle$6[ebp], eax

; 5191 : 			if(navangle < 0)

	cmp	DWORD PTR _navangle$6[ebp], 0
	jge	SHORT $LN2@CheckForTr

; 5192 : 				navangle = 360 + navangle;

	mov	edx, DWORD PTR _navangle$6[ebp]
	add	edx, 360				; 00000168H
	mov	DWORD PTR _navangle$6[ebp], edx
$LN2@CheckForTr:

; 5193 : 
; 5194 : 	
; 5195 : 			radioMessage->dataBlock.edata[3] = navangle / 30;	// scale compass angle for radio eData

	mov	eax, DWORD PTR _navangle$6[ebp]
	cdq
	mov	ecx, 30					; 0000001eH
	idiv	ecx
	mov	edx, 2
	imul	edx, 3
	mov	ecx, DWORD PTR _radioMessage$8[ebp]
	mov	WORD PTR [ecx+edx+64], ax

; 5196 : 			if(radioMessage->dataBlock.edata[3] >= 12)

	mov	edx, 2
	imul	edx, 3
	mov	eax, DWORD PTR _radioMessage$8[ebp]
	movsx	ecx, WORD PTR [eax+edx+64]
	cmp	ecx, 12					; 0000000cH
	jl	SHORT $LN1@CheckForTr

; 5197 : 				radioMessage->dataBlock.edata[3] = 0;

	mov	edx, 2
	imul	edx, 3
	xor	eax, eax
	mov	ecx, DWORD PTR _radioMessage$8[ebp]
	mov	WORD PTR [ecx+edx+64], ax
$LN1@CheckForTr:

; 5198 : 		
; 5199 : 			//eRangeLast
; 5200 : 			radioMessage->dataBlock.edata[4] = SimToGrid(sqrt(self->brain->trafficRange));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+240]
	push	ecx
	movss	xmm0, DWORD PTR [ecx+40]
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	fstp	DWORD PTR [esp]
	call	?SimToGrid@@YAFM@Z			; SimToGrid
	add	esp, 4
	mov	edx, 2
	shl	edx, 2
	mov	ecx, DWORD PTR _radioMessage$8[ebp]
	mov	WORD PTR [ecx+edx+64], ax

; 5201 : 			radioMessage->dataBlock.time_to_play= 0;

	mov	edx, DWORD PTR _radioMessage$8[ebp]
	mov	DWORD PTR [edx+56], 0

; 5202 : 
; 5203 : 			FalconSendMessage(radioMessage, FALSE);  //Sends Message to player

	push	0
	mov	eax, DWORD PTR _radioMessage$8[ebp]
	push	eax
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8

; 5204 : 			self->brain->lastTrafficCallTime = SimLibElapsedTime;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+240]
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [eax+32], ecx

; 5205 : 			playerInfo->lastContacted = SimLibElapsedTime;			

	mov	edx, DWORD PTR _playerInfo$[ebp]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [edx+16], eax
$LN3@CheckForTr:
$LN14@CheckForTr:

; 5206 : 		}
; 5207 : 	}
; 5208 : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN20@CheckForTr:
	DD	$LN8@CheckForTr
	DD	$LN6@CheckForTr
	DD	$LN7@CheckForTr
	DD	$LN5@CheckForTr
	DD	$LN7@CheckForTr
?CheckForTraffic@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ENDP ; ATCBrain::CheckForTraffic
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
$T1 = -20						; size = 8
_this$ = -12						; size = 4
_wingman$ = -8						; size = 4
_wingmanInfo$ = -4					; size = 4
_us$ = 8						; size = 4
_status$ = 12						; size = 4
?GiveOrderToWingman@ATCBrain@@QAEXPAVAircraftClass@@W4AtcStatusEnum@@@Z PROC ; ATCBrain::GiveOrderToWingman
; _this$ = ecx

; 3869 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 3870 : 	runwayQueueStruct	*wingmanInfo = NULL;

	mov	DWORD PTR _wingmanInfo$[ebp], 0

; 3871 : 	AircraftClass		*wingman = NULL;

	mov	DWORD PTR _wingman$[ebp], 0

; 3872 : 
; 3873 : 	if(!us)

	cmp	DWORD PTR _us$[ebp], 0
	jne	SHORT $LN9@GiveOrderT

; 3874 : 		return;

	jmp	$LN10@GiveOrderT
$LN9@GiveOrderT:

; 3875 : 
; 3876 : 	if(us->vehicleInUnit == 1 || us->vehicleInUnit == 3)

	mov	eax, DWORD PTR _us$[ebp]
	movzx	ecx, BYTE PTR [eax+664]
	cmp	ecx, 1
	je	SHORT $LN7@GiveOrderT
	mov	edx, DWORD PTR _us$[ebp]
	movzx	eax, BYTE PTR [edx+664]
	cmp	eax, 3
	jne	SHORT $LN8@GiveOrderT
$LN7@GiveOrderT:

; 3877 : 		return;

	jmp	$LN10@GiveOrderT
$LN8@GiveOrderT:

; 3878 : 
; 3879 : 	wingman = (AircraftClass*)us->GetCampaignObject()->GetComponentNumber(WingmanTable[us->vehicleInUnit]);

	mov	ecx, DWORD PTR _us$[ebp]
	movzx	edx, BYTE PTR [ecx+664]
	mov	eax, DWORD PTR ?WingmanTable@@3PAHA[edx*4]
	push	eax
	mov	ecx, DWORD PTR _us$[ebp]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentNumber@CampBaseClass@@QAEPAVSimBaseClass@@H@Z ; CampBaseClass::GetComponentNumber
	mov	DWORD PTR _wingman$[ebp], eax

; 3880 : 	if(wingman)

	cmp	DWORD PTR _wingman$[ebp], 0
	je	SHORT $LN6@GiveOrderT

; 3881 : 		wingmanInfo = InList(wingman->Id());

	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _wingman$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InList@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@@Z ; ATCBrain::InList
	mov	DWORD PTR _wingmanInfo$[ebp], eax
$LN6@GiveOrderT:

; 3882 : 
; 3883 : 	if (UseSectionTakeoff((Flight)us->GetCampaignObject(), us->DBrain()->Runway()))	

	mov	ecx, DWORD PTR _us$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?Runway@DigitalBrain@@QAEHXZ		; DigitalBrain::Runway
	push	eax
	mov	ecx, DWORD PTR _us$[ebp]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UseSectionTakeoff@ATCBrain@@QAEHPAVFlightClass@@H@Z ; ATCBrain::UseSectionTakeoff
	test	eax, eax
	je	SHORT $LN5@GiveOrderT

; 3884 : 	{
; 3885 : 		if( wingmanInfo && wingmanInfo->status < status)

	cmp	DWORD PTR _wingmanInfo$[ebp], 0
	je	SHORT $LN4@GiveOrderT
	mov	ecx, DWORD PTR _wingmanInfo$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR _status$[ebp]
	jge	SHORT $LN4@GiveOrderT

; 3886 : 		{
; 3887 : 			wingmanInfo->status = status;

	mov	eax, DWORD PTR _wingmanInfo$[ebp]
	mov	ecx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 3888 : 			SendCmdMessage(wingman, wingmanInfo);

	mov	edx, DWORD PTR _wingmanInfo$[ebp]
	push	edx
	mov	eax, DWORD PTR _wingman$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage
$LN4@GiveOrderT:

; 3889 : 		}
; 3890 : 	}

	jmp	SHORT $LN10@GiveOrderT
$LN5@GiveOrderT:

; 3891 : 	else if(wingmanInfo && (status == tTakeoff || status == tTakeRunway) && wingmanInfo->status < status)

	cmp	DWORD PTR _wingmanInfo$[ebp], 0
	je	SHORT $LN10@GiveOrderT
	cmp	DWORD PTR _status$[ebp], 27		; 0000001bH
	je	SHORT $LN1@GiveOrderT
	cmp	DWORD PTR _status$[ebp], 26		; 0000001aH
	jne	SHORT $LN10@GiveOrderT
$LN1@GiveOrderT:
	mov	ecx, DWORD PTR _wingmanInfo$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR _status$[ebp]
	jge	SHORT $LN10@GiveOrderT

; 3892 : 	{
; 3893 : 		wingmanInfo->status = tPrepToTakeRunway;

	mov	eax, DWORD PTR _wingmanInfo$[ebp]
	mov	DWORD PTR [eax+8], 25			; 00000019H

; 3894 : 		SendCmdMessage(wingman, wingmanInfo);

	mov	ecx, DWORD PTR _wingmanInfo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _wingman$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage
$LN10@GiveOrderT:

; 3895 : 	}
; 3896 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GiveOrderToWingman@ATCBrain@@QAEXPAVAircraftClass@@W4AtcStatusEnum@@@Z ENDP ; ATCBrain::GiveOrderToWingman
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
$T1 = -24						; size = 8
_this$ = -16						; size = 4
_aircraft$ = -12					; size = 4
_i$ = -8						; size = 4
_info$ = -4						; size = 4
_us$ = 8						; size = 4
_status$ = 12						; size = 4
_section$ = 16						; size = 4
?GiveOrderToSection@ATCBrain@@QAEXPAVAircraftClass@@W4AtcStatusEnum@@H@Z PROC ; ATCBrain::GiveOrderToSection
; _this$ = ecx

; 3900 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 3901 : 	runwayQueueStruct	*info = NULL;

	mov	DWORD PTR _info$[ebp], 0

; 3902 : 	AircraftClass		*aircraft = NULL;

	mov	DWORD PTR _aircraft$[ebp], 0

; 3903 : 	int					i;
; 3904 : 
; 3905 : 	if(!us )

	cmp	DWORD PTR _us$[ebp], 0
	jne	SHORT $LN6@GiveOrderT

; 3906 : 		return;

	jmp	$LN7@GiveOrderT
$LN6@GiveOrderT:

; 3907 : 
; 3908 : 	for(i = 0; i < 2; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN5@GiveOrderT
$LN4@GiveOrderT:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN5@GiveOrderT:
	cmp	DWORD PTR _i$[ebp], 2
	jge	SHORT $LN7@GiveOrderT

; 3909 : 	{
; 3910 : 		aircraft = (AircraftClass*)us->GetCampaignObject()->GetComponentNumber( section*2 + i);	

	mov	ecx, DWORD PTR _section$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	push	eax
	mov	ecx, DWORD PTR _us$[ebp]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentNumber@CampBaseClass@@QAEPAVSimBaseClass@@H@Z ; CampBaseClass::GetComponentNumber
	mov	DWORD PTR _aircraft$[ebp], eax

; 3911 : 			
; 3912 : 		if( aircraft )

	cmp	DWORD PTR _aircraft$[ebp], 0
	je	SHORT $LN2@GiveOrderT

; 3913 : 		{
; 3914 : 			info = InList(aircraft->Id());

	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InList@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@@Z ; ATCBrain::InList
	mov	DWORD PTR _info$[ebp], eax

; 3915 : 			if(info && info->status < status)

	cmp	DWORD PTR _info$[ebp], 0
	je	SHORT $LN2@GiveOrderT
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR _status$[ebp]
	jge	SHORT $LN2@GiveOrderT

; 3916 : 			{
; 3917 : 				info->status = status;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 3918 : 				SendCmdMessage(aircraft, info);

	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage
$LN2@GiveOrderT:

; 3919 : 			}
; 3920 : 		}
; 3921 : 	}

	jmp	SHORT $LN4@GiveOrderT
$LN7@GiveOrderT:

; 3922 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GiveOrderToSection@ATCBrain@@QAEXPAVAircraftClass@@W4AtcStatusEnum@@H@Z ENDP ; ATCBrain::GiveOrderToSection
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
tv394 = -68						; size = 4
tv376 = -64						; size = 4
tv352 = -60						; size = 4
tv328 = -56						; size = 4
tv296 = -52						; size = 4
tv273 = -48						; size = 4
tv250 = -44						; size = 4
tv218 = -40						; size = 4
tv194 = -36						; size = 4
tv171 = -32						; size = 4
_waitforlanding$ = -28					; size = 4
_queue$ = -24						; size = 4
_nextTakeoff$ = -20					; size = 4
_rwindex$ = -16						; size = 4
_nextLand$ = -12					; size = 4
_this$ = -8						; size = 4
_nextOnRunway$ = -4					; size = 4
_aircraft$ = 8						; size = 4
_info$ = 12						; size = 4
?CheckIfBlockingRunway@ATCBrain@@QAEHPAVAircraftClass@@PAUrunwayQueueStruct@@@Z PROC ; ATCBrain::CheckIfBlockingRunway
; _this$ = ecx

; 4849 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 4850 : 	if(aircraft->af->IsSet(AirframeClass::GearBroken) || aircraft->af->Fuel() <= 0.0F)

	push	2048					; 00000800H
	mov	eax, DWORD PTR _aircraft$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	jne	SHORT $LN33@CheckIfBlo
	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?Fuel@AirframeClass@@QAEMXZ		; AirframeClass::Fuel
	fstp	DWORD PTR tv394[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR tv394[ebp]
	jb	SHORT $LN34@CheckIfBlo
$LN33@CheckIfBlo:

; 4851 : 		return FALSE;

	xor	eax, eax
	jmp	$LN35@CheckIfBlo
$LN34@CheckIfBlo:

; 4852 : 
; 4853 : 	int queue;
; 4854 : 	runwayQueueStruct	*nextTakeoff = NULL;

	mov	DWORD PTR _nextTakeoff$[ebp], 0

; 4855 : 	runwayQueueStruct	*nextLand = NULL;

	mov	DWORD PTR _nextLand$[ebp], 0

; 4856 : 	runwayQueueStruct	*nextOnRunway = NULL;

	mov	DWORD PTR _nextOnRunway$[ebp], 0

; 4857 : 	int waitforlanding = FALSE;

	mov	DWORD PTR _waitforlanding$[ebp], 0

; 4858 : 
; 4859 : 	
; 4860 : 	//check to see if on a runway
; 4861 : 	int rwindex = IsOnRunway(aircraft);

	mov	edx, DWORD PTR _aircraft$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsOnRunway@ATCBrain@@QAEHPAVAircraftClass@@@Z ; ATCBrain::IsOnRunway
	mov	DWORD PTR _rwindex$[ebp], eax

; 4862 : 	if(rwindex)

	cmp	DWORD PTR _rwindex$[ebp], 0
	je	$LN25@CheckIfBlo

; 4863 : 	{
; 4864 : 		queue = GetQueue(rwindex);

	mov	eax, DWORD PTR _rwindex$[ebp]
	push	eax
	call	?GetQueue@@YAHH@Z			; GetQueue
	add	esp, 4
	mov	DWORD PTR _queue$[ebp], eax

; 4865 : 		nextTakeoff = NextToTakeoff(queue);

	mov	ecx, DWORD PTR _queue$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NextToTakeoff@ATCBrain@@AAEPAUrunwayQueueStruct@@H@Z ; ATCBrain::NextToTakeoff
	mov	DWORD PTR _nextTakeoff$[ebp], eax

; 4866 : 		nextLand = NextToLand(queue);		

	mov	edx, DWORD PTR _queue$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NextToLand@ATCBrain@@AAEPAUrunwayQueueStruct@@H@Z ; ATCBrain::NextToLand
	mov	DWORD PTR _nextLand$[ebp], eax

; 4867 : 
; 4868 : 		if(nextLand && SimLibElapsedTime + LAND_TIME_DELTA - 2*CampaignSeconds > nextLand->schedTime)

	cmp	DWORD PTR _nextLand$[ebp], 0
	je	SHORT $LN31@CheckIfBlo
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	eax, 58000				; 0000e290H
	mov	ecx, DWORD PTR _nextLand$[ebp]
	cmp	eax, DWORD PTR [ecx+12]
	jbe	SHORT $LN31@CheckIfBlo

; 4869 : 			waitforlanding = TRUE;

	mov	DWORD PTR _waitforlanding$[ebp], 1
$LN31@CheckIfBlo:

; 4870 : 
; 4871 : 		if(!nextTakeoff || waitforlanding)

	cmp	DWORD PTR _nextTakeoff$[ebp], 0
	je	SHORT $LN29@CheckIfBlo
	cmp	DWORD PTR _waitforlanding$[ebp], 0
	je	SHORT $LN30@CheckIfBlo
$LN29@CheckIfBlo:

; 4872 : 			nextOnRunway = nextLand;

	mov	edx, DWORD PTR _nextLand$[ebp]
	mov	DWORD PTR _nextOnRunway$[ebp], edx
	jmp	SHORT $LN25@CheckIfBlo
$LN30@CheckIfBlo:

; 4873 : 		else if(!nextLand || nextLand->schedTime > nextTakeoff->schedTime)

	cmp	DWORD PTR _nextLand$[ebp], 0
	je	SHORT $LN26@CheckIfBlo
	mov	eax, DWORD PTR _nextLand$[ebp]
	mov	ecx, DWORD PTR _nextTakeoff$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+12]
	jbe	SHORT $LN27@CheckIfBlo
$LN26@CheckIfBlo:

; 4874 : 			nextOnRunway = nextTakeoff;

	mov	eax, DWORD PTR _nextTakeoff$[ebp]
	mov	DWORD PTR _nextOnRunway$[ebp], eax

; 4875 : 		else 

	jmp	SHORT $LN25@CheckIfBlo
$LN27@CheckIfBlo:

; 4876 : 			nextOnRunway = nextLand;

	mov	ecx, DWORD PTR _nextLand$[ebp]
	mov	DWORD PTR _nextOnRunway$[ebp], ecx
$LN25@CheckIfBlo:

; 4877 : 	}
; 4878 : 
; 4879 : 	if(info && info->status == lLanded)

	cmp	DWORD PTR _info$[ebp], 0
	je	$LN24@CheckIfBlo
	mov	edx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [edx+8], 13			; 0000000dH
	jne	$LN24@CheckIfBlo

; 4880 : 	{		
; 4881 : 		// OW: Jackals "scold-on-bounce" fix
; 4882 : #if 0
; 4883 : 		if(!rwindex)
; 4884 : 		{
; 4885 : 			info->status = lTaxiOff;
; 4886 : #else
; 4887 : 		  // JB 000421
; 4888 : 		  if(!rwindex && aircraft->OnGround())

	cmp	DWORD PTR _rwindex$[ebp], 0
	jne	SHORT $LN23@CheckIfBlo
	mov	eax, DWORD PTR _aircraft$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	SHORT $LN23@CheckIfBlo

; 4889 : 		  // JB 000421
; 4890 : 		  {
; 4891 : 			info->status = lTaxiOff;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+8], 14			; 0000000eH

; 4892 : #endif
; 4893 : 
; 4894 : //			info->timer = SimLibElapsedTime + 15 * CampaignSeconds;
; 4895 : 		}
; 4896 : 		else if( info->lastContacted + 90 * CampaignSeconds < SimLibElapsedTime &&	 // 06FEB04 - FRB - was 45 seconds 

	jmp	$LN21@CheckIfBlo
$LN23@CheckIfBlo:

; 4897 : 					(SimLibElapsedTime > LAND_TIME_DELTA + info->schedTime || 
; 4898 : 					(rwindex != info->rwindex && GetOppositeRunway(rwindex) != info->rwindex)) )

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 90000				; 00015f90H
	cmp	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	$LN21@CheckIfBlo
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, 60000				; 0000ea60H
	cmp	DWORD PTR ?SimLibElapsedTime@@3KA, edx	; SimLibElapsedTime
	ja	SHORT $LN20@CheckIfBlo
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR _rwindex$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	je	$LN21@CheckIfBlo
	mov	edx, DWORD PTR _rwindex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOppositeRunway@ATCBrain@@QAEHH@Z	; ATCBrain::GetOppositeRunway
	mov	ecx, DWORD PTR _info$[ebp]
	cmp	eax, DWORD PTR [ecx+20]
	je	$LN21@CheckIfBlo
$LN20@CheckIfBlo:

; 4899 : 		{
; 4900 : 			//yell at them to get off runway
; 4901 : 			if(!nextOnRunway)

	cmp	DWORD PTR _nextOnRunway$[ebp], 0
	jne	SHORT $LN19@CheckIfBlo

; 4902 : 				SendCallFromATC (self, aircraft, rcTAXICLEAR, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN37@CheckIfBlo
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv171[ebp], eax
	jmp	SHORT $LN38@CheckIfBlo
$LN37@CheckIfBlo:
	mov	DWORD PTR tv171[ebp], 0
$LN38@CheckIfBlo:
	mov	eax, DWORD PTR tv171[ebp]
	push	eax
	push	305					; 00000131H
	mov	ecx, DWORD PTR _aircraft$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?SendCallFromATC@@YAXPAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; SendCallFromATC
	add	esp, 16					; 00000010H
	jmp	$LN15@CheckIfBlo
$LN19@CheckIfBlo:

; 4903 : 			else if(nextOnRunway == nextTakeoff)

	mov	ecx, DWORD PTR _nextOnRunway$[ebp]
	cmp	ecx, DWORD PTR _nextTakeoff$[ebp]
	jne	SHORT $LN17@CheckIfBlo

; 4904 : 				SendCallFromATC (self, aircraft, rcTAXICLEAR, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN39@CheckIfBlo
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv194[ebp], eax
	jmp	SHORT $LN40@CheckIfBlo
$LN39@CheckIfBlo:
	mov	DWORD PTR tv194[ebp], 0
$LN40@CheckIfBlo:
	mov	eax, DWORD PTR tv194[ebp]
	push	eax
	push	305					; 00000131H
	mov	ecx, DWORD PTR _aircraft$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?SendCallFromATC@@YAXPAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; SendCallFromATC
	add	esp, 16					; 00000010H
	jmp	SHORT $LN15@CheckIfBlo
$LN17@CheckIfBlo:

; 4905 : 			else if(nextOnRunway == nextLand && nextOnRunway != info)

	mov	ecx, DWORD PTR _nextOnRunway$[ebp]
	cmp	ecx, DWORD PTR _nextLand$[ebp]
	jne	SHORT $LN15@CheckIfBlo
	mov	edx, DWORD PTR _nextOnRunway$[ebp]
	cmp	edx, DWORD PTR _info$[ebp]
	je	SHORT $LN15@CheckIfBlo

; 4906 : 				SendCallFromATC (self, aircraft, rcGETOFFRUNWAYA, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN41@CheckIfBlo
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv218[ebp], eax
	jmp	SHORT $LN42@CheckIfBlo
$LN41@CheckIfBlo:
	mov	DWORD PTR tv218[ebp], 0
$LN42@CheckIfBlo:
	mov	ecx, DWORD PTR tv218[ebp]
	push	ecx
	push	84					; 00000054H
	mov	edx, DWORD PTR _aircraft$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?SendCallFromATC@@YAXPAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; SendCallFromATC
	add	esp, 16					; 00000010H
$LN15@CheckIfBlo:

; 4907 : 
; 4908 : 			info->lastContacted = SimLibElapsedTime;

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [edx+16], eax

; 4909 : 			return TRUE;

	mov	eax, 1
	jmp	$LN35@CheckIfBlo
$LN21@CheckIfBlo:

; 4910 : 		}
; 4911 : 	}

	jmp	$LN6@CheckIfBlo
$LN24@CheckIfBlo:

; 4912 : 	else if(rwindex && !info && aircraft->DBrain()->WaitTime() + 90 *CampaignSeconds < SimLibElapsedTime)	 // 06FEB04 - FRB - was 45 seconds

	cmp	DWORD PTR _rwindex$[ebp], 0
	je	$LN13@CheckIfBlo
	cmp	DWORD PTR _info$[ebp], 0
	jne	$LN13@CheckIfBlo
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?WaitTime@DigitalBrain@@QAEKXZ		; DigitalBrain::WaitTime
	add	eax, 90000				; 00015f90H
	cmp	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	$LN13@CheckIfBlo

; 4913 : 	{
; 4914 : 		//yell at them to get off runway
; 4915 : 			if(!nextOnRunway)

	cmp	DWORD PTR _nextOnRunway$[ebp], 0
	jne	SHORT $LN12@CheckIfBlo

; 4916 : 				SendCallFromATC (self, aircraft, rcTAXICLEAR, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN43@CheckIfBlo
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv250[ebp], eax
	jmp	SHORT $LN44@CheckIfBlo
$LN43@CheckIfBlo:
	mov	DWORD PTR tv250[ebp], 0
$LN44@CheckIfBlo:
	mov	edx, DWORD PTR tv250[ebp]
	push	edx
	push	305					; 00000131H
	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?SendCallFromATC@@YAXPAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; SendCallFromATC
	add	esp, 16					; 00000010H
	jmp	$LN8@CheckIfBlo
$LN12@CheckIfBlo:

; 4917 : 			else if(nextOnRunway == nextTakeoff)

	mov	eax, DWORD PTR _nextOnRunway$[ebp]
	cmp	eax, DWORD PTR _nextTakeoff$[ebp]
	jne	SHORT $LN10@CheckIfBlo

; 4918 : 				SendCallFromATC (self, aircraft, rcTAXICLEAR, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN45@CheckIfBlo
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv273[ebp], eax
	jmp	SHORT $LN46@CheckIfBlo
$LN45@CheckIfBlo:
	mov	DWORD PTR tv273[ebp], 0
$LN46@CheckIfBlo:
	mov	edx, DWORD PTR tv273[ebp]
	push	edx
	push	305					; 00000131H
	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?SendCallFromATC@@YAXPAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; SendCallFromATC
	add	esp, 16					; 00000010H
	jmp	SHORT $LN8@CheckIfBlo
$LN10@CheckIfBlo:

; 4919 : 			else if(nextOnRunway == nextLand)

	mov	eax, DWORD PTR _nextOnRunway$[ebp]
	cmp	eax, DWORD PTR _nextLand$[ebp]
	jne	SHORT $LN8@CheckIfBlo

; 4920 : 				SendCallFromATC (self, aircraft, rcGETOFFRUNWAYA, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN47@CheckIfBlo
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv296[ebp], eax
	jmp	SHORT $LN48@CheckIfBlo
$LN47@CheckIfBlo:
	mov	DWORD PTR tv296[ebp], 0
$LN48@CheckIfBlo:
	mov	edx, DWORD PTR tv296[ebp]
	push	edx
	push	84					; 00000054H
	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?SendCallFromATC@@YAXPAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; SendCallFromATC
	add	esp, 16					; 00000010H
$LN8@CheckIfBlo:

; 4921 : 
; 4922 : 		aircraft->DBrain()->SetWaitTimer(SimLibElapsedTime);

	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	push	eax
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?SetWaitTimer@DigitalBrain@@QAEXK@Z	; DigitalBrain::SetWaitTimer

; 4923 : 		return TRUE;

	mov	eax, 1
	jmp	$LN35@CheckIfBlo
	jmp	$LN6@CheckIfBlo
$LN13@CheckIfBlo:

; 4924 : 	}
; 4925 : 	else if( rwindex && info && info->lastContacted + 90 *CampaignSeconds < SimLibElapsedTime )	 // 06FEB04 - FRB - was 45 seconds

	cmp	DWORD PTR _rwindex$[ebp], 0
	je	$LN6@CheckIfBlo
	cmp	DWORD PTR _info$[ebp], 0
	je	$LN6@CheckIfBlo
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 90000				; 00015f90H
	cmp	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	$LN6@CheckIfBlo

; 4926 : 	{					
; 4927 : 		//yell at them to get off runway
; 4928 : 			if(!nextOnRunway)

	cmp	DWORD PTR _nextOnRunway$[ebp], 0
	jne	SHORT $LN5@CheckIfBlo

; 4929 : 				SendCallFromATC (self, aircraft, rcTAXICLEAR, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN49@CheckIfBlo
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv328[ebp], eax
	jmp	SHORT $LN50@CheckIfBlo
$LN49@CheckIfBlo:
	mov	DWORD PTR tv328[ebp], 0
$LN50@CheckIfBlo:
	mov	ecx, DWORD PTR tv328[ebp]
	push	ecx
	push	305					; 00000131H
	mov	edx, DWORD PTR _aircraft$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?SendCallFromATC@@YAXPAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; SendCallFromATC
	add	esp, 16					; 00000010H
	jmp	$LN1@CheckIfBlo
$LN5@CheckIfBlo:

; 4930 : 			else if(nextOnRunway == nextTakeoff && nextOnRunway != info)

	mov	edx, DWORD PTR _nextOnRunway$[ebp]
	cmp	edx, DWORD PTR _nextTakeoff$[ebp]
	jne	SHORT $LN3@CheckIfBlo
	mov	eax, DWORD PTR _nextOnRunway$[ebp]
	cmp	eax, DWORD PTR _info$[ebp]
	je	SHORT $LN3@CheckIfBlo

; 4931 : 				SendCallFromATC (self, aircraft, rcTAXICLEAR, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN51@CheckIfBlo
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv352[ebp], eax
	jmp	SHORT $LN52@CheckIfBlo
$LN51@CheckIfBlo:
	mov	DWORD PTR tv352[ebp], 0
$LN52@CheckIfBlo:
	mov	edx, DWORD PTR tv352[ebp]
	push	edx
	push	305					; 00000131H
	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?SendCallFromATC@@YAXPAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; SendCallFromATC
	add	esp, 16					; 00000010H
	jmp	SHORT $LN1@CheckIfBlo
$LN3@CheckIfBlo:

; 4932 : 			else if(nextOnRunway == nextLand && nextOnRunway != info)

	mov	eax, DWORD PTR _nextOnRunway$[ebp]
	cmp	eax, DWORD PTR _nextLand$[ebp]
	jne	SHORT $LN1@CheckIfBlo
	mov	ecx, DWORD PTR _nextOnRunway$[ebp]
	cmp	ecx, DWORD PTR _info$[ebp]
	je	SHORT $LN1@CheckIfBlo

; 4933 : 				SendCallFromATC (self, aircraft, rcGETOFFRUNWAYA, FalconLocalGame);		

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN53@CheckIfBlo
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv376[ebp], eax
	jmp	SHORT $LN54@CheckIfBlo
$LN53@CheckIfBlo:
	mov	DWORD PTR tv376[ebp], 0
$LN54@CheckIfBlo:
	mov	eax, DWORD PTR tv376[ebp]
	push	eax
	push	84					; 00000054H
	mov	ecx, DWORD PTR _aircraft$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?SendCallFromATC@@YAXPAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; SendCallFromATC
	add	esp, 16					; 00000010H
$LN1@CheckIfBlo:

; 4934 : 
; 4935 : 		info->lastContacted = SimLibElapsedTime;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [ecx+16], edx

; 4936 : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $LN35@CheckIfBlo
$LN6@CheckIfBlo:

; 4937 : 	}
; 4938 : 	return FALSE;

	xor	eax, eax
$LN35@CheckIfBlo:

; 4939 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?CheckIfBlockingRunway@ATCBrain@@QAEHPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ENDP ; ATCBrain::CheckIfBlockingRunway
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_groundZ$1 = -16					; size = 4
_radioMessage$ = -12					; size = 4
tv189 = -8						; size = 4
_this$ = -4						; size = 4
_aircraft$ = 8						; size = 4
_info$ = 12						; size = 4
?CheckTakeoff@ATCBrain@@QAEHPAVAircraftClass@@PAUrunwayQueueStruct@@@Z PROC ; ATCBrain::CheckTakeoff
; _this$ = ecx

; 4730 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 4731 : 	FalconRadioChatterMessage	*radioMessage;
; 4732 : 	
; 4733 : 	if(!aircraft->OnGround() && aircraft->DBrain()->IsSetATC(DigitalBrain::Landed))

	mov	eax, DWORD PTR _aircraft$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	jne	$LN5@CheckTakeo
	push	1
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?IsSetATC@DigitalBrain@@QAEHH@Z		; DigitalBrain::IsSetATC
	test	eax, eax
	je	$LN5@CheckTakeo

; 4734 : 	{
; 4735 : 		if(info)

	cmp	DWORD PTR _info$[ebp], 0
	je	SHORT $LN4@CheckTakeo

; 4736 : 		{
; 4737 : // RAS - 29Jan04 - This section changed because when you would do a touch and go, ATC would
; 4738 : //					still think you were on the ground.  I could not see any reason to leave
; 4739 : //					this the way it was.  If you are in this routine, then you are airborne because
; 4740 : //					!aircraft->OnGround() means you are flying.  if you are flying, then you should
; 4741 : //					be removed from the ATC list unless you call inbound again.
; 4742 : 
; 4743 : //			if(info->status == lLanded)
; 4744 : //			{
; 4745 : //				aircraft->DBrain()->ClearATCFlag(DigitalBrain::Landed);
; 4746 : //			}
; 4747 : //			else
; 4748 : //			{
; 4749 : 				info->lastContacted = SimLibElapsedTime;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [ecx+16], edx

; 4750 : 				info->status = tFlyOut;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+8], 28			; 0000001cH

; 4751 : //				info->timer = SimLibElapsedTime + 60 * CampaignSeconds;
; 4752 : 				SendCmdMessage(aircraft, info);

	mov	ecx, DWORD PTR _info$[ebp]
	push	ecx
	mov	edx, DWORD PTR _aircraft$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage

; 4753 : 				RemoveTraffic(info->aircraftID, PtHeaderDataTable[info->rwindex].runwayNum);

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	eax, BYTE PTR [edx+ecx+24]
	push	eax
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR [ecx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveTraffic@ATCBrain@@QAEXVVU_ID@@H@Z ; ATCBrain::RemoveTraffic
$LN4@CheckTakeo:

; 4754 : //			}
; 4755 : 		}
; 4756 : 
; 4757 : 		if(!aircraft->DBrain()->IsSetATC(DigitalBrain::PermitTakeoff) && aircraft->DBrain()->IsSetATC(DigitalBrain::Landed))

	push	4
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?IsSetATC@DigitalBrain@@QAEHH@Z		; DigitalBrain::IsSetATC
	test	eax, eax
	jne	$LN2@CheckTakeo
	push	1
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?IsSetATC@DigitalBrain@@QAEHH@Z		; DigitalBrain::IsSetATC
	test	eax, eax
	je	$LN2@CheckTakeo

; 4758 : 		{
; 4759 : 			aircraft->DBrain()->SetATCFlag(DigitalBrain::PermitTakeoff);

	push	4
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?SetATCFlag@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetATCFlag

; 4760 : 			float groundZ = OTWDriver.GetGroundLevel (aircraft->XPos(), aircraft->YPos());

	push	0
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR _groundZ$1[ebp]

; 4761 : 			aircraft->FeatureCollision(groundZ);

	push	ecx
	movss	xmm0, DWORD PTR _groundZ$1[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	eax, DWORD PTR [edx+444]
	call	eax

; 4762 : 			if(aircraft->onFlatFeature)

	mov	ecx, DWORD PTR _aircraft$[ebp]
	cmp	DWORD PTR [ecx+668], 0
	je	SHORT $LN2@CheckTakeo

; 4763 : 			{
; 4764 : 				//took off without permission
; 4765 : 				radioMessage = CreateCallFromATC (self, aircraft, rcTOWERSCOLD2, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN8@CheckTakeo
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv189[ebp], eax
	jmp	SHORT $LN9@CheckTakeo
$LN8@CheckTakeo:
	mov	DWORD PTR tv189[ebp], 0
$LN9@CheckTakeo:
	mov	eax, DWORD PTR tv189[ebp]
	push	eax
	push	311					; 00000137H
	mov	ecx, DWORD PTR _aircraft$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$[ebp], eax

; 4766 : 				radioMessage->dataBlock.edata[3] = 32767;

	mov	ecx, 2
	imul	ecx, 3
	mov	edx, 32767				; 00007fffH
	mov	eax, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [eax+ecx+64], dx

; 4767 : 				FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	push	ecx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN2@CheckTakeo:

; 4768 : 			}
; 4769 : 		}
; 4770 : 		if(SimDriver.GetPlayerEntity() == aircraft)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ ; SimulationDriver::GetPlayerEntity
	cmp	eax, DWORD PTR _aircraft$[ebp]
	jne	SHORT $LN1@CheckTakeo

; 4771 : 			gBumpFlag = FALSE;

	mov	DWORD PTR ?gBumpFlag@@3HA, 0		; gBumpFlag
$LN1@CheckTakeo:

; 4772 : 		aircraft->DBrain()->ClearATCFlag(DigitalBrain::Landed);

	push	1
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?ClearATCFlag@DigitalBrain@@QAEXH@Z	; DigitalBrain::ClearATCFlag

; 4773 : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $LN6@CheckTakeo
$LN5@CheckTakeo:

; 4774 : 	}
; 4775 : 
; 4776 : 	return FALSE;

	xor	eax, eax
$LN6@CheckTakeo:

; 4777 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?CheckTakeoff@ATCBrain@@QAEHPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ENDP ; ATCBrain::CheckTakeoff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_groundZ$1 = -24					; size = 4
_next$ = -20						; size = 4
_queue$ = -16						; size = 4
_radioMessage$ = -12					; size = 4
tv176 = -8						; size = 4
_this$ = -4						; size = 4
_aircraft$ = 8						; size = 4
_landInfo$ = 12						; size = 4
?CheckLanding@ATCBrain@@QAEHPAVAircraftClass@@PAUrunwayQueueStruct@@@Z PROC ; ATCBrain::CheckLanding
; _this$ = ecx

; 4686 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 4687 : 	ShiAssert(landInfo);
; 4688 : 	FalconRadioChatterMessage	*radioMessage;
; 4689 : 	int							queue = PtHeaderDataTable[landInfo->rwindex].runwayNum;

	mov	eax, DWORD PTR _landInfo$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	eax, BYTE PTR [edx+ecx+24]
	mov	DWORD PTR _queue$[ebp], eax

; 4690 : 	runwayQueueStruct*			next = NextToLand(queue);

	mov	ecx, DWORD PTR _queue$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NextToLand@ATCBrain@@AAEPAUrunwayQueueStruct@@H@Z ; ATCBrain::NextToLand
	mov	DWORD PTR _next$[ebp], eax

; 4691 : 	
; 4692 : 	//ShiAssert(runwayQueue[queue]);
; 4693 : 
; 4694 : 	if(aircraft->OnGround() && !aircraft->DBrain()->IsSetATC(DigitalBrain::Landed))

	mov	edx, DWORD PTR _aircraft$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	test	eax, eax
	je	$LN5@CheckLandi
	push	1
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?IsSetATC@DigitalBrain@@QAEHH@Z		; DigitalBrain::IsSetATC
	test	eax, eax
	jne	$LN5@CheckLandi

; 4695 : 	{
; 4696 : 		if(landInfo)

	cmp	DWORD PTR _landInfo$[ebp], 0
	je	$LN1@CheckLandi

; 4697 : 		{
; 4698 : 			if(landInfo->status != lEmergencyToBase && landInfo->status != lEmergencyToFinal &&
; 4699 : 			   landInfo->status != lEmergencyOnFinal && next != landInfo &&
; 4700 : 				 landInfo->status != lLanded) // JB 010713 If we're already landed, then what's the big deal?

	mov	eax, DWORD PTR _landInfo$[ebp]
	cmp	DWORD PTR [eax+8], 15			; 0000000fH
	je	$LN2@CheckLandi
	mov	ecx, DWORD PTR _landInfo$[ebp]
	cmp	DWORD PTR [ecx+8], 16			; 00000010H
	je	$LN2@CheckLandi
	mov	edx, DWORD PTR _landInfo$[ebp]
	cmp	DWORD PTR [edx+8], 17			; 00000011H
	je	$LN2@CheckLandi
	mov	eax, DWORD PTR _next$[ebp]
	cmp	eax, DWORD PTR _landInfo$[ebp]
	je	$LN2@CheckLandi
	mov	ecx, DWORD PTR _landInfo$[ebp]
	cmp	DWORD PTR [ecx+8], 13			; 0000000dH
	je	$LN2@CheckLandi

; 4701 : 			{
; 4702 : 				float groundZ = OTWDriver.GetGroundLevel (aircraft->XPos(), aircraft->YPos());

	push	0
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR _groundZ$1[ebp]

; 4703 : 				aircraft->FeatureCollision(groundZ);

	push	ecx
	movss	xmm0, DWORD PTR _groundZ$1[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _aircraft$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	edx, DWORD PTR [eax+444]
	call	edx

; 4704 : 				if(aircraft->onFlatFeature)

	mov	eax, DWORD PTR _aircraft$[ebp]
	cmp	DWORD PTR [eax+668], 0
	je	SHORT $LN2@CheckLandi

; 4705 : 				{
; 4706 : 					//landed without permission
; 4707 : 					radioMessage = CreateCallFromATC (self, aircraft, rcTOWERSCOLD3, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN8@CheckLandi
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv176[ebp], eax
	jmp	SHORT $LN9@CheckLandi
$LN8@CheckLandi:
	mov	DWORD PTR tv176[ebp], 0
$LN9@CheckLandi:
	mov	edx, DWORD PTR tv176[ebp]
	push	edx
	push	312					; 00000138H
	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$[ebp], eax

; 4708 : 					radioMessage->dataBlock.edata[3] = 32767;

	mov	eax, 2
	imul	eax, 3
	mov	ecx, 32767				; 00007fffH
	mov	edx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [edx+eax+64], cx

; 4709 : 					FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	eax, DWORD PTR _radioMessage$[ebp]
	push	eax
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8

; 4710 : 					landInfo->lastContacted = SimLibElapsedTime;

	mov	ecx, DWORD PTR _landInfo$[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [ecx+16], edx
$LN2@CheckLandi:

; 4711 : 				}
; 4712 : 			}
; 4713 : 				
; 4714 : 			
; 4715 : 			if(landInfo->status != lLanded)

	mov	eax, DWORD PTR _landInfo$[ebp]
	cmp	DWORD PTR [eax+8], 13			; 0000000dH
	je	SHORT $LN1@CheckLandi

; 4716 : 			{
; 4717 : 				landInfo->status = lLanded;

	mov	ecx, DWORD PTR _landInfo$[ebp]
	mov	DWORD PTR [ecx+8], 13			; 0000000dH

; 4718 : //				landInfo->timer = SimLibElapsedTime + 15 * CampaignSeconds;
; 4719 : 				SendCmdMessage(aircraft, landInfo);

	mov	edx, DWORD PTR _landInfo$[ebp]
	push	edx
	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage
$LN1@CheckLandi:

; 4720 : 			}
; 4721 : 		}
; 4722 : 		aircraft->DBrain()->SetATCFlag(DigitalBrain::Landed);

	push	1
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?SetATCFlag@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetATCFlag

; 4723 : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $LN6@CheckLandi
$LN5@CheckLandi:

; 4724 : 	}
; 4725 : 	return FALSE;

	xor	eax, eax
$LN6@CheckLandi:

; 4726 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?CheckLanding@ATCBrain@@QAEHPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ENDP ; ATCBrain::CheckLanding
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
tv939 = -236						; size = 8
tv854 = -228						; size = 8
_z$ = -220						; size = 4
tv731 = -216						; size = 4
tv689 = -212						; size = 4
tv1058 = -208						; size = 4
tv977 = -204						; size = 4
tv749 = -200						; size = 4
tv1062 = -196						; size = 4
tv1056 = -192						; size = 4
tv956 = -188						; size = 4
tv693 = -184						; size = 4
tv951 = -180						; size = 4
tv666 = -176						; size = 4
tv896 = -172						; size = 4
tv736 = -168						; size = 4
tv886 = -164						; size = 4
tv719 = -160						; size = 4
tv877 = -156						; size = 4
tv701 = -152						; size = 4
tv816 = -148						; size = 4
tv697 = -144						; size = 4
_baseX$ = -140						; size = 4
tv1022 = -136						; size = 4
_baseY$ = -132						; size = 4
tv671 = -128						; size = 4
tv1060 = -124						; size = 4
tv754 = -120						; size = 4
tv658 = -116						; size = 4
tv593 = -112						; size = 4
tv936 = -108						; size = 4
tv567 = -104						; size = 4
tv851 = -100						; size = 4
tv542 = -96						; size = 4
tv380 = -92						; size = 4
tv515 = -88						; size = 4
tv485 = -84						; size = 4
_speed$ = -80						; size = 4
_deltaTime$ = -76					; size = 4
tv180 = -72						; size = 4
_cosHdg$ = -68						; size = 4
_cosAngle$ = -64					; size = 4
_finalX$ = -60						; size = 4
_norm$ = -56						; size = 4
_sinHdg$ = -52						; size = 4
_x$ = -48						; size = 4
_finalY$ = -44						; size = 4
_y$ = -40						; size = 4
_rely$ = -36						; size = 4
_relx$ = -32						; size = 4
_dist$ = -28						; size = 4
_vt$ = -24						; size = 4
_turnDist$ = -20					; size = 4
_this$ = -16						; size = 4
_dy$ = -12						; size = 4
_dx$ = -8						; size = 4
_turnTime$ = -4						; size = 4
_aircraft$ = 8						; size = 4
_info$ = 12						; size = 4
?CheckVector@ATCBrain@@QAEHPAVAircraftClass@@PAUrunwayQueueStruct@@@Z PROC ; ATCBrain::CheckVector
; _this$ = ecx

; 3001 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 236				; 000000ecH
	mov	DWORD PTR _this$[ebp], ecx

; 3002 : 	float	x,y,z, dx, dy, cosAngle, dist;
; 3003 : 	float	norm, vt, cosHdg, sinHdg, relx, rely;
; 3004 : 	float	turnDist, speed, deltaTime;
; 3005 : 	float	baseX,baseY,finalX,finalY;
; 3006 : 	ulong	turnTime;
; 3007 : 
; 3008 : 	speed = aircraft->af->MinVcas()*KNOTS_TO_FTPSEC;

	mov	eax, DWORD PTR _aircraft$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv658[ebp]
	movss	xmm0, DWORD PTR tv658[ebp]
	mulss	xmm0, DWORD PTR __real@3fd80b03
	movss	DWORD PTR _speed$[ebp], xmm0

; 3009 : 	aircraft->DBrain()->GetTrackPoint(x, y, z);

	lea	ecx, DWORD PTR _z$[ebp]
	push	ecx
	lea	edx, DWORD PTR _y$[ebp]
	push	edx
	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?GetTrackPoint@DigitalBrain@@QAEXAAM00@Z ; DigitalBrain::GetTrackPoint

; 3010 : 	
; 3011 : 	dx = x - aircraft->XPos();

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv666[ebp]
	movss	xmm0, DWORD PTR _x$[ebp]
	subss	xmm0, DWORD PTR tv666[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 3012 : 	dy = y - aircraft->YPos();

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv671[ebp]
	movss	xmm0, DWORD PTR _y$[ebp]
	subss	xmm0, DWORD PTR tv671[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 3013 : 	dist = (float)sqrt(dx * dx + dy * dy);

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]

; 3014 : 
; 3015 : 	cosHdg = aircraft->platformAngles.cossig;

	mov	ecx, DWORD PTR _aircraft$[ebp]
	movss	xmm0, DWORD PTR [ecx+376]
	movss	DWORD PTR _cosHdg$[ebp], xmm0

; 3016 : 	sinHdg = aircraft->platformAngles.sinsig;	

	mov	edx, DWORD PTR _aircraft$[ebp]
	movss	xmm0, DWORD PTR [edx+372]
	movss	DWORD PTR _sinHdg$[ebp], xmm0

; 3017 : 
; 3018 : 	relx = (  cosHdg*dx + sinHdg*dy);

	movss	xmm0, DWORD PTR _cosHdg$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _sinHdg$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _relx$[ebp], xmm0

; 3019 : 	rely = ( -sinHdg*dx + cosHdg*dy);

	movss	xmm0, DWORD PTR _sinHdg$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _cosHdg$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _rely$[ebp], xmm0

; 3020 : 	
; 3021 : 
; 3022 : 	vt = (float)sqrt(aircraft->XDelta() * aircraft->XDelta() + aircraft->YDelta() * aircraft->YDelta());

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?XDelta@VuEntity@@QBEMXZ		; VuEntity::XDelta
	fstp	DWORD PTR tv689[ebp]
	movss	xmm0, DWORD PTR tv689[ebp]
	mov	ecx, DWORD PTR _aircraft$[ebp]
	movss	DWORD PTR tv1022[ebp], xmm0
	call	?XDelta@VuEntity@@QBEMXZ		; VuEntity::XDelta
	fstp	DWORD PTR tv693[ebp]
	movss	xmm0, DWORD PTR tv1022[ebp]
	mulss	xmm0, DWORD PTR tv693[ebp]
	mov	ecx, DWORD PTR _aircraft$[ebp]
	movss	DWORD PTR tv1056[ebp], xmm0
	call	?YDelta@VuEntity@@QBEMXZ		; VuEntity::YDelta
	fstp	DWORD PTR tv697[ebp]
	movss	xmm0, DWORD PTR tv697[ebp]
	mov	ecx, DWORD PTR _aircraft$[ebp]
	movss	DWORD PTR tv1058[ebp], xmm0
	call	?YDelta@VuEntity@@QBEMXZ		; VuEntity::YDelta
	fstp	DWORD PTR tv701[ebp]
	movss	xmm0, DWORD PTR tv1058[ebp]
	mulss	xmm0, DWORD PTR tv701[ebp]
	movss	xmm1, DWORD PTR tv1056[ebp]
	addss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _vt$[ebp]

; 3023 : 
; 3024 : 	//turnDist = aircraft->DBrain()->TurnDistance() + vt * 3.0F;
; 3025 : 	turnDist = aircraft->DBrain()->TurnDistance();

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?TurnDistance@DigitalBrain@@QAEMXZ	; DigitalBrain::TurnDistance
	fstp	DWORD PTR _turnDist$[ebp]

; 3026 : 
; 3027 : 	switch(info->status)

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv180[ebp], ecx
	mov	edx, DWORD PTR tv180[ebp]
	sub	edx, 1
	mov	DWORD PTR tv180[ebp], edx
	cmp	DWORD PTR tv180[ebp], 15		; 0000000fH
	ja	$LN17@CheckVecto
	mov	eax, DWORD PTR tv180[ebp]
	movzx	ecx, BYTE PTR $LN52@CheckVecto[eax]
	jmp	DWORD PTR $LN53@CheckVecto[ecx*4]
$LN35@CheckVecto:

; 3028 : 	{
; 3029 : 	case lFirstLeg:	
; 3030 : 		//if(dist < turnDist || (cosAngle < -0.5F && dist < turnDist + 1000.0F) || (cosAngle < 0.0F && dist < turnDist + 500.0F) )
; 3031 : 		if(relx < turnDist && fabs(rely) < turnDist*3.0F && info->lastContacted < SimLibElapsedTime)

	movss	xmm0, DWORD PTR _turnDist$[ebp]
	comiss	xmm0, DWORD PTR _relx$[ebp]
	jbe	$LN34@CheckVecto
	push	ecx
	movss	xmm0, DWORD PTR _rely$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv719[ebp]
	movss	xmm0, DWORD PTR _turnDist$[ebp]
	mulss	xmm0, DWORD PTR __real@40400000
	comiss	xmm0, DWORD PTR tv719[ebp]
	jbe	$LN34@CheckVecto
	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	$LN34@CheckVecto

; 3032 : 		{
; 3033 : 			FindFinalPt(aircraft, info->rwindex, &x, &y);

	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR _aircraft$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindFinalPt@ATCBrain@@QAEXPAVAircraftClass@@HPAM1@Z ; ATCBrain::FindFinalPt

; 3034 : 			dx = x - aircraft->XPos();

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv731[ebp]
	movss	xmm0, DWORD PTR _x$[ebp]
	subss	xmm0, DWORD PTR tv731[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 3035 : 			dy = y - aircraft->YPos();

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv736[ebp]
	movss	xmm0, DWORD PTR _y$[ebp]
	subss	xmm0, DWORD PTR tv736[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 3036 : 			dist = (float)sqrt(dx * dx + dy * dy);

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]

; 3037 : 			norm = (float)(1.0F/dist);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR _norm$[ebp], xmm0

; 3038 : 			dx *= norm;

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _norm$[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 3039 : 			dy *= norm;

	movss	xmm0, DWORD PTR _dy$[ebp]
	mulss	xmm0, DWORD PTR _norm$[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 3040 : 
; 3041 : 			cosAngle =	dx * aircraft->XDelta()/vt + 
; 3042 : 						dy * aircraft->YDelta()/vt;

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?XDelta@VuEntity@@QBEMXZ		; VuEntity::XDelta
	fstp	DWORD PTR tv749[ebp]
	movss	xmm0, DWORD PTR tv749[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	divss	xmm0, DWORD PTR _vt$[ebp]
	mov	ecx, DWORD PTR _aircraft$[ebp]
	movss	DWORD PTR tv1060[ebp], xmm0
	call	?YDelta@VuEntity@@QBEMXZ		; VuEntity::YDelta
	fstp	DWORD PTR tv754[ebp]
	movss	xmm0, DWORD PTR tv754[ebp]
	mulss	xmm0, DWORD PTR _dy$[ebp]
	divss	xmm0, DWORD PTR _vt$[ebp]
	movss	xmm1, DWORD PTR tv1060[ebp]
	addss	xmm1, xmm0
	movss	DWORD PTR _cosAngle$[ebp], xmm1

; 3043 : 			if(cosAngle < 0.0F)

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _cosAngle$[ebp]
	jbe	$LN33@CheckVecto

; 3044 : 			{
; 3045 : 				FindFinalPt(aircraft, info->rwindex, &finalX, &finalY);

	lea	eax, DWORD PTR _finalY$[ebp]
	push	eax
	lea	ecx, DWORD PTR _finalX$[ebp]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _aircraft$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindFinalPt@ATCBrain@@QAEXPAVAircraftClass@@HPAM1@Z ; ATCBrain::FindFinalPt

; 3046 : 				FindBasePt(aircraft, info->rwindex, finalX, finalY, &baseX, &baseY);

	lea	edx, DWORD PTR _baseY$[ebp]
	push	edx
	lea	eax, DWORD PTR _baseX$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _finalY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _finalX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindBasePt@ATCBrain@@QAE?AW4AtcStatusEnum@@PAVAircraftClass@@HMMPAM1@Z ; ATCBrain::FindBasePt

; 3047 : 				aircraft->DBrain()->SetATCStatus(lToBase);

	push	9
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?SetATCStatus@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SetATCStatus

; 3048 : 				aircraft->DBrain()->SetTrackPoint(baseX, baseY, GetAltitude(aircraft, lToBase));

	push	9
	mov	ecx, DWORD PTR _aircraft$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAltitude@ATCBrain@@QAEMPAVAircraftClass@@W4AtcStatusEnum@@@Z ; ATCBrain::GetAltitude
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	movss	xmm0, DWORD PTR _baseY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _baseX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?SetTrackPoint@DigitalBrain@@QAEXMMM@Z	; DigitalBrain::SetTrackPoint

; 3049 : 				aircraft->DBrain()->CalculateNextTurnDistance();

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?CalculateNextTurnDistance@DigitalBrain@@QAEMXZ ; DigitalBrain::CalculateNextTurnDistance
	fstp	ST(0)

; 3050 : 				info->status = lToBase;

	mov	edx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [edx+8], 9

; 3051 : 			}
; 3052 : 			else

	jmp	SHORT $LN32@CheckVecto
$LN33@CheckVecto:

; 3053 : 			{
; 3054 : 				FindFinalPt(aircraft, info->rwindex, &finalX, &finalY);

	lea	eax, DWORD PTR _finalY$[ebp]
	push	eax
	lea	ecx, DWORD PTR _finalX$[ebp]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _aircraft$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindFinalPt@ATCBrain@@QAEXPAVAircraftClass@@HPAM1@Z ; ATCBrain::FindFinalPt

; 3055 : 				aircraft->DBrain()->SetATCStatus(lToFinal);

	push	10					; 0000000aH
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?SetATCStatus@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SetATCStatus

; 3056 : 				aircraft->DBrain()->SetTrackPoint(finalX, finalY, GetAltitude(aircraft, lToFinal));

	push	10					; 0000000aH
	mov	edx, DWORD PTR _aircraft$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAltitude@ATCBrain@@QAEMPAVAircraftClass@@W4AtcStatusEnum@@@Z ; ATCBrain::GetAltitude
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	movss	xmm0, DWORD PTR _finalY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _finalX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?SetTrackPoint@DigitalBrain@@QAEXMMM@Z	; DigitalBrain::SetTrackPoint

; 3057 : 				aircraft->DBrain()->CalculateNextTurnDistance();

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?CalculateNextTurnDistance@DigitalBrain@@QAEMXZ ; DigitalBrain::CalculateNextTurnDistance
	fstp	ST(0)

; 3058 : 				info->status = lToFinal;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+8], 10			; 0000000aH
$LN32@CheckVecto:

; 3059 : 			}
; 3060 : 			
; 3061 : 			turnTime = FloatToInt32(turnDist/(12.15854203708F * 3.0F * vt ));

	movss	xmm0, DWORD PTR __real@4211e70a
	mulss	xmm0, DWORD PTR _vt$[ebp]
	movss	xmm1, DWORD PTR _turnDist$[ebp]
	divss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _turnTime$[ebp], eax

; 3062 : 			if(turnTime > 30 * CampaignSeconds)

	cmp	DWORD PTR _turnTime$[ebp], 30000	; 00007530H
	jbe	SHORT $LN31@CheckVecto

; 3063 : 				turnTime -= 15 * CampaignSeconds;

	mov	ecx, DWORD PTR _turnTime$[ebp]
	sub	ecx, 15000				; 00003a98H
	mov	DWORD PTR _turnTime$[ebp], ecx

; 3064 : 			else

	jmp	SHORT $LN30@CheckVecto
$LN31@CheckVecto:

; 3065 : 				turnTime = 15 * CampaignSeconds;

	mov	DWORD PTR _turnTime$[ebp], 15000	; 00003a98H
$LN30@CheckVecto:

; 3066 : 
; 3067 : 			info->lastContacted = SimLibElapsedTime + turnTime;

	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	edx, DWORD PTR _turnTime$[ebp]
	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+16], edx

; 3068 : 			return TRUE;

	mov	eax, 1
	jmp	$LN38@CheckVecto
$LN34@CheckVecto:

; 3069 : 		}
; 3070 : 		break;

	jmp	$LN36@CheckVecto
$LN29@CheckVecto:

; 3071 : 
; 3072 : 	
; 3073 : 	case lToBase:
; 3074 : 		if(relx < turnDist && fabs(rely) < turnDist*3.0F && info->lastContacted < SimLibElapsedTime)

	movss	xmm0, DWORD PTR _turnDist$[ebp]
	comiss	xmm0, DWORD PTR _relx$[ebp]
	jbe	$LN28@CheckVecto
	push	ecx
	movss	xmm0, DWORD PTR _rely$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv816[ebp]
	movss	xmm0, DWORD PTR _turnDist$[ebp]
	mulss	xmm0, DWORD PTR __real@40400000
	comiss	xmm0, DWORD PTR tv816[ebp]
	jbe	$LN28@CheckVecto
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	cmp	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	$LN28@CheckVecto

; 3075 : 		{
; 3076 : 			FindFinalPt(aircraft, info->rwindex, &finalX, &finalY);

	lea	eax, DWORD PTR _finalY$[ebp]
	push	eax
	lea	ecx, DWORD PTR _finalX$[ebp]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _aircraft$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindFinalPt@ATCBrain@@QAEXPAVAircraftClass@@HPAM1@Z ; ATCBrain::FindFinalPt

; 3077 : 			aircraft->DBrain()->SetATCStatus(lToFinal);

	push	10					; 0000000aH
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?SetATCStatus@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SetATCStatus

; 3078 : 			aircraft->DBrain()->SetTrackPoint(finalX, finalY, GetAltitude(aircraft, lToFinal));

	push	10					; 0000000aH
	mov	edx, DWORD PTR _aircraft$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAltitude@ATCBrain@@QAEMPAVAircraftClass@@W4AtcStatusEnum@@@Z ; ATCBrain::GetAltitude
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	movss	xmm0, DWORD PTR _finalY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _finalX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?SetTrackPoint@DigitalBrain@@QAEXMMM@Z	; DigitalBrain::SetTrackPoint

; 3079 : 			aircraft->DBrain()->CalculateNextTurnDistance();

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?CalculateNextTurnDistance@DigitalBrain@@QAEMXZ ; DigitalBrain::CalculateNextTurnDistance
	fstp	ST(0)

; 3080 : 			info->status = lToFinal;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+8], 10			; 0000000aH

; 3081 : 
; 3082 : 			turnTime = FloatToInt32(turnDist/(12.15854203708F * 3.0F * vt ));

	movss	xmm0, DWORD PTR __real@4211e70a
	mulss	xmm0, DWORD PTR _vt$[ebp]
	movss	xmm1, DWORD PTR _turnDist$[ebp]
	divss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _turnTime$[ebp], eax

; 3083 : 			if(turnTime > 30 * CampaignSeconds)

	cmp	DWORD PTR _turnTime$[ebp], 30000	; 00007530H
	jbe	SHORT $LN27@CheckVecto

; 3084 : 				turnTime -= 15 * CampaignSeconds;

	mov	ecx, DWORD PTR _turnTime$[ebp]
	sub	ecx, 15000				; 00003a98H
	mov	DWORD PTR _turnTime$[ebp], ecx

; 3085 : 			else

	jmp	SHORT $LN26@CheckVecto
$LN27@CheckVecto:

; 3086 : 				turnTime = 15 * CampaignSeconds;

	mov	DWORD PTR _turnTime$[ebp], 15000	; 00003a98H
$LN26@CheckVecto:

; 3087 : 
; 3088 : 			info->lastContacted = SimLibElapsedTime + turnTime;

	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	edx, DWORD PTR _turnTime$[ebp]
	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+16], edx

; 3089 : 			return TRUE;

	mov	eax, 1
	jmp	$LN38@CheckVecto
$LN28@CheckVecto:

; 3090 : 		}
; 3091 : 
; 3092 : 		if(info->schedTime > SimLibElapsedTime + FINAL_TIME + BASE_TIME)

	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	ecx, 180000				; 0002bf20H
	mov	edx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [edx+12], ecx
	jbe	SHORT $LN25@CheckVecto

; 3093 : 		{
; 3094 : 			deltaTime = (info->schedTime - SimLibElapsedTime - FINAL_TIME - BASE_TIME)/(float)CampaignSeconds;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	sub	ecx, 180000				; 0002bf20H
	mov	DWORD PTR tv851[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv851[ebp]
	mov	edx, DWORD PTR tv851[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	QWORD PTR tv854[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv854[ebp]
	divss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR _deltaTime$[ebp], xmm0

; 3095 : 			speed = dist/deltaTime;

	movss	xmm0, DWORD PTR _dist$[ebp]
	divss	xmm0, DWORD PTR _deltaTime$[ebp]
	movss	DWORD PTR _speed$[ebp], xmm0
$LN25@CheckVecto:

; 3096 : 		}
; 3097 : 		break;

	jmp	$LN36@CheckVecto
$LN24@CheckVecto:

; 3098 : 
; 3099 : 	
; 3100 : 	case lToFinal:
; 3101 : 		cosHdg = PtHeaderDataTable[info->rwindex].cosHeading;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm0, DWORD PTR [edx+ecx+16]
	movss	DWORD PTR _cosHdg$[ebp], xmm0

; 3102 : 		sinHdg = PtHeaderDataTable[info->rwindex].sinHeading;	

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm0, DWORD PTR [edx+ecx+12]
	movss	DWORD PTR _sinHdg$[ebp], xmm0

; 3103 : 
; 3104 : 		relx = (  cosHdg*dx + sinHdg*dy);

	movss	xmm0, DWORD PTR _cosHdg$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _sinHdg$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _relx$[ebp], xmm0

; 3105 : 		rely = ( -sinHdg*dx + cosHdg*dy);

	movss	xmm0, DWORD PTR _sinHdg$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _cosHdg$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _rely$[ebp], xmm0

; 3106 : 
; 3107 : 		if(relx > 0.0F)

	movss	xmm0, DWORD PTR _relx$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	$LN23@CheckVecto

; 3108 : 			rely = max(0.0F, (float)fabs(rely) - relx * 0.3F);

	push	ecx
	movss	xmm0, DWORD PTR _rely$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv877[ebp]
	movss	xmm0, DWORD PTR tv877[ebp]
	movss	xmm1, DWORD PTR _relx$[ebp]
	mulss	xmm1, DWORD PTR __real@3e99999a
	subss	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@00000000
	comiss	xmm1, xmm0
	jbe	SHORT $LN40@CheckVecto
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv380[ebp], xmm0
	jmp	SHORT $LN41@CheckVecto
$LN40@CheckVecto:
	push	ecx
	movss	xmm0, DWORD PTR _rely$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv886[ebp]
	movss	xmm0, DWORD PTR tv886[ebp]
	movss	xmm1, DWORD PTR _relx$[ebp]
	mulss	xmm1, DWORD PTR __real@3e99999a
	subss	xmm0, xmm1
	movss	DWORD PTR tv380[ebp], xmm0
$LN41@CheckVecto:
	movss	xmm0, DWORD PTR tv380[ebp]
	movss	DWORD PTR _rely$[ebp], xmm0
$LN23@CheckVecto:

; 3109 : 
; 3110 : 		//Cleared turn to final
; 3111 : 		if(relx < 3.0F*NM_TO_FT && relx > -1.0F*NM_TO_FT && fabs(rely) < turnDist && info->lastContacted < SimLibElapsedTime)

	movss	xmm0, DWORD PTR __real@468e6944
	comiss	xmm0, DWORD PTR _relx$[ebp]
	jbe	$LN22@CheckVecto
	movss	xmm0, DWORD PTR _relx$[ebp]
	comiss	xmm0, DWORD PTR __real@c5bde1b0
	jbe	$LN22@CheckVecto
	push	ecx
	movss	xmm0, DWORD PTR _rely$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv896[ebp]
	movss	xmm0, DWORD PTR _turnDist$[ebp]
	comiss	xmm0, DWORD PTR tv896[ebp]
	jbe	$LN22@CheckVecto
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	$LN22@CheckVecto

; 3112 : 		{
; 3113 : 			aircraft->DBrain()->SetTaxiPoint(GetFirstPt(info->rwindex));

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	?GetFirstPt@@YAHH@Z			; GetFirstPt
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?SetTaxiPoint@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetTaxiPoint

; 3114 : 			aircraft->DBrain()->SetATCStatus(lOnFinal);

	push	11					; 0000000bH
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?SetATCStatus@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SetATCStatus

; 3115 : 			TranslatePointData (self, GetFirstPt(info->rwindex), &x, &y);

	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	?GetFirstPt@@YAHH@Z			; GetFirstPt
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData
	add	esp, 16					; 00000010H

; 3116 : 			aircraft->DBrain()->SetTrackPoint(x, y, GetAltitude(aircraft, lOnFinal));

	push	11					; 0000000bH
	mov	ecx, DWORD PTR _aircraft$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAltitude@ATCBrain@@QAEMPAVAircraftClass@@W4AtcStatusEnum@@@Z ; ATCBrain::GetAltitude
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?SetTrackPoint@DigitalBrain@@QAEXMMM@Z	; DigitalBrain::SetTrackPoint

; 3117 : 			info->status = lOnFinal;

	mov	edx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [edx+8], 11			; 0000000bH

; 3118 : 
; 3119 : 			turnTime = FloatToInt32(turnDist/(12.15854203708F * 3.0F * vt ));

	movss	xmm0, DWORD PTR __real@4211e70a
	mulss	xmm0, DWORD PTR _vt$[ebp]
	movss	xmm1, DWORD PTR _turnDist$[ebp]
	divss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _turnTime$[ebp], eax

; 3120 : 			if(turnTime > 30 * CampaignSeconds)

	cmp	DWORD PTR _turnTime$[ebp], 30000	; 00007530H
	jbe	SHORT $LN21@CheckVecto

; 3121 : 				turnTime -= 15 * CampaignSeconds;

	mov	eax, DWORD PTR _turnTime$[ebp]
	sub	eax, 15000				; 00003a98H
	mov	DWORD PTR _turnTime$[ebp], eax

; 3122 : 			else

	jmp	SHORT $LN20@CheckVecto
$LN21@CheckVecto:

; 3123 : 				turnTime = 15 * CampaignSeconds;

	mov	DWORD PTR _turnTime$[ebp], 15000	; 00003a98H
$LN20@CheckVecto:

; 3124 : 
; 3125 : 			info->lastContacted = SimLibElapsedTime + turnTime;

	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	ecx, DWORD PTR _turnTime$[ebp]
	mov	edx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 3126 : 			return TRUE;

	mov	eax, 1
	jmp	$LN38@CheckVecto
$LN22@CheckVecto:

; 3127 : 		}
; 3128 : 
; 3129 : 		if(info->schedTime > SimLibElapsedTime + FINAL_TIME)

	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	eax, 120000				; 0001d4c0H
	mov	ecx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [ecx+12], eax
	jbe	SHORT $LN19@CheckVecto

; 3130 : 		{
; 3131 : 			deltaTime = (info->schedTime - SimLibElapsedTime - FINAL_TIME)/(float)CampaignSeconds;

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+12]
	sub	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	sub	eax, 120000				; 0001d4c0H
	mov	DWORD PTR tv936[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv936[ebp]
	mov	ecx, DWORD PTR tv936[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv939[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv939[ebp]
	divss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR _deltaTime$[ebp], xmm0

; 3132 : 			speed = dist/deltaTime;

	movss	xmm0, DWORD PTR _dist$[ebp]
	divss	xmm0, DWORD PTR _deltaTime$[ebp]
	movss	DWORD PTR _speed$[ebp], xmm0
$LN19@CheckVecto:

; 3133 : 		}
; 3134 : 		break;

	jmp	SHORT $LN36@CheckVecto
$LN18@CheckVecto:

; 3135 : 	
; 3136 : 	case lReqClearance:
; 3137 : 	case lReqEmerClearance:
; 3138 : 	case lIngressing:
; 3139 : 	case lTakingPosition:
; 3140 : 	case lAborted:
; 3141 : 	case lEmerHold:
; 3142 : 	case lHolding:
; 3143 : 	case lOnFinal:
; 3144 : 	case lEmergencyToBase:
; 3145 : 	case lEmergencyToFinal:
; 3146 : 	case lClearToLand:
; 3147 : 		return FALSE;

	xor	eax, eax
	jmp	$LN38@CheckVecto
$LN17@CheckVecto:
$LN36@CheckVecto:

; 3148 : 		break;
; 3149 : 
; 3150 : 	default:
; 3151 : 		//we should never get here
; 3152 : 		ShiWarning("We are in an undefined state, we shouldn't be here");
; 3153 : 		break;
; 3154 : 	}
; 3155 : 
; 3156 : 	norm = (float)(1.0F/dist);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR _norm$[ebp], xmm0

; 3157 : 	dx *= norm;

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _norm$[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 3158 : 	dy *= norm;

	movss	xmm0, DWORD PTR _dy$[ebp]
	mulss	xmm0, DWORD PTR _norm$[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 3159 : 
; 3160 : 	cosAngle =	dx * aircraft->XDelta()/vt + 
; 3161 : 				dy * aircraft->YDelta()/vt;

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?XDelta@VuEntity@@QBEMXZ		; VuEntity::XDelta
	fstp	DWORD PTR tv951[ebp]
	movss	xmm0, DWORD PTR tv951[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	divss	xmm0, DWORD PTR _vt$[ebp]
	mov	ecx, DWORD PTR _aircraft$[ebp]
	movss	DWORD PTR tv1062[ebp], xmm0
	call	?YDelta@VuEntity@@QBEMXZ		; VuEntity::YDelta
	fstp	DWORD PTR tv956[ebp]
	movss	xmm0, DWORD PTR tv956[ebp]
	mulss	xmm0, DWORD PTR _dy$[ebp]
	divss	xmm0, DWORD PTR _vt$[ebp]
	movss	xmm1, DWORD PTR tv1062[ebp]
	addss	xmm1, xmm0
	movss	DWORD PTR _cosAngle$[ebp], xmm1

; 3162 : 
; 3163 : 	// RAS - 3Oct04 - Verify this information
; 3164 : 	// Old information - Broken out to make easier to debug
; 3165 : 	/*  
; 3166 : 	if( (info->lastContacted + 30 * CampaignSeconds < SimLibElapsedTime && dist > 4.0F*turnDist && 
; 3167 : 		(cosAngle < 0.965925F || info->status < lLanded && fabs(speed - vt) > 30.0F))	||
; 3168 : 		(info->lastContacted + 15 * CampaignSeconds < SimLibElapsedTime && cosAngle < 0.5F && dist > 3.0F*turnDist)	||
; 3169 : 		(info->lastContacted + 8 * CampaignSeconds < SimLibElapsedTime && cosAngle < -0.866F )||
; 3170 : 		info->lastContacted + 2 * CampaignMinutes < SimLibElapsedTime && dist > 4.0F*turnDist)
; 3171 : 	{
; 3172 : 		//we're not heading for our track point
; 3173 : 		MakeVectorCall(aircraft, FalconLocalGame);
; 3174 : 		info->lastContacted = SimLibElapsedTime;
; 3175 : 	}
; 3176 : 	*/
; 3177 : 
; 3178 : 	if(info->lastContacted + 30 * CampaignSeconds < SimLibElapsedTime)

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 30000				; 00007530H
	cmp	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	SHORT $LN16@CheckVecto

; 3179 : 	{
; 3180 : 		if(dist > 4.0F*turnDist)

	movss	xmm0, DWORD PTR __real@40800000
	mulss	xmm0, DWORD PTR _turnDist$[ebp]
	movss	xmm1, DWORD PTR _dist$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN14@CheckVecto

; 3181 :             if(cosAngle < 0.965925F)

	movss	xmm0, DWORD PTR __real@3f7746dc
	comiss	xmm0, DWORD PTR _cosAngle$[ebp]
	jbe	SHORT $LN14@CheckVecto

; 3182 : 			{
; 3183 : 				//we're not heading for our track point
; 3184 : 				MakeVectorCall(aircraft, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN42@CheckVecto
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv485[ebp], eax
	jmp	SHORT $LN43@CheckVecto
$LN42@CheckVecto:
	mov	DWORD PTR tv485[ebp], 0
$LN43@CheckVecto:
	mov	edx, DWORD PTR tv485[ebp]
	push	edx
	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeVectorCall@ATCBrain@@QAEXPAVAircraftClass@@PAVVuTargetEntity@@@Z ; ATCBrain::MakeVectorCall

; 3185 : 				info->lastContacted = SimLibElapsedTime;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [ecx+16], edx

; 3186 : 				return FALSE;

	xor	eax, eax
	jmp	$LN38@CheckVecto
$LN14@CheckVecto:

; 3187 :       }
; 3188 : 	}

	jmp	$LN1@CheckVecto
$LN16@CheckVecto:

; 3189 : 	//RAS-3Oct04-added airspeed check every 20 seconds instead of every time
; 3190 : 	else if(info->lastContacted + 20 * CampaignSeconds < SimLibElapsedTime)

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 20000				; 00004e20H
	cmp	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	$LN12@CheckVecto

; 3191 : 	{
; 3192 :     if(info->status < lLanded && fabs(speed - vt) > 30.0F)	//haven't landed and speed is off by > 30kts

	mov	edx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [edx+8], 13			; 0000000dH
	jge	$LN11@CheckVecto
	movss	xmm0, DWORD PTR _speed$[ebp]
	subss	xmm0, DWORD PTR _vt$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv977[ebp]
	movss	xmm0, DWORD PTR tv977[ebp]
	comiss	xmm0, DWORD PTR __real@41f00000
	jbe	SHORT $LN11@CheckVecto

; 3193 : 		{
; 3194 : 			//we're not heading for our track point
; 3195 : 			MakeVectorCall(aircraft, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN44@CheckVecto
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv515[ebp], eax
	jmp	SHORT $LN45@CheckVecto
$LN44@CheckVecto:
	mov	DWORD PTR tv515[ebp], 0
$LN45@CheckVecto:
	mov	ecx, DWORD PTR tv515[ebp]
	push	ecx
	mov	edx, DWORD PTR _aircraft$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeVectorCall@ATCBrain@@QAEXPAVAircraftClass@@PAVVuTargetEntity@@@Z ; ATCBrain::MakeVectorCall

; 3196 : 			info->lastContacted = SimLibElapsedTime;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [eax+16], ecx

; 3197 : 			return FALSE;

	xor	eax, eax
	jmp	$LN38@CheckVecto
$LN11@CheckVecto:

; 3198 : 		}
; 3199 : 	}

	jmp	$LN1@CheckVecto
$LN12@CheckVecto:

; 3200 : 	else if(info->lastContacted + 15 * CampaignSeconds < SimLibElapsedTime)

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 15000				; 00003a98H
	cmp	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	SHORT $LN9@CheckVecto

; 3201 : 	{
; 3202 : 		if(cosAngle < 0.5F)

	movss	xmm0, DWORD PTR __real@3f000000
	comiss	xmm0, DWORD PTR _cosAngle$[ebp]
	jbe	SHORT $LN7@CheckVecto

; 3203 : 		{
; 3204 : 			if(dist > 3.0F*turnDist)

	movss	xmm0, DWORD PTR __real@40400000
	mulss	xmm0, DWORD PTR _turnDist$[ebp]
	movss	xmm1, DWORD PTR _dist$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN7@CheckVecto

; 3205 : 			{
; 3206 : 				//we're not heading for our track point
; 3207 : 				MakeVectorCall(aircraft, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN46@CheckVecto
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv542[ebp], eax
	jmp	SHORT $LN47@CheckVecto
$LN46@CheckVecto:
	mov	DWORD PTR tv542[ebp], 0
$LN47@CheckVecto:
	mov	edx, DWORD PTR tv542[ebp]
	push	edx
	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeVectorCall@ATCBrain@@QAEXPAVAircraftClass@@PAVVuTargetEntity@@@Z ; ATCBrain::MakeVectorCall

; 3208 : 				info->lastContacted = SimLibElapsedTime;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [ecx+16], edx

; 3209 : 				return FALSE;

	xor	eax, eax
	jmp	$LN38@CheckVecto
$LN7@CheckVecto:

; 3210 : 			}
; 3211 : 		}
; 3212 : 	}

	jmp	$LN1@CheckVecto
$LN9@CheckVecto:

; 3213 : 	else if(info->lastContacted + 8 * CampaignSeconds < SimLibElapsedTime)

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 8000				; 00001f40H
	cmp	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	SHORT $LN5@CheckVecto

; 3214 : 	{
; 3215 : 		if(cosAngle < -0.866F)

	movss	xmm0, DWORD PTR __real@bf5db22d
	comiss	xmm0, DWORD PTR _cosAngle$[ebp]
	jbe	SHORT $LN4@CheckVecto

; 3216 : 		{
; 3217 : 			//we're not heading for our track point
; 3218 : 			MakeVectorCall(aircraft, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN48@CheckVecto
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv567[ebp], eax
	jmp	SHORT $LN49@CheckVecto
$LN48@CheckVecto:
	mov	DWORD PTR tv567[ebp], 0
$LN49@CheckVecto:
	mov	eax, DWORD PTR tv567[ebp]
	push	eax
	mov	ecx, DWORD PTR _aircraft$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeVectorCall@ATCBrain@@QAEXPAVAircraftClass@@PAVVuTargetEntity@@@Z ; ATCBrain::MakeVectorCall

; 3219 : 			info->lastContacted = SimLibElapsedTime;

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [edx+16], eax

; 3220 : 			return FALSE;

	xor	eax, eax
	jmp	SHORT $LN38@CheckVecto
$LN4@CheckVecto:

; 3221 : 		}
; 3222 : 	}

	jmp	SHORT $LN1@CheckVecto
$LN5@CheckVecto:

; 3223 : 	else if(info->lastContacted + 2 * CampaignMinutes < SimLibElapsedTime)

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 120000				; 0001d4c0H
	cmp	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	SHORT $LN1@CheckVecto

; 3224 : 	{
; 3225 : 		if(dist > 4.0F*turnDist)

	movss	xmm0, DWORD PTR __real@40800000
	mulss	xmm0, DWORD PTR _turnDist$[ebp]
	movss	xmm1, DWORD PTR _dist$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN1@CheckVecto

; 3226 : 		{
; 3227 : 			//we're not heading for our track point
; 3228 : 			MakeVectorCall(aircraft, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN50@CheckVecto
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv593[ebp], eax
	jmp	SHORT $LN51@CheckVecto
$LN50@CheckVecto:
	mov	DWORD PTR tv593[ebp], 0
$LN51@CheckVecto:
	mov	ecx, DWORD PTR tv593[ebp]
	push	ecx
	mov	edx, DWORD PTR _aircraft$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeVectorCall@ATCBrain@@QAEXPAVAircraftClass@@PAVVuTargetEntity@@@Z ; ATCBrain::MakeVectorCall

; 3229 : 			info->lastContacted = SimLibElapsedTime;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [eax+16], ecx

; 3230 : 			return FALSE;

	xor	eax, eax
	jmp	SHORT $LN38@CheckVecto
$LN1@CheckVecto:

; 3231 : 		}
; 3232 : 	}
; 3233 : 		// End if statement breakup
; 3234 : 		return FALSE;

	xor	eax, eax
$LN38@CheckVecto:

; 3235 : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN53@CheckVecto:
	DD	$LN18@CheckVecto
	DD	$LN35@CheckVecto
	DD	$LN29@CheckVecto
	DD	$LN24@CheckVecto
	DD	$LN17@CheckVecto
$LN52@CheckVecto:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	2
	DB	3
	DB	0
	DB	0
	DB	4
	DB	4
	DB	0
	DB	0
?CheckVector@ATCBrain@@QAEHPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ENDP ; ATCBrain::CheckVector
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_pos$ = -8						; size = 4
_info$1 = -4						; size = 4
_takeoffInfo$ = 8					; size = 4
?GetTakeoffNumber@ATCBrain@@QAEHPAUrunwayQueueStruct@@@Z PROC ; ATCBrain::GetTakeoffNumber
; _this$ = ecx

; 4438 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 4439 : 	int pos = 0;

	mov	DWORD PTR _pos$[ebp], 0

; 4440 : 
; 4441 : 	if(takeoffInfo->status <= lCrashed)

	mov	eax, DWORD PTR _takeoffInfo$[ebp]
	cmp	DWORD PTR [eax+8], 18			; 00000012H
	jg	SHORT $LN6@GetTakeoff

; 4442 : 		return -1;

	or	eax, -1
	jmp	SHORT $LN7@GetTakeoff
$LN6@GetTakeoff:

; 4443 : 
; 4444 : 	if(takeoffInfo && takeoffInfo->rwindex)

	cmp	DWORD PTR _takeoffInfo$[ebp], 0
	je	SHORT $LN5@GetTakeoff
	mov	ecx, DWORD PTR _takeoffInfo$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	je	SHORT $LN5@GetTakeoff

; 4445 : 	{
; 4446 : 		runwayQueueStruct* info = runwayQueue[PtHeaderDataTable[takeoffInfo->rwindex].runwayNum];

	mov	edx, DWORD PTR _takeoffInfo$[ebp]
	mov	eax, DWORD PTR [edx+20]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	edx, BYTE PTR [ecx+eax+24]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _info$1[ebp], edx
$LN4@GetTakeoff:

; 4447 : 
; 4448 : 		while(info)

	cmp	DWORD PTR _info$1[ebp], 0
	je	SHORT $LN5@GetTakeoff

; 4449 : 		{
; 4450 : 			if(info->aircraftID == takeoffInfo->aircraftID)		

	mov	eax, DWORD PTR _takeoffInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _info$1[ebp]
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@GetTakeoff

; 4451 : 				break;

	jmp	SHORT $LN5@GetTakeoff
$LN2@GetTakeoff:

; 4452 : 
; 4453 : 			if(info->status > lCrashed && info->status < tTakeoff)

	mov	edx, DWORD PTR _info$1[ebp]
	cmp	DWORD PTR [edx+8], 18			; 00000012H
	jle	SHORT $LN1@GetTakeoff
	mov	eax, DWORD PTR _info$1[ebp]
	cmp	DWORD PTR [eax+8], 27			; 0000001bH
	jge	SHORT $LN1@GetTakeoff

; 4454 : 				pos++;

	mov	ecx, DWORD PTR _pos$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pos$[ebp], ecx
$LN1@GetTakeoff:

; 4455 : 
; 4456 : 			info = info->next;

	mov	edx, DWORD PTR _info$1[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _info$1[ebp], eax

; 4457 : 		}

	jmp	SHORT $LN4@GetTakeoff
$LN5@GetTakeoff:

; 4458 : 	}
; 4459 : 	return pos;

	mov	eax, DWORD PTR _pos$[ebp]
$LN7@GetTakeoff:

; 4460 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetTakeoffNumber@ATCBrain@@QAEHPAUrunwayQueueStruct@@@Z ENDP ; ATCBrain::GetTakeoffNumber
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_pos$ = -8						; size = 4
_info$1 = -4						; size = 4
_landInfo$ = 8						; size = 4
?GetLandingNumber@ATCBrain@@QAEHPAUrunwayQueueStruct@@@Z PROC ; ATCBrain::GetLandingNumber
; _this$ = ecx

; 4415 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 4416 : 	int pos = 0;

	mov	DWORD PTR _pos$[ebp], 0

; 4417 : 	if(landInfo && landInfo->rwindex)

	cmp	DWORD PTR _landInfo$[ebp], 0
	je	SHORT $LN5@GetLanding
	mov	eax, DWORD PTR _landInfo$[ebp]
	cmp	DWORD PTR [eax+20], 0
	je	SHORT $LN5@GetLanding

; 4418 : 	{
; 4419 : 		runwayQueueStruct* info = runwayQueue[PtHeaderDataTable[landInfo->rwindex].runwayNum];

	mov	ecx, DWORD PTR _landInfo$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	ecx, BYTE PTR [eax+edx+24]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _info$1[ebp], ecx
$LN4@GetLanding:

; 4420 : 
; 4421 : 		while(info)

	cmp	DWORD PTR _info$1[ebp], 0
	je	SHORT $LN5@GetLanding

; 4422 : 		{
; 4423 : 			if(info->aircraftID == landInfo->aircraftID)

	mov	edx, DWORD PTR _landInfo$[ebp]
	push	edx
	mov	ecx, DWORD PTR _info$1[ebp]
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@GetLanding

; 4424 : 				break;

	jmp	SHORT $LN5@GetLanding
$LN2@GetLanding:

; 4425 : 
; 4426 : 			if(info->status < tReqTaxi && info->status >= lReqClearance)

	mov	ecx, DWORD PTR _info$1[ebp]
	cmp	DWORD PTR [ecx+8], 19			; 00000013H
	jge	SHORT $LN1@GetLanding
	mov	edx, DWORD PTR _info$1[ebp]
	cmp	DWORD PTR [edx+8], 1
	jl	SHORT $LN1@GetLanding

; 4427 : 				pos++;

	mov	eax, DWORD PTR _pos$[ebp]
	add	eax, 1
	mov	DWORD PTR _pos$[ebp], eax
$LN1@GetLanding:

; 4428 : 
; 4429 : 			info = info->next;			

	mov	ecx, DWORD PTR _info$1[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _info$1[ebp], edx

; 4430 : 		}

	jmp	SHORT $LN4@GetLanding
$LN5@GetLanding:

; 4431 : 	}
; 4432 : 
; 4433 : 	return pos;

	mov	eax, DWORD PTR _pos$[ebp]

; 4434 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetLandingNumber@ATCBrain@@QAEHPAUrunwayQueueStruct@@@Z ENDP ; ATCBrain::GetLandingNumber
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
tv972 = -216						; size = 8
_z$ = -208						; size = 4
tv796 = -204						; size = 8
_cosAngle$ = -196					; size = 4
tv814 = -192						; size = 4
tv845 = -188						; size = 4
tv884 = -184						; size = 4
tv983 = -180						; size = 4
tv661 = -176						; size = 4
tv859 = -172						; size = 4
$T1 = -168						; size = 4
tv832 = -164						; size = 4
tv1060 = -160						; size = 4
tv803 = -156						; size = 4
tv1040 = -152						; size = 4
tv979 = -148						; size = 4
tv1035 = -144						; size = 4
tv864 = -140						; size = 4
tv1030 = -136						; size = 4
tv854 = -132						; size = 4
tv1021 = -128						; size = 4
tv839 = -124						; size = 4
tv1015 = -120						; size = 4
tv827 = -116						; size = 4
tv1008 = -112						; size = 4
tv752 = -108						; size = 4
tv1003 = -104						; size = 4
tv990 = -100						; size = 4
tv807 = -96						; size = 4
tv504 = -92						; size = 4
tv84 = -88						; size = 4
tv492 = -84						; size = 4
tv268 = -80						; size = 4
tv969 = -76						; size = 4
tv280 = -72						; size = 4
tv793 = -68						; size = 4
$T2 = -64						; size = 4
_deltaTime$ = -60					; size = 4
_status$ = -56						; size = 4
_rwtime$ = -52						; size = 4
tv167 = -48						; size = 4
_finalHdg$ = -44					; size = 4
_dy$ = -40						; size = 4
_x$ = -36						; size = 4
_dx$ = -32						; size = 4
_y$ = -28						; size = 4
_desAlt$ = -24						; size = 4
_rwindex$ = -20						; size = 4
_index$ = -16						; size = 4
_this$ = -12						; size = 4
_speed$ = -8						; size = 4
_radioMessage$ = -4					; size = 4
_aircraft$ = 8						; size = 4
_target$ = 12						; size = 4
?MakeVectorCall@ATCBrain@@QAEXPAVAircraftClass@@PAVVuTargetEntity@@@Z PROC ; ATCBrain::MakeVectorCall
; _this$ = ecx

; 4179 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 4180 : 	FalconRadioChatterMessage	*radioMessage = NULL;

	mov	DWORD PTR _radioMessage$[ebp], 0

; 4181 : 	int rwindex, index;
; 4182 : 	float x, y, z, speed, cosAngle;
; 4183 : 	AtcStatusEnum status;
; 4184 : 	unsigned long rwtime;
; 4185 : 	float deltaTime, dx, dy, finalHdg, desAlt;
; 4186 : 	
; 4187 : 	rwtime = aircraft->DBrain()->RwTime();

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?RwTime@DigitalBrain@@QAEKXZ		; DigitalBrain::RwTime
	mov	DWORD PTR _rwtime$[ebp], eax

; 4188 : 	status = aircraft->DBrain()->ATCStatus();

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?ATCStatus@DigitalBrain@@QAE?AW4AtcStatusEnum@@XZ ; DigitalBrain::ATCStatus
	mov	DWORD PTR _status$[ebp], eax

; 4189 : 	rwindex = aircraft->DBrain()->Runway();

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?Runway@DigitalBrain@@QAEHXZ		; DigitalBrain::Runway
	mov	DWORD PTR _rwindex$[ebp], eax

; 4190 : 	cosAngle = DetermineAngle(aircraft, rwindex, status);

	mov	eax, DWORD PTR _status$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rwindex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _aircraft$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DetermineAngle@ATCBrain@@QAEMPAVAircraftClass@@HW4AtcStatusEnum@@@Z ; ATCBrain::DetermineAngle
	fstp	DWORD PTR _cosAngle$[ebp]

; 4191 : 	speed = aircraft->af->MinVcas();

	mov	eax, DWORD PTR _aircraft$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR _speed$[ebp]

; 4192 : 	
; 4193 : 
; 4194 : 
; 4195 : 	// JB 010527 (from MN) start
; 4196 :  	//radioMessage = CreateCallFromATC (self, aircraft, rcATCVECTORS, target);
; 4197 : 	switch(status)

	mov	ecx, DWORD PTR _status$[ebp]
	mov	DWORD PTR tv84[ebp], ecx
	cmp	DWORD PTR tv84[ebp], 10			; 0000000aH
	je	SHORT $LN47@MakeVector
	cmp	DWORD PTR tv84[ebp], 16			; 00000010H
	je	SHORT $LN47@MakeVector
	jmp	SHORT $LN46@MakeVector
$LN47@MakeVector:

; 4198 : 	{
; 4199 : 	case lEmergencyToFinal:
; 4200 : 	case lToFinal:
; 4201 : 		radioMessage = CreateCallFromATC (self, aircraft, rcATCVECTORSRW, target);

	mov	edx, DWORD PTR _target$[ebp]
	push	edx
	push	340					; 00000154H
	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$[ebp], eax

; 4202 : 		radioMessage->dataBlock.edata[8] = (short)GetRunwayName(GetOppositeRunway(rwindex));//Cobra test

	mov	eax, DWORD PTR _rwindex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOppositeRunway@ATCBrain@@QAEHH@Z	; ATCBrain::GetOppositeRunway
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRunwayName@ATCBrain@@QAEHH@Z	; ATCBrain::GetRunwayName
	mov	ecx, 2
	shl	ecx, 3
	mov	edx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [edx+ecx+64], ax

; 4203 : 		break;

	jmp	SHORT $LN48@MakeVector
$LN46@MakeVector:

; 4204 : 	default:
; 4205 : 		//RAS-6Oct04-Change to from rcATCVECTORS to rcATCVECTORSRW for rwy calls
; 4206 : 		radioMessage = CreateCallFromATC (self, aircraft, rcATCVECTORSRW, target);

	mov	eax, DWORD PTR _target$[ebp]
	push	eax
	push	340					; 00000154H
	mov	ecx, DWORD PTR _aircraft$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$[ebp], eax

; 4207 : 		radioMessage->dataBlock.edata[8] = (short)GetRunwayName(GetOppositeRunway(rwindex));//Cobra test

	mov	ecx, DWORD PTR _rwindex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOppositeRunway@ATCBrain@@QAEHH@Z	; ATCBrain::GetOppositeRunway
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRunwayName@ATCBrain@@QAEHH@Z	; ATCBrain::GetRunwayName
	mov	edx, 2
	shl	edx, 3
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [ecx+edx+64], ax
$LN48@MakeVector:

; 4208 : 	}
; 4209 : 	// JB 010527 (from MN) end
; 4210 : 
; 4211 : 	/*
; 4212 : 	if(fabs(aircraft->ZPos() - desAlt) < 100.0F)
; 4213 : 		index = 2;
; 4214 : 	else if(aircraft->ZPos() < desAlt)
; 4215 : 		index = 0;
; 4216 : 	else
; 4217 : 		index = 1;
; 4218 : 	*/
; 4219 : 
; 4220 : 	//radioMessage->dataBlock.edata[2] = index;
; 4221 : 	//radioMessage->dataBlock.edata[3] = -desAlt; //altitude in feet
; 4222 : 	radioMessage->dataBlock.edata[2] = -1; //climb or descend

	mov	edx, 2
	shl	edx, 1
	or	eax, -1
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [ecx+edx+64], ax

; 4223 : 	radioMessage->dataBlock.edata[3] = -1; //altitude in feet	

	mov	edx, 2
	imul	edx, 3
	or	eax, -1
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [ecx+edx+64], ax

; 4224 : 
; 4225 : 	aircraft->DBrain()->GetTrackPoint(x, y, z);

	lea	edx, DWORD PTR _z$[ebp]
	push	edx
	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?GetTrackPoint@DigitalBrain@@QAEXAAM00@Z ; DigitalBrain::GetTrackPoint

; 4226 : 
; 4227 : 	switch(status)

	mov	edx, DWORD PTR _status$[ebp]
	mov	DWORD PTR tv167[ebp], edx
	mov	eax, DWORD PTR tv167[ebp]
	sub	eax, 8
	mov	DWORD PTR tv167[ebp], eax
	cmp	DWORD PTR tv167[ebp], 8
	ja	$LN1@MakeVector
	mov	ecx, DWORD PTR tv167[ebp]
	movzx	edx, BYTE PTR $LN62@MakeVector[ecx]
	jmp	DWORD PTR $LN63@MakeVector[edx*4]
$LN43@MakeVector:

; 4228 : 	{
; 4229 : 	case lFirstLeg:
; 4230 : 		if(fabs(aircraft->af->vcas - speed) > 10.0F)

	mov	eax, DWORD PTR _aircraft$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1124]
	subss	xmm0, DWORD PTR _speed$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv752[ebp]
	movss	xmm0, DWORD PTR tv752[ebp]
	comiss	xmm0, DWORD PTR __real@41200000
	jbe	SHORT $LN42@MakeVector

; 4231 : 			radioMessage->dataBlock.edata[4] = (short)FloatToInt32(speed); //speed

	push	ecx
	movss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	edx, 2
	shl	edx, 2
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [ecx+edx+64], ax

; 4232 : 		else

	jmp	SHORT $LN41@MakeVector
$LN42@MakeVector:

; 4233 : 			radioMessage->dataBlock.edata[4] = -1; //speed

	mov	edx, 2
	shl	edx, 2
	or	eax, -1
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [ecx+edx+64], ax
$LN41@MakeVector:

; 4234 : 		radioMessage->dataBlock.edata[5] = (short)CalculateStandRateTurnToPt(aircraft, x, y, &finalHdg); //turn direction	

	lea	edx, DWORD PTR _finalHdg$[ebp]
	push	edx
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateStandRateTurnToPt@ATCBrain@@QAEHPAVAircraftClass@@MMPAM@Z ; ATCBrain::CalculateStandRateTurnToPt
	mov	ecx, 2
	imul	ecx, 5
	mov	edx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [edx+ecx+64], ax

; 4235 : 		if(radioMessage->dataBlock.edata[5] >= 0)

	mov	eax, 2
	imul	eax, 5
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	movsx	edx, WORD PTR [ecx+eax+64]
	test	edx, edx
	jl	SHORT $LN40@MakeVector

; 4236 : 			radioMessage->dataBlock.edata[6] = (short)FloatToInt32(finalHdg);

	push	ecx
	movss	xmm0, DWORD PTR _finalHdg$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	ecx, 2
	imul	ecx, 6
	mov	edx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [edx+ecx+64], ax

; 4237 : 		else

	jmp	SHORT $LN39@MakeVector
$LN40@MakeVector:

; 4238 : 			radioMessage->dataBlock.edata[6] = -1;

	mov	eax, 2
	imul	eax, 6
	or	ecx, -1
	mov	edx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [edx+eax+64], cx
$LN39@MakeVector:

; 4239 : 		radioMessage->dataBlock.edata[7] = -1; //vector type? , not relevant

	mov	eax, 2
	imul	eax, 7
	or	ecx, -1
	mov	edx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [edx+eax+64], cx

; 4240 : 		FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	eax, DWORD PTR _radioMessage$[ebp]
	push	eax
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8

; 4241 : 		return;

	jmp	$LN50@MakeVector

; 4242 : 		break;

	jmp	$LN44@MakeVector
$LN38@MakeVector:

; 4243 : 
; 4244 : 	case lEmergencyToBase:
; 4245 : 	case lToBase:
; 4246 : 		if(rwtime > SimLibElapsedTime)

	mov	ecx, DWORD PTR _rwtime$[ebp]
	cmp	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jbe	$LN37@MakeVector

; 4247 : 		{
; 4248 : 			deltaTime = (rwtime - SimLibElapsedTime - 3 * CampaignMinutes)/(float)CampaignSeconds;

	mov	edx, DWORD PTR _rwtime$[ebp]
	sub	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	sub	edx, 180000				; 0002bf20H
	mov	DWORD PTR tv793[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv793[ebp]
	mov	eax, DWORD PTR tv793[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv796[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv796[ebp]
	divss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR _deltaTime$[ebp], xmm0

; 4249 : 			dx = aircraft->XPos() - x;

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv803[ebp]
	movss	xmm0, DWORD PTR tv803[ebp]
	subss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 4250 : 			dy = aircraft->YPos() - y;

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv807[ebp]
	movss	xmm0, DWORD PTR tv807[ebp]
	subss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 4251 : 			speed = (float)sqrt(dx*dx + dy*dy)/deltaTime * FTPSEC_TO_KNOTS;

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv814[ebp]
	movss	xmm0, DWORD PTR tv814[ebp]
	divss	xmm0, DWORD PTR _deltaTime$[ebp]
	mulss	xmm0, DWORD PTR __real@3f17ac60
	movss	DWORD PTR _speed$[ebp], xmm0

; 4252 : 			speed = get_air_speed( speed, -1*FloatToInt32(aircraft->af->z));

	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	push	ecx
	movss	xmm0, DWORD PTR [edx+1116]
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	imul	eax, -1
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?get_air_speed@@YAMMH@Z			; get_air_speed
	add	esp, 8
	fstp	DWORD PTR _speed$[ebp]

; 4253 : 			speed = max(aircraft->af->MinVcas() * 0.8F, speed);

	mov	eax, DWORD PTR _aircraft$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv827[ebp]
	movss	xmm0, DWORD PTR tv827[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	comiss	xmm0, DWORD PTR _speed$[ebp]
	jbe	SHORT $LN52@MakeVector
	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv832[ebp]
	movss	xmm0, DWORD PTR tv832[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR tv268[ebp], xmm0
	jmp	SHORT $LN53@MakeVector
$LN52@MakeVector:
	movss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR tv268[ebp], xmm0
$LN53@MakeVector:
	movss	xmm0, DWORD PTR tv268[ebp]
	movss	DWORD PTR _speed$[ebp], xmm0

; 4254 : 			speed = min(aircraft->af->MaxVcas() * 0.8F, speed);

	mov	edx, DWORD PTR _aircraft$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	call	?MaxVcas@AirframeClass@@QAEMXZ		; AirframeClass::MaxVcas
	fstp	DWORD PTR tv839[ebp]
	movss	xmm0, DWORD PTR tv839[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	movss	xmm1, DWORD PTR _speed$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN54@MakeVector
	mov	eax, DWORD PTR _aircraft$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?MaxVcas@AirframeClass@@QAEMXZ		; AirframeClass::MaxVcas
	fstp	DWORD PTR tv845[ebp]
	movss	xmm0, DWORD PTR tv845[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR tv280[ebp], xmm0
	jmp	SHORT $LN55@MakeVector
$LN54@MakeVector:
	movss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR tv280[ebp], xmm0
$LN55@MakeVector:
	movss	xmm0, DWORD PTR tv280[ebp]
	movss	DWORD PTR _speed$[ebp], xmm0
$LN37@MakeVector:

; 4255 : 			
; 4256 : 		}		
; 4257 : 
; 4258 : 		desAlt = GetAltitude(aircraft, lToBase);	//RAS-3Oct04-Changed from lToFinal to lToBase

	push	9
	mov	ecx, DWORD PTR _aircraft$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAltitude@ATCBrain@@QAEMPAVAircraftClass@@W4AtcStatusEnum@@@Z ; ATCBrain::GetAltitude
	fstp	DWORD PTR _desAlt$[ebp]

; 4259 : 		
; 4260 : 		if(fabs(aircraft->ZPos() - desAlt) < 800.0F)	//RAS-23Jan04-changed from 100 to 800

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv854[ebp]
	movss	xmm0, DWORD PTR tv854[ebp]
	subss	xmm0, DWORD PTR _desAlt$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv859[ebp]
	movss	xmm0, DWORD PTR __real@44480000
	comiss	xmm0, DWORD PTR tv859[ebp]
	jbe	SHORT $LN36@MakeVector

; 4261 : 			index = -1;									//RAS-3Oct04-Maintain Altitude-changed from 2 to -1

	mov	DWORD PTR _index$[ebp], -1
	jmp	SHORT $LN33@MakeVector
$LN36@MakeVector:

; 4262 : 														//no climb/descend/maintain call if within 800
; 4263 : 														//feet of alt
; 4264 : 		else if(aircraft->ZPos() < desAlt) 

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv864[ebp]
	movss	xmm0, DWORD PTR _desAlt$[ebp]
	comiss	xmm0, DWORD PTR tv864[ebp]
	jbe	SHORT $LN34@MakeVector

; 4265 : 			index = 1;									// Descend

	mov	DWORD PTR _index$[ebp], 1

; 4266 : 		else

	jmp	SHORT $LN33@MakeVector
$LN34@MakeVector:

; 4267 : 			index = 0;									// Climb

	mov	DWORD PTR _index$[ebp], 0
$LN33@MakeVector:

; 4268 : 		
; 4269 : 
; 4270 : 		//RAS-3Oct04- Set index to -1 if don't need to make altitude call
; 4271 : 		radioMessage->dataBlock.edata[2] = (short)index;

	mov	edx, 2
	shl	edx, 1
	mov	eax, DWORD PTR _radioMessage$[ebp]
	mov	cx, WORD PTR _index$[ebp]
	mov	WORD PTR [eax+edx+64], cx

; 4272 : 		if(index == -1)								//if on altitude, don't say climb,descend or maintain

	cmp	DWORD PTR _index$[ebp], -1
	jne	SHORT $LN32@MakeVector

; 4273 : 			radioMessage->dataBlock.edata[3] = -1;

	mov	edx, 2
	imul	edx, 3
	or	eax, -1
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [ecx+edx+64], ax

; 4274 : 		else										// if on altitude, don't say altitude

	jmp	SHORT $LN31@MakeVector
$LN32@MakeVector:

; 4275 :             radioMessage->dataBlock.edata[3] = (short)(-1*FloatToInt32(desAlt)); //altitude in feet

	push	ecx
	movss	xmm0, DWORD PTR _desAlt$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	imul	eax, -1
	mov	edx, 2
	imul	edx, 3
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [ecx+edx+64], ax
$LN31@MakeVector:

; 4276 : 
; 4277 : 		if(fabs(aircraft->af->vcas - speed) > 10.0F)

	mov	edx, DWORD PTR _aircraft$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [eax+1124]
	subss	xmm0, DWORD PTR _speed$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv884[ebp]
	movss	xmm0, DWORD PTR tv884[ebp]
	comiss	xmm0, DWORD PTR __real@41200000
	jbe	SHORT $LN30@MakeVector

; 4278 : 			radioMessage->dataBlock.edata[4] =  (short)FloatToInt32(speed); //speed

	push	ecx
	movss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	ecx, 2
	shl	ecx, 2
	mov	edx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [edx+ecx+64], ax

; 4279 : 		else

	jmp	SHORT $LN29@MakeVector
$LN30@MakeVector:

; 4280 : 			radioMessage->dataBlock.edata[4] = -1; //speed

	mov	eax, 2
	shl	eax, 2
	or	ecx, -1
	mov	edx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [edx+eax+64], cx
$LN29@MakeVector:

; 4281 : 		radioMessage->dataBlock.edata[5] = (short)CalculateStandRateTurnToPt(aircraft, x, y, &finalHdg); //turn direction	

	lea	eax, DWORD PTR _finalHdg$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _aircraft$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateStandRateTurnToPt@ATCBrain@@QAEHPAVAircraftClass@@MMPAM@Z ; ATCBrain::CalculateStandRateTurnToPt
	mov	edx, 2
	imul	edx, 5
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [ecx+edx+64], ax

; 4282 : 		if(radioMessage->dataBlock.edata[5] >= 0)

	mov	edx, 2
	imul	edx, 5
	mov	eax, DWORD PTR _radioMessage$[ebp]
	movsx	ecx, WORD PTR [eax+edx+64]
	test	ecx, ecx
	jl	SHORT $LN28@MakeVector

; 4283 : 			radioMessage->dataBlock.edata[6] = (short)FloatToInt32(finalHdg);

	push	ecx
	movss	xmm0, DWORD PTR _finalHdg$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	edx, 2
	imul	edx, 6
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [ecx+edx+64], ax

; 4284 : 		else

	jmp	SHORT $LN27@MakeVector
$LN28@MakeVector:

; 4285 : 			radioMessage->dataBlock.edata[6] = -1;

	mov	edx, 2
	imul	edx, 6
	or	eax, -1
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [ecx+edx+64], ax
$LN27@MakeVector:

; 4286 : 
; 4287 : 
; 4288 : 			
; 4289 : 		//RAS-3Oct04- updated vector type code to be sent every two min
; 4290 : 		if(aircraft->DBrain()->lastVectorTypeCall < SimLibElapsedTime)

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	edx, DWORD PTR [eax+280]
	cmp	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	$LN26@MakeVector

; 4291 : 		{
; 4292 : 			aircraft->DBrain()->lastVectorTypeCall = SimLibElapsedTime + 2 * CampaignMinutes;

	mov	esi, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	esi, 120000				; 0001d4c0H
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	DWORD PTR [eax+280], esi

; 4293 :             if(radioMessage->dataBlock.edata[3] == -1 && radioMessage->dataBlock.edata[4] == -1)

	mov	eax, 2
	imul	eax, 3
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	movsx	edx, WORD PTR [ecx+eax+64]
	cmp	edx, -1
	jne	SHORT $LN25@MakeVector
	mov	eax, 2
	shl	eax, 2
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	movsx	edx, WORD PTR [ecx+eax+64]
	cmp	edx, -1
	jne	SHORT $LN25@MakeVector

; 4294 : 				radioMessage->dataBlock.edata[7] = -1;	//RAS-3Oct04-no vector type if no alt and airspeed call

	mov	eax, 2
	imul	eax, 7
	or	ecx, -1
	mov	edx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [edx+eax+64], cx

; 4295 : 			else 

	jmp	$LN20@MakeVector
$LN25@MakeVector:

; 4296 : 			{
; 4297 : 				if(PtHeaderDataTable[rwindex].ltrt > 0)

	mov	eax, DWORD PTR _rwindex$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	edx, BYTE PTR [ecx+eax+25]
	test	edx, edx
	jle	SHORT $LN23@MakeVector

; 4298 : 				{
; 4299 : 					radioMessage->dataBlock.edata[7] = 1; //vector type

	mov	eax, 2
	imul	eax, 7
	mov	ecx, 1
	mov	edx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [edx+eax+64], cx

; 4300 : 					//RAS-3Oct04-Say rwy name when telling what vectors are for
; 4301 : 					radioMessage->dataBlock.edata[8] = (short)GetRunwayName(GetOppositeRunway(rwindex));

	mov	eax, DWORD PTR _rwindex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOppositeRunway@ATCBrain@@QAEHH@Z	; ATCBrain::GetOppositeRunway
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRunwayName@ATCBrain@@QAEHH@Z	; ATCBrain::GetRunwayName
	mov	ecx, 2
	shl	ecx, 3
	mov	edx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [edx+ecx+64], ax

; 4302 : 				}
; 4303 : 				else

	jmp	SHORT $LN20@MakeVector
$LN23@MakeVector:

; 4304 : 					if(PtHeaderDataTable[rwindex].ltrt < 0)

	mov	eax, DWORD PTR _rwindex$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	edx, BYTE PTR [ecx+eax+25]
	test	edx, edx
	jge	SHORT $LN21@MakeVector

; 4305 : 					{
; 4306 : 						radioMessage->dataBlock.edata[7] = 2; //vector type

	mov	eax, 2
	imul	eax, 7
	mov	ecx, 2
	mov	edx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [edx+eax+64], cx

; 4307 : 						//RAS-3Oct04-Say rwy name when telling what vectors are for
; 4308 : 						radioMessage->dataBlock.edata[8] = (short)GetRunwayName(GetOppositeRunway(rwindex));

	mov	eax, DWORD PTR _rwindex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOppositeRunway@ATCBrain@@QAEHH@Z	; ATCBrain::GetOppositeRunway
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRunwayName@ATCBrain@@QAEHH@Z	; ATCBrain::GetRunwayName
	mov	ecx, 2
	shl	ecx, 3
	mov	edx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [edx+ecx+64], ax

; 4309 : 					}
; 4310 : 					else

	jmp	SHORT $LN20@MakeVector
$LN21@MakeVector:

; 4311 : 						radioMessage->dataBlock.edata[7] = -1;

	mov	eax, 2
	imul	eax, 7
	or	ecx, -1
	mov	edx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [edx+eax+64], cx
$LN20@MakeVector:

; 4312 : 			}
; 4313 : 		}
; 4314 : 		else

	jmp	SHORT $LN19@MakeVector
$LN26@MakeVector:

; 4315 : 		{
; 4316 :             radioMessage->dataBlock.edata[7] = -1;

	mov	eax, 2
	imul	eax, 7
	or	ecx, -1
	mov	edx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [edx+eax+64], cx

; 4317 : 			radioMessage->dataBlock.edata[8] = -1;

	mov	eax, 2
	shl	eax, 3
	or	ecx, -1
	mov	edx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [edx+eax+64], cx
$LN19@MakeVector:

; 4318 : 		}
; 4319 : 		//End vector type code
; 4320 : 
; 4321 : 		FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	eax, DWORD PTR _radioMessage$[ebp]
	push	eax
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8

; 4322 : 		return;

	jmp	$LN50@MakeVector

; 4323 : 		break;

	jmp	$LN44@MakeVector
$LN18@MakeVector:

; 4324 : 
; 4325 : 	case lEmergencyToFinal:
; 4326 : 	case lToFinal:
; 4327 : 		if(rwtime > SimLibElapsedTime + 2 * CampaignMinutes)

	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	ecx, 120000				; 0001d4c0H
	cmp	DWORD PTR _rwtime$[ebp], ecx
	jbe	$LN17@MakeVector

; 4328 : 		{
; 4329 : 			deltaTime = (rwtime - SimLibElapsedTime - 2 * CampaignMinutes)/(float)CampaignSeconds;

	mov	edx, DWORD PTR _rwtime$[ebp]
	sub	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	sub	edx, 120000				; 0001d4c0H
	mov	DWORD PTR tv969[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv969[ebp]
	mov	eax, DWORD PTR tv969[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movsd	QWORD PTR tv972[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv972[ebp]
	divss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR _deltaTime$[ebp], xmm0

; 4330 : 			dx = aircraft->XPos() - x;

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv979[ebp]
	movss	xmm0, DWORD PTR tv979[ebp]
	subss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 4331 : 			dy = aircraft->YPos() - y;

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv983[ebp]
	movss	xmm0, DWORD PTR tv983[ebp]
	subss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 4332 : 			speed = (float)sqrt(dx*dx + dy*dy)/deltaTime * FTPSEC_TO_KNOTS;

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv990[ebp]
	movss	xmm0, DWORD PTR tv990[ebp]
	divss	xmm0, DWORD PTR _deltaTime$[ebp]
	mulss	xmm0, DWORD PTR __real@3f17ac60
	movss	DWORD PTR _speed$[ebp], xmm0

; 4333 : 			speed = get_air_speed( speed, -1*FloatToInt32(aircraft->af->z));

	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	push	ecx
	movss	xmm0, DWORD PTR [edx+1116]
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	imul	eax, -1
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?get_air_speed@@YAMMH@Z			; get_air_speed
	add	esp, 8
	fstp	DWORD PTR _speed$[ebp]

; 4334 : 			speed = max(aircraft->af->MinVcas() * 0.8F, speed);

	mov	eax, DWORD PTR _aircraft$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv1003[ebp]
	movss	xmm0, DWORD PTR tv1003[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	comiss	xmm0, DWORD PTR _speed$[ebp]
	jbe	SHORT $LN56@MakeVector
	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv1008[ebp]
	movss	xmm0, DWORD PTR tv1008[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR tv492[ebp], xmm0
	jmp	SHORT $LN57@MakeVector
$LN56@MakeVector:
	movss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR tv492[ebp], xmm0
$LN57@MakeVector:
	movss	xmm0, DWORD PTR tv492[ebp]
	movss	DWORD PTR _speed$[ebp], xmm0

; 4335 : 			speed = min(aircraft->af->MaxVcas() * 0.8F, speed);

	mov	edx, DWORD PTR _aircraft$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	call	?MaxVcas@AirframeClass@@QAEMXZ		; AirframeClass::MaxVcas
	fstp	DWORD PTR tv1015[ebp]
	movss	xmm0, DWORD PTR tv1015[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	movss	xmm1, DWORD PTR _speed$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN58@MakeVector
	mov	eax, DWORD PTR _aircraft$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?MaxVcas@AirframeClass@@QAEMXZ		; AirframeClass::MaxVcas
	fstp	DWORD PTR tv1021[ebp]
	movss	xmm0, DWORD PTR tv1021[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR tv504[ebp], xmm0
	jmp	SHORT $LN59@MakeVector
$LN58@MakeVector:
	movss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR tv504[ebp], xmm0
$LN59@MakeVector:
	movss	xmm0, DWORD PTR tv504[ebp]
	movss	DWORD PTR _speed$[ebp], xmm0
$LN17@MakeVector:

; 4336 : 		}
; 4337 : 
; 4338 : 		desAlt = GetAltitude(aircraft, lToFinal);

	push	10					; 0000000aH
	mov	ecx, DWORD PTR _aircraft$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAltitude@ATCBrain@@QAEMPAVAircraftClass@@W4AtcStatusEnum@@@Z ; ATCBrain::GetAltitude
	fstp	DWORD PTR _desAlt$[ebp]

; 4339 : 		
; 4340 : 		if(fabs(aircraft->ZPos() - desAlt) < 500.0F)	//RAS-23Jan04- changed from 100 to 500

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv1030[ebp]
	movss	xmm0, DWORD PTR tv1030[ebp]
	subss	xmm0, DWORD PTR _desAlt$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv1035[ebp]
	movss	xmm0, DWORD PTR __real@43fa0000
	comiss	xmm0, DWORD PTR tv1035[ebp]
	jbe	SHORT $LN16@MakeVector

; 4341 : 			index = -1;									//RAS-3Oct04-Maintain Altitude-changed from 2 to -1

	mov	DWORD PTR _index$[ebp], -1
	jmp	SHORT $LN13@MakeVector
$LN16@MakeVector:

; 4342 : 														//no climb/descend/maintain call if within 500
; 4343 : 														//feet of alt
; 4344 : 		else if(aircraft->ZPos() < desAlt)

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?ZPos@VuEntity@@QBEMXZ			; VuEntity::ZPos
	fstp	DWORD PTR tv1040[ebp]
	movss	xmm0, DWORD PTR _desAlt$[ebp]
	comiss	xmm0, DWORD PTR tv1040[ebp]
	jbe	SHORT $LN14@MakeVector

; 4345 : 			index = 1;									//Descend

	mov	DWORD PTR _index$[ebp], 1

; 4346 : 		else

	jmp	SHORT $LN13@MakeVector
$LN14@MakeVector:

; 4347 : 			index = 0;									//Climb

	mov	DWORD PTR _index$[ebp], 0
$LN13@MakeVector:

; 4348 : 		
; 4349 : 		//RAS-3Oct04- Set index to -1 if don't need to make altitude call
; 4350 : 		radioMessage->dataBlock.edata[2] = (short)index;

	mov	edx, 2
	shl	edx, 1
	mov	eax, DWORD PTR _radioMessage$[ebp]
	mov	cx, WORD PTR _index$[ebp]
	mov	WORD PTR [eax+edx+64], cx

; 4351 : 		if(index == -1)								//if on altitude, don't say climb,descend or maintain

	cmp	DWORD PTR _index$[ebp], -1
	jne	SHORT $LN12@MakeVector

; 4352 : 			radioMessage->dataBlock.edata[3] = -1;

	mov	edx, 2
	imul	edx, 3
	or	eax, -1
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [ecx+edx+64], ax

; 4353 : 		else											// if on altitude, don't say altitude

	jmp	SHORT $LN11@MakeVector
$LN12@MakeVector:

; 4354 :             radioMessage->dataBlock.edata[3] = (short)(-1*FloatToInt32(desAlt)); //altitude in feet

	push	ecx
	movss	xmm0, DWORD PTR _desAlt$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	imul	eax, -1
	mov	edx, 2
	imul	edx, 3
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [ecx+edx+64], ax
$LN11@MakeVector:

; 4355 : 		
; 4356 : 		if(fabs(aircraft->af->vcas - speed) > 10.0F)

	mov	edx, DWORD PTR _aircraft$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [eax+1124]
	subss	xmm0, DWORD PTR _speed$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv1060[ebp]
	movss	xmm0, DWORD PTR tv1060[ebp]
	comiss	xmm0, DWORD PTR __real@41200000
	jbe	SHORT $LN10@MakeVector

; 4357 : 			radioMessage->dataBlock.edata[4] = (short)FloatToInt32(speed); //speed

	push	ecx
	movss	xmm0, DWORD PTR _speed$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	ecx, 2
	shl	ecx, 2
	mov	edx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [edx+ecx+64], ax

; 4358 : 		else

	jmp	SHORT $LN9@MakeVector
$LN10@MakeVector:

; 4359 : 			radioMessage->dataBlock.edata[4] = -1; //speed

	mov	eax, 2
	shl	eax, 2
	or	ecx, -1
	mov	edx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [edx+eax+64], cx
$LN9@MakeVector:

; 4360 : 		radioMessage->dataBlock.edata[5] = (short)CalculateStandRateTurnToPt(aircraft, x, y, &finalHdg); //turn direction	

	lea	eax, DWORD PTR _finalHdg$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _aircraft$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateStandRateTurnToPt@ATCBrain@@QAEHPAVAircraftClass@@MMPAM@Z ; ATCBrain::CalculateStandRateTurnToPt
	mov	edx, 2
	imul	edx, 5
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [ecx+edx+64], ax

; 4361 : 		if(radioMessage->dataBlock.edata[5] >= 0)

	mov	edx, 2
	imul	edx, 5
	mov	eax, DWORD PTR _radioMessage$[ebp]
	movsx	ecx, WORD PTR [eax+edx+64]
	test	ecx, ecx
	jl	SHORT $LN8@MakeVector

; 4362 : 			radioMessage->dataBlock.edata[6] = (short)FloatToInt32(finalHdg);	//heading

	push	ecx
	movss	xmm0, DWORD PTR _finalHdg$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	edx, 2
	imul	edx, 6
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [ecx+edx+64], ax

; 4363 : 		else

	jmp	SHORT $LN7@MakeVector
$LN8@MakeVector:

; 4364 : 			radioMessage->dataBlock.edata[6] = -1;

	mov	edx, 2
	imul	edx, 6
	or	eax, -1
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [ecx+edx+64], ax
$LN7@MakeVector:

; 4365 : 		radioMessage->dataBlock.edata[7] = 0; //vector type

	mov	edx, 2
	imul	edx, 7
	xor	eax, eax
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [ecx+edx+64], ax

; 4366 : 
; 4367 : 		//RAS-3Oct04- updated vector type code to be sent every 30 Sec if getting vectors to final
; 4368 : 		if(aircraft->DBrain()->lastVectorTypeCall < SimLibElapsedTime)

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	edx, DWORD PTR [eax+280]
	cmp	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	$LN6@MakeVector

; 4369 : 		{
; 4370 : 			aircraft->DBrain()->lastVectorTypeCall = SimLibElapsedTime + 60 * CampaignSeconds;

	mov	esi, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	esi, 60000				; 0000ea60H
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	DWORD PTR [eax+280], esi

; 4371 :             if(radioMessage->dataBlock.edata[3] == -1 && radioMessage->dataBlock.edata[4] == -1)

	mov	eax, 2
	imul	eax, 3
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	movsx	edx, WORD PTR [ecx+eax+64]
	cmp	edx, -1
	jne	SHORT $LN5@MakeVector
	mov	eax, 2
	shl	eax, 2
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	movsx	edx, WORD PTR [ecx+eax+64]
	cmp	edx, -1
	jne	SHORT $LN5@MakeVector

; 4372 : 			{
; 4373 : 				radioMessage->dataBlock.edata[7] = -1;	//RAS-3Oct04-no vector type if no alt and airspeed call

	mov	eax, 2
	imul	eax, 7
	or	ecx, -1
	mov	edx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [edx+eax+64], cx

; 4374 : 				radioMessage->dataBlock.edata[8] = -1;

	mov	eax, 2
	shl	eax, 3
	or	ecx, -1
	mov	edx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [edx+eax+64], cx

; 4375 : 			}
; 4376 : 			else 

	jmp	SHORT $LN4@MakeVector
$LN5@MakeVector:

; 4377 : 			{
; 4378 : 				radioMessage->dataBlock.edata[7] = 0; //vector type

	mov	eax, 2
	imul	eax, 7
	xor	ecx, ecx
	mov	edx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [edx+eax+64], cx

; 4379 : 				//RAS-3Oct04-Say rwy name when telling what vectors are for
; 4380 : 				radioMessage->dataBlock.edata[8] = (short)GetRunwayName(GetOppositeRunway(rwindex)); // JB 010527 (from MN)

	mov	eax, DWORD PTR _rwindex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOppositeRunway@ATCBrain@@QAEHH@Z	; ATCBrain::GetOppositeRunway
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRunwayName@ATCBrain@@QAEHH@Z	; ATCBrain::GetRunwayName
	mov	ecx, 2
	shl	ecx, 3
	mov	edx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [edx+ecx+64], ax
$LN4@MakeVector:

; 4381 : 			}
; 4382 : 		}
; 4383 : 		else

	jmp	SHORT $LN3@MakeVector
$LN6@MakeVector:

; 4384 : 		{
; 4385 :             radioMessage->dataBlock.edata[7] = -1;	//vector type

	mov	eax, 2
	imul	eax, 7
	or	ecx, -1
	mov	edx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [edx+eax+64], cx

; 4386 : 			radioMessage->dataBlock.edata[8] = -1;	//active rwy

	mov	eax, 2
	shl	eax, 3
	or	ecx, -1
	mov	edx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [edx+eax+64], cx
$LN3@MakeVector:

; 4387 : 		}
; 4388 : 		//End vector type code
; 4389 : 
; 4390 : 		FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	eax, DWORD PTR _radioMessage$[ebp]
	push	eax
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8

; 4391 : 		return;

	jmp	SHORT $LN50@MakeVector
$LN1@MakeVector:
$LN44@MakeVector:

; 4392 : 		break;
; 4393 : 
; 4394 : 	case lEmergencyOnFinal:
; 4395 : 	case lOnFinal:
; 4396 : 	case lReqClearance:
; 4397 : 	case lReqEmerClearance:
; 4398 : 	case lIngressing:
; 4399 : 	case lTakingPosition:
; 4400 : 	case lEmerHold:
; 4401 : 	case lHolding:
; 4402 : 		
; 4403 : 		break;	
; 4404 : 
; 4405 : 	default:
; 4406 : 		//we should never get here
; 4407 : 		break;
; 4408 : 		//ShiAssert(!"We are in an undefined state, we shouldn't be here");
; 4409 : 	}
; 4410 : 	delete radioMessage;

	mov	ecx, DWORD PTR _radioMessage$[ebp]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T2[ebp], edx
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN60@MakeVector
	push	1
	mov	eax, DWORD PTR $T2[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T2[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv661[ebp], eax
	jmp	SHORT $LN61@MakeVector
$LN60@MakeVector:
	mov	DWORD PTR tv661[ebp], 0
$LN61@MakeVector:
$LN50@MakeVector:

; 4411 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN63@MakeVector:
	DD	$LN43@MakeVector
	DD	$LN38@MakeVector
	DD	$LN18@MakeVector
	DD	$LN1@MakeVector
$LN62@MakeVector:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	3
	DB	3
	DB	3
	DB	1
	DB	2
?MakeVectorCall@ATCBrain@@QAEXPAVAircraftClass@@PAVVuTargetEntity@@@Z ENDP ; ATCBrain::MakeVectorCall
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flight$ = 8						; size = 4
_rwindex$ = 12						; size = 4
?UseSectionTakeoff@ATCBrain@@QAEHPAVFlightClass@@H@Z PROC ; ATCBrain::UseSectionTakeoff
; _this$ = ecx

; 5012 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5013 : 	//TJL 10/31/03 Changing to 40 from 80
; 5014 : 	if (runwayStats[PtHeaderDataTable[rwindex].runwayNum].halfwidth > 40.0F &&
; 5015 : 		(flight->GetSType() == STYPE_UNIT_ATTACK		||
; 5016 : 		 flight->GetSType() == STYPE_UNIT_FIGHTER		||
; 5017 : 		 flight->GetSType() == STYPE_UNIT_FIGHTER_BOMBER)&&
; 5018 : 		flight->GetTotalVehicles() > 1)		

	mov	eax, DWORD PTR _rwindex$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	edx, BYTE PTR [ecx+eax+24]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	movss	xmm0, DWORD PTR [ecx+edx+8]
	comiss	xmm0, DWORD PTR __real@42200000
	jbe	SHORT $LN2@UseSection
	mov	ecx, DWORD PTR _flight$[ebp]
	call	?GetSType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetSType
	movzx	edx, al
	cmp	edx, 3
	je	SHORT $LN1@UseSection
	mov	ecx, DWORD PTR _flight$[ebp]
	call	?GetSType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetSType
	movzx	eax, al
	cmp	eax, 8
	je	SHORT $LN1@UseSection
	mov	ecx, DWORD PTR _flight$[ebp]
	call	?GetSType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetSType
	movzx	ecx, al
	cmp	ecx, 9
	jne	SHORT $LN2@UseSection
$LN1@UseSection:
	mov	ecx, DWORD PTR _flight$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	cmp	eax, 1
	jle	SHORT $LN2@UseSection

; 5019 : 			return TRUE;

	mov	eax, 1
	jmp	SHORT $LN3@UseSection
$LN2@UseSection:

; 5020 : 	return FALSE;

	xor	eax, eax
$LN3@UseSection:

; 5021 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?UseSectionTakeoff@ATCBrain@@QAEHPAVFlightClass@@H@Z ENDP ; ATCBrain::UseSectionTakeoff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_aircraft$ = 8						; size = 4
?IsOverRunway@ATCBrain@@QAEHPAVAircraftClass@@@Z PROC	; ATCBrain::IsOverRunway
; _this$ = ecx

; 2469 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2470 : 	return IsOnRunway(aircraft->XPos(), aircraft->YPos());;

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsOnRunway@ATCBrain@@QAEHMM@Z		; ATCBrain::IsOnRunway

; 2471 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsOverRunway@ATCBrain@@QAEHPAVAircraftClass@@@Z ENDP	; ATCBrain::IsOverRunway
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_tempX$ = -12						; size = 4
_tempY$ = -8						; size = 4
_this$ = -4						; size = 4
_taxipoint$ = 8						; size = 4
?IsOnRunway@ATCBrain@@QAEHH@Z PROC			; ATCBrain::IsOnRunway
; _this$ = ecx

; 2461 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2462 : 	float tempX,tempY;
; 2463 : 	TranslatePointData(self, taxipoint, &tempX, &tempY);

	lea	eax, DWORD PTR _tempY$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tempX$[ebp]
	push	ecx
	mov	edx, DWORD PTR _taxipoint$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData

; 2464 : 	return IsOnRunway(tempX,tempY);

	add	esp, 12					; 0000000cH
	movss	xmm0, DWORD PTR _tempY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _tempX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsOnRunway@ATCBrain@@QAEHMM@Z		; ATCBrain::IsOnRunway

; 2465 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsOnRunway@ATCBrain@@QAEHH@Z ENDP			; ATCBrain::IsOnRunway
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_aircraft$ = 8						; size = 4
?IsOnRunway@ATCBrain@@QAEHPAVAircraftClass@@@Z PROC	; ATCBrain::IsOnRunway
; _this$ = ecx

; 2452 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2453 : 	if(!aircraft->OnGround())

	mov	eax, DWORD PTR _aircraft$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	jne	SHORT $LN1@IsOnRunway

; 2454 : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $LN2@IsOnRunway
$LN1@IsOnRunway:

; 2455 : 
; 2456 : 	return IsOverRunway(aircraft);

	mov	ecx, DWORD PTR _aircraft$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsOverRunway@ATCBrain@@QAEHPAVAircraftClass@@@Z ; ATCBrain::IsOverRunway
$LN2@IsOnRunway:

; 2457 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsOnRunway@ATCBrain@@QAEHPAVAircraftClass@@@Z ENDP	; ATCBrain::IsOnRunway
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
tv235 = -36						; size = 4
_rely$ = -32						; size = 4
tv226 = -28						; size = 4
_relx$ = -24						; size = 4
_retval$ = -20						; size = 4
_dy$ = -16						; size = 4
_dx$ = -12						; size = 4
_this$ = -8						; size = 4
_i$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?IsOnRunway@ATCBrain@@QAEHMM@Z PROC			; ATCBrain::IsOnRunway
; _this$ = ecx

; 2429 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 2430 : 	float	dx, dy, relx, rely;
; 2431 : 	int		i;
; 2432 : 
; 2433 : 	int retval = 0;

	mov	DWORD PTR _retval$[ebp], 0

; 2434 : 
; 2435 : 	for( i = 0; i < numRwys; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@IsOnRunway
$LN3@IsOnRunway:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@IsOnRunway:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jge	$LN2@IsOnRunway

; 2436 : 	{
; 2437 : 		dx = runwayStats[i].centerX - x;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	movss	xmm0, DWORD PTR [edx+eax+16]
	subss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 2438 : 		dy = runwayStats[i].centerY - y;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	movss	xmm0, DWORD PTR [edx+eax+20]
	subss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 2439 : 		
; 2440 : 		relx = (  PtHeaderDataTable[runwayStats[i].rwIndexes[0]].cosHeading*dx + PtHeaderDataTable[runwayStats[i].rwIndexes[0]].sinHeading*dy);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, eax
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR [edx+eax]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm0, DWORD PTR [edx+ecx+16]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, eax
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR [edx+eax]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm1, DWORD PTR [edx+ecx+12]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _relx$[ebp], xmm0

; 2441 : 		rely = ( -PtHeaderDataTable[runwayStats[i].rwIndexes[0]].sinHeading*dx + PtHeaderDataTable[runwayStats[i].rwIndexes[0]].cosHeading*dy);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, eax
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR [edx+eax]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm0, DWORD PTR [edx+ecx+12]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR _dx$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, eax
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR [edx+eax]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm1, DWORD PTR [edx+ecx+16]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _rely$[ebp], xmm0

; 2442 : 
; 2443 : 		if(fabs(relx) < runwayStats[i].halfheight && fabs(rely) < runwayStats[i].halfwidth)

	push	ecx
	movss	xmm0, DWORD PTR _relx$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv226[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	movss	xmm0, DWORD PTR [edx+eax+12]
	comiss	xmm0, DWORD PTR tv226[ebp]
	jbe	SHORT $LN1@IsOnRunway
	push	ecx
	movss	xmm0, DWORD PTR _rely$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv235[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	movss	xmm0, DWORD PTR [edx+eax+8]
	comiss	xmm0, DWORD PTR tv235[ebp]
	jbe	SHORT $LN1@IsOnRunway

; 2444 : 			retval = runwayStats[i].rwIndexes[0];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR [eax+edx]
	mov	DWORD PTR _retval$[ebp], eax
$LN1@IsOnRunway:

; 2445 : 
; 2446 : 	}

	jmp	$LN3@IsOnRunway
$LN2@IsOnRunway:

; 2447 : 	return retval;

	mov	eax, DWORD PTR _retval$[ebp]

; 2448 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?IsOnRunway@ATCBrain@@QAEHMM@Z ENDP			; ATCBrain::IsOnRunway
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
tv345 = -116						; size = 8
_Trig$ = -108						; size = 8
_this$ = -100						; size = 4
_ty$ = -96						; size = 4
_tx$ = -92						; size = 4
tv336 = -88						; size = 4
tv331 = -84						; size = 4
_vt$ = -80						; size = 4
tv322 = -76						; size = 4
tv312 = -72						; size = 4
tv302 = -68						; size = 4
tv357 = -64						; size = 4
tv277 = -60						; size = 4
tv359 = -56						; size = 4
tv273 = -52						; size = 4
tv269 = -48						; size = 4
tv355 = -44						; size = 4
tv265 = -40						; size = 4
tv260 = -36						; size = 4
tv223 = -32						; size = 4
_dist$ = -28						; size = 4
_dy$ = -24						; size = 4
_dx$ = -20						; size = 4
_heading$ = -16						; size = 4
_hdgToPt$ = -12						; size = 4
_dir$ = -8						; size = 4
_deltaHdg$ = -4						; size = 4
_aircraft$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_finalHdg$ = 20						; size = 4
?CalculateStandRateTurnToPt@ATCBrain@@QAEHPAVAircraftClass@@MMPAM@Z PROC ; ATCBrain::CalculateStandRateTurnToPt
; _this$ = ecx

; 3525 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	DWORD PTR _this$[ebp], ecx

; 3526 : 	float dx, dy, tx, ty, hdgToPt, deltaHdg, dist, vt, heading;
; 3527 : 	int dir;
; 3528 : 	mlTrig Trig;
; 3529 : 
; 3530 : 	dx = x - aircraft->XPos();

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv223[ebp]
	movss	xmm0, DWORD PTR _x$[ebp]
	subss	xmm0, DWORD PTR tv223[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 3531 : 	dy = y - aircraft->YPos();

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv260[ebp]
	movss	xmm0, DWORD PTR _y$[ebp]
	subss	xmm0, DWORD PTR tv260[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 3532 : 
; 3533 : 	vt = (float)sqrt(aircraft->XDelta() * aircraft->XDelta() + aircraft->YDelta() * aircraft->YDelta());

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?XDelta@VuEntity@@QBEMXZ		; VuEntity::XDelta
	fstp	DWORD PTR tv265[ebp]
	movss	xmm0, DWORD PTR tv265[ebp]
	mov	ecx, DWORD PTR _aircraft$[ebp]
	movss	DWORD PTR tv355[ebp], xmm0
	call	?XDelta@VuEntity@@QBEMXZ		; VuEntity::XDelta
	fstp	DWORD PTR tv269[ebp]
	movss	xmm0, DWORD PTR tv355[ebp]
	mulss	xmm0, DWORD PTR tv269[ebp]
	mov	ecx, DWORD PTR _aircraft$[ebp]
	movss	DWORD PTR tv357[ebp], xmm0
	call	?YDelta@VuEntity@@QBEMXZ		; VuEntity::YDelta
	fstp	DWORD PTR tv273[ebp]
	movss	xmm0, DWORD PTR tv273[ebp]
	mov	ecx, DWORD PTR _aircraft$[ebp]
	movss	DWORD PTR tv359[ebp], xmm0
	call	?YDelta@VuEntity@@QBEMXZ		; VuEntity::YDelta
	fstp	DWORD PTR tv277[ebp]
	movss	xmm0, DWORD PTR tv359[ebp]
	mulss	xmm0, DWORD PTR tv277[ebp]
	movss	xmm1, DWORD PTR tv357[ebp]
	addss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _vt$[ebp]

; 3534 : 	
; 3535 : 	hdgToPt = (float)atan2(dy, dx);

	cvtss2sd xmm0, DWORD PTR _dx$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _dy$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _hdgToPt$[ebp]

; 3536 : 	if(hdgToPt < 0.0F)

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _hdgToPt$[ebp]
	jbe	SHORT $LN15@CalculateS

; 3537 : 		hdgToPt += PI * 2.0F;

	movss	xmm0, DWORD PTR _hdgToPt$[ebp]
	addss	xmm0, DWORD PTR __real@40c90fdb
	movss	DWORD PTR _hdgToPt$[ebp], xmm0
$LN15@CalculateS:

; 3538 : 
; 3539 : 	heading = aircraft->Yaw();

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR _heading$[ebp]

; 3540 : 	if(heading < 0.0F)

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _heading$[ebp]
	jbe	SHORT $LN14@CalculateS

; 3541 : 		heading += PI * 2.0F;

	movss	xmm0, DWORD PTR _heading$[ebp]
	addss	xmm0, DWORD PTR __real@40c90fdb
	movss	DWORD PTR _heading$[ebp], xmm0
$LN14@CalculateS:

; 3542 : 
; 3543 : 	deltaHdg = hdgToPt - heading;

	movss	xmm0, DWORD PTR _hdgToPt$[ebp]
	subss	xmm0, DWORD PTR _heading$[ebp]
	movss	DWORD PTR _deltaHdg$[ebp], xmm0

; 3544 : 	if(deltaHdg > PI)

	movss	xmm0, DWORD PTR _deltaHdg$[ebp]
	comiss	xmm0, DWORD PTR __real@40490fdb
	jbe	SHORT $LN13@CalculateS

; 3545 : 		deltaHdg -= (2.0F*PI);

	movss	xmm0, DWORD PTR _deltaHdg$[ebp]
	subss	xmm0, DWORD PTR __real@40c90fdb
	movss	DWORD PTR _deltaHdg$[ebp], xmm0
	jmp	SHORT $LN11@CalculateS
$LN13@CalculateS:

; 3546 : 	else if(deltaHdg < -PI)

	movss	xmm0, DWORD PTR __real@c0490fdb
	comiss	xmm0, DWORD PTR _deltaHdg$[ebp]
	jbe	SHORT $LN11@CalculateS

; 3547 : 		deltaHdg += (2.0F*PI);

	movss	xmm0, DWORD PTR _deltaHdg$[ebp]
	addss	xmm0, DWORD PTR __real@40c90fdb
	movss	DWORD PTR _deltaHdg$[ebp], xmm0
$LN11@CalculateS:

; 3548 : 
; 3549 : 	if(fabs(deltaHdg) < 5.0F*DTR)

	push	ecx
	movss	xmm0, DWORD PTR _deltaHdg$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv302[ebp]
	movss	xmm0, DWORD PTR __real@3db2b8c1
	comiss	xmm0, DWORD PTR tv302[ebp]
	jbe	SHORT $LN10@CalculateS

; 3550 : 		dir = -1; //no turn

	mov	DWORD PTR _dir$[ebp], -1
	jmp	SHORT $LN3@CalculateS
$LN10@CalculateS:

; 3551 : 	else if(deltaHdg < -PI)

	movss	xmm0, DWORD PTR __real@c0490fdb
	comiss	xmm0, DWORD PTR _deltaHdg$[ebp]
	jbe	SHORT $LN8@CalculateS

; 3552 : 		dir = 1;

	mov	DWORD PTR _dir$[ebp], 1
	jmp	SHORT $LN3@CalculateS
$LN8@CalculateS:

; 3553 : 	else if(deltaHdg > PI)

	movss	xmm0, DWORD PTR _deltaHdg$[ebp]
	comiss	xmm0, DWORD PTR __real@40490fdb
	jbe	SHORT $LN6@CalculateS

; 3554 : 		dir = 0;

	mov	DWORD PTR _dir$[ebp], 0
	jmp	SHORT $LN3@CalculateS
$LN6@CalculateS:

; 3555 : 	else if(deltaHdg < 0.0F)

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _deltaHdg$[ebp]
	jbe	SHORT $LN4@CalculateS

; 3556 : 		dir = 0;//left

	mov	DWORD PTR _dir$[ebp], 0

; 3557 : 	else

	jmp	SHORT $LN3@CalculateS
$LN4@CalculateS:

; 3558 : 		dir = 1;//right

	mov	DWORD PTR _dir$[ebp], 1
$LN3@CalculateS:

; 3559 : 
; 3560 : 	if(fabs(deltaHdg) <  0.3490658503989F) //20degrees

	push	ecx
	movss	xmm0, DWORD PTR _deltaHdg$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv312[ebp]
	movss	xmm0, DWORD PTR __real@3eb2b8c2
	comiss	xmm0, DWORD PTR tv312[ebp]
	jbe	SHORT $LN2@CalculateS

; 3561 : 	{
; 3562 : 		*finalHdg = hdgToPt*RTD;

	movss	xmm0, DWORD PTR _hdgToPt$[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	mov	eax, DWORD PTR _finalHdg$[ebp]
	movss	DWORD PTR [eax], xmm0

; 3563 : 		return dir;

	mov	eax, DWORD PTR _dir$[ebp]
	jmp	$LN16@CalculateS
$LN2@CalculateS:

; 3564 : 	}
; 3565 : 
; 3566 : 	dist = (float)fabs(deltaHdg) * 12.15854203708F * vt ;

	push	ecx
	movss	xmm0, DWORD PTR _deltaHdg$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv322[ebp]
	movss	xmm0, DWORD PTR tv322[ebp]
	mulss	xmm0, DWORD PTR __real@41428963
	mulss	xmm0, DWORD PTR _vt$[ebp]
	movss	DWORD PTR _dist$[ebp], xmm0

; 3567 : 
; 3568 : 	//mlSinCos(&Trig,hdgToPt + dir * PI * 0.5F);
; 3569 : 	mlSinCos(&Trig,aircraft->Yaw());

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _Trig$[ebp]
	push	ecx
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 3570 : 
; 3571 : 	tx = aircraft->XPos() + Trig.cos * dist;

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv331[ebp]
	movss	xmm0, DWORD PTR tv331[ebp]
	movss	xmm1, DWORD PTR _Trig$[ebp+4]
	mulss	xmm1, DWORD PTR _dist$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _tx$[ebp], xmm0

; 3572 : 	ty = aircraft->YPos() + Trig.sin * dist;

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv336[ebp]
	movss	xmm0, DWORD PTR tv336[ebp]
	movss	xmm1, DWORD PTR _Trig$[ebp]
	mulss	xmm1, DWORD PTR _dist$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _ty$[ebp], xmm0

; 3573 : 
; 3574 : 	dx = x - tx;

	movss	xmm0, DWORD PTR _x$[ebp]
	subss	xmm0, DWORD PTR _tx$[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 3575 : 	dy = y - ty;

	movss	xmm0, DWORD PTR _y$[ebp]
	subss	xmm0, DWORD PTR _ty$[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 3576 : 
; 3577 : 	*finalHdg = (float)atan2(dy, dx)* RTD;

	cvtss2sd xmm0, DWORD PTR _dx$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _dy$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	QWORD PTR tv345[ebp]
	movsd	xmm0, QWORD PTR tv345[ebp]
	cvtsd2ss xmm0, xmm0
	mulss	xmm0, DWORD PTR __real@42652ee1
	mov	edx, DWORD PTR _finalHdg$[ebp]
	movss	DWORD PTR [edx], xmm0

; 3578 : 
; 3579 : 	//Hack
; 3580 : 	//*finalHdg = hdgToPt * RTD;
; 3581 : 
; 3582 : 	if(*finalHdg < 0.0F)

	mov	eax, DWORD PTR _finalHdg$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR [eax]
	jbe	SHORT $LN1@CalculateS

; 3583 : 		*finalHdg += 360.0F;

	mov	ecx, DWORD PTR _finalHdg$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	addss	xmm0, DWORD PTR __real@43b40000
	mov	edx, DWORD PTR _finalHdg$[ebp]
	movss	DWORD PTR [edx], xmm0
$LN1@CalculateS:

; 3584 : 
; 3585 : 	return dir;

	mov	eax, DWORD PTR _dir$[ebp]
$LN16@CalculateS:

; 3586 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?CalculateStandRateTurnToPt@ATCBrain@@QAEHPAVAircraftClass@@MMPAM@Z ENDP ; ATCBrain::CalculateStandRateTurnToPt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
tv819 = -128						; size = 4
tv814 = -124						; size = 4
tv771 = -120						; size = 4
tv766 = -116						; size = 4
tv730 = -112						; size = 4
tv725 = -108						; size = 4
tv681 = -104						; size = 4
tv676 = -100						; size = 4
tv640 = -96						; size = 4
tv635 = -92						; size = 4
_finAngle$ = -88					; size = 4
tv594 = -84						; size = 4
tv590 = -80						; size = 4
tv569 = -76						; size = 4
tv554 = -72						; size = 4
_norm$ = -68						; size = 4
tv132 = -64						; size = 4
_minSpeed$1 = -60					; size = 4
_finalDist$ = -56					; size = 4
_py$ = -52						; size = 4
_px$ = -48						; size = 4
_baseY$ = -44						; size = 4
_baseX$ = -40						; size = 4
_finalY$ = -36						; size = 4
_finalX$ = -32						; size = 4
_this$ = -28						; size = 4
_dy$ = -24						; size = 4
_dx$ = -20						; size = 4
_decelDist$ = -16					; size = 4
_decelTime$ = -12					; size = 4
_PatternSpd$ = -8					; size = 4
_dist$ = -4						; size = 4
_aircraft$ = 8						; size = 4
_rwindex$ = 12						; size = 4
_status$ = 16						; size = 4
_min$ = 20						; size = 4
_max$ = 24						; size = 4
_cosAngle$ = 28						; size = 4
?CalculateMinMaxTime@ATCBrain@@QAEXPAVAircraftClass@@HW4AtcStatusEnum@@PAK2M@Z PROC ; ATCBrain::CalculateMinMaxTime
; _this$ = ecx

; 2207 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	mov	DWORD PTR _this$[ebp], ecx

; 2208 : 	float finalX, finalY, baseX, baseY, px, py, dist, dx, dy, finalDist;
; 2209 : 	float decelDist, decelTime, finAngle, norm;
; 2210 : 	float PatternSpd = aircraft->af->MinVcas() * KNOTS_TO_FTPSEC;

	mov	eax, DWORD PTR _aircraft$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv554[ebp]
	movss	xmm0, DWORD PTR tv554[ebp]
	mulss	xmm0, DWORD PTR __real@3fd80b03
	movss	DWORD PTR _PatternSpd$[ebp], xmm0

; 2211 : 
; 2212 : 	if(aircraft->IsLocal())

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN32@CalculateM

; 2213 : 	{
; 2214 : 		float minSpeed = aircraft->af->CalcDesSpeed(10.0F);

	push	ecx
	movss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _aircraft$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	call	?CalcDesSpeed@AirframeClass@@QAEMM@Z	; AirframeClass::CalcDesSpeed
	fstp	DWORD PTR _minSpeed$1[ebp]

; 2215 : 
; 2216 : 		if(minSpeed > PatternSpd)

	movss	xmm0, DWORD PTR _minSpeed$1[ebp]
	comiss	xmm0, DWORD PTR _PatternSpd$[ebp]
	jbe	SHORT $LN32@CalculateM

; 2217 : 			PatternSpd = minSpeed;

	movss	xmm0, DWORD PTR _minSpeed$1[ebp]
	movss	DWORD PTR _PatternSpd$[ebp], xmm0
$LN32@CalculateM:

; 2218 : 	}
; 2219 : 
; 2220 : 	//cosAngle = DetermineAngle(aircraft, rwindex, status);
; 2221 : 	decelTime = (float)fabs(aircraft->af->vt - PatternSpd)*0.2F;

	mov	eax, DWORD PTR _aircraft$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1120]
	subss	xmm0, DWORD PTR _PatternSpd$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv569[ebp]
	movss	xmm0, DWORD PTR tv569[ebp]
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR _decelTime$[ebp], xmm0

; 2222 : 	decelDist = decelTime * (aircraft->af->vt + PatternSpd)*0.5F;

	mov	edx, DWORD PTR _aircraft$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [eax+1120]
	addss	xmm0, DWORD PTR _PatternSpd$[ebp]
	mulss	xmm0, DWORD PTR _decelTime$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _decelDist$[ebp], xmm0

; 2223 : 
; 2224 : 	FindFinalPt(aircraft, rwindex, &finalX, &finalY);

	lea	ecx, DWORD PTR _finalY$[ebp]
	push	ecx
	lea	edx, DWORD PTR _finalX$[ebp]
	push	edx
	mov	eax, DWORD PTR _rwindex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _aircraft$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindFinalPt@ATCBrain@@QAEXPAVAircraftClass@@HPAM1@Z ; ATCBrain::FindFinalPt

; 2225 : 
; 2226 : 	finalDist = 0.8F * PatternSpd * 120.0F;

	movss	xmm0, DWORD PTR __real@3f4ccccd
	mulss	xmm0, DWORD PTR _PatternSpd$[ebp]
	mulss	xmm0, DWORD PTR __real@42f00000
	movss	DWORD PTR _finalDist$[ebp], xmm0

; 2227 : 
; 2228 : 	switch(status)

	mov	edx, DWORD PTR _status$[ebp]
	mov	DWORD PTR tv132[ebp], edx
	cmp	DWORD PTR tv132[ebp], 29		; 0000001dH
	ja	$LN1@CalculateM
	mov	eax, DWORD PTR tv132[ebp]
	movzx	ecx, BYTE PTR $LN36@CalculateM[eax]
	jmp	DWORD PTR $LN37@CalculateM[ecx*4]
$LN29@CalculateM:

; 2229 : 	{
; 2230 : 	case lReqClearance:
; 2231 : 	case lReqEmerClearance:	
; 2232 : 		TranslatePointData (self, GetFirstPt(rwindex), &px, &py);

	lea	edx, DWORD PTR _py$[ebp]
	push	edx
	lea	eax, DWORD PTR _px$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rwindex$[ebp]
	push	ecx
	call	?GetFirstPt@@YAHH@Z			; GetFirstPt
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData
	add	esp, 16					; 00000010H

; 2233 : 
; 2234 : 		//this is declared backwards because the runway heading is opposite the
; 2235 : 		//heading we need to have when landing
; 2236 : 		dx = aircraft->XPos() - px;

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv590[ebp]
	movss	xmm0, DWORD PTR tv590[ebp]
	subss	xmm0, DWORD PTR _px$[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 2237 : 		dy = aircraft->YPos() - py;

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv594[ebp]
	movss	xmm0, DWORD PTR tv594[ebp]
	subss	xmm0, DWORD PTR _py$[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 2238 : 		dist = (float)sqrt(dx * dx + dy * dy);

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]

; 2239 : 
; 2240 : 		if(dist < finalDist)

	movss	xmm0, DWORD PTR _finalDist$[ebp]
	comiss	xmm0, DWORD PTR _dist$[ebp]
	jbe	$LN27@CalculateM

; 2241 : 		{
; 2242 : 			norm = (float)(1.0F/dist);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR _norm$[ebp], xmm0

; 2243 : 			dx *= norm;

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _norm$[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 2244 : 			dy *= norm;

	movss	xmm0, DWORD PTR _dy$[ebp]
	mulss	xmm0, DWORD PTR _norm$[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 2245 : 
; 2246 : 			finAngle =	dx * PtHeaderDataTable[rwindex].cosHeading + 
; 2247 : 						dy * PtHeaderDataTable[rwindex].sinHeading;

	mov	ecx, DWORD PTR _rwindex$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR [edx+ecx+16]
	mov	eax, DWORD PTR _rwindex$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR [ecx+eax+12]
	addss	xmm0, xmm1
	movss	DWORD PTR _finAngle$[ebp], xmm0

; 2248 : 
; 2249 : 			if(finAngle > 0.707F)

	movss	xmm0, DWORD PTR _finAngle$[ebp]
	comiss	xmm0, DWORD PTR __real@3f34fdf4
	jbe	$LN27@CalculateM

; 2250 : 			{				
; 2251 : 				*max = FloatToInt32(dist/(PatternSpd * 0.65F)) * CampaignSeconds;

	movss	xmm0, DWORD PTR _PatternSpd$[ebp]
	mulss	xmm0, DWORD PTR __real@3f266666
	movss	xmm1, DWORD PTR _dist$[ebp]
	divss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	imul	eax, 1000				; 000003e8H
	mov	edx, DWORD PTR _max$[ebp]
	mov	DWORD PTR [edx], eax

; 2252 : 				PatternSpd = PatternSpd * (dist * 0.4F / finalDist + 0.6F);

	movss	xmm0, DWORD PTR _dist$[ebp]
	mulss	xmm0, DWORD PTR __real@3ecccccd
	divss	xmm0, DWORD PTR _finalDist$[ebp]
	addss	xmm0, DWORD PTR __real@3f19999a
	mulss	xmm0, DWORD PTR _PatternSpd$[ebp]
	movss	DWORD PTR _PatternSpd$[ebp], xmm0

; 2253 : 				*min = FloatToInt32(dist/(PatternSpd * 0.7F)) * CampaignSeconds;

	movss	xmm0, DWORD PTR _PatternSpd$[ebp]
	mulss	xmm0, DWORD PTR __real@3f333333
	movss	xmm1, DWORD PTR _dist$[ebp]
	divss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	imul	eax, 1000				; 000003e8H
	mov	ecx, DWORD PTR _min$[ebp]
	mov	DWORD PTR [ecx], eax

; 2254 : 				break;

	jmp	$LN30@CalculateM
$LN27@CalculateM:

; 2255 : 			}
; 2256 : 		}
; 2257 : 
; 2258 : 	case noATC:
; 2259 : 	case lHolding:
; 2260 : 	case lFirstLeg:
; 2261 : 	case lAborted:
; 2262 : 	case lEmerHold:
; 2263 : 	case lIngressing:
; 2264 : 	case lTakingPosition:
; 2265 : 		
; 2266 : 		if(cosAngle < 0.0F)

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _cosAngle$[ebp]
	jbe	$LN25@CalculateM

; 2267 : 		{
; 2268 : 			//we need to use a base pt
; 2269 : 			FindBasePt(aircraft, rwindex, finalX, finalY, &baseX, &baseY);

	lea	edx, DWORD PTR _baseY$[ebp]
	push	edx
	lea	eax, DWORD PTR _baseX$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _finalY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _finalX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _rwindex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _aircraft$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindBasePt@ATCBrain@@QAE?AW4AtcStatusEnum@@PAVAircraftClass@@HMMPAM1@Z ; ATCBrain::FindBasePt

; 2270 : 
; 2271 : 			dx = baseX - aircraft->XPos();

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv635[ebp]
	movss	xmm0, DWORD PTR _baseX$[ebp]
	subss	xmm0, DWORD PTR tv635[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 2272 : 			dy = baseY - aircraft->YPos();

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv640[ebp]
	movss	xmm0, DWORD PTR _baseY$[ebp]
	subss	xmm0, DWORD PTR tv640[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 2273 : 			dist = (float)sqrt(dx * dx + dy * dy);

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]

; 2274 : 
; 2275 : 			if(dist > decelDist)

	movss	xmm0, DWORD PTR _dist$[ebp]
	comiss	xmm0, DWORD PTR _decelDist$[ebp]
	jbe	SHORT $LN24@CalculateM

; 2276 : 			{
; 2277 : 				*min = FloatToInt32((decelTime + (dist - decelDist)/PatternSpd)) * CampaignSeconds + FINAL_TIME + BASE_TIME;

	movss	xmm0, DWORD PTR _dist$[ebp]
	subss	xmm0, DWORD PTR _decelDist$[ebp]
	divss	xmm0, DWORD PTR _PatternSpd$[ebp]
	addss	xmm0, DWORD PTR _decelTime$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	imul	eax, 1000				; 000003e8H
	add	eax, 180000				; 0002bf20H
	mov	ecx, DWORD PTR _min$[ebp]
	mov	DWORD PTR [ecx], eax

; 2278 : 				*max = FloatToInt32(1.4142F * (decelTime + (dist - decelDist)/PatternSpd)) * CampaignSeconds + FINAL_TIME + BASE_TIME;

	movss	xmm0, DWORD PTR _dist$[ebp]
	subss	xmm0, DWORD PTR _decelDist$[ebp]
	divss	xmm0, DWORD PTR _PatternSpd$[ebp]
	addss	xmm0, DWORD PTR _decelTime$[ebp]
	mulss	xmm0, DWORD PTR __real@3fb50481
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	imul	eax, 1000				; 000003e8H
	add	eax, 180000				; 0002bf20H
	mov	edx, DWORD PTR _max$[ebp]
	mov	DWORD PTR [edx], eax

; 2279 : 			}
; 2280 : 			else

	jmp	$LN21@CalculateM
$LN24@CalculateM:

; 2281 : 			{
; 2282 : 				*min = FloatToInt32(decelTime) * CampaignSeconds + FINAL_TIME + BASE_TIME;

	push	ecx
	movss	xmm0, DWORD PTR _decelTime$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	imul	eax, 1000				; 000003e8H
	add	eax, 180000				; 0002bf20H
	mov	ecx, DWORD PTR _min$[ebp]
	mov	DWORD PTR [ecx], eax

; 2283 : 				if(dist * 1.4142F > decelDist)

	movss	xmm0, DWORD PTR _dist$[ebp]
	mulss	xmm0, DWORD PTR __real@3fb50481
	comiss	xmm0, DWORD PTR _decelDist$[ebp]
	jbe	SHORT $LN22@CalculateM

; 2284 : 					*max = FloatToInt32((decelTime + (1.4142F * dist - decelDist)/PatternSpd))  * CampaignSeconds + FINAL_TIME + BASE_TIME;

	movss	xmm0, DWORD PTR __real@3fb50481
	mulss	xmm0, DWORD PTR _dist$[ebp]
	subss	xmm0, DWORD PTR _decelDist$[ebp]
	divss	xmm0, DWORD PTR _PatternSpd$[ebp]
	addss	xmm0, DWORD PTR _decelTime$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	imul	eax, 1000				; 000003e8H
	add	eax, 180000				; 0002bf20H
	mov	edx, DWORD PTR _max$[ebp]
	mov	DWORD PTR [edx], eax

; 2285 : 				else

	jmp	SHORT $LN21@CalculateM
$LN22@CalculateM:

; 2286 : 					*max = FloatToInt32(decelTime * CampaignSeconds) + FINAL_TIME + BASE_TIME;

	movss	xmm0, DWORD PTR _decelTime$[ebp]
	mulss	xmm0, DWORD PTR __real@447a0000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	add	eax, 180000				; 0002bf20H
	mov	ecx, DWORD PTR _max$[ebp]
	mov	DWORD PTR [ecx], eax
$LN21@CalculateM:

; 2287 : 			}
; 2288 : 		}
; 2289 : 		else

	jmp	$LN16@CalculateM
$LN25@CalculateM:

; 2290 : 		{
; 2291 : 			//we can head directly for our final pt
; 2292 : 			dx = finalX - aircraft->XPos();

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv676[ebp]
	movss	xmm0, DWORD PTR _finalX$[ebp]
	subss	xmm0, DWORD PTR tv676[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 2293 : 			dy = finalY - aircraft->YPos();

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv681[ebp]
	movss	xmm0, DWORD PTR _finalY$[ebp]
	subss	xmm0, DWORD PTR tv681[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 2294 : 			dist = (float)sqrt(dx * dx + dy * dy);

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]

; 2295 : 
; 2296 : 			if(dist > decelDist)

	movss	xmm0, DWORD PTR _dist$[ebp]
	comiss	xmm0, DWORD PTR _decelDist$[ebp]
	jbe	SHORT $LN19@CalculateM

; 2297 : 			{
; 2298 : 				*min = FloatToInt32((decelTime + (dist - decelDist)/PatternSpd)) * CampaignSeconds + FINAL_TIME;

	movss	xmm0, DWORD PTR _dist$[ebp]
	subss	xmm0, DWORD PTR _decelDist$[ebp]
	divss	xmm0, DWORD PTR _PatternSpd$[ebp]
	addss	xmm0, DWORD PTR _decelTime$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	imul	eax, 1000				; 000003e8H
	add	eax, 120000				; 0001d4c0H
	mov	edx, DWORD PTR _min$[ebp]
	mov	DWORD PTR [edx], eax

; 2299 : 				*max = FloatToInt32( 1.879385241572F * (decelTime + (dist - decelDist)/PatternSpd)) * CampaignSeconds + FINAL_TIME;

	movss	xmm0, DWORD PTR _dist$[ebp]
	subss	xmm0, DWORD PTR _decelDist$[ebp]
	divss	xmm0, DWORD PTR _PatternSpd$[ebp]
	addss	xmm0, DWORD PTR _decelTime$[ebp]
	mulss	xmm0, DWORD PTR __real@3ff08fb2
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	imul	eax, 1000				; 000003e8H
	add	eax, 120000				; 0001d4c0H
	mov	ecx, DWORD PTR _max$[ebp]
	mov	DWORD PTR [ecx], eax

; 2300 : 			}
; 2301 : 			else

	jmp	$LN16@CalculateM
$LN19@CalculateM:

; 2302 : 			{
; 2303 : 				*min = FloatToInt32(decelTime) * CampaignSeconds + FINAL_TIME;

	push	ecx
	movss	xmm0, DWORD PTR _decelTime$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	imul	eax, 1000				; 000003e8H
	add	eax, 120000				; 0001d4c0H
	mov	edx, DWORD PTR _min$[ebp]
	mov	DWORD PTR [edx], eax

; 2304 : 				if(dist *  1.879385241572F > decelDist)

	movss	xmm0, DWORD PTR _dist$[ebp]
	mulss	xmm0, DWORD PTR __real@3ff08fb2
	comiss	xmm0, DWORD PTR _decelDist$[ebp]
	jbe	SHORT $LN17@CalculateM

; 2305 : 					*max = FloatToInt32((decelTime + ( 1.879385241572F * dist - decelDist)/PatternSpd)) * CampaignSeconds + FINAL_TIME;

	movss	xmm0, DWORD PTR __real@3ff08fb2
	mulss	xmm0, DWORD PTR _dist$[ebp]
	subss	xmm0, DWORD PTR _decelDist$[ebp]
	divss	xmm0, DWORD PTR _PatternSpd$[ebp]
	addss	xmm0, DWORD PTR _decelTime$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	imul	eax, 1000				; 000003e8H
	add	eax, 120000				; 0001d4c0H
	mov	ecx, DWORD PTR _max$[ebp]
	mov	DWORD PTR [ecx], eax

; 2306 : 				else

	jmp	SHORT $LN16@CalculateM
$LN17@CalculateM:

; 2307 : 					*max = FloatToInt32(decelTime) * CampaignSeconds + FINAL_TIME;

	push	ecx
	movss	xmm0, DWORD PTR _decelTime$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	imul	eax, 1000				; 000003e8H
	add	eax, 120000				; 0001d4c0H
	mov	edx, DWORD PTR _max$[ebp]
	mov	DWORD PTR [edx], eax
$LN16@CalculateM:

; 2308 : 			}
; 2309 : 		}
; 2310 : 		break;

	jmp	$LN30@CalculateM
$LN15@CalculateM:

; 2311 : 
; 2312 : 	case lEmergencyToBase:
; 2313 : 	case lToBase:
; 2314 : 		//we need to use a base pt
; 2315 : 		FindBasePt(aircraft, rwindex, finalX, finalY, &baseX, &baseY);

	lea	eax, DWORD PTR _baseY$[ebp]
	push	eax
	lea	ecx, DWORD PTR _baseX$[ebp]
	push	ecx
	push	ecx
	movss	xmm0, DWORD PTR _finalY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _finalX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _rwindex$[ebp]
	push	edx
	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindBasePt@ATCBrain@@QAE?AW4AtcStatusEnum@@PAVAircraftClass@@HMMPAM1@Z ; ATCBrain::FindBasePt

; 2316 : 
; 2317 : 		dx = baseX - aircraft->XPos();

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv725[ebp]
	movss	xmm0, DWORD PTR _baseX$[ebp]
	subss	xmm0, DWORD PTR tv725[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 2318 : 		dy = baseY - aircraft->YPos();

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv730[ebp]
	movss	xmm0, DWORD PTR _baseY$[ebp]
	subss	xmm0, DWORD PTR tv730[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 2319 : 		dist = (float)sqrt(dx * dx + dy * dy);

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]

; 2320 : 
; 2321 : 		if(dist > decelDist)

	movss	xmm0, DWORD PTR _dist$[ebp]
	comiss	xmm0, DWORD PTR _decelDist$[ebp]
	jbe	SHORT $LN14@CalculateM

; 2322 : 		{
; 2323 : 			*min = FloatToInt32((decelTime + (dist - decelDist)/PatternSpd)) * CampaignSeconds + FINAL_TIME + BASE_TIME;

	movss	xmm0, DWORD PTR _dist$[ebp]
	subss	xmm0, DWORD PTR _decelDist$[ebp]
	divss	xmm0, DWORD PTR _PatternSpd$[ebp]
	addss	xmm0, DWORD PTR _decelTime$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	imul	eax, 1000				; 000003e8H
	add	eax, 180000				; 0002bf20H
	mov	ecx, DWORD PTR _min$[ebp]
	mov	DWORD PTR [ecx], eax

; 2324 : 			*max = FloatToInt32(1.4142F * (decelTime + (dist - decelDist)/PatternSpd))  * CampaignSeconds + FINAL_TIME + BASE_TIME;

	movss	xmm0, DWORD PTR _dist$[ebp]
	subss	xmm0, DWORD PTR _decelDist$[ebp]
	divss	xmm0, DWORD PTR _PatternSpd$[ebp]
	addss	xmm0, DWORD PTR _decelTime$[ebp]
	mulss	xmm0, DWORD PTR __real@3fb50481
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	imul	eax, 1000				; 000003e8H
	add	eax, 180000				; 0002bf20H
	mov	edx, DWORD PTR _max$[ebp]
	mov	DWORD PTR [edx], eax

; 2325 : 		}
; 2326 : 		else

	jmp	$LN11@CalculateM
$LN14@CalculateM:

; 2327 : 		{
; 2328 : 			*min = FloatToInt32(decelTime) * CampaignSeconds + FINAL_TIME + BASE_TIME;

	push	ecx
	movss	xmm0, DWORD PTR _decelTime$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	imul	eax, 1000				; 000003e8H
	add	eax, 180000				; 0002bf20H
	mov	ecx, DWORD PTR _min$[ebp]
	mov	DWORD PTR [ecx], eax

; 2329 : 			if(dist * 1.4142F > decelDist)

	movss	xmm0, DWORD PTR _dist$[ebp]
	mulss	xmm0, DWORD PTR __real@3fb50481
	comiss	xmm0, DWORD PTR _decelDist$[ebp]
	jbe	SHORT $LN12@CalculateM

; 2330 : 				*max = FloatToInt32((decelTime + (1.4142F * dist - decelDist)/PatternSpd))  * CampaignSeconds + FINAL_TIME + BASE_TIME;

	movss	xmm0, DWORD PTR __real@3fb50481
	mulss	xmm0, DWORD PTR _dist$[ebp]
	subss	xmm0, DWORD PTR _decelDist$[ebp]
	divss	xmm0, DWORD PTR _PatternSpd$[ebp]
	addss	xmm0, DWORD PTR _decelTime$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	imul	eax, 1000				; 000003e8H
	add	eax, 180000				; 0002bf20H
	mov	edx, DWORD PTR _max$[ebp]
	mov	DWORD PTR [edx], eax

; 2331 : 			else

	jmp	SHORT $LN11@CalculateM
$LN12@CalculateM:

; 2332 : 				*max = FloatToInt32(decelTime) * CampaignSeconds + FINAL_TIME + BASE_TIME;

	push	ecx
	movss	xmm0, DWORD PTR _decelTime$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	imul	eax, 1000				; 000003e8H
	add	eax, 180000				; 0002bf20H
	mov	ecx, DWORD PTR _max$[ebp]
	mov	DWORD PTR [ecx], eax
$LN11@CalculateM:

; 2333 : 		}
; 2334 : 		break;

	jmp	$LN30@CalculateM
$LN10@CalculateM:

; 2335 : 
; 2336 : 	case lEmergencyToFinal:
; 2337 : 	case lToFinal:
; 2338 : 		//we can head directly for our final pt
; 2339 : 		dx = finalX - aircraft->XPos();

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv766[ebp]
	movss	xmm0, DWORD PTR _finalX$[ebp]
	subss	xmm0, DWORD PTR tv766[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 2340 : 		dy = finalY - aircraft->YPos();

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv771[ebp]
	movss	xmm0, DWORD PTR _finalY$[ebp]
	subss	xmm0, DWORD PTR tv771[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 2341 : 		dist = (float)sqrt(dx * dx + dy * dy);

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]

; 2342 : 
; 2343 : 		if(dist > decelDist)

	movss	xmm0, DWORD PTR _dist$[ebp]
	comiss	xmm0, DWORD PTR _decelDist$[ebp]
	jbe	SHORT $LN9@CalculateM

; 2344 : 		{
; 2345 : 			*min = FloatToInt32((decelTime + (dist - decelDist)/PatternSpd)) * CampaignSeconds + FINAL_TIME;

	movss	xmm0, DWORD PTR _dist$[ebp]
	subss	xmm0, DWORD PTR _decelDist$[ebp]
	divss	xmm0, DWORD PTR _PatternSpd$[ebp]
	addss	xmm0, DWORD PTR _decelTime$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	imul	eax, 1000				; 000003e8H
	add	eax, 120000				; 0001d4c0H
	mov	edx, DWORD PTR _min$[ebp]
	mov	DWORD PTR [edx], eax

; 2346 : 			*max = FloatToInt32(1.4142F * (decelTime + (dist - decelDist)/PatternSpd)) * CampaignSeconds + FINAL_TIME;

	movss	xmm0, DWORD PTR _dist$[ebp]
	subss	xmm0, DWORD PTR _decelDist$[ebp]
	divss	xmm0, DWORD PTR _PatternSpd$[ebp]
	addss	xmm0, DWORD PTR _decelTime$[ebp]
	mulss	xmm0, DWORD PTR __real@3fb50481
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	imul	eax, 1000				; 000003e8H
	add	eax, 120000				; 0001d4c0H
	mov	ecx, DWORD PTR _max$[ebp]
	mov	DWORD PTR [ecx], eax

; 2347 : 		}
; 2348 : 		else

	jmp	$LN6@CalculateM
$LN9@CalculateM:

; 2349 : 		{
; 2350 : 			*min = FloatToInt32(decelTime) * CampaignSeconds + FINAL_TIME;

	push	ecx
	movss	xmm0, DWORD PTR _decelTime$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	imul	eax, 1000				; 000003e8H
	add	eax, 120000				; 0001d4c0H
	mov	edx, DWORD PTR _min$[ebp]
	mov	DWORD PTR [edx], eax

; 2351 : 			if(dist * 1.4142F > decelDist)

	movss	xmm0, DWORD PTR _dist$[ebp]
	mulss	xmm0, DWORD PTR __real@3fb50481
	comiss	xmm0, DWORD PTR _decelDist$[ebp]
	jbe	SHORT $LN7@CalculateM

; 2352 : 				*max = FloatToInt32((decelTime + (1.4142F * dist - decelDist)/PatternSpd))  * CampaignSeconds + FINAL_TIME;

	movss	xmm0, DWORD PTR __real@3fb50481
	mulss	xmm0, DWORD PTR _dist$[ebp]
	subss	xmm0, DWORD PTR _decelDist$[ebp]
	divss	xmm0, DWORD PTR _PatternSpd$[ebp]
	addss	xmm0, DWORD PTR _decelTime$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	imul	eax, 1000				; 000003e8H
	add	eax, 120000				; 0001d4c0H
	mov	ecx, DWORD PTR _max$[ebp]
	mov	DWORD PTR [ecx], eax

; 2353 : 			else

	jmp	SHORT $LN6@CalculateM
$LN7@CalculateM:

; 2354 : 				*max = FloatToInt32(decelTime) * CampaignSeconds + FINAL_TIME;

	push	ecx
	movss	xmm0, DWORD PTR _decelTime$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	imul	eax, 1000				; 000003e8H
	add	eax, 120000				; 0001d4c0H
	mov	edx, DWORD PTR _max$[ebp]
	mov	DWORD PTR [edx], eax
$LN6@CalculateM:

; 2355 : 		}
; 2356 : 		break;

	jmp	$LN30@CalculateM
$LN5@CalculateM:

; 2357 : 
; 2358 : 	case lLanded:
; 2359 : 	case lEmergencyOnFinal:
; 2360 : 	case lOnFinal:
; 2361 : 	case lClearToLand:
; 2362 : 		if(cosAngle > 0.707F)

	movss	xmm0, DWORD PTR _cosAngle$[ebp]
	comiss	xmm0, DWORD PTR __real@3f34fdf4
	jbe	$LN4@CalculateM

; 2363 : 		{
; 2364 : 			TranslatePointData (self, GetFirstPt(rwindex), &px, &py);

	lea	eax, DWORD PTR _py$[ebp]
	push	eax
	lea	ecx, DWORD PTR _px$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rwindex$[ebp]
	push	edx
	call	?GetFirstPt@@YAHH@Z			; GetFirstPt
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData
	add	esp, 16					; 00000010H

; 2365 : 			dx = px - aircraft->XPos();

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv814[ebp]
	movss	xmm0, DWORD PTR _px$[ebp]
	subss	xmm0, DWORD PTR tv814[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 2366 : 			dy = py - aircraft->YPos();

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv819[ebp]
	movss	xmm0, DWORD PTR _py$[ebp]
	subss	xmm0, DWORD PTR tv819[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 2367 : 			dist = (float)sqrt(dx * dx + dy * dy);

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]

; 2368 : 
; 2369 : 			*max = FloatToInt32(dist/(PatternSpd * 0.67F)) * CampaignSeconds;

	movss	xmm0, DWORD PTR _PatternSpd$[ebp]
	mulss	xmm0, DWORD PTR __real@3f2b851f
	movss	xmm1, DWORD PTR _dist$[ebp]
	divss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	imul	eax, 1000				; 000003e8H
	mov	edx, DWORD PTR _max$[ebp]
	mov	DWORD PTR [edx], eax

; 2370 : 
; 2371 : 			PatternSpd = PatternSpd * (dist * 0.4F / finalDist + 0.6F);

	movss	xmm0, DWORD PTR _dist$[ebp]
	mulss	xmm0, DWORD PTR __real@3ecccccd
	divss	xmm0, DWORD PTR _finalDist$[ebp]
	addss	xmm0, DWORD PTR __real@3f19999a
	mulss	xmm0, DWORD PTR _PatternSpd$[ebp]
	movss	DWORD PTR _PatternSpd$[ebp], xmm0

; 2372 : 
; 2373 : 			*min = FloatToInt32(dist/PatternSpd) * CampaignSeconds;

	movss	xmm0, DWORD PTR _dist$[ebp]
	divss	xmm0, DWORD PTR _PatternSpd$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	imul	eax, 1000				; 000003e8H
	mov	ecx, DWORD PTR _min$[ebp]
	mov	DWORD PTR [ecx], eax

; 2374 : 		}
; 2375 : 		else

	jmp	SHORT $LN3@CalculateM
$LN4@CalculateM:

; 2376 : 		{
; 2377 : 			*max = 0;

	mov	edx, DWORD PTR _max$[ebp]
	mov	DWORD PTR [edx], 0

; 2378 : 			*min = 180 * CampaignSeconds;

	mov	eax, DWORD PTR _min$[ebp]
	mov	DWORD PTR [eax], 180000			; 0002bf20H
$LN3@CalculateM:

; 2379 : 		}
; 2380 : 		break;

	jmp	SHORT $LN30@CalculateM
$LN2@CalculateM:

; 2381 : 
; 2382 : 	case lCrashed:
; 2383 : 	case tReqTaxi:
; 2384 : 	case tReqTakeoff:
; 2385 : 	case tEmerStop:
; 2386 : 	case tTaxi:
; 2387 : 	case tWait:
; 2388 : 	case tHoldShort:
; 2389 : 	case tPrepToTakeRunway:
; 2390 : 	case tTakeRunway:
; 2391 : 	case tTakeoff:
; 2392 : 	case tFlyOut:
; 2393 : 	case tTaxiBack:
; 2394 : 	case lTaxiOff:
; 2395 : 		*max = 0;

	mov	ecx, DWORD PTR _max$[ebp]
	mov	DWORD PTR [ecx], 0

; 2396 : 		*min = 0;

	mov	edx, DWORD PTR _min$[ebp]
	mov	DWORD PTR [edx], 0
$LN1@CalculateM:
$LN30@CalculateM:

; 2397 : 		break;
; 2398 : 	default:
; 2399 : 		//we should never get here
; 2400 : 		ShiWarning("We are in an undefined state, we shouldn't be here");
; 2401 : 	}
; 2402 : 
; 2403 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
	npad	3
$LN37@CalculateM:
	DD	$LN27@CalculateM
	DD	$LN29@CalculateM
	DD	$LN15@CalculateM
	DD	$LN10@CalculateM
	DD	$LN5@CalculateM
	DD	$LN2@CalculateM
$LN36@CalculateM:
	DB	0
	DB	1
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	2
	DB	3
	DB	4
	DB	4
	DB	4
	DB	5
	DB	2
	DB	3
	DB	4
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
?CalculateMinMaxTime@ATCBrain@@QAEXPAVAircraftClass@@HW4AtcStatusEnum@@PAK2M@Z ENDP ; ATCBrain::CalculateMinMaxTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_cit$2 = -68						; size = 12
tv190 = -56						; size = 4
_this$ = -52						; size = 4
tv196 = -48						; size = 4
tv184 = -44						; size = 4
tv134 = -40						; size = 4
_entity$ = -36						; size = 4
_alt$ = -32						; size = 4
_pos$ = -28						; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_aircraft$ = 8						; size = 4
_status$ = 12						; size = 4
?GetAltitude@ATCBrain@@QAEMPAVAircraftClass@@W4AtcStatusEnum@@@Z PROC ; ATCBrain::GetAltitude
; _this$ = ecx

; 3470 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetAltitude@ATCBrain@@QAEMPAVAircraftClass@@W4AtcStatusEnum@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3471 : 	float alt = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _alt$[ebp], xmm0

; 3472 : 	Tpoint pos;
; 3473 : 	SimBaseClass*	entity = NULL;

	mov	DWORD PTR _entity$[ebp], 0

; 3474 : 
; 3475 : 	{
; 3476 : 		// destroy iterator here
; 3477 : 		VuListIterator	cit(self->GetComponents());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	push	eax
	lea	ecx, DWORD PTR _cit$2[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3478 : 		entity = (SimBaseClass*)cit.GetFirst();

	lea	ecx, DWORD PTR _cit$2[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _entity$[ebp], eax
$LN12@GetAltitud:

; 3479 : 		while(entity && !entity->drawPointer){

	cmp	DWORD PTR _entity$[ebp], 0
	je	SHORT $LN11@GetAltitud
	mov	ecx, DWORD PTR _entity$[ebp]
	cmp	DWORD PTR [ecx+332], 0
	jne	SHORT $LN11@GetAltitud

; 3480 : 			entity = (SimBaseClass*)cit.GetNext();

	lea	ecx, DWORD PTR _cit$2[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _entity$[ebp], eax

; 3481 : 		}

	jmp	SHORT $LN12@GetAltitud
$LN11@GetAltitud:

; 3482 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cit$2[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator

; 3483 : 
; 3484 : 	if(entity && entity->drawPointer)

	cmp	DWORD PTR _entity$[ebp], 0
	je	SHORT $LN10@GetAltitud
	mov	edx, DWORD PTR _entity$[ebp]
	cmp	DWORD PTR [edx+332], 0
	je	SHORT $LN10@GetAltitud

; 3485 : 		entity->drawPointer->GetPosition(&pos);

	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _entity$[ebp]
	mov	ecx, DWORD PTR [ecx+332]
	call	?GetPosition@DrawableObject@@QAEXPAUTpoint@@@Z ; DrawableObject::GetPosition

; 3486 : 	else

	jmp	SHORT $LN9@GetAltitud
$LN10@GetAltitud:

; 3487 : 		pos.z = aircraft->af->groundZ;

	mov	edx, DWORD PTR _aircraft$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR [eax+1272]
	movss	DWORD PTR _pos$[ebp+8], xmm0
$LN9@GetAltitud:

; 3488 : 
; 3489 : 	switch(status)

	mov	ecx, DWORD PTR _status$[ebp]
	mov	DWORD PTR tv134[ebp], ecx
	cmp	DWORD PTR tv134[ebp], 17		; 00000011H
	ja	$LN1@GetAltitud
	mov	edx, DWORD PTR tv134[ebp]
	movzx	eax, BYTE PTR $LN16@GetAltitud[edx]
	jmp	DWORD PTR $LN18@GetAltitud[eax*4]
$LN6@GetAltitud:

; 3490 : 	{
; 3491 : 		case lReqClearance:
; 3492 : 		case lAborted:
; 3493 : 		case noATC: // JPO - when landing but outside airspace.
; 3494 : 			alt = pos.z - 4000.0F;

	movss	xmm0, DWORD PTR _pos$[ebp+8]
	subss	xmm0, DWORD PTR __real@457a0000
	movss	DWORD PTR _alt$[ebp], xmm0

; 3495 : 			break;

	jmp	$LN7@GetAltitud
$LN5@GetAltitud:

; 3496 : 		case lIngressing:
; 3497 : 		case lTakingPosition:
; 3498 : 		case lEmerHold:
; 3499 : 		case lHolding:
; 3500 : 		case lFirstLeg:
; 3501 : 			alt = pos.z - aircraft->af->MinVcas() * KNOTS_TO_FTPSEC * (FINAL_TIME*0.8F + BASE_TIME + 60000)/CampaignSeconds *  TAN_THREE_DEG_GLIDE;

	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv184[ebp]
	movss	xmm0, DWORD PTR tv184[ebp]
	mulss	xmm0, DWORD PTR __real@3fd80b03
	mulss	xmm0, DWORD PTR __real@4852f000
	divss	xmm0, DWORD PTR __real@447a0000
	mulss	xmm0, DWORD PTR __real@3d56a98a
	movss	xmm1, DWORD PTR _pos$[ebp+8]
	subss	xmm1, xmm0
	movss	DWORD PTR _alt$[ebp], xmm1

; 3502 : 			break;

	jmp	$LN7@GetAltitud
$LN4@GetAltitud:

; 3503 : 		case lEmergencyToBase:
; 3504 : 		case lToBase:
; 3505 : 			alt = pos.z - aircraft->af->MinVcas() * KNOTS_TO_FTPSEC * (FINAL_TIME*0.8F + BASE_TIME)/CampaignSeconds *  TAN_THREE_DEG_GLIDE;

	mov	edx, DWORD PTR _aircraft$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv190[ebp]
	movss	xmm0, DWORD PTR tv190[ebp]
	mulss	xmm0, DWORD PTR __real@3fd80b03
	mulss	xmm0, DWORD PTR __real@48185800
	divss	xmm0, DWORD PTR __real@447a0000
	mulss	xmm0, DWORD PTR __real@3d56a98a
	movss	xmm1, DWORD PTR _pos$[ebp+8]
	subss	xmm1, xmm0
	movss	DWORD PTR _alt$[ebp], xmm1

; 3506 : 			break;

	jmp	SHORT $LN7@GetAltitud
$LN3@GetAltitud:

; 3507 : 		case lToFinal:
; 3508 : 		case lEmergencyToFinal:
; 3509 : 			alt = pos.z - aircraft->af->MinVcas() * KNOTS_TO_FTPSEC * (FINAL_TIME*0.8F)/CampaignSeconds *  TAN_THREE_DEG_GLIDE;

	mov	eax, DWORD PTR _aircraft$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv196[ebp]
	movss	xmm0, DWORD PTR tv196[ebp]
	mulss	xmm0, DWORD PTR __real@3fd80b03
	mulss	xmm0, DWORD PTR __real@47bb8000
	divss	xmm0, DWORD PTR __real@447a0000
	mulss	xmm0, DWORD PTR __real@3d56a98a
	movss	xmm1, DWORD PTR _pos$[ebp+8]
	subss	xmm1, xmm0
	movss	DWORD PTR _alt$[ebp], xmm1

; 3510 : 			break;

	jmp	SHORT $LN7@GetAltitud
$LN2@GetAltitud:

; 3511 : 		case lOnFinal:
; 3512 : 		case lEmergencyOnFinal:
; 3513 : 			alt = pos.z;

	movss	xmm0, DWORD PTR _pos$[ebp+8]
	movss	DWORD PTR _alt$[ebp], xmm0

; 3514 : 			break;

	jmp	SHORT $LN7@GetAltitud
$LN1@GetAltitud:

; 3515 : 		default:
; 3516 : 			alt = pos.z - 5.0F;

	movss	xmm0, DWORD PTR _pos$[ebp+8]
	subss	xmm0, DWORD PTR __real@40a00000
	movss	DWORD PTR _alt$[ebp], xmm0
$LN7@GetAltitud:

; 3517 : 			break;
; 3518 : 	}
; 3519 : 
; 3520 : 	return alt;

	fld	DWORD PTR _alt$[ebp]

; 3521 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
$LN18@GetAltitud:
	DD	$LN6@GetAltitud
	DD	$LN5@GetAltitud
	DD	$LN4@GetAltitud
	DD	$LN3@GetAltitud
	DD	$LN2@GetAltitud
	DD	$LN1@GetAltitud
$LN16@GetAltitud:
	DB	0
	DB	0
	DB	5
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	5
	DB	5
	DB	2
	DB	3
	DB	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?GetAltitude@ATCBrain@@QAEMPAVAircraftClass@@W4AtcStatusEnum@@@Z$0:
	lea	ecx, DWORD PTR _cit$2[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__ehhandler$?GetAltitude@ATCBrain@@QAEMPAVAircraftClass@@W4AtcStatusEnum@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-60]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetAltitude@ATCBrain@@QAEMPAVAircraftClass@@W4AtcStatusEnum@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetAltitude@ATCBrain@@QAEMPAVAircraftClass@@W4AtcStatusEnum@@@Z ENDP ; ATCBrain::GetAltitude
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
tv207 = -44						; size = 4
tv200 = -40						; size = 4
tv196 = -36						; size = 4
_cosAngle$ = -32					; size = 4
tv64 = -28						; size = 4
_norm$ = -24						; size = 4
_this$ = -20						; size = 4
_dy$ = -16						; size = 4
_dx$ = -12						; size = 4
_py$ = -8						; size = 4
_px$ = -4						; size = 4
_aircraft$ = 8						; size = 4
_rwindex$ = 12						; size = 4
_status$ = 16						; size = 4
?DetermineAngle@ATCBrain@@QAEMPAVAircraftClass@@HW4AtcStatusEnum@@@Z PROC ; ATCBrain::DetermineAngle
; _this$ = ecx

; 2475 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 2476 : 	float	px=0.0F,py=0.0F, dx=0.0F, dy=0.0F, norm=0.0F, cosAngle=1.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _px$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _py$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _dx$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _dy$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _norm$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _cosAngle$[ebp], xmm0

; 2477 : 
; 2478 : 	switch(status)

	mov	eax, DWORD PTR _status$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 29			; 0000001dH
	ja	$LN2@DetermineA
	mov	ecx, DWORD PTR tv64[ebp]
	movzx	edx, BYTE PTR $LN11@DetermineA[ecx]
	jmp	DWORD PTR $LN12@DetermineA[edx*4]
$LN6@DetermineA:

; 2479 : 	{
; 2480 : 	case lReqClearance:
; 2481 : 	case lReqEmerClearance:
; 2482 : 	case lIngressing:	
; 2483 : 	case lTakingPosition:
; 2484 : 	
; 2485 : 	case lAborted:
; 2486 : 	case lEmerHold:
; 2487 : 	case lHolding:	
; 2488 : 	case lFirstLeg:
; 2489 : 	case lToBase:
; 2490 : 	case lToFinal:
; 2491 : 	case lEmergencyToBase:
; 2492 : 	case lEmergencyToFinal:
; 2493 : 		// RED - CTD FIX
; 2494 : 		if(aircraft) FindFinalPt(aircraft, rwindex, &px, &py);

	cmp	DWORD PTR _aircraft$[ebp], 0
	je	SHORT $LN5@DetermineA
	lea	eax, DWORD PTR _py$[ebp]
	push	eax
	lea	ecx, DWORD PTR _px$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rwindex$[ebp]
	push	edx
	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindFinalPt@ATCBrain@@QAEXPAVAircraftClass@@HPAM1@Z ; ATCBrain::FindFinalPt
$LN5@DetermineA:

; 2495 : 		break;

	jmp	SHORT $LN7@DetermineA
$LN4@DetermineA:

; 2496 : 	case lEmergencyOnFinal:
; 2497 : 	case lOnFinal:
; 2498 : 	case lClearToLand:
; 2499 : 		TranslatePointData (self, GetFirstPt(rwindex), &px, &py);

	lea	ecx, DWORD PTR _py$[ebp]
	push	ecx
	lea	edx, DWORD PTR _px$[ebp]
	push	edx
	mov	eax, DWORD PTR _rwindex$[ebp]
	push	eax
	call	?GetFirstPt@@YAHH@Z			; GetFirstPt
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData
	add	esp, 16					; 00000010H

; 2500 : 		px -= 500.0F;

	movss	xmm0, DWORD PTR _px$[ebp]
	subss	xmm0, DWORD PTR __real@43fa0000
	movss	DWORD PTR _px$[ebp], xmm0

; 2501 : 		py -= 500.0F;

	movss	xmm0, DWORD PTR _py$[ebp]
	subss	xmm0, DWORD PTR __real@43fa0000
	movss	DWORD PTR _py$[ebp], xmm0

; 2502 : 		break;

	jmp	SHORT $LN7@DetermineA
$LN3@DetermineA:

; 2503 : 	case noATC:
; 2504 : 	case lCrashed:
; 2505 : 	case lLanded:
; 2506 : 	case lTaxiOff:
; 2507 : 	case tReqTaxi:
; 2508 : 	case tReqTakeoff:
; 2509 : 	case tEmerStop:
; 2510 : 	case tTaxi:
; 2511 : 	case tWait:
; 2512 : 	case tHoldShort:
; 2513 : 	case tPrepToTakeRunway:
; 2514 : 	case tTakeRunway:
; 2515 : 	case tTakeoff:
; 2516 : 	case tFlyOut:
; 2517 : 	case tTaxiBack:
; 2518 : 		TranslatePointData (self, GetNextPt(GetFirstPt(rwindex)), &px, &py);

	lea	eax, DWORD PTR _py$[ebp]
	push	eax
	lea	ecx, DWORD PTR _px$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rwindex$[ebp]
	push	edx
	call	?GetFirstPt@@YAHH@Z			; GetFirstPt
	add	esp, 4
	push	eax
	call	?GetNextPt@@YAHH@Z			; GetNextPt
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData
	add	esp, 16					; 00000010H
$LN2@DetermineA:
$LN7@DetermineA:

; 2519 : 		break;
; 2520 : 	default:
; 2521 : 		//we should never get here
; 2522 : 		ShiWarning("We are in an undefined state, we shouldn't be here");
; 2523 : 		break;
; 2524 : 	}
; 2525 : 
; 2526 : 	//this is declared backwards because the runway heading is opposite the
; 2527 : 	//heading we need to have when landing
; 2528 : 	if (aircraft)

	cmp	DWORD PTR _aircraft$[ebp], 0
	je	$LN1@DetermineA

; 2529 : 	{
; 2530 : 		dx = aircraft->XPos() - px;

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv196[ebp]
	movss	xmm0, DWORD PTR tv196[ebp]
	subss	xmm0, DWORD PTR _px$[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 2531 : 		dy = aircraft->YPos() - py;

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv200[ebp]
	movss	xmm0, DWORD PTR tv200[ebp]
	subss	xmm0, DWORD PTR _py$[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 2532 : 		norm = (float)(1.0F/sqrt(dx * dx + dy * dy));

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv207[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR tv207[ebp]
	movss	DWORD PTR _norm$[ebp], xmm0

; 2533 : 		dx *= norm;

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _norm$[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 2534 : 		dy *= norm;

	movss	xmm0, DWORD PTR _dy$[ebp]
	mulss	xmm0, DWORD PTR _norm$[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 2535 : 
; 2536 : 		cosAngle =	dx * PtHeaderDataTable[rwindex].cosHeading + 
; 2537 : 					dy * PtHeaderDataTable[rwindex].sinHeading;

	mov	edx, DWORD PTR _rwindex$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR [eax+edx+16]
	mov	ecx, DWORD PTR _rwindex$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR [edx+ecx+12]
	addss	xmm0, xmm1
	movss	DWORD PTR _cosAngle$[ebp], xmm0
$LN1@DetermineA:

; 2538 : 	}
; 2539 : 
; 2540 : 	return cosAngle;

	fld	DWORD PTR _cosAngle$[ebp]

; 2541 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	3
$LN12@DetermineA:
	DD	$LN3@DetermineA
	DD	$LN6@DetermineA
	DD	$LN4@DetermineA
$LN11@DetermineA:
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	2
	DB	2
	DB	0
	DB	0
	DB	1
	DB	1
	DB	2
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
?DetermineAngle@ATCBrain@@QAEMPAVAircraftClass@@HW4AtcStatusEnum@@@Z ENDP ; ATCBrain::DetermineAngle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_prev$ = -16						; size = 4
_this$ = -12						; size = 4
_tempDelta$ = -8					; size = 4
_cur$ = -4						; size = 4
_queue$ = 8						; size = 4
_rwTime$ = 12						; size = 4
_delta$ = 16						; size = 4
?GetNextAvailRunwayTime@ATCBrain@@QAEKHKK@Z PROC	; ATCBrain::GetNextAvailRunwayTime
; _this$ = ecx

; 2621 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2622 : 	runwayQueueStruct *cur = runwayQueue[queue];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _queue$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _cur$[ebp], eax

; 2623 : 	runwayQueueStruct *prev = NULL;

	mov	DWORD PTR _prev$[ebp], 0

; 2624 : 	ulong tempDelta;
; 2625 : 
; 2626 : 	if(!cur)

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN19@GetNextAva

; 2627 : 	{
; 2628 : 		//flights may ahve been given a time that is already past
; 2629 : 		//when they deaggregate, but we don't want to give out ancient
; 2630 : 		//takeoff times
; 2631 : 		if(rwTime + 30 * CampaignSeconds < SimLibElapsedTime)

	mov	ecx, DWORD PTR _rwTime$[ebp]
	add	ecx, 30000				; 00007530H
	cmp	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	SHORT $LN18@GetNextAva

; 2632 : 			rwTime = SimLibElapsedTime;

	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR _rwTime$[ebp], edx
$LN18@GetNextAva:

; 2633 : 		return rwTime;

	mov	eax, DWORD PTR _rwTime$[ebp]
	jmp	$LN20@GetNextAva
$LN19@GetNextAva:

; 2634 : 	}
; 2635 : 
; 2636 : 	if(cur->aircraftID == runwayStats[queue].nextEmergency || (cur->status >= lEmergencyToBase && cur->status <= lEmergencyOnFinal))

	mov	eax, DWORD PTR _queue$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	lea	eax, DWORD PTR [edx+eax+32]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN16@GetNextAva
	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+8], 15			; 0000000fH
	jl	SHORT $LN17@GetNextAva
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+8], 17			; 00000011H
	jg	SHORT $LN17@GetNextAva
$LN16@GetNextAva:

; 2637 : 		tempDelta = EMER_SLOT;

	mov	DWORD PTR _tempDelta$[ebp], 60000	; 0000ea60H

; 2638 : 	else 

	jmp	SHORT $LN14@GetNextAva
$LN17@GetNextAva:

; 2639 : 		tempDelta = delta;

	mov	ecx, DWORD PTR _delta$[ebp]
	mov	DWORD PTR _tempDelta$[ebp], ecx
$LN14@GetNextAva:

; 2640 : 
; 2641 : 	while(cur && (cur->schedTime < rwTime || (rwTime < cur->schedTime && rwTime + tempDelta > cur->schedTime) ) )

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN13@GetNextAva
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+12]
	cmp	eax, DWORD PTR _rwTime$[ebp]
	jb	SHORT $LN12@GetNextAva
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _rwTime$[ebp]
	cmp	edx, DWORD PTR [ecx+12]
	jae	SHORT $LN13@GetNextAva
	mov	eax, DWORD PTR _rwTime$[ebp]
	add	eax, DWORD PTR _tempDelta$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	eax, DWORD PTR [ecx+12]
	jbe	SHORT $LN13@GetNextAva
$LN12@GetNextAva:

; 2642 : 	{
; 2643 : 		if(cur->aircraftID == runwayStats[queue].nextEmergency || (cur->status >= lEmergencyToBase && cur->status <= lEmergencyOnFinal))

	mov	edx, DWORD PTR _queue$[ebp]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	lea	edx, DWORD PTR [ecx+edx+32]
	push	edx
	mov	ecx, DWORD PTR _cur$[ebp]
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN10@GetNextAva
	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+8], 15			; 0000000fH
	jl	SHORT $LN11@GetNextAva
	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+8], 17			; 00000011H
	jg	SHORT $LN11@GetNextAva
$LN10@GetNextAva:

; 2644 : 			tempDelta = EMER_SLOT;

	mov	DWORD PTR _tempDelta$[ebp], 60000	; 0000ea60H

; 2645 : 		else 

	jmp	SHORT $LN9@GetNextAva
$LN11@GetNextAva:

; 2646 : 			tempDelta = delta;

	mov	eax, DWORD PTR _delta$[ebp]
	mov	DWORD PTR _tempDelta$[ebp], eax
$LN9@GetNextAva:

; 2647 : 
; 2648 : 		if(rwTime < cur->schedTime + tempDelta)

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, DWORD PTR _tempDelta$[ebp]
	cmp	DWORD PTR _rwTime$[ebp], edx
	jae	SHORT $LN8@GetNextAva

; 2649 : 			rwTime = cur->schedTime + tempDelta;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, DWORD PTR _tempDelta$[ebp]
	mov	DWORD PTR _rwTime$[ebp], ecx
$LN8@GetNextAva:

; 2650 : 		prev = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _prev$[ebp], edx

; 2651 : 		cur = cur->next;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _cur$[ebp], ecx

; 2652 : 	}

	jmp	$LN14@GetNextAva
$LN13@GetNextAva:

; 2653 : 
; 2654 : 	cur = prev;

	mov	edx, DWORD PTR _prev$[ebp]
	mov	DWORD PTR _cur$[ebp], edx
$LN7@GetNextAva:

; 2655 : 
; 2656 : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN6@GetNextAva

; 2657 : 	{
; 2658 : 		if(cur->aircraftID == runwayStats[queue].nextEmergency || (cur->status >= lEmergencyToBase && cur->status <= lEmergencyOnFinal))

	mov	eax, DWORD PTR _queue$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	lea	eax, DWORD PTR [edx+eax+32]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN4@GetNextAva
	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+8], 15			; 0000000fH
	jl	SHORT $LN5@GetNextAva
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+8], 17			; 00000011H
	jg	SHORT $LN5@GetNextAva
$LN4@GetNextAva:

; 2659 : 			tempDelta = EMER_SLOT;

	mov	DWORD PTR _tempDelta$[ebp], 60000	; 0000ea60H

; 2660 : 		else 

	jmp	SHORT $LN3@GetNextAva
$LN5@GetNextAva:

; 2661 : 			tempDelta = delta;

	mov	ecx, DWORD PTR _delta$[ebp]
	mov	DWORD PTR _tempDelta$[ebp], ecx
$LN3@GetNextAva:

; 2662 : 
; 2663 : 		if(rwTime < cur->schedTime + tempDelta)

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, DWORD PTR _tempDelta$[ebp]
	cmp	DWORD PTR _rwTime$[ebp], eax
	jae	SHORT $LN2@GetNextAva

; 2664 : 			rwTime = cur->schedTime + tempDelta;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, DWORD PTR _tempDelta$[ebp]
	mov	DWORD PTR _rwTime$[ebp], edx
$LN2@GetNextAva:

; 2665 : 		if(cur->next && cur->schedTime + tempDelta + LAND_TIME_DELTA <= cur->next->schedTime && rwTime + tempDelta < cur->next->schedTime)

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN1@GetNextAva
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _tempDelta$[ebp]
	lea	ecx, DWORD PTR [edx+eax+60000]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+24]
	cmp	ecx, DWORD PTR [eax+12]
	ja	SHORT $LN1@GetNextAva
	mov	ecx, DWORD PTR _rwTime$[ebp]
	add	ecx, DWORD PTR _tempDelta$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+24]
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN1@GetNextAva

; 2666 : 		{
; 2667 : 			ShiAssert(rwTime >= cur->schedTime + tempDelta);
; 2668 : 			ShiAssert(rwTime + tempDelta <= cur->next->schedTime);
; 2669 : 			break;

	jmp	SHORT $LN6@GetNextAva
$LN1@GetNextAva:

; 2670 : 		}
; 2671 : 
; 2672 : 		cur = cur->next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _cur$[ebp], edx

; 2673 : 	}

	jmp	$LN7@GetNextAva
$LN6@GetNextAva:

; 2674 : 
; 2675 : 	return rwTime; 

	mov	eax, DWORD PTR _rwTime$[ebp]
$LN20@GetNextAva:

; 2676 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetNextAvailRunwayTime@ATCBrain@@QAEKHKK@Z ENDP	; ATCBrain::GetNextAvailRunwayTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
tv309 = -100						; size = 8
_Trig$ = -92						; size = 8
_z$1 = -84						; size = 4
tv383 = -80						; size = 4
tv377 = -76						; size = 4
_this$ = -72						; size = 4
tv300 = -68						; size = 4
tv255 = -64						; size = 4
tv250 = -60						; size = 4
tv246 = -56						; size = 4
_norm$2 = -52						; size = 4
_avgDecelSpd$ = -48					; size = 4
tv306 = -44						; size = 4
_decelTime$ = -40					; size = 4
_legHeading$ = -36					; size = 4
_hdgToPt$ = -32						; size = 4
_PatternSpd$ = -28					; size = 4
_deltaTime$ = -24					; size = 4
_dist$ = -20						; size = 4
_totalDist$ = -16					; size = 4
_legAngle$ = -12					; size = 4
_dy$ = -8						; size = 4
_dx$ = -4						; size = 4
_approaching$ = 8					; size = 4
_rwindex$ = 12						; size = 4
_schedTime$ = 16					; size = 4
_pointX$ = 20						; size = 4
_pointY$ = 24						; size = 4
_usebase$ = 28						; size = 4
_x$ = 32						; size = 4
_y$ = 36						; size = 4
?FindFirstLegPt@ATCBrain@@QAE?AW4AtcStatusEnum@@PAVAircraftClass@@HKMMHPAM1@Z PROC ; ATCBrain::FindFirstLegPt
; _this$ = ecx

; 3296 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	DWORD PTR _this$[ebp], ecx

; 3297 : 	float	dist=0.0F, totalDist=0.0F, legAngle=0.0F, legHeading=0.0F, hdgToPt=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _dist$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _totalDist$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _legAngle$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _legHeading$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _hdgToPt$[ebp], xmm0

; 3298 : 	float	dx=0.0F, dy=0.0F, PatternSpd=0.0F, decelTime=0.0F, avgDecelSpd=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _dx$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _dy$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _PatternSpd$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _decelTime$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _avgDecelSpd$[ebp], xmm0

; 3299 : 	float	deltaTime=0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _deltaTime$[ebp], xmm0

; 3300 : 	mlTrig	Trig;
; 3301 : 
; 3302 : 	PatternSpd = approaching->af->MinVcas() * KNOTS_TO_FTPSEC;

	mov	eax, DWORD PTR _approaching$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv246[ebp]
	movss	xmm0, DWORD PTR tv246[ebp]
	mulss	xmm0, DWORD PTR __real@3fd80b03
	movss	DWORD PTR _PatternSpd$[ebp], xmm0

; 3303 : 
; 3304 : 	dx = pointX - approaching->XPos();

	mov	ecx, DWORD PTR _approaching$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv250[ebp]
	movss	xmm0, DWORD PTR _pointX$[ebp]
	subss	xmm0, DWORD PTR tv250[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 3305 : 	dy = pointY - approaching->YPos();

	mov	ecx, DWORD PTR _approaching$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv255[ebp]
	movss	xmm0, DWORD PTR _pointY$[ebp]
	subss	xmm0, DWORD PTR tv255[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 3306 : 
; 3307 : 	dist = (float)sqrt(dx * dx + dy * dy);

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]

; 3308 : 
; 3309 : 	//assume a 5knot/s deceleration
; 3310 : 	decelTime = (float)fabs(approaching->af->vt - PatternSpd)*0.2F;

	mov	ecx, DWORD PTR _approaching$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR [edx+1120]
	subss	xmm0, DWORD PTR _PatternSpd$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?fabs@@YAMM@Z				; fabs
	add	esp, 4
	fstp	DWORD PTR tv300[ebp]
	movss	xmm0, DWORD PTR tv300[ebp]
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	movss	DWORD PTR _decelTime$[ebp], xmm0

; 3311 : 	avgDecelSpd = (approaching->af->vt + PatternSpd)*0.5F;

	mov	eax, DWORD PTR _approaching$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1120]
	addss	xmm0, DWORD PTR _PatternSpd$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _avgDecelSpd$[ebp], xmm0

; 3312 : 
; 3313 : 	deltaTime = (float)(schedTime - FINAL_TIME - BASE_TIME *  usebase - SimLibElapsedTime)/CampaignSeconds;

	mov	edx, DWORD PTR _schedTime$[ebp]
	sub	edx, 120000				; 0001d4c0H
	mov	eax, DWORD PTR _usebase$[ebp]
	imul	eax, 60000				; 0000ea60H
	sub	edx, eax
	sub	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR tv306[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv306[ebp]
	mov	ecx, DWORD PTR tv306[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	QWORD PTR tv309[ebp], xmm0
	cvtsd2ss xmm0, QWORD PTR tv309[ebp]
	divss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR _deltaTime$[ebp], xmm0

; 3314 : 
; 3315 : 	if(deltaTime < -10.0F)

	movss	xmm0, DWORD PTR __real@c1200000
	comiss	xmm0, DWORD PTR _deltaTime$[ebp]
	jbe	SHORT $LN12@FindFirstL

; 3316 : 	{
; 3317 : 		//hmmm, we don't have enough time for the base pt
; 3318 : 		if(deltaTime > -BASE_TIME/CampaignSeconds && usebase)

	movss	xmm0, DWORD PTR _deltaTime$[ebp]
	comiss	xmm0, DWORD PTR __real@c2700000
	jbe	SHORT $LN13@FindFirstL
	cmp	DWORD PTR _usebase$[ebp], 0
	je	SHORT $LN13@FindFirstL

; 3319 : 		{
; 3320 : 			*x = pointX;

	mov	edx, DWORD PTR _x$[ebp]
	movss	xmm0, DWORD PTR _pointX$[ebp]
	movss	DWORD PTR [edx], xmm0

; 3321 : 			*y = pointY;

	mov	eax, DWORD PTR _y$[ebp]
	movss	xmm0, DWORD PTR _pointY$[ebp]
	movss	DWORD PTR [eax], xmm0

; 3322 : 			return lToFinal;

	mov	eax, 10					; 0000000aH
	jmp	$LN15@FindFirstL

; 3323 : 		}
; 3324 : 		else

	jmp	SHORT $LN12@FindFirstL
$LN13@FindFirstL:

; 3325 : 		{
; 3326 : 			//can't make a final approach, and arrive in time
; 3327 : 			float z;
; 3328 : 			FindAbortPt(approaching, x, y, &z);

	lea	ecx, DWORD PTR _z$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _approaching$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindAbortPt@ATCBrain@@QAEXPAVAircraftClass@@PAM11@Z ; ATCBrain::FindAbortPt

; 3329 : 			return lAborted;

	mov	eax, 5
	jmp	$LN15@FindFirstL
$LN12@FindFirstL:

; 3330 : 		}
; 3331 : 
; 3332 : 	}
; 3333 : //cobra this fixes aborts not ever being allowed to come back  
; 3334 : 	/*if(deltaTime < decelTime)
; 3335 : 	{
; 3336 : 		*x = approaching->XPos();
; 3337 : 		*y = approaching->YPos();
; 3338 : 		return lHolding;
; 3339 : 	}*/
; 3340 : 
; 3341 : 	totalDist = decelTime * avgDecelSpd + PatternSpd * (deltaTime - decelTime);

	movss	xmm0, DWORD PTR _decelTime$[ebp]
	mulss	xmm0, DWORD PTR _avgDecelSpd$[ebp]
	movss	xmm1, DWORD PTR _deltaTime$[ebp]
	subss	xmm1, DWORD PTR _decelTime$[ebp]
	mulss	xmm1, DWORD PTR _PatternSpd$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _totalDist$[ebp], xmm0

; 3342 : 
; 3343 : 	if(totalDist > dist)

	movss	xmm0, DWORD PTR _totalDist$[ebp]
	comiss	xmm0, DWORD PTR _dist$[ebp]
	jbe	SHORT $LN11@FindFirstL

; 3344 : 		legAngle = (float)acos(dist / totalDist);

	movss	xmm0, DWORD PTR _dist$[ebp]
	divss	xmm0, DWORD PTR _totalDist$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?acos@@YAMM@Z				; acos
	add	esp, 4
	fstp	DWORD PTR _legAngle$[ebp]
$LN11@FindFirstL:

; 3345 : 
; 3346 : 	//legAngle = atan2( sqrt(totalDist*totalDist*0.25F - dist*dist*0.25F), dist*0.5F );
; 3347 : 
; 3348 : 	if(legAngle < 10.0F * DTR || totalDist <= dist)

	movss	xmm0, DWORD PTR __real@3e32b8c1
	comiss	xmm0, DWORD PTR _legAngle$[ebp]
	ja	SHORT $LN9@FindFirstL
	movss	xmm0, DWORD PTR _dist$[ebp]
	comiss	xmm0, DWORD PTR _totalDist$[ebp]
	jb	SHORT $LN10@FindFirstL
$LN9@FindFirstL:

; 3349 : 	{
; 3350 : 		//if less than 10 degrees, just fly to  the base/final pt 		
; 3351 : 		*x = pointX;

	mov	edx, DWORD PTR _x$[ebp]
	movss	xmm0, DWORD PTR _pointX$[ebp]
	movss	DWORD PTR [edx], xmm0

; 3352 : 		*y = pointY;

	mov	eax, DWORD PTR _y$[ebp]
	movss	xmm0, DWORD PTR _pointY$[ebp]
	movss	DWORD PTR [eax], xmm0

; 3353 : 
; 3354 : 		if(usebase)

	cmp	DWORD PTR _usebase$[ebp], 0
	je	SHORT $LN8@FindFirstL

; 3355 : 			return lToBase;

	mov	eax, 9
	jmp	$LN15@FindFirstL

; 3356 : 		else

	jmp	SHORT $LN7@FindFirstL
$LN8@FindFirstL:

; 3357 : 			return lToFinal;

	mov	eax, 10					; 0000000aH
	jmp	$LN15@FindFirstL
$LN7@FindFirstL:
	jmp	SHORT $LN5@FindFirstL
$LN10@FindFirstL:

; 3358 : 	}
; 3359 : 	else if(legAngle > 70.0F * DTR)

	movss	xmm0, DWORD PTR _legAngle$[ebp]
	comiss	xmm0, DWORD PTR __real@3f9c61a9
	jbe	SHORT $LN5@FindFirstL

; 3360 : 	{
; 3361 : 		*x = approaching->XPos();

	mov	ecx, DWORD PTR _approaching$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	mov	ecx, DWORD PTR _x$[ebp]
	fstp	DWORD PTR [ecx]

; 3362 : 		*y = approaching->YPos();

	mov	ecx, DWORD PTR _approaching$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	mov	edx, DWORD PTR _y$[ebp]
	fstp	DWORD PTR [edx]

; 3363 : 		return lHolding;

	mov	eax, 7
	jmp	$LN15@FindFirstL
$LN5@FindFirstL:

; 3364 : 	}
; 3365 : 	
; 3366 : 	hdgToPt = (float)atan2(dy, dx);

	cvtss2sd xmm0, DWORD PTR _dx$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	cvtss2sd xmm0, DWORD PTR _dy$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _hdgToPt$[ebp]

; 3367 : 
; 3368 : 	if(PtHeaderDataTable[rwindex].ltrt)

	mov	eax, DWORD PTR _rwindex$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	edx, BYTE PTR [ecx+eax+25]
	test	edx, edx
	je	SHORT $LN4@FindFirstL

; 3369 : 		legHeading = hdgToPt + PtHeaderDataTable[rwindex].ltrt * legAngle;

	mov	eax, DWORD PTR _rwindex$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	edx, BYTE PTR [ecx+eax+25]
	cvtsi2ss xmm0, edx
	mulss	xmm0, DWORD PTR _legAngle$[ebp]
	addss	xmm0, DWORD PTR _hdgToPt$[ebp]
	movss	DWORD PTR _legHeading$[ebp], xmm0

; 3370 : 	else

	jmp	$LN1@FindFirstL
$LN4@FindFirstL:

; 3371 : 	{
; 3372 : 		float norm = (float)(1.0F/dist);

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR _norm$2[ebp], xmm0

; 3373 : 		dx *= norm;

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _norm$2[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 3374 : 		dy *= norm;

	movss	xmm0, DWORD PTR _dy$[ebp]
	mulss	xmm0, DWORD PTR _norm$2[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 3375 : 
; 3376 : 		if(dx * -PtHeaderDataTable[rwindex].sinHeading + dy * PtHeaderDataTable[rwindex].cosHeading > 0.0F)

	mov	eax, DWORD PTR _rwindex$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm0, DWORD PTR [ecx+eax+12]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	mulss	xmm0, DWORD PTR _dx$[ebp]
	mov	edx, DWORD PTR _rwindex$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR [eax+edx+16]
	addss	xmm0, xmm1
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN2@FindFirstL

; 3377 : 		{
; 3378 : 			legHeading = hdgToPt - legAngle;

	movss	xmm0, DWORD PTR _hdgToPt$[ebp]
	subss	xmm0, DWORD PTR _legAngle$[ebp]
	movss	DWORD PTR _legHeading$[ebp], xmm0

; 3379 : 		}
; 3380 : 		else

	jmp	SHORT $LN1@FindFirstL
$LN2@FindFirstL:

; 3381 : 			legHeading = hdgToPt + legAngle;

	movss	xmm0, DWORD PTR _hdgToPt$[ebp]
	addss	xmm0, DWORD PTR _legAngle$[ebp]
	movss	DWORD PTR _legHeading$[ebp], xmm0
$LN1@FindFirstL:

; 3382 : 		
; 3383 : 		//for now always go right then left on the legs
; 3384 : 		//if necessary we will calculate the best direction to turn first
; 3385 : 		//legHeading = hdgToPt + legAngle;
; 3386 : 	}
; 3387 : 
; 3388 : 	mlSinCos(&Trig, legHeading);

	push	ecx
	movss	xmm0, DWORD PTR _legHeading$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _Trig$[ebp]
	push	ecx
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 3389 : 
; 3390 : 	*x = approaching->XPos() + Trig.cos * totalDist * 0.5F;

	mov	ecx, DWORD PTR _approaching$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv377[ebp]
	movss	xmm0, DWORD PTR tv377[ebp]
	movss	xmm1, DWORD PTR _Trig$[ebp+4]
	mulss	xmm1, DWORD PTR _totalDist$[ebp]
	mulss	xmm1, DWORD PTR __real@3f000000
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _x$[ebp]
	movss	DWORD PTR [edx], xmm0

; 3391 : 	*y = approaching->YPos() + Trig.sin * totalDist * 0.5F;

	mov	ecx, DWORD PTR _approaching$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv383[ebp]
	movss	xmm0, DWORD PTR tv383[ebp]
	movss	xmm1, DWORD PTR _Trig$[ebp]
	mulss	xmm1, DWORD PTR _totalDist$[ebp]
	mulss	xmm1, DWORD PTR __real@3f000000
	addss	xmm0, xmm1
	mov	eax, DWORD PTR _y$[ebp]
	movss	DWORD PTR [eax], xmm0

; 3392 : 
; 3393 : 	return lFirstLeg;

	mov	eax, 8
$LN15@FindFirstL:

; 3394 : 
; 3395 : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?FindFirstLegPt@ATCBrain@@QAE?AW4AtcStatusEnum@@PAVAircraftClass@@HKMMHPAM1@Z ENDP ; ATCBrain::FindFirstLegPt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_this$ = -44						; size = 4
tv217 = -40						; size = 4
tv201 = -36						; size = 4
tv193 = -32						; size = 4
tv188 = -28						; size = 4
_dist$ = -24						; size = 4
_norm$ = -20						; size = 4
_sinAngle$ = -16					; size = 4
_cosAngle$ = -12					; size = 4
_dx$ = -8						; size = 4
_dy$ = -4						; size = 4
_approaching$ = 8					; size = 4
_rwindex$ = 12						; size = 4
_finalX$ = 16						; size = 4
_finalY$ = 20						; size = 4
_x$ = 24						; size = 4
_y$ = 28						; size = 4
?FindBasePt@ATCBrain@@QAE?AW4AtcStatusEnum@@PAVAircraftClass@@HMMPAM1@Z PROC ; ATCBrain::FindBasePt
; _this$ = ecx

; 3255 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 3256 : 	float	dist, cosAngle, sinAngle, dx, dy, norm;
; 3257 : 
; 3258 : 	dx = dy = 0.0F;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _dy$[ebp], xmm0
	movss	xmm0, DWORD PTR _dy$[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 3259 : 	
; 3260 : 	if(PtHeaderDataTable[rwindex].ltrt > 0)

	mov	eax, DWORD PTR _rwindex$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	edx, BYTE PTR [ecx+eax+25]
	test	edx, edx
	jle	SHORT $LN4@FindBasePt

; 3261 : 	{
; 3262 : 		//want sin and cos of heading 90 degrees to right of runway heading
; 3263 : 		cosAngle = -PtHeaderDataTable[rwindex].sinHeading;

	mov	eax, DWORD PTR _rwindex$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm0, DWORD PTR [ecx+eax+12]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _cosAngle$[ebp], xmm0

; 3264 : 		sinAngle = PtHeaderDataTable[rwindex].cosHeading;		

	mov	edx, DWORD PTR _rwindex$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm0, DWORD PTR [eax+edx+16]
	movss	DWORD PTR _sinAngle$[ebp], xmm0

; 3265 : 	}
; 3266 : 	else

	jmp	$LN1@FindBasePt
$LN4@FindBasePt:

; 3267 : 	{
; 3268 : 		cosAngle = PtHeaderDataTable[rwindex].sinHeading;

	mov	ecx, DWORD PTR _rwindex$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm0, DWORD PTR [edx+ecx+12]
	movss	DWORD PTR _cosAngle$[ebp], xmm0

; 3269 : 		sinAngle = -PtHeaderDataTable[rwindex].cosHeading;

	mov	eax, DWORD PTR _rwindex$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm0, DWORD PTR [ecx+eax+16]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _sinAngle$[ebp], xmm0

; 3270 : 
; 3271 : 		if(PtHeaderDataTable[rwindex].ltrt == 0)

	mov	edx, DWORD PTR _rwindex$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	ecx, BYTE PTR [eax+edx+25]
	test	ecx, ecx
	jne	$LN1@FindBasePt

; 3272 : 		{
; 3273 : 			dx = finalX - approaching->XPos();

	mov	ecx, DWORD PTR _approaching$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv188[ebp]
	movss	xmm0, DWORD PTR _finalX$[ebp]
	subss	xmm0, DWORD PTR tv188[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 3274 : 			dy = finalY - approaching->YPos();

	mov	ecx, DWORD PTR _approaching$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv193[ebp]
	movss	xmm0, DWORD PTR _finalY$[ebp]
	subss	xmm0, DWORD PTR tv193[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 3275 : 			norm = (float)(1.0F/sqrt(dx * dx + dy * dy));

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv201[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, DWORD PTR tv201[ebp]
	movss	DWORD PTR _norm$[ebp], xmm0

; 3276 : 			dx *= norm;

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _norm$[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 3277 : 			dy *= norm;

	movss	xmm0, DWORD PTR _dy$[ebp]
	mulss	xmm0, DWORD PTR _norm$[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 3278 : 
; 3279 : 			if(dx * cosAngle + dy * sinAngle > 0.0F)

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _cosAngle$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _sinAngle$[ebp]
	addss	xmm0, xmm1
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN1@FindBasePt

; 3280 : 			{
; 3281 : 				cosAngle = -PtHeaderDataTable[rwindex].sinHeading;

	mov	edx, DWORD PTR _rwindex$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm0, DWORD PTR [eax+edx+12]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _cosAngle$[ebp], xmm0

; 3282 : 				sinAngle = PtHeaderDataTable[rwindex].cosHeading;

	mov	ecx, DWORD PTR _rwindex$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm0, DWORD PTR [edx+ecx+16]
	movss	DWORD PTR _sinAngle$[ebp], xmm0
$LN1@FindBasePt:

; 3283 : 			}
; 3284 : 		}
; 3285 : 	}
; 3286 : 
; 3287 : 	dist = approaching->af->MinVcas() * KNOTS_TO_FTPSEC * BASE_TIME/CampaignSeconds;

	mov	eax, DWORD PTR _approaching$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv217[ebp]
	movss	xmm0, DWORD PTR tv217[ebp]
	mulss	xmm0, DWORD PTR __real@3fd80b03
	mulss	xmm0, DWORD PTR __real@476a6000
	divss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR _dist$[ebp], xmm0

; 3288 : 	
; 3289 : 	*x = finalX + dist * cosAngle;

	movss	xmm0, DWORD PTR _dist$[ebp]
	mulss	xmm0, DWORD PTR _cosAngle$[ebp]
	addss	xmm0, DWORD PTR _finalX$[ebp]
	mov	ecx, DWORD PTR _x$[ebp]
	movss	DWORD PTR [ecx], xmm0

; 3290 : 	*y = finalY + dist * sinAngle;

	movss	xmm0, DWORD PTR _dist$[ebp]
	mulss	xmm0, DWORD PTR _sinAngle$[ebp]
	addss	xmm0, DWORD PTR _finalY$[ebp]
	mov	edx, DWORD PTR _y$[ebp]
	movss	DWORD PTR [edx], xmm0

; 3291 : 	return lToBase;

	mov	eax, 9

; 3292 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?FindBasePt@ATCBrain@@QAE?AW4AtcStatusEnum@@PAVAircraftClass@@HMMPAM1@Z ENDP ; ATCBrain::FindBasePt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_py$ = -20						; size = 4
_px$ = -16						; size = 4
tv134 = -12						; size = 4
_this$ = -8						; size = 4
_dist$ = -4						; size = 4
_approaching$ = 8					; size = 4
_rwindex$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
?FindFinalPt@ATCBrain@@QAEXPAVAircraftClass@@HPAM1@Z PROC ; ATCBrain::FindFinalPt
; _this$ = ecx

; 3239 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 3240 : 	float	dist;
; 3241 : 	float	px,py;
; 3242 : 
; 3243 : 	TranslatePointData (self, GetFirstPt(rwindex), &px, &py);

	lea	eax, DWORD PTR _py$[ebp]
	push	eax
	lea	ecx, DWORD PTR _px$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rwindex$[ebp]
	push	edx
	call	?GetFirstPt@@YAHH@Z			; GetFirstPt
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData
	add	esp, 16					; 00000010H

; 3244 : 
; 3245 : 	//assume landing speed is 60% MinVcas use linear decel from minvcas
; 3246 : 	dist = 0.8F * approaching->af->MinVcas() * KNOTS_TO_FTPSEC * FINAL_TIME/CampaignSeconds;

	mov	edx, DWORD PTR _approaching$[ebp]
	mov	ecx, DWORD PTR [edx+932]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv134[ebp]
	movss	xmm0, DWORD PTR tv134[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	mulss	xmm0, DWORD PTR __real@3fd80b03
	mulss	xmm0, DWORD PTR __real@47ea6000
	divss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR _dist$[ebp], xmm0

; 3247 : 
; 3248 : 	*x = px + dist * PtHeaderDataTable[rwindex].cosHeading;

	mov	eax, DWORD PTR _rwindex$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm0, DWORD PTR _dist$[ebp]
	mulss	xmm0, DWORD PTR [ecx+eax+16]
	addss	xmm0, DWORD PTR _px$[ebp]
	mov	edx, DWORD PTR _x$[ebp]
	movss	DWORD PTR [edx], xmm0

; 3249 : 	*y = py + dist * PtHeaderDataTable[rwindex].sinHeading;

	mov	eax, DWORD PTR _rwindex$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm0, DWORD PTR _dist$[ebp]
	mulss	xmm0, DWORD PTR [ecx+eax+12]
	addss	xmm0, DWORD PTR _py$[ebp]
	mov	edx, DWORD PTR _y$[ebp]
	movss	DWORD PTR [edx], xmm0

; 3250 : 
; 3251 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?FindFinalPt@ATCBrain@@QAEXPAVAircraftClass@@HPAM1@Z ENDP ; ATCBrain::FindFinalPt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_Trig$ = -24						; size = 8
_point$ = -16						; size = 4
_heading$ = -12						; size = 4
_dir$ = -8						; size = 4
_this$ = -4						; size = 4
_flight$ = 8						; size = 4
_vehicleInUnit$ = 12					; size = 4
_rwindex$ = 16						; size = 4
_x$ = 20						; size = 4
_y$ = 24						; size = 4
?FindRunwayPt@ATCBrain@@QAEHPAVFlightClass@@HHPAM1@Z PROC ; ATCBrain::FindRunwayPt
; _this$ = ecx

; 3439 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 3440 : 	int		point;
; 3441 : 	float	heading, dir;
; 3442 : 	mlTrig	Trig;
; 3443 : 
; 3444 : 	point = GetFirstPt(rwindex);

	mov	eax, DWORD PTR _rwindex$[ebp]
	push	eax
	call	?GetFirstPt@@YAHH@Z			; GetFirstPt
	add	esp, 4
	mov	DWORD PTR _point$[ebp], eax

; 3445 : 	TranslatePointData (self, point, x, y);

	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	eax, DWORD PTR _point$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData
	add	esp, 16					; 00000010H

; 3446 : 
; 3447 : 	if (UseSectionTakeoff(flight, rwindex) )		

	mov	eax, DWORD PTR _rwindex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _flight$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UseSectionTakeoff@ATCBrain@@QAEHPAVFlightClass@@H@Z ; ATCBrain::UseSectionTakeoff
	test	eax, eax
	je	$LN5@FindRunway

; 3448 : 	{
; 3449 : 		if(PtHeaderDataTable[rwindex].ltrt)

	mov	edx, DWORD PTR _rwindex$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	ecx, BYTE PTR [eax+edx+25]
	test	ecx, ecx
	je	SHORT $LN4@FindRunway

; 3450 : 			dir = PtHeaderDataTable[rwindex].ltrt;

	mov	edx, DWORD PTR _rwindex$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	ecx, BYTE PTR [eax+edx+25]
	cvtsi2ss xmm0, ecx
	movss	DWORD PTR _dir$[ebp], xmm0

; 3451 : 		else

	jmp	SHORT $LN3@FindRunway
$LN4@FindRunway:

; 3452 : 			dir = 1.0F;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _dir$[ebp], xmm0
$LN3@FindRunway:

; 3453 : 
; 3454 : 		if(vehicleInUnit % 2)

	mov	edx, DWORD PTR _vehicleInUnit$[ebp]
	and	edx, -2147483647			; 80000001H
	jns	SHORT $LN8@FindRunway
	dec	edx
	or	edx, -2					; fffffffeH
	inc	edx
$LN8@FindRunway:
	test	edx, edx
	je	SHORT $LN2@FindRunway

; 3455 : 			heading = (PtHeaderDataTable[rwindex].data + dir * 90.0F)*DTR;

	mov	eax, DWORD PTR _rwindex$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	edx, WORD PTR [ecx+eax+10]
	cvtsi2ss xmm0, edx
	movss	xmm1, DWORD PTR _dir$[ebp]
	mulss	xmm1, DWORD PTR __real@42b40000
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	DWORD PTR _heading$[ebp], xmm0

; 3456 : 		else

	jmp	SHORT $LN1@FindRunway
$LN2@FindRunway:

; 3457 : 			heading = (PtHeaderDataTable[rwindex].data + dir * -90.0F)*DTR;

	mov	eax, DWORD PTR _rwindex$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	edx, WORD PTR [ecx+eax+10]
	cvtsi2ss xmm0, edx
	movss	xmm1, DWORD PTR _dir$[ebp]
	mulss	xmm1, DWORD PTR __real@c2b40000
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	DWORD PTR _heading$[ebp], xmm0
$LN1@FindRunway:

; 3458 : 
; 3459 : 		mlSinCos(&Trig, heading);

	push	ecx
	movss	xmm0, DWORD PTR _heading$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _Trig$[ebp]
	push	eax
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 3460 : 		
; 3461 : 		*x += runwayStats[PtHeaderDataTable[rwindex].runwayNum].halfwidth/2.0F * Trig.cos;

	mov	ecx, DWORD PTR _rwindex$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	eax, BYTE PTR [edx+ecx+24]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	movss	xmm0, DWORD PTR [edx+eax+8]
	divss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR _Trig$[ebp+4]
	mov	eax, DWORD PTR _x$[ebp]
	addss	xmm0, DWORD PTR [eax]
	mov	ecx, DWORD PTR _x$[ebp]
	movss	DWORD PTR [ecx], xmm0

; 3462 : 		*y += runwayStats[PtHeaderDataTable[rwindex].runwayNum].halfwidth/2.0F * Trig.sin;

	mov	edx, DWORD PTR _rwindex$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	ecx, BYTE PTR [eax+edx+24]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	movss	xmm0, DWORD PTR [eax+ecx+8]
	divss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR _Trig$[ebp]
	mov	ecx, DWORD PTR _y$[ebp]
	addss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _y$[ebp]
	movss	DWORD PTR [edx], xmm0
$LN5@FindRunway:

; 3463 : 	}
; 3464 : 
; 3465 : 	return point;

	mov	eax, DWORD PTR _point$[ebp]

; 3466 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?FindRunwayPt@ATCBrain@@QAEHPAVFlightClass@@HHPAM1@Z ENDP ; ATCBrain::FindRunwayPt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_Trig$ = -28						; size = 8
_classPtr$ = -20					; size = 4
_point$ = -16						; size = 4
_heading$ = -12						; size = 4
_dir$ = -8						; size = 4
_this$ = -4						; size = 4
_flight$ = 8						; size = 4
_vehicleInUnit$ = 12					; size = 4
_rwindex$ = 16						; size = 4
_x$ = 20						; size = 4
_y$ = 24						; size = 4
?FindTakeoffPt@ATCBrain@@QAEHPAVFlightClass@@HHPAM1@Z PROC ; ATCBrain::FindTakeoffPt
; _this$ = ecx

; 3399 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 3400 : 	int		point;
; 3401 : 	float	heading, dir;
; 3402 : 	mlTrig	Trig;
; 3403 : 	Falcon4EntityClassType* classPtr;
; 3404 : 
; 3405 : 	point = GetNextPtLoop(GetFirstPt(rwindex));

	mov	eax, DWORD PTR _rwindex$[ebp]
	push	eax
	call	?GetFirstPt@@YAHH@Z			; GetFirstPt
	add	esp, 4
	push	eax
	call	?GetNextPtLoop@@YAHH@Z			; GetNextPtLoop
	add	esp, 4
	mov	DWORD PTR _point$[ebp], eax

; 3406 : 
; 3407 : 	TranslatePointData (self, point, x, y);

	mov	ecx, DWORD PTR _y$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	eax, DWORD PTR _point$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData
	add	esp, 16					; 00000010H

; 3408 : 
; 3409 : 	classPtr = (Falcon4EntityClassType*)flight->EntityType();

	mov	ecx, DWORD PTR _flight$[ebp]
	call	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ; VuEntity::EntityType
	mov	DWORD PTR _classPtr$[ebp], eax

; 3410 : 	if (UseSectionTakeoff(flight, rwindex) )	

	mov	eax, DWORD PTR _rwindex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _flight$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UseSectionTakeoff@ATCBrain@@QAEHPAVFlightClass@@H@Z ; ATCBrain::UseSectionTakeoff
	test	eax, eax
	je	$LN1@FindTakeof

; 3411 : 	{
; 3412 : 		if(PtHeaderDataTable[rwindex].ltrt)

	mov	edx, DWORD PTR _rwindex$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	ecx, BYTE PTR [eax+edx+25]
	test	ecx, ecx
	je	SHORT $LN5@FindTakeof

; 3413 : 			dir = PtHeaderDataTable[rwindex].ltrt;

	mov	edx, DWORD PTR _rwindex$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	ecx, BYTE PTR [eax+edx+25]
	cvtsi2ss xmm0, ecx
	movss	DWORD PTR _dir$[ebp], xmm0

; 3414 : 		else

	jmp	SHORT $LN4@FindTakeof
$LN5@FindTakeof:

; 3415 : 			dir = 1.0F;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _dir$[ebp], xmm0
$LN4@FindTakeof:

; 3416 : 
; 3417 : 		if(vehicleInUnit % 2)

	mov	edx, DWORD PTR _vehicleInUnit$[ebp]
	and	edx, -2147483647			; 80000001H
	jns	SHORT $LN9@FindTakeof
	dec	edx
	or	edx, -2					; fffffffeH
	inc	edx
$LN9@FindTakeof:
	test	edx, edx
	je	SHORT $LN3@FindTakeof

; 3418 : 			heading = (PtHeaderDataTable[rwindex].data + dir * 90.0F)*DTR;

	mov	eax, DWORD PTR _rwindex$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	edx, WORD PTR [ecx+eax+10]
	cvtsi2ss xmm0, edx
	movss	xmm1, DWORD PTR _dir$[ebp]
	mulss	xmm1, DWORD PTR __real@42b40000
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	DWORD PTR _heading$[ebp], xmm0

; 3419 : 		else

	jmp	SHORT $LN2@FindTakeof
$LN3@FindTakeof:

; 3420 : 			heading = (PtHeaderDataTable[rwindex].data + dir * -90.0F)*DTR;

	mov	eax, DWORD PTR _rwindex$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	edx, WORD PTR [ecx+eax+10]
	cvtsi2ss xmm0, edx
	movss	xmm1, DWORD PTR _dir$[ebp]
	mulss	xmm1, DWORD PTR __real@c2b40000
	addss	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@3c8efa34
	movss	DWORD PTR _heading$[ebp], xmm0
$LN2@FindTakeof:

; 3421 : 
; 3422 : 		mlSinCos(&Trig, heading);

	push	ecx
	movss	xmm0, DWORD PTR _heading$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _Trig$[ebp]
	push	eax
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 3423 : 		*x += runwayStats[PtHeaderDataTable[rwindex].runwayNum].halfwidth/2.0F * Trig.cos;

	mov	ecx, DWORD PTR _rwindex$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	eax, BYTE PTR [edx+ecx+24]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	movss	xmm0, DWORD PTR [edx+eax+8]
	divss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR _Trig$[ebp+4]
	mov	eax, DWORD PTR _x$[ebp]
	addss	xmm0, DWORD PTR [eax]
	mov	ecx, DWORD PTR _x$[ebp]
	movss	DWORD PTR [ecx], xmm0

; 3424 : 		*y += runwayStats[PtHeaderDataTable[rwindex].runwayNum].halfwidth/2.0F * Trig.sin;

	mov	edx, DWORD PTR _rwindex$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	ecx, BYTE PTR [eax+edx+24]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	movss	xmm0, DWORD PTR [eax+ecx+8]
	divss	xmm0, DWORD PTR __real@40000000
	mulss	xmm0, DWORD PTR _Trig$[ebp]
	mov	ecx, DWORD PTR _y$[ebp]
	addss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _y$[ebp]
	movss	DWORD PTR [edx], xmm0

; 3425 : 
; 3426 : 		if(!(vehicleInUnit % 2))

	mov	eax, DWORD PTR _vehicleInUnit$[ebp]
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN10@FindTakeof
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN10@FindTakeof:
	test	eax, eax
	jne	SHORT $LN1@FindTakeof

; 3427 : 		{
; 3428 : 			*x += PtHeaderDataTable[rwindex].cosHeading * 100.0F;

	mov	ecx, DWORD PTR _rwindex$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm0, DWORD PTR [edx+ecx+16]
	mulss	xmm0, DWORD PTR __real@42c80000
	mov	eax, DWORD PTR _x$[ebp]
	addss	xmm0, DWORD PTR [eax]
	mov	ecx, DWORD PTR _x$[ebp]
	movss	DWORD PTR [ecx], xmm0

; 3429 : 			*y += PtHeaderDataTable[rwindex].sinHeading * 100.0F;

	mov	edx, DWORD PTR _rwindex$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm0, DWORD PTR [eax+edx+12]
	mulss	xmm0, DWORD PTR __real@42c80000
	mov	ecx, DWORD PTR _y$[ebp]
	addss	xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _y$[ebp]
	movss	DWORD PTR [edx], xmm0
$LN1@FindTakeof:

; 3430 : 		}
; 3431 : 	}
; 3432 : 		
; 3433 : 
; 3434 : 	return point;

	mov	eax, DWORD PTR _point$[ebp]

; 3435 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?FindTakeoffPt@ATCBrain@@QAEHPAVFlightClass@@HHPAM1@Z ENDP ; ATCBrain::FindTakeoffPt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_trig$ = -28						; size = 8
tv149 = -20						; size = 4
tv142 = -16						; size = 4
_abortHeading$ = -12					; size = 4
tv134 = -8						; size = 4
_this$ = -4						; size = 4
_aircraft$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_z$ = 20						; size = 4
?FindAbortPt@ATCBrain@@QAEXPAVAircraftClass@@PAM11@Z PROC ; ATCBrain::FindAbortPt
; _this$ = ecx

; 4943 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 4944 : 	float abortHeading;
; 4945 : 	mlTrig trig;
; 4946 : 
; 4947 : 	abortHeading = aircraft->Yaw() + 90.0F * DTR;

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?Yaw@VuEntity@@QBEMXZ			; VuEntity::Yaw
	fstp	DWORD PTR tv134[ebp]
	movss	xmm0, DWORD PTR tv134[ebp]
	addss	xmm0, DWORD PTR __real@3fc90fd9
	movss	DWORD PTR _abortHeading$[ebp], xmm0

; 4948 : 
; 4949 : 	mlSinCos(&trig, abortHeading);

	push	ecx
	movss	xmm0, DWORD PTR _abortHeading$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _trig$[ebp]
	push	eax
	call	?mlSinCos@@YAXPAUmlTrig@@M@Z		; mlSinCos
	add	esp, 8

; 4950 : 
; 4951 : 	*x = self->XPos() + trig.cos * 8.0F * NM_TO_FT;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv142[ebp]
	movss	xmm0, DWORD PTR tv142[ebp]
	movss	xmm1, DWORD PTR _trig$[ebp+4]
	mulss	xmm1, DWORD PTR __real@41000000
	mulss	xmm1, DWORD PTR __real@45bde1b0
	addss	xmm0, xmm1
	mov	edx, DWORD PTR _x$[ebp]
	movss	DWORD PTR [edx], xmm0

; 4952 : 	*y = self->YPos() + trig.sin * 8.0F * NM_TO_FT;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv149[ebp]
	movss	xmm0, DWORD PTR tv149[ebp]
	movss	xmm1, DWORD PTR _trig$[ebp]
	mulss	xmm1, DWORD PTR __real@41000000
	mulss	xmm1, DWORD PTR __real@45bde1b0
	addss	xmm0, xmm1
	mov	ecx, DWORD PTR _y$[ebp]
	movss	DWORD PTR [ecx], xmm0

; 4953 : 	*z = GetAltitude(aircraft, lAborted);

	push	5
	mov	edx, DWORD PTR _aircraft$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAltitude@ATCBrain@@QAEMPAVAircraftClass@@W4AtcStatusEnum@@@Z ; ATCBrain::GetAltitude
	mov	eax, DWORD PTR _z$[ebp]
	fstp	DWORD PTR [eax]

; 4954 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?FindAbortPt@ATCBrain@@QAEXPAVAircraftClass@@PAM11@Z ENDP ; ATCBrain::FindAbortPt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_dist2$ = -116						; size = 4
_dist1$ = -112						; size = 4
tv578 = -108						; size = 4
tv574 = -104						; size = 4
tv561 = -100						; size = 4
tv557 = -96						; size = 4
tv437 = -92						; size = 4
tv632 = -88						; size = 4
tv433 = -84						; size = 4
tv428 = -80						; size = 4
tv630 = -76						; size = 4
tv424 = -72						; size = 4
_headingfrom$ = -68					; size = 4
_py$ = -64						; size = 4
_px$ = -60						; size = 4
_ptindex$ = -56						; size = 4
_sbest$ = -52						; size = 4
_best$ = -48						; size = 4
_score1$ = -44						; size = 4
_dy$ = -40						; size = 4
_dx$ = -36						; size = 4
_score2$ = -32						; size = 4
_queue2$ = -28						; size = 4
_rwindex2$ = -24					; size = 4
_j$ = -20						; size = 4
_info$ = -16						; size = 4
_delta$ = -12						; size = 4
_i$ = -8						; size = 4
_this$ = -4						; size = 4
_queue$ = 8						; size = 4
_rwindex$ = 12						; size = 4
_landing$ = 16						; size = 4
?FindEmergencyLandingRunway@ATCBrain@@QAEXPAH0PAVFalconEntity@@@Z PROC ; ATCBrain::FindEmergencyLandingRunway
; _this$ = ecx

; 2815 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2816 : 	int i, j, ptindex;
; 2817 : 	int	delta, best=91, sbest = 91, rwindex2, queue2, score1, score2;

	mov	DWORD PTR _best$[ebp], 91		; 0000005bH
	mov	DWORD PTR _sbest$[ebp], 91		; 0000005bH

; 2818 : 	float dist1, dist2, px, py, dx, dy, headingfrom;
; 2819 : 	runwayQueueStruct* info;
; 2820 : 
; 2821 : 	headingfrom = (float)atan2(self->XPos() - landing->XPos(), self->YPos() - landing->YPos());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv424[ebp]
	movss	xmm0, DWORD PTR tv424[ebp]
	mov	ecx, DWORD PTR _landing$[ebp]
	movss	DWORD PTR tv630[ebp], xmm0
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv428[ebp]
	movss	xmm0, DWORD PTR tv630[ebp]
	subss	xmm0, DWORD PTR tv428[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv433[ebp]
	movss	xmm0, DWORD PTR tv433[ebp]
	mov	ecx, DWORD PTR _landing$[ebp]
	movss	DWORD PTR tv632[ebp], xmm0
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv437[ebp]
	movss	xmm0, DWORD PTR tv632[ebp]
	subss	xmm0, DWORD PTR tv437[ebp]
	cvtss2sd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	?checked_atan2@@YANNN@Z			; checked_atan2
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _headingfrom$[ebp]

; 2822 : 
; 2823 : 	*queue = 0;

	mov	edx, DWORD PTR _queue$[ebp]
	mov	DWORD PTR [edx], 0

; 2824 : 	*rwindex = 0;

	mov	eax, DWORD PTR _rwindex$[ebp]
	mov	DWORD PTR [eax], 0

; 2825 : 	queue2 = 0;

	mov	DWORD PTR _queue2$[ebp], 0

; 2826 : 	rwindex2 = 0;

	mov	DWORD PTR _rwindex2$[ebp], 0

; 2827 : 
; 2828 : 	for(i = 0; i < numRwys; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN30@FindEmerge
$LN29@FindEmerge:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN30@FindEmerge:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jge	$LN28@FindEmerge

; 2829 : 	{
; 2830 : 		if(runwayStats[i].state < VIS_DAMAGED)

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	cx, WORD PTR [eax+ecx+24]
	and	cx, 7
	movzx	edx, cx
	cmp	edx, 2
	jge	$LN24@FindEmerge

; 2831 : 		{
; 2832 : 			for(j = 0; j < 2 && runwayStats[i].rwIndexes[j]; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN26@FindEmerge
$LN25@FindEmerge:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN26@FindEmerge:
	cmp	DWORD PTR _j$[ebp], 2
	jge	$LN24@FindEmerge
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+16]
	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	$LN24@FindEmerge

; 2833 : 			{
; 2834 : 				delta = abs(PtHeaderDataTable[runwayStats[i].rwIndexes[j]].data - FloatToInt32(headingfrom*RTD));

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	add	eax, ecx
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	esi, WORD PTR [eax+edx+10]
	movss	xmm0, DWORD PTR _headingfrom$[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	sub	esi, eax
	push	esi
	call	_abs
	add	esp, 4
	mov	DWORD PTR _delta$[ebp], eax

; 2835 : 				if (delta > 180)

	cmp	DWORD PTR _delta$[ebp], 180		; 000000b4H
	jle	SHORT $LN23@FindEmerge

; 2836 : 					delta = abs(PtHeaderDataTable[runwayStats[i].rwIndexes[j]].data - 360 + FloatToInt32(headingfrom*RTD));

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	add	eax, ecx
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	esi, WORD PTR [eax+edx+10]
	movss	xmm0, DWORD PTR _headingfrom$[ebp]
	mulss	xmm0, DWORD PTR __real@42652ee1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	lea	ecx, DWORD PTR [esi+eax-360]
	push	ecx
	call	_abs
	add	esp, 4
	mov	DWORD PTR _delta$[ebp], eax
$LN23@FindEmerge:

; 2837 : 				if (delta < best)

	mov	edx, DWORD PTR _delta$[ebp]
	cmp	edx, DWORD PTR _best$[ebp]
	jge	SHORT $LN22@FindEmerge

; 2838 : 				{
; 2839 : 					sbest = best;

	mov	eax, DWORD PTR _best$[ebp]
	mov	DWORD PTR _sbest$[ebp], eax

; 2840 : 					best = delta;

	mov	ecx, DWORD PTR _delta$[ebp]
	mov	DWORD PTR _best$[ebp], ecx

; 2841 : 					rwindex2 = *rwindex;

	mov	edx, DWORD PTR _rwindex$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _rwindex2$[ebp], eax

; 2842 : 					*rwindex = runwayStats[i].rwIndexes[j];

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+16]
	mov	eax, DWORD PTR _rwindex$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [eax], ecx

; 2843 : 					queue2 = *queue;

	mov	edx, DWORD PTR _queue$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _queue2$[ebp], eax

; 2844 : 					*queue = i;

	mov	ecx, DWORD PTR _queue$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN20@FindEmerge
$LN22@FindEmerge:

; 2845 : 				}
; 2846 : 				else if (delta < sbest)

	mov	eax, DWORD PTR _delta$[ebp]
	cmp	eax, DWORD PTR _sbest$[ebp]
	jge	SHORT $LN20@FindEmerge

; 2847 : 				{
; 2848 : 					sbest = delta;

	mov	ecx, DWORD PTR _delta$[ebp]
	mov	DWORD PTR _sbest$[ebp], ecx

; 2849 : 					rwindex2 = runwayStats[i].rwIndexes[j];

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _rwindex2$[ebp], edx

; 2850 : 					queue2 = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _queue2$[ebp], eax
$LN20@FindEmerge:

; 2851 : 				}
; 2852 : 			}

	jmp	$LN25@FindEmerge
$LN24@FindEmerge:

; 2853 : 		}
; 2854 : 	}

	jmp	$LN29@FindEmerge
$LN28@FindEmerge:

; 2855 : 
; 2856 : 	//we prefer to use the runway with a shorter queue that is closer to us
; 2857 : 	if(rwindex2 && PtHeaderDataTable[rwindex2].runwayNum != PtHeaderDataTable[*rwindex].runwayNum)

	cmp	DWORD PTR _rwindex2$[ebp], 0
	je	$LN12@FindEmerge
	mov	ecx, DWORD PTR _rwindex2$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	eax, BYTE PTR [edx+ecx+24]
	mov	ecx, DWORD PTR _rwindex$[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	edx, BYTE PTR [ecx+edx+24]
	cmp	eax, edx
	je	$LN12@FindEmerge

; 2858 : 	{
; 2859 : 		//score both choices, while favoring the second choice so we don't have crossing patterns
; 2860 : 		score1 = (runwayStats[queue2].numInQueue - runwayStats[*queue].numInQueue);

	mov	eax, DWORD PTR _queue2$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ax, WORD PTR [edx+eax+24]
	shr	ax, 3
	mov	ecx, 8191				; 00001fffH
	and	ax, cx
	movzx	edx, ax
	mov	eax, DWORD PTR _queue$[ebp]
	mov	ecx, DWORD PTR [eax]
	imul	ecx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	mov	cx, WORD PTR [eax+ecx+24]
	shr	cx, 3
	mov	eax, 8191				; 00001fffH
	and	cx, ax
	movzx	ecx, cx
	sub	edx, ecx
	mov	DWORD PTR _score1$[ebp], edx

; 2861 : 		if(PtHeaderDataTable[*rwindex].data == PtHeaderDataTable[rwindex2].data)

	mov	edx, DWORD PTR _rwindex$[ebp]
	mov	eax, DWORD PTR [edx]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	edx, WORD PTR [ecx+eax+10]
	mov	eax, DWORD PTR _rwindex2$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	eax, WORD PTR [ecx+eax+10]
	cmp	edx, eax
	jne	SHORT $LN18@FindEmerge

; 2862 : 			score2 = (runwayStats[*queue].numInQueue - runwayStats[queue2].numInQueue);

	mov	ecx, DWORD PTR _queue$[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	dx, WORD PTR [ecx+edx+24]
	shr	dx, 3
	mov	eax, 8191				; 00001fffH
	and	dx, ax
	movzx	ecx, dx
	mov	edx, DWORD PTR _queue2$[ebp]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	mov	dx, WORD PTR [eax+edx+24]
	shr	dx, 3
	mov	eax, 8191				; 00001fffH
	and	dx, ax
	movzx	edx, dx
	sub	ecx, edx
	mov	DWORD PTR _score2$[ebp], ecx

; 2863 : 		else

	jmp	SHORT $LN17@FindEmerge
$LN18@FindEmerge:

; 2864 : 			score2 = (runwayStats[*queue].numInQueue - runwayStats[queue2].numInQueue) + 7;

	mov	eax, DWORD PTR _queue$[ebp]
	mov	ecx, DWORD PTR [eax]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	cx, WORD PTR [eax+ecx+24]
	shr	cx, 3
	mov	edx, 8191				; 00001fffH
	and	cx, dx
	movzx	eax, cx
	mov	ecx, DWORD PTR _queue2$[ebp]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+16]
	mov	cx, WORD PTR [edx+ecx+24]
	shr	cx, 3
	mov	edx, 8191				; 00001fffH
	and	cx, dx
	movzx	ecx, cx
	sub	eax, ecx
	add	eax, 7
	mov	DWORD PTR _score2$[ebp], eax
$LN17@FindEmerge:

; 2865 : 
; 2866 : 		if(runwayStats[*queue].nextEmergency != FalconNullId)

	push	OFFSET ?FalconNullId@@3VVU_ID@@A	; FalconNullId
	mov	edx, DWORD PTR _queue$[ebp]
	mov	eax, DWORD PTR [edx]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	lea	ecx, DWORD PTR [edx+eax+32]
	call	??9VU_ID@@QBE_NABV0@@Z			; VU_ID::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN16@FindEmerge

; 2867 : 			score1 -= 6;

	mov	ecx, DWORD PTR _score1$[ebp]
	sub	ecx, 6
	mov	DWORD PTR _score1$[ebp], ecx
$LN16@FindEmerge:

; 2868 : 
; 2869 : 		if(runwayStats[queue2].nextEmergency != FalconNullId)

	push	OFFSET ?FalconNullId@@3VVU_ID@@A	; FalconNullId
	mov	edx, DWORD PTR _queue2$[ebp]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	lea	ecx, DWORD PTR [ecx+edx+32]
	call	??9VU_ID@@QBE_NABV0@@Z			; VU_ID::operator!=
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN15@FindEmerge

; 2870 : 			score2 -= 6;

	mov	eax, DWORD PTR _score2$[ebp]
	sub	eax, 6
	mov	DWORD PTR _score2$[ebp], eax
$LN15@FindEmerge:

; 2871 : 		//if we choose the closer runway we won't have to worry about our patterns crossing over the runway
; 2872 : 
; 2873 : 		ptindex = GetFirstPt(*rwindex);

	mov	ecx, DWORD PTR _rwindex$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?GetFirstPt@@YAHH@Z			; GetFirstPt
	add	esp, 4
	mov	DWORD PTR _ptindex$[ebp], eax

; 2874 : 		TranslatePointData (self, ptindex, &px, &py);

	lea	eax, DWORD PTR _py$[ebp]
	push	eax
	lea	ecx, DWORD PTR _px$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ptindex$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData
	add	esp, 16					; 00000010H

; 2875 : 
; 2876 : 		dx = landing->XPos() - px;

	mov	ecx, DWORD PTR _landing$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv557[ebp]
	movss	xmm0, DWORD PTR tv557[ebp]
	subss	xmm0, DWORD PTR _px$[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 2877 : 		dy = landing->YPos() - py;

	mov	ecx, DWORD PTR _landing$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv561[ebp]
	movss	xmm0, DWORD PTR tv561[ebp]
	subss	xmm0, DWORD PTR _py$[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 2878 : 
; 2879 : 		dist1 = dx*dx + dy*dy;

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _dist1$[ebp], xmm0

; 2880 : 
; 2881 : 		ptindex = GetFirstPt(rwindex2);

	mov	edx, DWORD PTR _rwindex2$[ebp]
	push	edx
	call	?GetFirstPt@@YAHH@Z			; GetFirstPt
	add	esp, 4
	mov	DWORD PTR _ptindex$[ebp], eax

; 2882 : 		TranslatePointData (self, ptindex, &px, &py);

	lea	eax, DWORD PTR _py$[ebp]
	push	eax
	lea	ecx, DWORD PTR _px$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ptindex$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData
	add	esp, 16					; 00000010H

; 2883 : 
; 2884 : 		dx = landing->XPos() - px;

	mov	ecx, DWORD PTR _landing$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv574[ebp]
	movss	xmm0, DWORD PTR tv574[ebp]
	subss	xmm0, DWORD PTR _px$[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 2885 : 		dy = landing->YPos() - py;

	mov	ecx, DWORD PTR _landing$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv578[ebp]
	movss	xmm0, DWORD PTR tv578[ebp]
	subss	xmm0, DWORD PTR _py$[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 2886 : 
; 2887 : 		dist2 = dx*dx + dy*dy;

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _dist2$[ebp], xmm0

; 2888 : 
; 2889 : 		if(dist1 > dist2)

	movss	xmm0, DWORD PTR _dist1$[ebp]
	comiss	xmm0, DWORD PTR _dist2$[ebp]
	jbe	SHORT $LN14@FindEmerge

; 2890 : 			score2 += 1;

	mov	edx, DWORD PTR _score2$[ebp]
	add	edx, 1
	mov	DWORD PTR _score2$[ebp], edx

; 2891 : 		else

	jmp	SHORT $LN13@FindEmerge
$LN14@FindEmerge:

; 2892 : 			score1 += 1;

	mov	eax, DWORD PTR _score1$[ebp]
	add	eax, 1
	mov	DWORD PTR _score1$[ebp], eax
$LN13@FindEmerge:

; 2893 : 
; 2894 : 		if(score2 > score1)

	mov	ecx, DWORD PTR _score2$[ebp]
	cmp	ecx, DWORD PTR _score1$[ebp]
	jle	SHORT $LN12@FindEmerge

; 2895 : 		{
; 2896 : 			*rwindex = rwindex2;

	mov	edx, DWORD PTR _rwindex$[ebp]
	mov	eax, DWORD PTR _rwindex2$[ebp]
	mov	DWORD PTR [edx], eax

; 2897 : 			*queue = queue2;

	mov	ecx, DWORD PTR _queue$[ebp]
	mov	edx, DWORD PTR _queue2$[ebp]
	mov	DWORD PTR [ecx], edx
$LN12@FindEmerge:

; 2898 : 		}
; 2899 : 	}
; 2900 : 
; 2901 : 	info = runwayQueue[PtHeaderDataTable[*rwindex].runwayNum];

	mov	eax, DWORD PTR _rwindex$[ebp]
	mov	ecx, DWORD PTR [eax]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	eax, BYTE PTR [edx+ecx+24]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _info$[ebp], eax

; 2902 : 	if(info)

	cmp	DWORD PTR _info$[ebp], 0
	je	SHORT $LN11@FindEmerge

; 2903 : 	{
; 2904 : 		if(info->status >= tReqTaxi)

	mov	ecx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [ecx+8], 19			; 00000013H
	jl	SHORT $LN10@FindEmerge

; 2905 : 			*rwindex = GetOppositeRunway(info->rwindex);

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOppositeRunway@ATCBrain@@QAEHH@Z	; ATCBrain::GetOppositeRunway
	mov	ecx, DWORD PTR _rwindex$[ebp]
	mov	DWORD PTR [ecx], eax

; 2906 : 		else

	jmp	SHORT $LN9@FindEmerge
$LN10@FindEmerge:

; 2907 : 			*rwindex = info->rwindex;

	mov	edx, DWORD PTR _rwindex$[ebp]
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx], ecx
$LN9@FindEmerge:
	jmp	$LN1@FindEmerge
$LN11@FindEmerge:

; 2908 : 	}
; 2909 : 	else if(numRwys == 2)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], 2
	jne	$LN1@FindEmerge

; 2910 : 	{
; 2911 : 		info = runwayQueue[1 - PtHeaderDataTable[*rwindex].runwayNum];

	mov	eax, DWORD PTR _rwindex$[ebp]
	mov	ecx, DWORD PTR [eax]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	eax, BYTE PTR [edx+ecx+24]
	mov	ecx, 1
	sub	ecx, eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _info$[ebp], ecx

; 2912 : 		if(info)

	cmp	DWORD PTR _info$[ebp], 0
	je	$LN1@FindEmerge

; 2913 : 		{
; 2914 : 			delta = abs(PtHeaderDataTable[*rwindex].data - PtHeaderDataTable[info->rwindex].data);

	mov	edx, DWORD PTR _rwindex$[ebp]
	mov	eax, DWORD PTR [edx]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	edx, WORD PTR [ecx+eax+10]
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	imul	ecx, 28					; 0000001cH
	mov	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	ecx, WORD PTR [eax+ecx+10]
	sub	edx, ecx
	push	edx
	call	_abs
	add	esp, 4
	mov	DWORD PTR _delta$[ebp], eax

; 2915 : 			if(delta > 180)

	cmp	DWORD PTR _delta$[ebp], 180		; 000000b4H
	jle	SHORT $LN5@FindEmerge

; 2916 : 				delta = abs(delta - 360);

	mov	edx, DWORD PTR _delta$[ebp]
	sub	edx, 360				; 00000168H
	push	edx
	call	_abs
	add	esp, 4
	mov	DWORD PTR _delta$[ebp], eax
$LN5@FindEmerge:

; 2917 : 
; 2918 : 			if(delta < 91)

	cmp	DWORD PTR _delta$[ebp], 91		; 0000005bH
	jge	SHORT $LN4@FindEmerge

; 2919 : 			{
; 2920 : 				if(info->status >= tReqTaxi)

	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax+8], 19			; 00000013H
	jl	SHORT $LN3@FindEmerge

; 2921 : 					*rwindex = GetOppositeRunway(*rwindex);

	mov	ecx, DWORD PTR _rwindex$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOppositeRunway@ATCBrain@@QAEHH@Z	; ATCBrain::GetOppositeRunway
	mov	ecx, DWORD PTR _rwindex$[ebp]
	mov	DWORD PTR [ecx], eax
$LN3@FindEmerge:

; 2922 : 			}
; 2923 : 			else

	jmp	SHORT $LN1@FindEmerge
$LN4@FindEmerge:

; 2924 : 			{
; 2925 : 				if(info->status < tReqTaxi)

	mov	edx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [edx+8], 19			; 00000013H
	jge	SHORT $LN1@FindEmerge

; 2926 : 					*rwindex = GetOppositeRunway(*rwindex);

	mov	eax, DWORD PTR _rwindex$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOppositeRunway@ATCBrain@@QAEHH@Z	; ATCBrain::GetOppositeRunway
	mov	edx, DWORD PTR _rwindex$[ebp]
	mov	DWORD PTR [edx], eax
$LN1@FindEmerge:

; 2927 : 			}
; 2928 : 		}
; 2929 : 	}
; 2930 : 
; 2931 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?FindEmergencyLandingRunway@ATCBrain@@QAEXPAH0PAVFalconEntity@@@Z ENDP ; ATCBrain::FindEmergencyLandingRunway
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_dist2$ = -104						; size = 4
_dist1$ = -100						; size = 4
tv550 = -96						; size = 4
tv546 = -92						; size = 4
tv533 = -88						; size = 4
tv529 = -84						; size = 4
_windheading$ = -80					; size = 4
_rel$ = -76						; size = 4
_py$ = -72						; size = 4
_px$ = -68						; size = 4
_ptindex$ = -64						; size = 4
_sbest$ = -60						; size = 4
_best$ = -56						; size = 4
_score1$ = -52						; size = 4
_dy$ = -48						; size = 4
_dx$ = -44						; size = 4
_score2$ = -40						; size = 4
_queue$ = -36						; size = 4
_queue2$ = -32						; size = 4
_rwindex2$ = -28					; size = 4
_j$ = -24						; size = 4
_i$ = -20						; size = 4
_delta$ = -16						; size = 4
_info$ = -12						; size = 4
_rwindex$ = -8						; size = 4
_this$ = -4						; size = 4
_landing$ = 8						; size = 4
_checklist$ = 12					; size = 4
?FindBestLandingRunway@ATCBrain@@QAEHPAVFalconEntity@@H@Z PROC ; ATCBrain::FindBestLandingRunway
; _this$ = ecx

; 2679 : int ATCBrain::FindBestLandingRunway(FalconEntity* landing, int checklist){

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	DWORD PTR _this$[ebp], ecx

; 2680 : 
; 2681 : 	// sfr: get relations between base and entity
; 2682 : 	// only return if they are on the same team
; 2683 : 	int rel = GetTTRelations(self->GetTeam(), landing->GetTeam());

	mov	eax, DWORD PTR _landing$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _landing$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	call	?GetTTRelations@@YAHEE@Z		; GetTTRelations
	add	esp, 8
	mov	DWORD PTR _rel$[ebp], eax

; 2684 : 	if ((rel != Friendly) && (rel != Allied)){

	cmp	DWORD PTR _rel$[ebp], 2
	je	SHORT $LN34@FindBestLa
	cmp	DWORD PTR _rel$[ebp], 1
	je	SHORT $LN34@FindBestLa

; 2685 : 		return 0;

	xor	eax, eax
	jmp	$LN35@FindBestLa
$LN34@FindBestLa:

; 2686 : 	}
; 2687 : 
; 2688 : 	int i, j, ptindex;
; 2689 : 	int	delta, best=91, sbest = 91, windheading, score1, score2;

	mov	DWORD PTR _best$[ebp], 91		; 0000005bH
	mov	DWORD PTR _sbest$[ebp], 91		; 0000005bH

; 2690 : 	int rwindex = 0, queue = 0, rwindex2 = 0, queue2 = 0;

	mov	DWORD PTR _rwindex$[ebp], 0
	mov	DWORD PTR _queue$[ebp], 0
	mov	DWORD PTR _rwindex2$[ebp], 0
	mov	DWORD PTR _queue2$[ebp], 0

; 2691 : 	float dist1, dist2, px, py, dx, dy;
; 2692 : 	runwayQueueStruct* info;
; 2693 : 
; 2694 : 	// Find windheading in degrees (add 180 if we want opposite direction)
; 2695 : 	// Cobra - windHeading in radians
; 2696 : 	windheading = FloatToInt32(((WeatherClass*)realWeather)->windHeading*RTD+0.5f ) % 360;

	mov	edx, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	movss	xmm0, DWORD PTR [edx+15728]
	mulss	xmm0, DWORD PTR __real@42652ee1
	addss	xmm0, DWORD PTR __real@3f000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	cdq
	mov	ecx, 360				; 00000168H
	idiv	ecx
	mov	DWORD PTR _windheading$[ebp], edx

; 2697 : 
; 2698 : 	for(i = 0; i < numRwys; i++){

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN33@FindBestLa
$LN32@FindBestLa:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN33@FindBestLa:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jge	$LN31@FindBestLa

; 2699 : 		if(runwayStats[i].state < VIS_DAMAGED){

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	dx, WORD PTR [ecx+edx+24]
	and	dx, 7
	movzx	eax, dx
	cmp	eax, 2
	jge	$LN27@FindBestLa

; 2700 : 			for(j = 0; runwayStats[i].rwIndexes[j] && j < 2; j++){

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN29@FindBestLa
$LN28@FindBestLa:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN29@FindBestLa:
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	DWORD PTR [edx+ecx*4], 0
	je	$LN27@FindBestLa
	cmp	DWORD PTR _j$[ebp], 2
	jge	$LN27@FindBestLa

; 2701 : 				delta = abs(PtHeaderDataTable[runwayStats[i].rwIndexes[j]].data - windheading);

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, edx
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	edx, WORD PTR [ecx+eax+10]
	sub	edx, DWORD PTR _windheading$[ebp]
	push	edx
	call	_abs
	add	esp, 4
	mov	DWORD PTR _delta$[ebp], eax

; 2702 : 				if (delta > 180){

	cmp	DWORD PTR _delta$[ebp], 180		; 000000b4H
	jle	SHORT $LN26@FindBestLa

; 2703 : 					delta = 360 - delta;  // Cobra - simplify angle adjustment

	mov	eax, 360				; 00000168H
	sub	eax, DWORD PTR _delta$[ebp]
	mov	DWORD PTR _delta$[ebp], eax
$LN26@FindBestLa:

; 2704 : //					delta = abs(PtHeaderDataTable[runwayStats[i].rwIndexes[j]].data - 360 + windheading);
; 2705 : 				}
; 2706 : 
; 2707 : 				if (delta < best){

	mov	ecx, DWORD PTR _delta$[ebp]
	cmp	ecx, DWORD PTR _best$[ebp]
	jge	SHORT $LN25@FindBestLa

; 2708 : 					sbest = best;

	mov	edx, DWORD PTR _best$[ebp]
	mov	DWORD PTR _sbest$[ebp], edx

; 2709 : 					best = delta;

	mov	eax, DWORD PTR _delta$[ebp]
	mov	DWORD PTR _best$[ebp], eax

; 2710 : 					rwindex2 = rwindex;

	mov	ecx, DWORD PTR _rwindex$[ebp]
	mov	DWORD PTR _rwindex2$[ebp], ecx

; 2711 : 					rwindex = runwayStats[i].rwIndexes[j];

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _rwindex$[ebp], edx

; 2712 : 					queue2 = queue;

	mov	eax, DWORD PTR _queue$[ebp]
	mov	DWORD PTR _queue2$[ebp], eax

; 2713 : 					queue = i;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _queue$[ebp], ecx
	jmp	SHORT $LN23@FindBestLa
$LN25@FindBestLa:

; 2714 : 				}
; 2715 : 				else if (delta < sbest){

	mov	edx, DWORD PTR _delta$[ebp]
	cmp	edx, DWORD PTR _sbest$[ebp]
	jge	SHORT $LN23@FindBestLa

; 2716 : 					sbest = delta;

	mov	eax, DWORD PTR _delta$[ebp]
	mov	DWORD PTR _sbest$[ebp], eax

; 2717 : 					rwindex2 = runwayStats[i].rwIndexes[j];

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+16]
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _rwindex2$[ebp], ecx

; 2718 : 					queue2 = i;

	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _queue2$[ebp], edx
$LN23@FindBestLa:

; 2719 : 				}
; 2720 : 			}

	jmp	$LN28@FindBestLa
$LN27@FindBestLa:

; 2721 : 		}
; 2722 : 	}

	jmp	$LN32@FindBestLa
$LN31@FindBestLa:

; 2723 : 
; 2724 : 	//we prefer to use the runway with a shorter queue that is closer to us
; 2725 : 	if(numRwys == 2 && rwindex2 && PtHeaderDataTable[rwindex2].runwayNum != PtHeaderDataTable[rwindex].runwayNum){

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 2
	jne	$LN15@FindBestLa
	cmp	DWORD PTR _rwindex2$[ebp], 0
	je	$LN15@FindBestLa
	mov	ecx, DWORD PTR _rwindex2$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	eax, BYTE PTR [edx+ecx+24]
	mov	ecx, DWORD PTR _rwindex$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	ecx, BYTE PTR [edx+ecx+24]
	cmp	eax, ecx
	je	$LN15@FindBestLa

; 2726 : 		//score both choices, while favoring the second choice so we don't have crossing patterns
; 2727 : 		score1 = (runwayStats[queue2].numInQueue - runwayStats[queue].numInQueue);

	mov	edx, DWORD PTR _queue2$[ebp]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	dx, WORD PTR [ecx+edx+24]
	shr	dx, 3
	mov	eax, 8191				; 00001fffH
	and	dx, ax
	movzx	ecx, dx
	mov	edx, DWORD PTR _queue$[ebp]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	mov	dx, WORD PTR [eax+edx+24]
	shr	dx, 3
	mov	eax, 8191				; 00001fffH
	and	dx, ax
	movzx	edx, dx
	sub	ecx, edx
	mov	DWORD PTR _score1$[ebp], ecx

; 2728 : 		if(PtHeaderDataTable[rwindex].data == PtHeaderDataTable[rwindex2].data){

	mov	eax, DWORD PTR _rwindex$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	edx, WORD PTR [ecx+eax+10]
	mov	eax, DWORD PTR _rwindex2$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	eax, WORD PTR [ecx+eax+10]
	cmp	edx, eax
	jne	SHORT $LN21@FindBestLa

; 2729 : 			score2 = (runwayStats[queue].numInQueue - runwayStats[queue2].numInQueue);

	mov	ecx, DWORD PTR _queue$[ebp]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	cx, WORD PTR [eax+ecx+24]
	shr	cx, 3
	mov	edx, 8191				; 00001fffH
	and	cx, dx
	movzx	eax, cx
	mov	ecx, DWORD PTR _queue2$[ebp]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+16]
	mov	cx, WORD PTR [edx+ecx+24]
	shr	cx, 3
	mov	edx, 8191				; 00001fffH
	and	cx, dx
	movzx	ecx, cx
	sub	eax, ecx
	mov	DWORD PTR _score2$[ebp], eax

; 2730 : 		}
; 2731 : 		else{

	jmp	SHORT $LN20@FindBestLa
$LN21@FindBestLa:

; 2732 : 			score2 = (runwayStats[queue].numInQueue - runwayStats[queue2].numInQueue) + 7;

	mov	edx, DWORD PTR _queue$[ebp]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	dx, WORD PTR [ecx+edx+24]
	shr	dx, 3
	mov	eax, 8191				; 00001fffH
	and	dx, ax
	movzx	ecx, dx
	mov	edx, DWORD PTR _queue2$[ebp]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	mov	dx, WORD PTR [eax+edx+24]
	shr	dx, 3
	mov	eax, 8191				; 00001fffH
	and	dx, ax
	movzx	edx, dx
	sub	ecx, edx
	add	ecx, 7
	mov	DWORD PTR _score2$[ebp], ecx
$LN20@FindBestLa:

; 2733 : 		}
; 2734 : 
; 2735 : 		if(runwayStats[queue].nextEmergency != FalconNullId){

	push	OFFSET ?FalconNullId@@3VVU_ID@@A	; FalconNullId
	mov	eax, DWORD PTR _queue$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	lea	ecx, DWORD PTR [edx+eax+32]
	call	??9VU_ID@@QBE_NABV0@@Z			; VU_ID::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN19@FindBestLa

; 2736 : 			score1 -= 6;

	mov	ecx, DWORD PTR _score1$[ebp]
	sub	ecx, 6
	mov	DWORD PTR _score1$[ebp], ecx
$LN19@FindBestLa:

; 2737 : 		}
; 2738 : 
; 2739 : 		if(runwayStats[queue2].nextEmergency != FalconNullId){

	push	OFFSET ?FalconNullId@@3VVU_ID@@A	; FalconNullId
	mov	edx, DWORD PTR _queue2$[ebp]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	lea	ecx, DWORD PTR [ecx+edx+32]
	call	??9VU_ID@@QBE_NABV0@@Z			; VU_ID::operator!=
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN18@FindBestLa

; 2740 : 			score2 -= 6;

	mov	eax, DWORD PTR _score2$[ebp]
	sub	eax, 6
	mov	DWORD PTR _score2$[ebp], eax
$LN18@FindBestLa:

; 2741 : 		}
; 2742 : 		//if we choose the closer runway we won't have to worry about our patterns crossing over the runway
; 2743 : 
; 2744 : 		ptindex = GetFirstPt(rwindex);

	mov	ecx, DWORD PTR _rwindex$[ebp]
	push	ecx
	call	?GetFirstPt@@YAHH@Z			; GetFirstPt
	add	esp, 4
	mov	DWORD PTR _ptindex$[ebp], eax

; 2745 : 		TranslatePointData (self, ptindex, &px, &py);

	lea	edx, DWORD PTR _py$[ebp]
	push	edx
	lea	eax, DWORD PTR _px$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptindex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData
	add	esp, 16					; 00000010H

; 2746 : 
; 2747 : 		dx = landing->XPos() - px;

	mov	ecx, DWORD PTR _landing$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv529[ebp]
	movss	xmm0, DWORD PTR tv529[ebp]
	subss	xmm0, DWORD PTR _px$[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 2748 : 		dy = landing->YPos() - py;

	mov	ecx, DWORD PTR _landing$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv533[ebp]
	movss	xmm0, DWORD PTR tv533[ebp]
	subss	xmm0, DWORD PTR _py$[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 2749 : 
; 2750 : 		dist1 = dx*dx + dy*dy;

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _dist1$[ebp], xmm0

; 2751 : 
; 2752 : 		ptindex = GetFirstPt(rwindex2);

	mov	ecx, DWORD PTR _rwindex2$[ebp]
	push	ecx
	call	?GetFirstPt@@YAHH@Z			; GetFirstPt
	add	esp, 4
	mov	DWORD PTR _ptindex$[ebp], eax

; 2753 : 		TranslatePointData (self, ptindex, &px, &py);

	lea	edx, DWORD PTR _py$[ebp]
	push	edx
	lea	eax, DWORD PTR _px$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptindex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData
	add	esp, 16					; 00000010H

; 2754 : 
; 2755 : 		dx = landing->XPos() - px;

	mov	ecx, DWORD PTR _landing$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv546[ebp]
	movss	xmm0, DWORD PTR tv546[ebp]
	subss	xmm0, DWORD PTR _px$[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 2756 : 		dy = landing->YPos() - py;

	mov	ecx, DWORD PTR _landing$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv550[ebp]
	movss	xmm0, DWORD PTR tv550[ebp]
	subss	xmm0, DWORD PTR _py$[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 2757 : 
; 2758 : 		dist2 = dx*dx + dy*dy;

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _dist2$[ebp], xmm0

; 2759 : 
; 2760 : 		if(dist1 > dist2){

	movss	xmm0, DWORD PTR _dist1$[ebp]
	comiss	xmm0, DWORD PTR _dist2$[ebp]
	jbe	SHORT $LN17@FindBestLa

; 2761 : 			score2 += 1;

	mov	ecx, DWORD PTR _score2$[ebp]
	add	ecx, 1
	mov	DWORD PTR _score2$[ebp], ecx

; 2762 : 		}
; 2763 : 		else{

	jmp	SHORT $LN16@FindBestLa
$LN17@FindBestLa:

; 2764 : 			score1 += 1;

	mov	edx, DWORD PTR _score1$[ebp]
	add	edx, 1
	mov	DWORD PTR _score1$[ebp], edx
$LN16@FindBestLa:

; 2765 : 		}
; 2766 : 
; 2767 : 		if(score2 > score1){

	mov	eax, DWORD PTR _score2$[ebp]
	cmp	eax, DWORD PTR _score1$[ebp]
	jle	SHORT $LN15@FindBestLa

; 2768 : 			rwindex = rwindex2;

	mov	ecx, DWORD PTR _rwindex2$[ebp]
	mov	DWORD PTR _rwindex$[ebp], ecx

; 2769 : 			queue = queue2;

	mov	edx, DWORD PTR _queue2$[ebp]
	mov	DWORD PTR _queue$[ebp], edx
$LN15@FindBestLa:

; 2770 : 		}
; 2771 : 	}
; 2772 : 
; 2773 : 	if (!checklist){

	cmp	DWORD PTR _checklist$[ebp], 0
	jne	SHORT $LN14@FindBestLa

; 2774 : 		return rwindex;

	mov	eax, DWORD PTR _rwindex$[ebp]
	jmp	$LN35@FindBestLa
$LN14@FindBestLa:

; 2775 : 	}
; 2776 : 
; 2777 : 	info = runwayQueue[PtHeaderDataTable[rwindex].runwayNum];

	mov	eax, DWORD PTR _rwindex$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	edx, BYTE PTR [ecx+eax+24]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _info$[ebp], edx
$LN13@FindBestLa:

; 2778 : 	while(info && info->status == noATC){

	cmp	DWORD PTR _info$[ebp], 0
	je	SHORT $LN12@FindBestLa
	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN12@FindBestLa

; 2779 : 		info = info->next;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _info$[ebp], edx

; 2780 : 	}

	jmp	SHORT $LN13@FindBestLa
$LN12@FindBestLa:

; 2781 : 
; 2782 : 	if(info){

	cmp	DWORD PTR _info$[ebp], 0
	je	SHORT $LN11@FindBestLa

; 2783 : 		if(info->status >= tReqTaxi && GetOppositeRunway(info->rwindex)){

	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax+8], 19			; 00000013H
	jl	SHORT $LN10@FindBestLa
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOppositeRunway@ATCBrain@@QAEHH@Z	; ATCBrain::GetOppositeRunway
	test	eax, eax
	je	SHORT $LN10@FindBestLa

; 2784 : 			rwindex = GetOppositeRunway(info->rwindex);

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOppositeRunway@ATCBrain@@QAEHH@Z	; ATCBrain::GetOppositeRunway
	mov	DWORD PTR _rwindex$[ebp], eax

; 2785 : 		}
; 2786 : 		else{

	jmp	SHORT $LN9@FindBestLa
$LN10@FindBestLa:

; 2787 : 			rwindex = info->rwindex;

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _rwindex$[ebp], eax
$LN9@FindBestLa:

; 2788 : 		}

	jmp	$LN1@FindBestLa
$LN11@FindBestLa:

; 2789 : 	}
; 2790 : 	else if(numRwys == 2){

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+8], 2
	jne	$LN1@FindBestLa

; 2791 : 		info = runwayQueue[1 - PtHeaderDataTable[rwindex].runwayNum];

	mov	edx, DWORD PTR _rwindex$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	ecx, BYTE PTR [eax+edx+24]
	mov	edx, 1
	sub	edx, ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _info$[ebp], edx

; 2792 : 		if(info){

	cmp	DWORD PTR _info$[ebp], 0
	je	$LN1@FindBestLa

; 2793 : 			delta = abs(PtHeaderDataTable[rwindex].data - PtHeaderDataTable[info->rwindex].data);

	mov	eax, DWORD PTR _rwindex$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	edx, WORD PTR [ecx+eax+10]
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	imul	ecx, 28					; 0000001cH
	mov	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	ecx, WORD PTR [eax+ecx+10]
	sub	edx, ecx
	push	edx
	call	_abs
	add	esp, 4
	mov	DWORD PTR _delta$[ebp], eax

; 2794 : 			if(delta > 180){

	cmp	DWORD PTR _delta$[ebp], 180		; 000000b4H
	jle	SHORT $LN5@FindBestLa

; 2795 : 				delta = abs(delta - 360);

	mov	edx, DWORD PTR _delta$[ebp]
	sub	edx, 360				; 00000168H
	push	edx
	call	_abs
	add	esp, 4
	mov	DWORD PTR _delta$[ebp], eax
$LN5@FindBestLa:

; 2796 : 			}
; 2797 : 
; 2798 : 			if(delta < 91){

	cmp	DWORD PTR _delta$[ebp], 91		; 0000005bH
	jge	SHORT $LN4@FindBestLa

; 2799 : 				if(info->status >= tReqTaxi && GetOppositeRunway(rwindex)){

	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax+8], 19			; 00000013H
	jl	SHORT $LN3@FindBestLa
	mov	ecx, DWORD PTR _rwindex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOppositeRunway@ATCBrain@@QAEHH@Z	; ATCBrain::GetOppositeRunway
	test	eax, eax
	je	SHORT $LN3@FindBestLa

; 2800 : 					rwindex = GetOppositeRunway(rwindex);

	mov	edx, DWORD PTR _rwindex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOppositeRunway@ATCBrain@@QAEHH@Z	; ATCBrain::GetOppositeRunway
	mov	DWORD PTR _rwindex$[ebp], eax
$LN3@FindBestLa:

; 2801 : 				}
; 2802 : 			}
; 2803 : 			else {

	jmp	SHORT $LN1@FindBestLa
$LN4@FindBestLa:

; 2804 : 				if(info->status < tReqTaxi && GetOppositeRunway(rwindex)){

	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax+8], 19			; 00000013H
	jge	SHORT $LN1@FindBestLa
	mov	ecx, DWORD PTR _rwindex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOppositeRunway@ATCBrain@@QAEHH@Z	; ATCBrain::GetOppositeRunway
	test	eax, eax
	je	SHORT $LN1@FindBestLa

; 2805 : 					rwindex = GetOppositeRunway(rwindex);

	mov	edx, DWORD PTR _rwindex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOppositeRunway@ATCBrain@@QAEHH@Z	; ATCBrain::GetOppositeRunway
	mov	DWORD PTR _rwindex$[ebp], eax
$LN1@FindBestLa:

; 2806 : 				}
; 2807 : 			}
; 2808 : 		}
; 2809 : 	}
; 2810 : 	return rwindex;

	mov	eax, DWORD PTR _rwindex$[ebp]
$LN35@FindBestLa:

; 2811 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?FindBestLandingRunway@ATCBrain@@QAEHPAVFalconEntity@@H@Z ENDP ; ATCBrain::FindBestLandingRunway
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_best$ = -32						; size = 4
_windheading$ = -28					; size = 4
_j$ = -24						; size = 4
_i$ = -20						; size = 4
_delta$ = -16						; size = 4
_rwindex$ = -12						; size = 4
_this$ = -8						; size = 4
_info$ = -4						; size = 4
_checklist$ = 8						; size = 4
?FindBestTakeoffRunway@ATCBrain@@QAEHH@Z PROC		; ATCBrain::FindBestTakeoffRunway
; _this$ = ecx

; 2127 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 2128 : 	int i, j;
; 2129 : 	int	delta, best=91, windheading = 0;

	mov	DWORD PTR _best$[ebp], 91		; 0000005bH
	mov	DWORD PTR _windheading$[ebp], 0

; 2130 : 	runwayQueueStruct *info = NULL;	

	mov	DWORD PTR _info$[ebp], 0

; 2131 : 
; 2132 : 	// Find windheading in degrees (add 180 if we want opposite direction)
; 2133 : 	if (realWeather)

	cmp	DWORD PTR ?realWeather@@3PAVRealWeather@@A, 0 ; realWeather
	je	SHORT $LN30@FindBestTa

; 2134 : 		windheading = FloatToInt32(((WeatherClass*)realWeather)->windHeading*RTD + 180.5f);

	mov	eax, DWORD PTR ?realWeather@@3PAVRealWeather@@A ; realWeather
	movss	xmm0, DWORD PTR [eax+15728]
	mulss	xmm0, DWORD PTR __real@42652ee1
	addss	xmm0, DWORD PTR __real@43348000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _windheading$[ebp], eax
$LN30@FindBestTa:

; 2135 : 	while (windheading > 360)

	cmp	DWORD PTR _windheading$[ebp], 360	; 00000168H
	jle	SHORT $LN28@FindBestTa

; 2136 : 		windheading -= 360;

	mov	ecx, DWORD PTR _windheading$[ebp]
	sub	ecx, 360				; 00000168H
	mov	DWORD PTR _windheading$[ebp], ecx
	jmp	SHORT $LN30@FindBestTa
$LN28@FindBestTa:

; 2137 : 
; 2138 : 	int rwindex = 0;

	mov	DWORD PTR _rwindex$[ebp], 0

; 2139 : 	// FRB - hack
; 2140 : 	if(numRwys > 4)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], 4
	jle	SHORT $LN27@FindBestTa

; 2141 : 		numRwys = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 1
$LN27@FindBestTa:

; 2142 : 
; 2143 : 	for(i = 0; i < numRwys; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN26@FindBestTa
$LN25@FindBestTa:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN26@FindBestTa:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jge	$LN24@FindBestTa

; 2144 : 	{
; 2145 : 		//if(runwayStats[i].state < VIS_DAMAGED && runwayStats[i].rwIndexes[1])
; 2146 : 		// FRB - CTDs
; 2147 : 		if(runwayStats[i].state < VIS_DAMAGED)

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	cx, WORD PTR [eax+ecx+24]
	and	cx, 7
	movzx	edx, cx
	cmp	edx, 2
	jge	$LN20@FindBestTa

; 2148 : 		{
; 2149 : 			for(j = 0; runwayStats[i].rwIndexes[j] && j < 2; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN22@FindBestTa
$LN21@FindBestTa:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN22@FindBestTa:
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+16]
	mov	eax, DWORD PTR _j$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $LN20@FindBestTa
	cmp	DWORD PTR _j$[ebp], 2
	jge	SHORT $LN20@FindBestTa

; 2150 : 			{
; 2151 : 				delta = abs(PtHeaderDataTable[runwayStats[i].rwIndexes[j]].data - windheading);

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	add	eax, ecx
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	ecx, WORD PTR [eax+edx+10]
	sub	ecx, DWORD PTR _windheading$[ebp]
	push	ecx
	call	_abs
	add	esp, 4
	mov	DWORD PTR _delta$[ebp], eax

; 2152 : 				if (delta > 180)

	cmp	DWORD PTR _delta$[ebp], 180		; 000000b4H
	jle	SHORT $LN19@FindBestTa

; 2153 : 					delta = 360 - delta;  // Cobra - simplify angle adjustment

	mov	edx, 360				; 00000168H
	sub	edx, DWORD PTR _delta$[ebp]
	mov	DWORD PTR _delta$[ebp], edx
$LN19@FindBestTa:

; 2154 : //					delta = abs(PtHeaderDataTable[runwayStats[i].rwIndexes[j]].data - 360 + windheading);
; 2155 : 				if (delta < best)

	mov	eax, DWORD PTR _delta$[ebp]
	cmp	eax, DWORD PTR _best$[ebp]
	jge	SHORT $LN18@FindBestTa

; 2156 : 				{
; 2157 : 					best = delta;

	mov	ecx, DWORD PTR _delta$[ebp]
	mov	DWORD PTR _best$[ebp], ecx

; 2158 : 					rwindex = runwayStats[i].rwIndexes[j];

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _rwindex$[ebp], edx
$LN18@FindBestTa:

; 2159 : 				}
; 2160 : 			}

	jmp	$LN21@FindBestTa
$LN20@FindBestTa:

; 2161 : 		}
; 2162 : 	}

	jmp	$LN25@FindBestTa
$LN24@FindBestTa:

; 2163 : 
; 2164 : 	if(!checklist)

	cmp	DWORD PTR _checklist$[ebp], 0
	jne	SHORT $LN17@FindBestTa

; 2165 : 		return rwindex;

	mov	eax, DWORD PTR _rwindex$[ebp]
	jmp	$LN31@FindBestTa
$LN17@FindBestTa:

; 2166 : 
; 2167 : 	info = runwayQueue[PtHeaderDataTable[rwindex].runwayNum];

	mov	eax, DWORD PTR _rwindex$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	edx, BYTE PTR [ecx+eax+24]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _info$[ebp], edx
$LN16@FindBestTa:

; 2168 : 	while(info && info->status == noATC)

	cmp	DWORD PTR _info$[ebp], 0
	je	SHORT $LN15@FindBestTa
	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN15@FindBestTa

; 2169 : 		info = info->next;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _info$[ebp], edx
	jmp	SHORT $LN16@FindBestTa
$LN15@FindBestTa:

; 2170 : 
; 2171 : 	if(info)

	cmp	DWORD PTR _info$[ebp], 0
	je	SHORT $LN14@FindBestTa

; 2172 : 	{
; 2173 : 		if(info->status >= tReqTaxi)

	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax+8], 19			; 00000013H
	jl	SHORT $LN13@FindBestTa

; 2174 : 			rwindex = info->rwindex;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _rwindex$[ebp], edx
	jmp	SHORT $LN11@FindBestTa
$LN13@FindBestTa:

; 2175 : 		else if(GetOppositeRunway(info->rwindex))

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOppositeRunway@ATCBrain@@QAEHH@Z	; ATCBrain::GetOppositeRunway
	test	eax, eax
	je	SHORT $LN11@FindBestTa

; 2176 : 			rwindex = GetOppositeRunway(info->rwindex);

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOppositeRunway@ATCBrain@@QAEHH@Z	; ATCBrain::GetOppositeRunway
	mov	DWORD PTR _rwindex$[ebp], eax
$LN11@FindBestTa:

; 2177 : 	}

	jmp	$LN1@FindBestTa
$LN14@FindBestTa:

; 2178 : 	else if(numRwys == 2 )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+8], 2
	jne	$LN1@FindBestTa

; 2179 : 	{
; 2180 : 		info = runwayQueue[1 - PtHeaderDataTable[rwindex].runwayNum];

	mov	edx, DWORD PTR _rwindex$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	ecx, BYTE PTR [eax+edx+24]
	mov	edx, 1
	sub	edx, ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _info$[ebp], edx
$LN8@FindBestTa:

; 2181 : 		while(info && info->status == noATC)

	cmp	DWORD PTR _info$[ebp], 0
	je	SHORT $LN7@FindBestTa
	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN7@FindBestTa

; 2182 : 			info = info->next;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _info$[ebp], edx
	jmp	SHORT $LN8@FindBestTa
$LN7@FindBestTa:

; 2183 : 
; 2184 : 		if(info)

	cmp	DWORD PTR _info$[ebp], 0
	je	$LN1@FindBestTa

; 2185 : 		{
; 2186 : 			delta = abs(PtHeaderDataTable[rwindex].data - PtHeaderDataTable[info->rwindex].data);

	mov	eax, DWORD PTR _rwindex$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	edx, WORD PTR [ecx+eax+10]
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	imul	ecx, 28					; 0000001cH
	mov	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	ecx, WORD PTR [eax+ecx+10]
	sub	edx, ecx
	push	edx
	call	_abs
	add	esp, 4
	mov	DWORD PTR _delta$[ebp], eax

; 2187 : 			if(delta > 180)

	cmp	DWORD PTR _delta$[ebp], 180		; 000000b4H
	jle	SHORT $LN5@FindBestTa

; 2188 : 				delta = abs(delta - 360);

	mov	edx, DWORD PTR _delta$[ebp]
	sub	edx, 360				; 00000168H
	push	edx
	call	_abs
	add	esp, 4
	mov	DWORD PTR _delta$[ebp], eax
$LN5@FindBestTa:

; 2189 : 
; 2190 : 			if(delta < 91)

	cmp	DWORD PTR _delta$[ebp], 91		; 0000005bH
	jge	SHORT $LN4@FindBestTa

; 2191 : 			{
; 2192 : 				if(info->status < tReqTaxi && info->status != noATC && GetOppositeRunway(rwindex))

	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax+8], 19			; 00000013H
	jge	SHORT $LN3@FindBestTa
	mov	ecx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN3@FindBestTa
	mov	edx, DWORD PTR _rwindex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOppositeRunway@ATCBrain@@QAEHH@Z	; ATCBrain::GetOppositeRunway
	test	eax, eax
	je	SHORT $LN3@FindBestTa

; 2193 : 					rwindex = GetOppositeRunway(rwindex);

	mov	eax, DWORD PTR _rwindex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOppositeRunway@ATCBrain@@QAEHH@Z	; ATCBrain::GetOppositeRunway
	mov	DWORD PTR _rwindex$[ebp], eax
$LN3@FindBestTa:

; 2194 : 			}
; 2195 : 			else

	jmp	SHORT $LN1@FindBestTa
$LN4@FindBestTa:

; 2196 : 			{
; 2197 : 				if(info->status >= tReqTaxi && GetOppositeRunway(rwindex))

	mov	ecx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [ecx+8], 19			; 00000013H
	jl	SHORT $LN1@FindBestTa
	mov	edx, DWORD PTR _rwindex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOppositeRunway@ATCBrain@@QAEHH@Z	; ATCBrain::GetOppositeRunway
	test	eax, eax
	je	SHORT $LN1@FindBestTa

; 2198 : 					rwindex = GetOppositeRunway(rwindex);

	mov	eax, DWORD PTR _rwindex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOppositeRunway@ATCBrain@@QAEHH@Z	; ATCBrain::GetOppositeRunway
	mov	DWORD PTR _rwindex$[ebp], eax
$LN1@FindBestTa:

; 2199 : 			}
; 2200 : 		}
; 2201 : 	}
; 2202 : 	return rwindex;

	mov	eax, DWORD PTR _rwindex$[ebp]
$LN31@FindBestTa:

; 2203 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?FindBestTakeoffRunway@ATCBrain@@QAEHH@Z ENDP		; ATCBrain::FindBestTakeoffRunway
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_prev$ = -24						; size = 4
_delta$ = -20						; size = 4
_this$ = -16						; size = 4
_takeoffTime$ = -12					; size = 4
_emerDelta$ = -8					; size = 4
_cur$ = -4						; size = 4
_flight$ = 8						; size = 4
_queue$ = 12						; size = 4
?FindFlightTakeoffTime@ATCBrain@@QAEKPAVFlightClass@@H@Z PROC ; ATCBrain::FindFlightTakeoffTime
; _this$ = ecx

; 2545 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 2546 : 	ulong takeoffTime, delta;
; 2547 : 	runwayQueueStruct *cur = runwayQueue[queue];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _queue$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _cur$[ebp], eax

; 2548 : 	runwayQueueStruct *prev = NULL;

	mov	DWORD PTR _prev$[ebp], 0

; 2549 : 	ulong emerDelta = 0;

	mov	DWORD PTR _emerDelta$[ebp], 0

; 2550 : 
; 2551 : 	//according to Kevin this should never happen
; 2552 : 	ShiAssert( flight->GetCurrentUnitWP() );
; 2553 : 
; 2554 : 	if(!flight || !flight->GetCurrentUnitWP())

	cmp	DWORD PTR _flight$[ebp], 0
	je	SHORT $LN23@FindFlight
	mov	ecx, DWORD PTR _flight$[ebp]
	call	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ ; UnitClass::GetCurrentUnitWP
	test	eax, eax
	jne	SHORT $LN24@FindFlight
$LN23@FindFlight:

; 2555 : 	{
; 2556 : 		if(!cur)

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN21@FindFlight

; 2557 : 			return SimLibElapsedTime;		

	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jmp	$LN25@FindFlight
$LN21@FindFlight:

; 2558 : 
; 2559 : 		while(cur->next)

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	je	SHORT $LN20@FindFlight

; 2560 : 		{
; 2561 : 			cur = cur->next;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _cur$[ebp], eax

; 2562 : 		}

	jmp	SHORT $LN21@FindFlight
$LN20@FindFlight:

; 2563 : 		
; 2564 : 		return cur->schedTime + LAND_TIME_DELTA;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	add	eax, 60000				; 0000ea60H
	jmp	$LN25@FindFlight
$LN24@FindFlight:

; 2565 : 	}
; 2566 : 
; 2567 : 	takeoffTime = flight->GetCurrentUnitWP()->GetWPDepartureTime();

	mov	ecx, DWORD PTR _flight$[ebp]
	call	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ ; UnitClass::GetCurrentUnitWP
	mov	ecx, eax
	call	?GetWPDepartureTime@WayPointClass@@QAEKXZ ; WayPointClass::GetWPDepartureTime
	mov	DWORD PTR _takeoffTime$[ebp], eax

; 2568 : 	//RAS - takeoff time has passed so set it to right now
; 2569 : 	if(takeoffTime < SimLibElapsedTime)

	mov	edx, DWORD PTR _takeoffTime$[ebp]
	cmp	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	SHORT $LN19@FindFlight

; 2570 : 		takeoffTime = SimLibElapsedTime;

	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR _takeoffTime$[ebp], eax
$LN19@FindFlight:

; 2571 : 
; 2572 : 	if(!cur)

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN18@FindFlight

; 2573 : 		return takeoffTime;

	mov	eax, DWORD PTR _takeoffTime$[ebp]
	jmp	$LN25@FindFlight
$LN18@FindFlight:

; 2574 : 
; 2575 : 	delta = flight->NumberOfComponents() * TAKEOFF_TIME_DELTA + LAND_TIME_DELTA;

	mov	ecx, DWORD PTR _flight$[ebp]
	call	?NumberOfComponents@CampBaseClass@@QAEHXZ ; CampBaseClass::NumberOfComponents
	imul	eax, 10000				; 00002710H
	add	eax, 60000				; 0000ea60H
	mov	DWORD PTR _delta$[ebp], eax

; 2576 : 
; 2577 : 	if(cur->aircraftID == runwayStats[queue].nextEmergency || (cur->status >= lEmergencyToBase && cur->status <= lEmergencyOnFinal))

	mov	ecx, DWORD PTR _queue$[ebp]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	lea	ecx, DWORD PTR [eax+ecx+32]
	push	ecx
	mov	ecx, DWORD PTR _cur$[ebp]
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN16@FindFlight
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+8], 15			; 0000000fH
	jl	SHORT $LN17@FindFlight
	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+8], 17			; 00000011H
	jg	SHORT $LN17@FindFlight
$LN16@FindFlight:

; 2578 : 		emerDelta = EMER_SLOT - LAND_TIME_DELTA;

	mov	DWORD PTR _emerDelta$[ebp], 0

; 2579 : 	else 

	jmp	SHORT $LN14@FindFlight
$LN17@FindFlight:

; 2580 : 		emerDelta = 0;

	mov	DWORD PTR _emerDelta$[ebp], 0
$LN14@FindFlight:

; 2581 : 
; 2582 : 	while(cur && (cur->schedTime <= takeoffTime || (takeoffTime < cur->schedTime && takeoffTime + delta + emerDelta > cur->schedTime) ) )

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN13@FindFlight
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+12]
	cmp	eax, DWORD PTR _takeoffTime$[ebp]
	jbe	SHORT $LN12@FindFlight
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _takeoffTime$[ebp]
	cmp	edx, DWORD PTR [ecx+12]
	jae	$LN13@FindFlight
	mov	eax, DWORD PTR _takeoffTime$[ebp]
	add	eax, DWORD PTR _delta$[ebp]
	add	eax, DWORD PTR _emerDelta$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	eax, DWORD PTR [ecx+12]
	jbe	SHORT $LN13@FindFlight
$LN12@FindFlight:

; 2583 : 	{
; 2584 : 		if(cur->aircraftID == runwayStats[queue].nextEmergency || (cur->status >= lEmergencyToBase && cur->status <= lEmergencyOnFinal))

	mov	edx, DWORD PTR _queue$[ebp]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	lea	edx, DWORD PTR [ecx+edx+32]
	push	edx
	mov	ecx, DWORD PTR _cur$[ebp]
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN10@FindFlight
	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+8], 15			; 0000000fH
	jl	SHORT $LN11@FindFlight
	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+8], 17			; 00000011H
	jg	SHORT $LN11@FindFlight
$LN10@FindFlight:

; 2585 : 			emerDelta = EMER_SLOT - LAND_TIME_DELTA;

	mov	DWORD PTR _emerDelta$[ebp], 0

; 2586 : 		else 

	jmp	SHORT $LN9@FindFlight
$LN11@FindFlight:

; 2587 : 			emerDelta = 0;

	mov	DWORD PTR _emerDelta$[ebp], 0
$LN9@FindFlight:

; 2588 : 
; 2589 : 		if(takeoffTime < cur->schedTime + LAND_TIME_DELTA + emerDelta)

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _emerDelta$[ebp]
	lea	eax, DWORD PTR [ecx+edx+60000]
	cmp	DWORD PTR _takeoffTime$[ebp], eax
	jae	SHORT $LN8@FindFlight

; 2590 : 			takeoffTime = cur->schedTime + LAND_TIME_DELTA + emerDelta;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _emerDelta$[ebp]
	lea	ecx, DWORD PTR [edx+eax+60000]
	mov	DWORD PTR _takeoffTime$[ebp], ecx
$LN8@FindFlight:

; 2591 : 		prev = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _prev$[ebp], edx

; 2592 : 		cur = cur->next;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _cur$[ebp], ecx

; 2593 : 	}

	jmp	$LN14@FindFlight
$LN13@FindFlight:

; 2594 : 
; 2595 : 	cur = prev;

	mov	edx, DWORD PTR _prev$[ebp]
	mov	DWORD PTR _cur$[ebp], edx
$LN7@FindFlight:

; 2596 : 
; 2597 : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN6@FindFlight

; 2598 : 	{
; 2599 : 		if(cur->aircraftID == runwayStats[queue].nextEmergency || (cur->status >= lEmergencyToBase && cur->status <= lEmergencyOnFinal))

	mov	eax, DWORD PTR _queue$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	lea	eax, DWORD PTR [edx+eax+32]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN4@FindFlight
	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+8], 15			; 0000000fH
	jl	SHORT $LN5@FindFlight
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+8], 17			; 00000011H
	jg	SHORT $LN5@FindFlight
$LN4@FindFlight:

; 2600 : 			emerDelta = EMER_SLOT - LAND_TIME_DELTA;

	mov	DWORD PTR _emerDelta$[ebp], 0

; 2601 : 		else 

	jmp	SHORT $LN3@FindFlight
$LN5@FindFlight:

; 2602 : 			emerDelta = 0;

	mov	DWORD PTR _emerDelta$[ebp], 0
$LN3@FindFlight:

; 2603 : 
; 2604 : 		if(takeoffTime < cur->schedTime + LAND_TIME_DELTA + emerDelta)

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _emerDelta$[ebp]
	lea	ecx, DWORD PTR [edx+eax+60000]
	cmp	DWORD PTR _takeoffTime$[ebp], ecx
	jae	SHORT $LN2@FindFlight

; 2605 : 			takeoffTime = cur->schedTime + LAND_TIME_DELTA + emerDelta;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _emerDelta$[ebp]
	lea	edx, DWORD PTR [eax+ecx+60000]
	mov	DWORD PTR _takeoffTime$[ebp], edx
$LN2@FindFlight:

; 2606 : 		if(cur->next && cur->schedTime + delta + emerDelta <= takeoffTime && takeoffTime + delta + emerDelta <= cur->next->schedTime)

	mov	eax, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN1@FindFlight
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, DWORD PTR _delta$[ebp]
	add	edx, DWORD PTR _emerDelta$[ebp]
	cmp	edx, DWORD PTR _takeoffTime$[ebp]
	ja	SHORT $LN1@FindFlight
	mov	eax, DWORD PTR _takeoffTime$[ebp]
	add	eax, DWORD PTR _delta$[ebp]
	add	eax, DWORD PTR _emerDelta$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	cmp	eax, DWORD PTR [edx+12]
	ja	SHORT $LN1@FindFlight

; 2607 : 		{
; 2608 : 			ShiAssert(takeoffTime >= cur->schedTime + LAND_TIME_DELTA + emerDelta);
; 2609 : 			ShiAssert(takeoffTime + delta + emerDelta <= cur->next->schedTime);
; 2610 : 			break;

	jmp	SHORT $LN6@FindFlight
$LN1@FindFlight:

; 2611 : 		}
; 2612 : 
; 2613 : 		cur = cur->next;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _cur$[ebp], ecx

; 2614 : 	}

	jmp	$LN7@FindFlight
$LN6@FindFlight:

; 2615 : 
; 2616 : 	return takeoffTime; 

	mov	eax, DWORD PTR _takeoffTime$[ebp]
$LN25@FindFlight:

; 2617 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?FindFlightTakeoffTime@ATCBrain@@QAEKPAVFlightClass@@H@Z ENDP ; ATCBrain::FindFlightTakeoffTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_info$ = -4						; size = 4
_queue$ = 8						; size = 4
?FindNextEmergency@ATCBrain@@QAEXH@Z PROC		; ATCBrain::FindNextEmergency
; _this$ = ecx

; 1915 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1916 : 	runwayQueueStruct	*info = runwayQueue[queue];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _queue$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _info$[ebp], eax

; 1917 : 
; 1918 : 	runwayStats[queue].nextEmergency = FalconNullId;

	mov	ecx, DWORD PTR _queue$[ebp]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [eax+ecx+32], edx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [eax+ecx+36], edx
$LN3@FindNextEm:

; 1919 : 
; 1920 : 	while(info && runwayStats[queue].nextEmergency == FalconNullId)

	cmp	DWORD PTR _info$[ebp], 0
	je	SHORT $LN4@FindNextEm
	push	OFFSET ?FalconNullId@@3VVU_ID@@A	; FalconNullId
	mov	eax, DWORD PTR _queue$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	lea	ecx, DWORD PTR [edx+eax+32]
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@FindNextEm

; 1921 : 	{
; 1922 : 		if(info->status >= lEmergencyToBase && info->status <= lCrashed)

	mov	ecx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [ecx+8], 15			; 0000000fH
	jl	SHORT $LN1@FindNextEm
	mov	edx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [edx+8], 18			; 00000012H
	jg	SHORT $LN1@FindNextEm

; 1923 : 		{
; 1924 : 			runwayStats[queue].nextEmergency = info->aircraftID;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _queue$[ebp]
	imul	eax, 40					; 00000028H
	mov	esi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [esi+16]
	mov	DWORD PTR [esi+eax+32], ecx
	mov	DWORD PTR [esi+eax+36], edx

; 1925 : 			break;

	jmp	SHORT $LN4@FindNextEm
$LN1@FindNextEm:

; 1926 : 		}
; 1927 : 		info = info->next;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _info$[ebp], edx

; 1928 : 	}

	jmp	SHORT $LN3@FindNextEm
$LN4@FindNextEm:

; 1929 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?FindNextEmergency@ATCBrain@@QAEXH@Z ENDP		; ATCBrain::FindNextEmergency
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_runway$ = -4						; size = 4
_rwindex$ = 8						; size = 4
?GetOppositeRunway@ATCBrain@@QAEHH@Z PROC		; ATCBrain::GetOppositeRunway
; _this$ = ecx

; 4464 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 4465 : // 2002-04-08 MN CTD fix
; 4466 : 	int runway = 0;

	mov	DWORD PTR _runway$[ebp], 0

; 4467 : 	if(runwayStats[PtHeaderDataTable[rwindex].runwayNum].rwIndexes[0] == rwindex)

	mov	eax, DWORD PTR _rwindex$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	edx, BYTE PTR [ecx+eax+24]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+16]
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR [edx+ecx]
	cmp	edx, DWORD PTR _rwindex$[ebp]
	jne	SHORT $LN3@GetOpposit

; 4468 : 		runway = runwayStats[PtHeaderDataTable[rwindex].runwayNum].rwIndexes[1];

	mov	eax, DWORD PTR _rwindex$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	edx, BYTE PTR [ecx+eax+24]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+16]
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _runway$[ebp], edx

; 4469 : 	else

	jmp	SHORT $LN2@GetOpposit
$LN3@GetOpposit:

; 4470 : 		runway = runwayStats[PtHeaderDataTable[rwindex].runwayNum].rwIndexes[0];

	mov	eax, DWORD PTR _rwindex$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	edx, BYTE PTR [ecx+eax+24]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+16]
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _runway$[ebp], edx
$LN2@GetOpposit:

; 4471 : 	ShiAssert(runway >= 0);
; 4472 : 	if (runway < 0)

	cmp	DWORD PTR _runway$[ebp], 0
	jge	SHORT $LN1@GetOpposit

; 4473 : 		runway = 0;

	mov	DWORD PTR _runway$[ebp], 0
$LN1@GetOpposit:

; 4474 : 	return runway;

	mov	eax, DWORD PTR _runway$[ebp]

; 4475 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetOppositeRunway@ATCBrain@@QAEHH@Z ENDP		; ATCBrain::GetOppositeRunway
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv66 = -8						; size = 4
_offset$ = -4						; size = 2
_hdg$ = 8						; size = 4
_ltrt$ = 12						; size = 4
?GetTextureIdFromHdg@ATCBrain@@QAEFHH@Z PROC		; ATCBrain::GetTextureIdFromHdg
; _this$ = ecx

; 4064 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 4065 : 	short offset = 0;

	xor	eax, eax
	mov	WORD PTR _offset$[ebp], ax

; 4066 : 	if(ltrt == -1)

	cmp	DWORD PTR _ltrt$[ebp], -1
	jne	SHORT $LN42@GetTexture

; 4067 : 		offset = 1;

	mov	ecx, 1
	mov	WORD PTR _offset$[ebp], cx
	jmp	SHORT $LN41@GetTexture
$LN42@GetTexture:

; 4068 : 	else if(ltrt == 1)

	cmp	DWORD PTR _ltrt$[ebp], 1
	jne	SHORT $LN41@GetTexture

; 4069 : 		offset = 2;

	mov	edx, 2
	mov	WORD PTR _offset$[ebp], dx
$LN41@GetTexture:

; 4070 : 
; 4071 : 	switch(hdg)

	mov	eax, DWORD PTR _hdg$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	cmp	DWORD PTR tv66[ebp], 36			; 00000024H
	ja	$LN38@GetTexture
	mov	ecx, DWORD PTR tv66[ebp]
	jmp	DWORD PTR $LN45@GetTexture[ecx*4]
$LN37@GetTexture:

; 4072 : 	{
; 4073 : 	case 0:
; 4074 : 		return (short)(offset + 37);

	movsx	eax, WORD PTR _offset$[ebp]
	add	eax, 37					; 00000025H
	jmp	$LN43@GetTexture
$LN36@GetTexture:

; 4075 : 	case 1:
; 4076 : 		return (short)(offset + 0);

	mov	ax, WORD PTR _offset$[ebp]
	jmp	$LN43@GetTexture
$LN35@GetTexture:

; 4077 : 	case 2:
; 4078 : 		return (short)(offset + 1);

	movsx	eax, WORD PTR _offset$[ebp]
	add	eax, 1
	jmp	$LN43@GetTexture
$LN34@GetTexture:

; 4079 : 	case 3:
; 4080 : 		return (short)(offset + 4);

	movsx	eax, WORD PTR _offset$[ebp]
	add	eax, 4
	jmp	$LN43@GetTexture
$LN33@GetTexture:

; 4081 : 	case 4:
; 4082 : 		return (short)(offset + 4);

	movsx	eax, WORD PTR _offset$[ebp]
	add	eax, 4
	jmp	$LN43@GetTexture
$LN32@GetTexture:

; 4083 : 	case 5:
; 4084 : 		return (short)(offset + 40);

	movsx	eax, WORD PTR _offset$[ebp]
	add	eax, 40					; 00000028H
	jmp	$LN43@GetTexture
$LN31@GetTexture:

; 4085 : 	case 6:
; 4086 : 		return (short)(offset + 5);

	movsx	eax, WORD PTR _offset$[ebp]
	add	eax, 5
	jmp	$LN43@GetTexture
$LN30@GetTexture:

; 4087 : 	case 7:
; 4088 : 		return (short)(offset + 6);

	movsx	eax, WORD PTR _offset$[ebp]
	add	eax, 6
	jmp	$LN43@GetTexture
$LN29@GetTexture:

; 4089 : 	case 8:
; 4090 : 		return (short)(offset + 6);

	movsx	eax, WORD PTR _offset$[ebp]
	add	eax, 6
	jmp	$LN43@GetTexture
$LN28@GetTexture:

; 4091 : 	case 9:
; 4092 : 		return (short)(offset + 7);

	movsx	eax, WORD PTR _offset$[ebp]
	add	eax, 7
	jmp	$LN43@GetTexture
$LN27@GetTexture:

; 4093 : 	case 10:
; 4094 : 		return (short)(offset + 8);

	movsx	eax, WORD PTR _offset$[ebp]
	add	eax, 8
	jmp	$LN43@GetTexture
$LN26@GetTexture:

; 4095 : 	case 11:
; 4096 : 		return (short)(offset + 8);

	movsx	eax, WORD PTR _offset$[ebp]
	add	eax, 8
	jmp	$LN43@GetTexture
$LN25@GetTexture:

; 4097 : 	case 12:
; 4098 : 		return (short)(offset + 9);

	movsx	eax, WORD PTR _offset$[ebp]
	add	eax, 9
	jmp	$LN43@GetTexture
$LN24@GetTexture:

; 4099 : 	case 13:
; 4100 : 		return (short)(offset + 10);

	movsx	eax, WORD PTR _offset$[ebp]
	add	eax, 10					; 0000000aH
	jmp	$LN43@GetTexture
$LN23@GetTexture:

; 4101 : 	case 14:
; 4102 : 		return (short)(offset + 10);

	movsx	eax, WORD PTR _offset$[ebp]
	add	eax, 10					; 0000000aH
	jmp	$LN43@GetTexture
$LN22@GetTexture:

; 4103 : 	case 15:
; 4104 : 		return (short)(offset + 16);

	movsx	eax, WORD PTR _offset$[ebp]
	add	eax, 16					; 00000010H
	jmp	$LN43@GetTexture
$LN21@GetTexture:

; 4105 : 	case 16:
; 4106 : 		return (short)(offset + 13);

	movsx	eax, WORD PTR _offset$[ebp]
	add	eax, 13					; 0000000dH
	jmp	$LN43@GetTexture
$LN20@GetTexture:

; 4107 : 	case 17:
; 4108 : 		return (short)(offset + 16);

	movsx	eax, WORD PTR _offset$[ebp]
	add	eax, 16					; 00000010H
	jmp	$LN43@GetTexture
$LN19@GetTexture:

; 4109 : 	case 18:
; 4110 : 		return (short)(offset + 17);

	movsx	eax, WORD PTR _offset$[ebp]
	add	eax, 17					; 00000011H
	jmp	$LN43@GetTexture
$LN18@GetTexture:

; 4111 : 	case 19:
; 4112 : 		return (short)(offset + 20);

	movsx	eax, WORD PTR _offset$[ebp]
	add	eax, 20					; 00000014H
	jmp	$LN43@GetTexture
$LN17@GetTexture:

; 4113 : 	case 20:
; 4114 : 		return (short)(offset + 21);

	movsx	eax, WORD PTR _offset$[ebp]
	add	eax, 21					; 00000015H
	jmp	$LN43@GetTexture
$LN16@GetTexture:

; 4115 : 	case 21:
; 4116 : 		return (short)(offset + 24);

	movsx	eax, WORD PTR _offset$[ebp]
	add	eax, 24					; 00000018H
	jmp	$LN43@GetTexture
$LN15@GetTexture:

; 4117 : 	case 22:
; 4118 : 		return (short)(offset + 24);

	movsx	eax, WORD PTR _offset$[ebp]
	add	eax, 24					; 00000018H
	jmp	$LN43@GetTexture
$LN14@GetTexture:

; 4119 : 	case 23:
; 4120 : 		return (short)(offset + 43);

	movsx	eax, WORD PTR _offset$[ebp]
	add	eax, 43					; 0000002bH
	jmp	SHORT $LN43@GetTexture
$LN13@GetTexture:

; 4121 : 	case 24:
; 4122 : 		return (short)(offset + 25);

	movsx	eax, WORD PTR _offset$[ebp]
	add	eax, 25					; 00000019H
	jmp	SHORT $LN43@GetTexture
$LN12@GetTexture:

; 4123 : 	case 25:
; 4124 : 		return (short)(offset + 26);

	movsx	eax, WORD PTR _offset$[ebp]
	add	eax, 26					; 0000001aH
	jmp	SHORT $LN43@GetTexture
$LN11@GetTexture:

; 4125 : 	case 26:
; 4126 : 		return (short)(offset + 26);

	movsx	eax, WORD PTR _offset$[ebp]
	add	eax, 26					; 0000001aH
	jmp	SHORT $LN43@GetTexture
$LN10@GetTexture:

; 4127 : 	case 27:
; 4128 : 		return (short)(offset + 27);

	movsx	eax, WORD PTR _offset$[ebp]
	add	eax, 27					; 0000001bH
	jmp	SHORT $LN43@GetTexture
$LN9@GetTexture:

; 4129 : 	case 28:
; 4130 : 		return (short)(offset + 28);

	movsx	eax, WORD PTR _offset$[ebp]
	add	eax, 28					; 0000001cH
	jmp	SHORT $LN43@GetTexture
$LN8@GetTexture:

; 4131 : 	case 29:
; 4132 : 		return (short)(offset + 28);

	movsx	eax, WORD PTR _offset$[ebp]
	add	eax, 28					; 0000001cH
	jmp	SHORT $LN43@GetTexture
$LN7@GetTexture:

; 4133 : 	case 30:
; 4134 : 		return (short)(offset + 29);

	movsx	eax, WORD PTR _offset$[ebp]
	add	eax, 29					; 0000001dH
	jmp	SHORT $LN43@GetTexture
$LN6@GetTexture:

; 4135 : 	case 31:
; 4136 : 		return (short)(offset + 30);

	movsx	eax, WORD PTR _offset$[ebp]
	add	eax, 30					; 0000001eH
	jmp	SHORT $LN43@GetTexture
$LN5@GetTexture:

; 4137 : 	case 32:
; 4138 : 		return (short)(offset + 30);

	movsx	eax, WORD PTR _offset$[ebp]
	add	eax, 30					; 0000001eH
	jmp	SHORT $LN43@GetTexture
$LN4@GetTexture:

; 4139 : 	case 33:
; 4140 : 		return (short)(offset + 36);

	movsx	eax, WORD PTR _offset$[ebp]
	add	eax, 36					; 00000024H
	jmp	SHORT $LN43@GetTexture
$LN3@GetTexture:

; 4141 : 	case 34:
; 4142 : 		return (short)(offset + 33);

	movsx	eax, WORD PTR _offset$[ebp]
	add	eax, 33					; 00000021H
	jmp	SHORT $LN43@GetTexture
$LN2@GetTexture:

; 4143 : 	case 35:
; 4144 : 		return (short)(offset + 36);

	movsx	eax, WORD PTR _offset$[ebp]
	add	eax, 36					; 00000024H
	jmp	SHORT $LN43@GetTexture
$LN1@GetTexture:

; 4145 : 	case 36:
; 4146 : 		return (short)(offset + 37);

	movsx	eax, WORD PTR _offset$[ebp]
	add	eax, 37					; 00000025H
	jmp	SHORT $LN43@GetTexture
$LN38@GetTexture:

; 4147 : 
; 4148 : 
; 4149 : 	}
; 4150 : 	return (short)(offset + 37);

	movsx	eax, WORD PTR _offset$[ebp]
	add	eax, 37					; 00000025H
$LN43@GetTexture:

; 4151 : }

	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN45@GetTexture:
	DD	$LN37@GetTexture
	DD	$LN36@GetTexture
	DD	$LN35@GetTexture
	DD	$LN34@GetTexture
	DD	$LN33@GetTexture
	DD	$LN32@GetTexture
	DD	$LN31@GetTexture
	DD	$LN30@GetTexture
	DD	$LN29@GetTexture
	DD	$LN28@GetTexture
	DD	$LN27@GetTexture
	DD	$LN26@GetTexture
	DD	$LN25@GetTexture
	DD	$LN24@GetTexture
	DD	$LN23@GetTexture
	DD	$LN22@GetTexture
	DD	$LN21@GetTexture
	DD	$LN20@GetTexture
	DD	$LN19@GetTexture
	DD	$LN18@GetTexture
	DD	$LN17@GetTexture
	DD	$LN16@GetTexture
	DD	$LN15@GetTexture
	DD	$LN14@GetTexture
	DD	$LN13@GetTexture
	DD	$LN12@GetTexture
	DD	$LN11@GetTexture
	DD	$LN10@GetTexture
	DD	$LN9@GetTexture
	DD	$LN8@GetTexture
	DD	$LN7@GetTexture
	DD	$LN6@GetTexture
	DD	$LN5@GetTexture
	DD	$LN4@GetTexture
	DD	$LN3@GetTexture
	DD	$LN2@GetTexture
	DD	$LN1@GetTexture
?GetTextureIdFromHdg@ATCBrain@@QAEFHH@Z ENDP		; ATCBrain::GetTextureIdFromHdg
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_index$ = -4						; size = 4
_rwindex$ = 8						; size = 4
?GetRunwayName@ATCBrain@@QAEHH@Z PROC			; ATCBrain::GetRunwayName
; _this$ = ecx

; 4156 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 4157 : // We have some bad data somewhere, just fix that here for now...
; 4158 : 	ShiAssert(rwindex >= 0);
; 4159 : 	if (rwindex < 0)

	cmp	DWORD PTR _rwindex$[ebp], 0
	jge	SHORT $LN1@GetRunwayN

; 4160 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN2@GetRunwayN
$LN1@GetRunwayN:

; 4161 : 	// FRB - CTD's here
; 4162 : 	int index = PtHeaderDataTable[rwindex].texIdx;

	mov	eax, DWORD PTR _rwindex$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	edx, WORD PTR [ecx+eax+22]
	mov	DWORD PTR _index$[ebp], edx

; 4163 : 
; 4164 : // JB 010508 Fix from Schumi
; 4165 : /*
; 4166 : 	//hack for unexpected 23L/R and 05L/R
; 4167 : 	if(index >= 43)
; 4168 : 		index = 27;
; 4169 : 	else if(index >= 40)
; 4170 : 		index = 5;
; 4171 : */
; 4172 : 
; 4173 : 	return index;

	mov	eax, DWORD PTR _index$[ebp]
$LN2@GetRunwayN:

; 4174 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetRunwayName@ATCBrain@@QAEHH@Z ENDP			; ATCBrain::GetRunwayName
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_index$ = -12						; size = 4
_this$ = -8						; size = 4
_i$ = -4						; size = 4
_component$ = 8						; size = 4
?GetRunwayTexture@ATCBrain@@QAEHH@Z PROC		; ATCBrain::GetRunwayTexture
; _this$ = ecx

; 4049 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 4050 : 	int i, index = 0;

	mov	DWORD PTR _index$[ebp], 0

; 4051 : 	for(i = 0; i < numRwys; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN5@GetRunwayT
$LN4@GetRunwayT:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN5@GetRunwayT:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jge	$LN3@GetRunwayT

; 4052 : 	{
; 4053 : 		if(PtHeaderDataTable[runwayStats[i].rwIndexes[0]].features[0] == component)

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, eax
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR [edx+eax]
	imul	ecx, 28					; 0000001cH
	add	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	mov	edx, 1
	imul	edx, 0
	movzx	eax, BYTE PTR [ecx+edx+4]
	cmp	eax, DWORD PTR _component$[ebp]
	jne	SHORT $LN2@GetRunwayT

; 4054 : 			index = PtHeaderDataTable[runwayStats[i].rwIndexes[0]].texIdx;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	add	eax, ecx
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR [eax+ecx]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	ecx, WORD PTR [eax+edx+22]
	mov	DWORD PTR _index$[ebp], ecx
$LN2@GetRunwayT:

; 4055 : 		if(PtHeaderDataTable[runwayStats[i].rwIndexes[1]].features[0] == component)

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, edx
	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR [ecx+edx]
	imul	eax, 28					; 0000001cH
	add	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	mov	ecx, 1
	imul	ecx, 0
	movzx	edx, BYTE PTR [eax+ecx+4]
	cmp	edx, DWORD PTR _component$[ebp]
	jne	SHORT $LN1@GetRunwayT

; 4056 : 			index = PtHeaderDataTable[runwayStats[i].rwIndexes[1]].texIdx;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, eax
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR [edx+eax]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	eax, WORD PTR [edx+ecx+22]
	mov	DWORD PTR _index$[ebp], eax
$LN1@GetRunwayT:

; 4057 : 	}

	jmp	$LN4@GetRunwayT
$LN3@GetRunwayT:

; 4058 : 
; 4059 : 	return index;

	mov	eax, DWORD PTR _index$[ebp]

; 4060 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetRunwayTexture@ATCBrain@@QAEHH@Z ENDP		; ATCBrain::GetRunwayTexture
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_aircraft$ = -24					; size = 4
_list$ = -20						; size = 4
_emer$ = -16						; size = 4
_this$ = -12						; size = 4
_info$ = -8						; size = 4
_listPtr$ = -4						; size = 4
_queue$ = 8						; size = 4
?SetEmergency@ATCBrain@@QAEXH@Z PROC			; ATCBrain::SetEmergency
; _this$ = ecx

; 1933 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1934 : 	AircraftClass		*aircraft = NULL;

	mov	DWORD PTR _aircraft$[ebp], 0

; 1935 : 	runwayQueueStruct	*info = NULL;

	mov	DWORD PTR _info$[ebp], 0

; 1936 : 	runwayQueueStruct	*list = NULL;

	mov	DWORD PTR _list$[ebp], 0

; 1937 : 	runwayQueueStruct	*listPtr = NULL;

	mov	DWORD PTR _listPtr$[ebp], 0

; 1938 : 	runwayQueueStruct	*emer = NULL;

	mov	DWORD PTR _emer$[ebp], 0

; 1939 : 
; 1940 : 	emer = runwayQueue[queue];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _queue$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _emer$[ebp], eax
$LN14@SetEmergen:

; 1941 : 	while(emer && emer->aircraftID != runwayStats[queue].nextEmergency)

	cmp	DWORD PTR _emer$[ebp], 0
	je	SHORT $LN13@SetEmergen
	mov	ecx, DWORD PTR _queue$[ebp]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	lea	ecx, DWORD PTR [eax+ecx+32]
	push	ecx
	mov	ecx, DWORD PTR _emer$[ebp]
	call	??9VU_ID@@QBE_NABV0@@Z			; VU_ID::operator!=
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN13@SetEmergen

; 1942 : 		emer = emer->next;

	mov	eax, DWORD PTR _emer$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _emer$[ebp], ecx
	jmp	SHORT $LN14@SetEmergen
$LN13@SetEmergen:

; 1943 : 
; 1944 :    // Check for AC in the queue. If its not, don't remove it, just return LRKLUDGE
; 1945 :    if (!emer)

	cmp	DWORD PTR _emer$[ebp], 0
	jne	SHORT $LN12@SetEmergen

; 1946 :       return;

	jmp	$LN15@SetEmergen
$LN12@SetEmergen:

; 1947 : 
; 1948 : 	info = emer->prev;

	mov	edx, DWORD PTR _emer$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR _info$[ebp], eax
$LN11@SetEmergen:

; 1949 : 	while(info && info->schedTime + EMER_SLOT > emer->schedTime)

	cmp	DWORD PTR _info$[ebp], 0
	je	SHORT $LN10@SetEmergen
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, 60000				; 0000ea60H
	mov	eax, DWORD PTR _emer$[ebp]
	cmp	edx, DWORD PTR [eax+12]
	jbe	SHORT $LN10@SetEmergen

; 1950 : 	{
; 1951 : 		runwayQueue[queue] = RemoveFromList(runwayQueue[queue], info);

	mov	ecx, DWORD PTR _info$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _queue$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveFromList@ATCBrain@@QAEPAUrunwayQueueStruct@@PAU2@0@Z ; ATCBrain::RemoveFromList
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _queue$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 1952 : 		list = AddToList(list, info);		

	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	mov	eax, DWORD PTR _list$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddToList@ATCBrain@@QAEPAUrunwayQueueStruct@@PAU2@0@Z ; ATCBrain::AddToList
	mov	DWORD PTR _list$[ebp], eax

; 1953 : 		info = emer->prev;

	mov	ecx, DWORD PTR _emer$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR _info$[ebp], edx

; 1954 : 	}

	jmp	SHORT $LN11@SetEmergen
$LN10@SetEmergen:

; 1955 : 
; 1956 : 	listPtr = emer->next;

	mov	eax, DWORD PTR _emer$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _listPtr$[ebp], ecx
$LN9@SetEmergen:

; 1957 : 	while(listPtr &&  ( listPtr->prev->status < lEmergencyToBase || listPtr->prev->status > lEmergencyOnFinal) )

	cmp	DWORD PTR _listPtr$[ebp], 0
	je	SHORT $LN8@SetEmergen
	mov	edx, DWORD PTR _listPtr$[ebp]
	mov	eax, DWORD PTR [edx+28]
	cmp	DWORD PTR [eax+8], 15			; 0000000fH
	jl	SHORT $LN7@SetEmergen
	mov	ecx, DWORD PTR _listPtr$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	cmp	DWORD PTR [edx+8], 17			; 00000011H
	jle	SHORT $LN8@SetEmergen
$LN7@SetEmergen:

; 1958 : 	{
; 1959 : 		info = listPtr;

	mov	eax, DWORD PTR _listPtr$[ebp]
	mov	DWORD PTR _info$[ebp], eax

; 1960 : 		listPtr = listPtr->next;

	mov	ecx, DWORD PTR _listPtr$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _listPtr$[ebp], edx

; 1961 : 		runwayQueue[queue] = RemoveFromList(runwayQueue[queue], info);

	mov	eax, DWORD PTR _info$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _queue$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveFromList@ATCBrain@@QAEPAUrunwayQueueStruct@@PAU2@0@Z ; ATCBrain::RemoveFromList
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _queue$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 1962 : 		list = AddToList(list, info);

	mov	eax, DWORD PTR _info$[ebp]
	push	eax
	mov	ecx, DWORD PTR _list$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddToList@ATCBrain@@QAEPAUrunwayQueueStruct@@PAU2@0@Z ; ATCBrain::AddToList
	mov	DWORD PTR _list$[ebp], eax

; 1963 : 	}

	jmp	SHORT $LN9@SetEmergen
$LN8@SetEmergen:

; 1964 : 
; 1965 : 	listPtr = list;

	mov	edx, DWORD PTR _list$[ebp]
	mov	DWORD PTR _listPtr$[ebp], edx
$LN6@SetEmergen:

; 1966 : 	while(listPtr)

	cmp	DWORD PTR _listPtr$[ebp], 0
	je	$LN15@SetEmergen

; 1967 : 	{
; 1968 : 		info = InList(listPtr->aircraftID);

	mov	eax, DWORD PTR _listPtr$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InList@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@@Z ; ATCBrain::InList
	mov	DWORD PTR _info$[ebp], eax

; 1969 : 		if(info)

	cmp	DWORD PTR _info$[ebp], 0
	je	SHORT $LN4@SetEmergen

; 1970 : 		{
; 1971 : 			info = listPtr;

	mov	eax, DWORD PTR _listPtr$[ebp]
	mov	DWORD PTR _info$[ebp], eax

; 1972 : 			listPtr = listPtr->next;

	mov	ecx, DWORD PTR _listPtr$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _listPtr$[ebp], edx

; 1973 : 			list = RemoveFromList(list, info);

	mov	eax, DWORD PTR _info$[ebp]
	push	eax
	mov	ecx, DWORD PTR _list$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveFromList@ATCBrain@@QAEPAUrunwayQueueStruct@@PAU2@0@Z ; ATCBrain::RemoveFromList
	mov	DWORD PTR _list$[ebp], eax

; 1974 : 			continue;

	jmp	SHORT $LN6@SetEmergen
$LN4@SetEmergen:

; 1975 : 		}
; 1976 : 		aircraft = (AircraftClass*)vuDatabase->Find(listPtr->aircraftID);

	mov	edx, DWORD PTR _listPtr$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR [edx]
	push	ecx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _aircraft$[ebp], eax

; 1977 : 		if(listPtr->status >= tReqTaxi)

	mov	edx, DWORD PTR _listPtr$[ebp]
	cmp	DWORD PTR [edx+8], 19			; 00000013H
	jl	SHORT $LN3@SetEmergen

; 1978 : 			RequestTakeoff(aircraft);

	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RequestTakeoff@ATCBrain@@QAEXPAVAircraftClass@@@Z ; ATCBrain::RequestTakeoff
	jmp	SHORT $LN2@SetEmergen
$LN3@SetEmergen:

; 1979 : 		else if(listPtr->status > noATC)

	mov	ecx, DWORD PTR _listPtr$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	jle	SHORT $LN2@SetEmergen

; 1980 : 			RequestClearance(aircraft, FALSE);

	push	0
	mov	edx, DWORD PTR _aircraft$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RequestClearance@ATCBrain@@QAEXPAVAircraftClass@@H@Z ; ATCBrain::RequestClearance
$LN2@SetEmergen:

; 1981 : 
; 1982 : 		info = listPtr;

	mov	eax, DWORD PTR _listPtr$[ebp]
	mov	DWORD PTR _info$[ebp], eax

; 1983 : 		listPtr = listPtr->next;

	mov	ecx, DWORD PTR _listPtr$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _listPtr$[ebp], edx

; 1984 :    		list = RemoveFromList(list, info);

	mov	eax, DWORD PTR _info$[ebp]
	push	eax
	mov	ecx, DWORD PTR _list$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveFromList@ATCBrain@@QAEPAUrunwayQueueStruct@@PAU2@0@Z ; ATCBrain::RemoveFromList
	mov	DWORD PTR _list$[ebp], eax

; 1985 : 	}

	jmp	$LN6@SetEmergen
$LN15@SetEmergen:

; 1986 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetEmergency@ATCBrain@@QAEXH@Z ENDP			; ATCBrain::SetEmergency
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_takeoffTime$ = -20					; size = 4
_this$ = -16						; size = 4
_deleteInfo$ = -12					; size = 4
_i$ = -8						; size = 4
_info$ = -4						; size = 4
_id$ = 8						; size = 8
?RemovePlaceHolders@ATCBrain@@QAEKVVU_ID@@@Z PROC	; ATCBrain::RemovePlaceHolders
; _this$ = ecx

; 5105 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 5106 : 	runwayQueueStruct	*info = NULL;

	mov	DWORD PTR _info$[ebp], 0

; 5107 : 	runwayQueueStruct	*deleteInfo = NULL;

	mov	DWORD PTR _deleteInfo$[ebp], 0

; 5108 : 	ulong				takeoffTime = 0;

	mov	DWORD PTR _takeoffTime$[ebp], 0

; 5109 : 	int					i;
; 5110 : 
; 5111 : 	for(i = 0; i < numRwys; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@RemovePlac
$LN6@RemovePlac:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@RemovePlac:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jge	SHORT $LN5@RemovePlac

; 5112 : 	{
; 5113 : 		info = runwayQueue[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _info$[ebp], eax
$LN4@RemovePlac:

; 5114 : 		while(info)

	cmp	DWORD PTR _info$[ebp], 0
	je	SHORT $LN3@RemovePlac

; 5115 : 		{
; 5116 : 			deleteInfo = info;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR _deleteInfo$[ebp], ecx

; 5117 : 			info = info->next;

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _info$[ebp], eax

; 5118 : 			if(deleteInfo->aircraftID == id)

	lea	ecx, DWORD PTR _id$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _deleteInfo$[ebp]
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@RemovePlac

; 5119 : 			{
; 5120 : 				if(!takeoffTime)

	cmp	DWORD PTR _takeoffTime$[ebp], 0
	jne	SHORT $LN1@RemovePlac

; 5121 : 					takeoffTime = deleteInfo->schedTime;

	mov	eax, DWORD PTR _deleteInfo$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _takeoffTime$[ebp], ecx
$LN1@RemovePlac:

; 5122 : 				RemoveTraffic(id, i);

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _id$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _id$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveTraffic@ATCBrain@@QAEXVVU_ID@@H@Z ; ATCBrain::RemoveTraffic
$LN2@RemovePlac:

; 5123 : 			}
; 5124 : 		}

	jmp	SHORT $LN4@RemovePlac
$LN3@RemovePlac:

; 5125 : 	}

	jmp	SHORT $LN6@RemovePlac
$LN5@RemovePlac:

; 5126 : 	return takeoffTime;

	mov	eax, DWORD PTR _takeoffTime$[ebp]

; 5127 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?RemovePlaceHolders@ATCBrain@@QAEKVVU_ID@@@Z ENDP	; ATCBrain::RemovePlaceHolders
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_findWalker$ = -52					; size = 12
$T2 = -40						; size = 8
$T3 = -32						; size = 8
_this$ = -24						; size = 4
_info$ = -20						; size = 4
_curObj$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_aircraft$ = 8						; size = 4
?RemoveFromAllATCs@ATCBrain@@QAEXPAVAircraftClass@@@Z PROC ; ATCBrain::RemoveFromAllATCs
; _this$ = ecx

; 4985 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?RemoveFromAllATCs@ATCBrain@@QAEXPAVAircraftClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 4986 : 	ObjectiveClass* curObj;
; 4987 : 	runwayQueueStruct *info;
; 4988 : 
; 4989 : 	VuListIterator findWalker (SimDriver.atcList);

	mov	eax, DWORD PTR ?SimDriver@@3VSimulationDriver@@A+32
	push	eax
	lea	ecx, DWORD PTR _findWalker$[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4990 : 	curObj = (ObjectiveClass*)findWalker.GetFirst();

	lea	ecx, DWORD PTR _findWalker$[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _curObj$[ebp], eax
$LN6@RemoveFrom:

; 4991 : 	while (curObj )

	cmp	DWORD PTR _curObj$[ebp], 0
	je	$LN5@RemoveFrom

; 4992 : 	{
; 4993 : 		if(curObj && curObj->GetType() == TYPE_AIRBASE )

	cmp	DWORD PTR _curObj$[ebp], 0
	je	$LN4@RemoveFrom
	mov	ecx, DWORD PTR _curObj$[ebp]
	call	?GetType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetType
	movzx	ecx, al
	cmp	ecx, 1
	jne	$LN4@RemoveFrom

; 4994 : 		{
; 4995 : 			info = curObj->brain->InList(aircraft->Id());

	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR _curObj$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?InList@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@@Z ; ATCBrain::InList
	mov	DWORD PTR _info$[ebp], eax

; 4996 : 			if(info)

	cmp	DWORD PTR _info$[ebp], 0
	je	SHORT $LN4@RemoveFrom

; 4997 : 			{
; 4998 : 				if(info->rwindex)

	mov	ecx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	je	SHORT $LN2@RemoveFrom

; 4999 : 					curObj->brain->RemoveTraffic(aircraft->Id(), PtHeaderDataTable[info->rwindex].runwayNum);

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+20]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	edx, BYTE PTR [ecx+eax+24]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR _curObj$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?RemoveTraffic@ATCBrain@@QAEXVVU_ID@@H@Z ; ATCBrain::RemoveTraffic

; 5000 : 				else

	jmp	SHORT $LN1@RemoveFrom
$LN2@RemoveFrom:

; 5001 : 					curObj->brain->RemoveInbound(info);

	mov	ecx, DWORD PTR _info$[ebp]
	push	ecx
	mov	edx, DWORD PTR _curObj$[ebp]
	mov	ecx, DWORD PTR [edx+240]
	call	?RemoveInbound@ATCBrain@@QAEXPAUrunwayQueueStruct@@@Z ; ATCBrain::RemoveInbound
$LN1@RemoveFrom:

; 5002 : 				return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _findWalker$[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
	jmp	SHORT $LN7@RemoveFrom
$LN4@RemoveFrom:

; 5003 : 			}
; 5004 : 		}
; 5005 : 		curObj = (ObjectiveClass*)findWalker.GetNext();

	lea	ecx, DWORD PTR _findWalker$[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _curObj$[ebp], eax

; 5006 : 	}

	jmp	$LN6@RemoveFrom
$LN5@RemoveFrom:

; 5007 : 
; 5008 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _findWalker$[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
$LN7@RemoveFrom:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?RemoveFromAllATCs@ATCBrain@@QAEXPAVAircraftClass@@@Z$0:
	lea	ecx, DWORD PTR _findWalker$[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__ehhandler$?RemoveFromAllATCs@ATCBrain@@QAEXPAVAircraftClass@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?RemoveFromAllATCs@ATCBrain@@QAEXPAVAircraftClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?RemoveFromAllATCs@ATCBrain@@QAEXPAVAircraftClass@@@Z ENDP ; ATCBrain::RemoveFromAllATCs
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_findWalker$ = -52					; size = 12
$T2 = -40						; size = 8
$T3 = -32						; size = 8
_this$ = -24						; size = 4
_info$ = -20						; size = 4
_curObj$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_aircraft$ = 8						; size = 4
?RemoveFromAllOtherATCs@ATCBrain@@QAEXPAVAircraftClass@@@Z PROC ; ATCBrain::RemoveFromAllOtherATCs
; _this$ = ecx

; 4958 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?RemoveFromAllOtherATCs@ATCBrain@@QAEXPAVAircraftClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 4959 : 	ObjectiveClass* curObj;
; 4960 : 	runwayQueueStruct *info;
; 4961 : 
; 4962 : 	VuListIterator findWalker (SimDriver.atcList);

	mov	eax, DWORD PTR ?SimDriver@@3VSimulationDriver@@A+32
	push	eax
	lea	ecx, DWORD PTR _findWalker$[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4963 : 	curObj = (ObjectiveClass*)findWalker.GetFirst();

	lea	ecx, DWORD PTR _findWalker$[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _curObj$[ebp], eax
$LN6@RemoveFrom:

; 4964 : 	while (curObj )

	cmp	DWORD PTR _curObj$[ebp], 0
	je	$LN5@RemoveFrom

; 4965 : 	{
; 4966 : 		if(curObj && curObj != self && curObj->GetType() == TYPE_AIRBASE )

	cmp	DWORD PTR _curObj$[ebp], 0
	je	$LN4@RemoveFrom
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _curObj$[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	je	$LN4@RemoveFrom
	mov	ecx, DWORD PTR _curObj$[ebp]
	call	?GetType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetType
	movzx	eax, al
	cmp	eax, 1
	jne	$LN4@RemoveFrom

; 4967 : 		{
; 4968 : 			info = curObj->brain->InList(aircraft->Id());

	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _curObj$[ebp]
	mov	ecx, DWORD PTR [ecx+240]
	call	?InList@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@@Z ; ATCBrain::InList
	mov	DWORD PTR _info$[ebp], eax

; 4969 : 			if(info)

	cmp	DWORD PTR _info$[ebp], 0
	je	SHORT $LN4@RemoveFrom

; 4970 : 			{
; 4971 : 				if(info->rwindex)

	mov	edx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [edx+20], 0
	je	SHORT $LN2@RemoveFrom

; 4972 : 					curObj->brain->RemoveTraffic(aircraft->Id(), PtHeaderDataTable[info->rwindex].runwayNum);

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	eax, BYTE PTR [edx+ecx+24]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _curObj$[ebp]
	mov	ecx, DWORD PTR [ecx+240]
	call	?RemoveTraffic@ATCBrain@@QAEXVVU_ID@@H@Z ; ATCBrain::RemoveTraffic

; 4973 : 				else

	jmp	SHORT $LN1@RemoveFrom
$LN2@RemoveFrom:

; 4974 : 					curObj->brain->RemoveInbound(info);

	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	mov	eax, DWORD PTR _curObj$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?RemoveInbound@ATCBrain@@QAEXPAUrunwayQueueStruct@@@Z ; ATCBrain::RemoveInbound
$LN1@RemoveFrom:

; 4975 : 				return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _findWalker$[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
	jmp	SHORT $LN7@RemoveFrom
$LN4@RemoveFrom:

; 4976 : 			}
; 4977 : 		}
; 4978 : 		curObj = (ObjectiveClass*)findWalker.GetNext();

	lea	ecx, DWORD PTR _findWalker$[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _curObj$[ebp], eax

; 4979 : 	}

	jmp	$LN6@RemoveFrom
$LN5@RemoveFrom:

; 4980 : 
; 4981 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _findWalker$[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
$LN7@RemoveFrom:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?RemoveFromAllOtherATCs@ATCBrain@@QAEXPAVAircraftClass@@@Z$0:
	lea	ecx, DWORD PTR _findWalker$[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__ehhandler$?RemoveFromAllOtherATCs@ATCBrain@@QAEXPAVAircraftClass@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?RemoveFromAllOtherATCs@ATCBrain@@QAEXPAVAircraftClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?RemoveFromAllOtherATCs@ATCBrain@@QAEXPAVAircraftClass@@@Z ENDP ; ATCBrain::RemoveFromAllOtherATCs
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
_info$ = 8						; size = 4
?RemoveInbound@ATCBrain@@QAEXPAUrunwayQueueStruct@@@Z PROC ; ATCBrain::RemoveInbound
; _this$ = ecx

; 3843 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 3844 : 	if(info == inboundQueue)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _info$[ebp]
	cmp	ecx, DWORD PTR [eax+24]
	jne	SHORT $LN4@RemoveInbo

; 3845 : 	{
; 3846 : 		inboundQueue = info->next;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [edx+24], ecx

; 3847 : 	}
; 3848 : 	else

	jmp	SHORT $LN3@RemoveInbo
$LN4@RemoveInbo:

; 3849 : 	{
; 3850 : 		ShiAssert( info->prev );
; 3851 : 		if (info->prev) // JB 010109 CTD sanity check

	mov	edx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $LN3@RemoveInbo

; 3852 : 			info->prev->next = info->next;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+24], eax
$LN3@RemoveInbo:

; 3853 : 	}
; 3854 : 
; 3855 : 	if(info->next)

	mov	ecx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	je	SHORT $LN1@RemoveInbo

; 3856 : 		info->next->prev = info->prev;

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], edx
$LN1@RemoveInbo:

; 3857 : 
; 3858 : #ifdef TEST_HACK_THAT_LEAKS
; 3859 : 	// We'll leave this thing arround, but tag it with the "this" of the atc brain that tried to kill it
; 3860 : 	info->deletor = this;
; 3861 : 	info->deleteLine = __LINE__;
; 3862 : #else
; 3863 : 	delete info;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 3864 : #endif
; 3865 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveInbound@ATCBrain@@QAEXPAUrunwayQueueStruct@@@Z ENDP ; ATCBrain::RemoveInbound
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_list$ = 8						; size = 4
_info$ = 12						; size = 4
?RemoveFromList@ATCBrain@@QAEPAUrunwayQueueStruct@@PAU2@0@Z PROC ; ATCBrain::RemoveFromList
; _this$ = ecx

; 3723 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3724 : 	if(info->prev)

	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $LN3@RemoveFrom

; 3725 : 	{
; 3726 : 		info->prev->next = info->next;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [edx+24], ecx

; 3727 : 	}
; 3728 : 	else

	jmp	SHORT $LN2@RemoveFrom
$LN3@RemoveFrom:

; 3729 : 	{
; 3730 : 		ShiAssert( info == list );
; 3731 : 		list = info->next;

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _list$[ebp], eax
$LN2@RemoveFrom:

; 3732 : 	}
; 3733 : 	
; 3734 : 	if(info->next)

	mov	ecx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	je	SHORT $LN1@RemoveFrom

; 3735 : 		info->next->prev = info->prev;

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], edx
$LN1@RemoveFrom:

; 3736 : 
; 3737 : 	return list;

	mov	eax, DWORD PTR _list$[ebp]

; 3738 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?RemoveFromList@ATCBrain@@QAEPAUrunwayQueueStruct@@PAU2@0@Z ENDP ; ATCBrain::RemoveFromList
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
$T1 = -12						; size = 4
_cur$ = -8						; size = 4
_this$ = -4						; size = 4
_aircraftID$ = 8					; size = 8
_queue$ = 16						; size = 4
?RemoveTraffic@ATCBrain@@QAEXVVU_ID@@H@Z PROC		; ATCBrain::RemoveTraffic
; _this$ = ecx

; 3742 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 3743 : 	runwayQueueStruct *cur = runwayQueue[queue];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _queue$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _cur$[ebp], eax
$LN4@RemoveTraf:

; 3744 : 	
; 3745 : 	//ShiAssert( GetCurrentThreadId() == gSimThreadID );
; 3746 : 
; 3747 : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN3@RemoveTraf

; 3748 : 	{
; 3749 : 		if(cur->aircraftID == aircraftID)

	lea	ecx, DWORD PTR _aircraftID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _cur$[ebp]
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	edx, al
	test	edx, edx
	je	$LN2@RemoveTraf

; 3750 : 		{
; 3751 : 			runwayQueue[queue] = RemoveFromList(runwayQueue[queue], cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _queue$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveFromList@ATCBrain@@QAEPAUrunwayQueueStruct@@PAU2@0@Z ; ATCBrain::RemoveFromList
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _queue$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 3752 : 
; 3753 : #ifdef TEST_HACK_THAT_LEAKS
; 3754 : 			// We'll leave this thing around, but tag it with the "this" of the atc brain that tried to kill it
; 3755 : 			cur->deletor = this;
; 3756 : 			cur->deleteLine = __LINE__;
; 3757 : #else
; 3758 : 			delete cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 3759 : #endif
; 3760 : 			runwayStats[queue].numInQueue--;

	mov	edx, DWORD PTR _queue$[ebp]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	dx, WORD PTR [ecx+edx+24]
	shr	dx, 3
	mov	eax, 8191				; 00001fffH
	and	dx, ax
	sub	dx, 1
	mov	ecx, DWORD PTR _queue$[ebp]
	imul	ecx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	mov	esi, 8191				; 00001fffH
	and	dx, si
	shl	dx, 3
	mov	cx, WORD PTR [eax+ecx+24]
	and	cx, 7
	or	cx, dx
	mov	edx, DWORD PTR _queue$[ebp]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	mov	WORD PTR [eax+edx+24], cx

; 3761 : 
; 3762 : 			break;

	jmp	SHORT $LN3@RemoveTraf
$LN2@RemoveTraf:

; 3763 : 		}
; 3764 : 		cur = cur->next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _cur$[ebp], edx

; 3765 : 	}

	jmp	$LN4@RemoveTraf
$LN3@RemoveTraf:

; 3766 : 
; 3767 : 	if(runwayStats[queue].nextEmergency == aircraftID)

	lea	eax, DWORD PTR _aircraftID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _queue$[ebp]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	lea	ecx, DWORD PTR [eax+ecx+32]
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@RemoveTraf

; 3768 : 	{
; 3769 : 		FindNextEmergency(queue);

	mov	edx, DWORD PTR _queue$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindNextEmergency@ATCBrain@@QAEXH@Z	; ATCBrain::FindNextEmergency
$LN5@RemoveTraf:

; 3770 : 	}
; 3771 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?RemoveTraffic@ATCBrain@@QAEXVVU_ID@@H@Z ENDP		; ATCBrain::RemoveTraffic
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_listPrev$ = -8						; size = 4
_listPtr$ = -4						; size = 4
_list$ = 8						; size = 4
_info$ = 12						; size = 4
?AddToList@ATCBrain@@QAEPAUrunwayQueueStruct@@PAU2@0@Z PROC ; ATCBrain::AddToList
; _this$ = ecx

; 3632 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 3633 : 	runwayQueueStruct* listPtr = list;

	mov	eax, DWORD PTR _list$[ebp]
	mov	DWORD PTR _listPtr$[ebp], eax

; 3634 : 	runwayQueueStruct* listPrev = NULL;

	mov	DWORD PTR _listPrev$[ebp], 0
$LN5@AddToList:

; 3635 : 
; 3636 : 	while(listPtr && listPtr->schedTime <= info->schedTime){

	cmp	DWORD PTR _listPtr$[ebp], 0
	je	SHORT $LN4@AddToList
	mov	ecx, DWORD PTR _listPtr$[ebp]
	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	cmp	eax, DWORD PTR [edx+12]
	ja	SHORT $LN4@AddToList

; 3637 : 		listPrev = listPtr;

	mov	ecx, DWORD PTR _listPtr$[ebp]
	mov	DWORD PTR _listPrev$[ebp], ecx

; 3638 : 		listPtr = listPtr->next;

	mov	edx, DWORD PTR _listPtr$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _listPtr$[ebp], eax

; 3639 : 	}

	jmp	SHORT $LN5@AddToList
$LN4@AddToList:

; 3640 : 
; 3641 : 	info->prev = listPrev;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR _listPrev$[ebp]
	mov	DWORD PTR [ecx+28], edx

; 3642 : 
; 3643 : 	if(listPrev){

	cmp	DWORD PTR _listPrev$[ebp], 0
	je	SHORT $LN3@AddToList

; 3644 : 		info->next = listPrev->next;		

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR _listPrev$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx

; 3645 : 		listPrev->next = info;

	mov	eax, DWORD PTR _listPrev$[ebp]
	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 3646 : 	}
; 3647 : 	else{

	jmp	SHORT $LN2@AddToList
$LN3@AddToList:

; 3648 : 		info->next = list;

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR _list$[ebp]
	mov	DWORD PTR [edx+24], eax

; 3649 : 		list = info;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR _list$[ebp], ecx
$LN2@AddToList:

; 3650 : 	}
; 3651 : 
; 3652 : 	if (info->next){

	mov	edx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN1@AddToList

; 3653 : 		info->next->prev = info;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+28], edx
$LN1@AddToList:

; 3654 : 	}	
; 3655 : 
; 3656 : 	return list;

	mov	eax, DWORD PTR _list$[ebp]

; 3657 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?AddToList@ATCBrain@@QAEPAUrunwayQueueStruct@@PAU2@0@Z ENDP ; ATCBrain::AddToList
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_position$ = -52					; size = 4
$T2 = -48						; size = 4
tv204 = -44						; size = 4
$T3 = -40						; size = 4
_entity$ = -36						; size = 4
_i$ = -32						; size = 4
_point$ = -28						; size = 4
_queue$ = -24						; size = 4
_this$ = -20						; size = 4
_newTraffic$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_aircraftID$ = 8					; size = 8
_status$ = 16						; size = 4
_rwindex$ = 20						; size = 4
_schedTime$ = 24					; size = 4
?AddTraffic@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@W4AtcStatusEnum@@HJ@Z PROC ; ATCBrain::AddTraffic
; _this$ = ecx

; 3661 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddTraffic@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@W4AtcStatusEnum@@HJ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3662 : 	int queue = PtHeaderDataTable[rwindex].runwayNum;

	mov	eax, DWORD PTR _rwindex$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	edx, BYTE PTR [ecx+eax+24]
	mov	DWORD PTR _queue$[ebp], edx

; 3663 : 
; 3664 : 	runwayQueueStruct *newTraffic = NULL;

	mov	DWORD PTR _newTraffic$[ebp], 0

; 3665 : 	int i, point, position;
; 3666 : 	
; 3667 : 	newTraffic = InList(aircraftID);

	mov	eax, DWORD PTR _aircraftID$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _aircraftID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InList@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@@Z ; ATCBrain::InList
	mov	DWORD PTR _newTraffic$[ebp], eax

; 3668 : 	FalconEntity *entity = (FalconEntity*)vuDatabase->Find(aircraftID);

	mov	edx, DWORD PTR _aircraftID$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _aircraftID$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _entity$[ebp], eax

; 3669 : 	if(newTraffic && entity->IsAirplane())

	cmp	DWORD PTR _newTraffic$[ebp], 0
	je	$LN12@AddTraffic
	mov	ecx, DWORD PTR _entity$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _entity$[ebp]
	mov	eax, DWORD PTR [edx+192]
	call	eax
	test	eax, eax
	je	$LN12@AddTraffic

; 3670 : 	{
; 3671 : 		ShiAssert (!(!newTraffic->rwindex && runwayQueue[queue] == newTraffic) );
; 3672 : 
; 3673 : 		//if we're already in list, pull us and reinsert us
; 3674 : 		if(newTraffic->rwindex && runwayQueue[PtHeaderDataTable[newTraffic->rwindex].runwayNum] == newTraffic)

	mov	ecx, DWORD PTR _newTraffic$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	je	SHORT $LN11@AddTraffic
	mov	edx, DWORD PTR _newTraffic$[ebp]
	mov	eax, DWORD PTR [edx+20]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	edx, BYTE PTR [ecx+eax+24]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [ecx+edx*4]
	cmp	edx, DWORD PTR _newTraffic$[ebp]
	jne	SHORT $LN11@AddTraffic

; 3675 : 			runwayQueue[PtHeaderDataTable[newTraffic->rwindex].runwayNum] = newTraffic->next;

	mov	eax, DWORD PTR _newTraffic$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	eax, BYTE PTR [edx+ecx+24]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _newTraffic$[ebp]
	mov	ecx, DWORD PTR [ecx+24]
	mov	DWORD PTR [edx+eax*4], ecx
	jmp	SHORT $LN10@AddTraffic
$LN11@AddTraffic:

; 3676 : 		else if(inboundQueue == newTraffic)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	cmp	eax, DWORD PTR _newTraffic$[ebp]
	jne	SHORT $LN10@AddTraffic

; 3677 : 			inboundQueue = newTraffic->next;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _newTraffic$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+24], eax
$LN10@AddTraffic:

; 3678 : 
; 3679 : 		if(newTraffic->prev)

	mov	ecx, DWORD PTR _newTraffic$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	je	SHORT $LN8@AddTraffic

; 3680 : 			newTraffic->prev->next = newTraffic->next;

	mov	edx, DWORD PTR _newTraffic$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _newTraffic$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx
$LN8@AddTraffic:

; 3681 : 
; 3682 : 		if(newTraffic->next)

	mov	eax, DWORD PTR _newTraffic$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN7@AddTraffic

; 3683 : 			newTraffic->next->prev = newTraffic->prev;

	mov	ecx, DWORD PTR _newTraffic$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _newTraffic$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR [edx+28], ecx
$LN7@AddTraffic:

; 3684 : 
; 3685 : 		if(newTraffic->rwindex)

	mov	edx, DWORD PTR _newTraffic$[ebp]
	cmp	DWORD PTR [edx+20], 0
	je	$LN6@AddTraffic

; 3686 : 			runwayStats[PtHeaderDataTable[newTraffic->rwindex].runwayNum].numInQueue--;

	mov	eax, DWORD PTR _newTraffic$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	eax, BYTE PTR [edx+ecx+24]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ax, WORD PTR [edx+eax+24]
	shr	ax, 3
	mov	ecx, 8191				; 00001fffH
	and	ax, cx
	sub	ax, 1
	mov	edx, DWORD PTR _newTraffic$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	ecx, BYTE PTR [edx+ecx+24]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+16]
	mov	esi, 8191				; 00001fffH
	and	ax, si
	shl	ax, 3
	mov	cx, WORD PTR [edx+ecx+24]
	and	cx, 7
	or	cx, ax
	mov	edx, DWORD PTR _newTraffic$[ebp]
	mov	eax, DWORD PTR [edx+20]
	imul	eax, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	eax, BYTE PTR [edx+eax+24]
	imul	eax, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+16]
	mov	WORD PTR [edx+eax+24], cx
$LN6@AddTraffic:

; 3687 : 	}
; 3688 : 	else

	jmp	SHORT $LN5@AddTraffic
$LN12@AddTraffic:

; 3689 : 	{	//not in list create a new link
; 3690 : 		newTraffic = new runwayQueueStruct;

	push	32					; 00000020H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN15@AddTraffic
	mov	ecx, DWORD PTR $T3[ebp]
	call	??0runwayQueueStruct@@QAE@XZ
	mov	DWORD PTR tv204[ebp], eax
	jmp	SHORT $LN16@AddTraffic
$LN15@AddTraffic:
	mov	DWORD PTR tv204[ebp], 0
$LN16@AddTraffic:
	mov	eax, DWORD PTR tv204[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _newTraffic$[ebp], ecx
$LN5@AddTraffic:

; 3691 : 		ShiAssert( newTraffic );		
; 3692 : 	}
; 3693 : 	//initialize all the data
; 3694 : 	newTraffic->next = NULL;

	mov	edx, DWORD PTR _newTraffic$[ebp]
	mov	DWORD PTR [edx+24], 0

; 3695 : 	newTraffic->prev = NULL;

	mov	eax, DWORD PTR _newTraffic$[ebp]
	mov	DWORD PTR [eax+28], 0

; 3696 : 
; 3697 : 	newTraffic->aircraftID = aircraftID;

	mov	ecx, DWORD PTR _newTraffic$[ebp]
	mov	edx, DWORD PTR _aircraftID$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _aircraftID$[ebp+4]
	mov	DWORD PTR [ecx+4], eax

; 3698 : 	newTraffic->status = status;

	mov	ecx, DWORD PTR _newTraffic$[ebp]
	mov	edx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 3699 : 	newTraffic->lastContacted = 0;

	mov	eax, DWORD PTR _newTraffic$[ebp]
	mov	DWORD PTR [eax+16], 0

; 3700 : 	newTraffic->schedTime = schedTime;

	mov	ecx, DWORD PTR _newTraffic$[ebp]
	mov	edx, DWORD PTR _schedTime$[ebp]
	mov	DWORD PTR [ecx+12], edx

; 3701 : 	newTraffic->rwindex = rwindex;

	mov	eax, DWORD PTR _newTraffic$[ebp]
	mov	ecx, DWORD PTR _rwindex$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 3702 : 
; 3703 : 	//if we are taking off set up our point appropriately
; 3704 : 	if(status > lCrashed)

	cmp	DWORD PTR _status$[ebp], 18		; 00000012H
	jle	SHORT $LN4@AddTraffic

; 3705 : 	{
; 3706 : 		point = PtHeaderDataTable[rwindex].first;

	mov	edx, DWORD PTR _rwindex$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	ecx, WORD PTR [eax+edx+20]
	mov	DWORD PTR _point$[ebp], ecx

; 3707 : 		point = GetNextPtLoop(point);

	mov	edx, DWORD PTR _point$[ebp]
	push	edx
	call	?GetNextPtLoop@@YAHH@Z			; GetNextPtLoop
	add	esp, 4
	mov	DWORD PTR _point$[ebp], eax

; 3708 : 		position = (schedTime - SimLibElapsedTime)/(SLOT_TIME);

	mov	eax, DWORD PTR _schedTime$[ebp]
	sub	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	xor	edx, edx
	mov	ecx, 10000				; 00002710H
	div	ecx
	mov	DWORD PTR _position$[ebp], eax

; 3709 : 		for(i = 0; i < position;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@AddTraffic
$LN2@AddTraffic:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN3@AddTraffic:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _position$[ebp]
	jge	SHORT $LN4@AddTraffic

; 3710 : 			point = GetNextTaxiPt(point);

	mov	ecx, DWORD PTR _point$[ebp]
	push	ecx
	call	?GetNextTaxiPt@@YAHH@Z			; GetNextTaxiPt
	add	esp, 4
	mov	DWORD PTR _point$[ebp], eax
	jmp	SHORT $LN2@AddTraffic
$LN4@AddTraffic:

; 3711 : 		
; 3712 : 	}
; 3713 : 
; 3714 : 	runwayStats[queue].numInQueue++; //increment number in queue

	mov	edx, DWORD PTR _queue$[ebp]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	dx, WORD PTR [ecx+edx+24]
	shr	dx, 3
	mov	eax, 8191				; 00001fffH
	and	dx, ax
	add	dx, 1
	mov	ecx, DWORD PTR _queue$[ebp]
	imul	ecx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	mov	esi, 8191				; 00001fffH
	and	dx, si
	shl	dx, 3
	mov	cx, WORD PTR [eax+ecx+24]
	and	cx, 7
	or	cx, dx
	mov	edx, DWORD PTR _queue$[ebp]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	mov	WORD PTR [eax+edx+24], cx

; 3715 : 
; 3716 : 	runwayQueue[queue] = AddToList(runwayQueue[queue], newTraffic);

	mov	ecx, DWORD PTR _newTraffic$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _queue$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddToList@ATCBrain@@QAEPAUrunwayQueueStruct@@PAU2@0@Z ; ATCBrain::AddToList
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _queue$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 3717 : 	
; 3718 : 	return newTraffic;

	mov	eax, DWORD PTR _newTraffic$[ebp]

; 3719 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?AddTraffic@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@W4AtcStatusEnum@@HJ@Z$0:
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?AddTraffic@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@W4AtcStatusEnum@@HJ@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddTraffic@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@W4AtcStatusEnum@@HJ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddTraffic@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@W4AtcStatusEnum@@HJ@Z ENDP ; ATCBrain::AddTraffic
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_flightIter$ = -32					; size = 12
_this$ = -20						; size = 4
_aircraft$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_flight$ = 8						; size = 4
?AddInboundFlight@ATCBrain@@QAEXPAVFlightClass@@@Z PROC	; ATCBrain::AddInboundFlight
; _this$ = ecx

; 3826 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddInboundFlight@ATCBrain@@QAEXPAVFlightClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3827 : 	AircraftClass		*aircraft;
; 3828 : 
; 3829 : 	// protect against no components
; 3830 : 	if ( !flight->GetComponents() )

	mov	ecx, DWORD PTR _flight$[ebp]
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	test	eax, eax
	jne	SHORT $LN3@AddInbound

; 3831 : 		return;

	jmp	SHORT $LN4@AddInbound
$LN3@AddInbound:

; 3832 : 	
; 3833 : 	VuListIterator		flightIter(flight->GetComponents());

	mov	ecx, DWORD PTR _flight$[ebp]
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	push	eax
	lea	ecx, DWORD PTR _flightIter$[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3834 : 	aircraft = (AircraftClass*) flightIter.GetFirst();

	lea	ecx, DWORD PTR _flightIter$[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _aircraft$[ebp], eax
$LN2@AddInbound:

; 3835 : 	while(aircraft){

	cmp	DWORD PTR _aircraft$[ebp], 0
	je	SHORT $LN1@AddInbound

; 3836 : 		AddInbound(aircraft);

	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddInbound@ATCBrain@@QAEXPAVAircraftClass@@@Z ; ATCBrain::AddInbound

; 3837 : 		aircraft = (AircraftClass*) flightIter.GetNext();

	lea	ecx, DWORD PTR _flightIter$[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _aircraft$[ebp], eax

; 3838 : 	}

	jmp	SHORT $LN2@AddInbound
$LN1@AddInbound:

; 3839 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _flightIter$[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
$LN4@AddInbound:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?AddInboundFlight@ATCBrain@@QAEXPAVFlightClass@@@Z$0:
	lea	ecx, DWORD PTR _flightIter$[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__ehhandler$?AddInboundFlight@ATCBrain@@QAEXPAVFlightClass@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddInboundFlight@ATCBrain@@QAEXPAVFlightClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddInboundFlight@ATCBrain@@QAEXPAVFlightClass@@@Z ENDP	; ATCBrain::AddInboundFlight
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
$T2 = -48						; size = 8
$T3 = -40						; size = 8
$T4 = -32						; size = 4
tv204 = -28						; size = 4
$T5 = -24						; size = 4
_this$ = -20						; size = 4
_info$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_aircraft$ = 8						; size = 4
?AddInbound@ATCBrain@@QAEXPAVAircraftClass@@@Z PROC	; ATCBrain::AddInbound
; _this$ = ecx

; 3775 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddInbound@ATCBrain@@QAEXPAVAircraftClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3776 : 	runwayQueueStruct* info;
; 3777 : 	
; 3778 : 
; 3779 : 	if(aircraft->OnGround())

	mov	eax, DWORD PTR _aircraft$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	SHORT $LN12@AddInbound

; 3780 : 		return;

	jmp	$LN13@AddInbound
$LN12@AddInbound:

; 3781 : 
; 3782 : 	info = InList(aircraft->Id());

	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InList@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@@Z ; ATCBrain::InList
	mov	DWORD PTR _info$[ebp], eax

; 3783 : 	if(info)

	cmp	DWORD PTR _info$[ebp], 0
	je	$LN11@AddInbound

; 3784 : 	{
; 3785 : 		if(info->rwindex && runwayQueue[PtHeaderDataTable[info->rwindex].runwayNum] == info)

	mov	ecx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	je	SHORT $LN10@AddInbound
	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+20]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	edx, BYTE PTR [ecx+eax+24]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [ecx+edx*4]
	cmp	edx, DWORD PTR _info$[ebp]
	jne	SHORT $LN10@AddInbound

; 3786 : 			runwayQueue[PtHeaderDataTable[info->rwindex].runwayNum] = info->next;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	eax, BYTE PTR [edx+ecx+24]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [ecx+24]
	mov	DWORD PTR [edx+eax*4], ecx
	jmp	SHORT $LN9@AddInbound
$LN10@AddInbound:

; 3787 : 		else if(inboundQueue == info)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	cmp	eax, DWORD PTR _info$[ebp]
	jne	SHORT $LN9@AddInbound

; 3788 : 			inboundQueue = info->next;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+24], eax
$LN9@AddInbound:

; 3789 : 
; 3790 : 		if(info->prev)

	mov	ecx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	je	SHORT $LN7@AddInbound

; 3791 : 			info->prev->next = info->next;

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx
$LN7@AddInbound:

; 3792 : 
; 3793 : 		if(info->next)

	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN6@AddInbound

; 3794 : 			info->next->prev = info->prev;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR [edx+28], ecx
$LN6@AddInbound:

; 3795 : 
; 3796 : 		if(info->rwindex)

	mov	edx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [edx+20], 0
	je	$LN5@AddInbound

; 3797 : 			runwayStats[PtHeaderDataTable[info->rwindex].runwayNum].numInQueue--;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	eax, BYTE PTR [edx+ecx+24]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ax, WORD PTR [edx+eax+24]
	shr	ax, 3
	mov	ecx, 8191				; 00001fffH
	and	ax, cx
	sub	ax, 1
	mov	edx, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	ecx, BYTE PTR [edx+ecx+24]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+16]
	mov	esi, 8191				; 00001fffH
	and	ax, si
	shl	ax, 3
	mov	cx, WORD PTR [edx+ecx+24]
	and	cx, 7
	or	cx, ax
	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+20]
	imul	eax, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	eax, BYTE PTR [edx+eax+24]
	imul	eax, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+16]
	mov	WORD PTR [edx+eax+24], cx
$LN5@AddInbound:

; 3798 : 	}
; 3799 : 	else

	jmp	SHORT $LN4@AddInbound
$LN11@AddInbound:

; 3800 : 	{
; 3801 : 		info = new runwayQueueStruct;

	push	32					; 00000020H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN15@AddInbound
	mov	ecx, DWORD PTR $T5[ebp]
	call	??0runwayQueueStruct@@QAE@XZ
	mov	DWORD PTR tv204[ebp], eax
	jmp	SHORT $LN16@AddInbound
$LN15@AddInbound:
	mov	DWORD PTR tv204[ebp], 0
$LN16@AddInbound:
	mov	eax, DWORD PTR tv204[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T4[ebp]
	mov	DWORD PTR _info$[ebp], ecx

; 3802 : 		if(!info)

	cmp	DWORD PTR _info$[ebp], 0
	jne	SHORT $LN4@AddInbound

; 3803 : 			return;

	jmp	$LN13@AddInbound
$LN4@AddInbound:

; 3804 : 	}
; 3805 : 	
; 3806 : 	if (inboundQueue && F4IsBadReadPtr(inboundQueue, sizeof(runwayQueueStruct))) // JB 010326 CTD

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN2@AddInbound
	push	32					; 00000020H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?F4IsBadReadPtr@@YA_NPBXI@Z		; F4IsBadReadPtr
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@AddInbound

; 3807 : 		inboundQueue = NULL; // JB 010326 CTD

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0
$LN2@AddInbound:

; 3808 : 
; 3809 : 	info->aircraftID	= aircraft->Id();			//which plane is it

	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax

; 3810 : 	info->status		= lTakingPosition;			//at what point in the landing/takeoff process

	mov	edx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [edx+8], 4

; 3811 : 	info->schedTime		= 0;						//when scheduled to be on runway

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+12], 0

; 3812 : 	info->lastContacted = 0;						//time last talked to

	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 3813 : 	info->rwindex		= 0;						//what runway I'm supposed to use

	mov	edx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [edx+20], 0

; 3814 : 	info->prev			= NULL;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+28], 0

; 3815 : 	info->next			= inboundQueue;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+24], eax

; 3816 : 
; 3817 : 	if(inboundQueue)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	je	SHORT $LN1@AddInbound

; 3818 : 		inboundQueue->prev	= info;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+28], ecx
$LN1@AddInbound:

; 3819 : 
; 3820 : 	inboundQueue		= info;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [edx+24], eax

; 3821 : 	SendCmdMessage(aircraft, info);

	mov	ecx, DWORD PTR _info$[ebp]
	push	ecx
	mov	edx, DWORD PTR _aircraft$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage
$LN13@AddInbound:

; 3822 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?AddInbound@ATCBrain@@QAEXPAVAircraftClass@@@Z$0:
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?AddInbound@ATCBrain@@QAEXPAVAircraftClass@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddInbound@ATCBrain@@QAEXPAVAircraftClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddInbound@ATCBrain@@QAEXPAVAircraftClass@@@Z ENDP	; ATCBrain::AddInbound
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
$T1 = -28						; size = 8
$T2 = -20						; size = 8
_radioMessage$ = -12					; size = 4
_this$ = -8						; size = 4
_info$ = -4						; size = 4
_approaching$ = 8					; size = 4
?AbortApproach@ATCBrain@@QAEXPAVAircraftClass@@@Z PROC	; ATCBrain::AbortApproach
; _this$ = ecx

; 1884 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 1885 : 	runwayQueueStruct *info = NULL;

	mov	DWORD PTR _info$[ebp], 0

; 1886 : 	FalconRadioChatterMessage *radioMessage = NULL;

	mov	DWORD PTR _radioMessage$[ebp], 0

; 1887 : 	
; 1888 : 	info = InList(approaching->Id());

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _approaching$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InList@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@@Z ; ATCBrain::InList
	mov	DWORD PTR _info$[ebp], eax

; 1889 : 	
; 1890 : 	if(info)

	cmp	DWORD PTR _info$[ebp], 0
	je	SHORT $LN3@AbortAppro

; 1891 : 	{
; 1892 : 		if (info->rwindex)

	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax+20], 0
	je	SHORT $LN2@AbortAppro

; 1893 : 			RemoveTraffic(approaching->Id(), PtHeaderDataTable[info->rwindex].runwayNum);

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	ecx, BYTE PTR [eax+edx+24]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _approaching$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveTraffic@ATCBrain@@QAEXVVU_ID@@H@Z ; ATCBrain::RemoveTraffic

; 1894 : 		else

	jmp	SHORT $LN3@AbortAppro
$LN2@AbortAppro:

; 1895 : 			RemoveInbound(info);

	mov	eax, DWORD PTR _info$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveInbound@ATCBrain@@QAEXPAUrunwayQueueStruct@@@Z ; ATCBrain::RemoveInbound
$LN3@AbortAppro:

; 1896 : 	}
; 1897 : 
; 1898 : 	approaching->DBrain()->SetATCStatus(noATC);

	push	0
	mov	ecx, DWORD PTR _approaching$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?SetATCStatus@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SetATCStatus

; 1899 : 	//Cobra
; 1900 : 	radioMessage = CreateCallFromATC( self, approaching, rcRESUMEOWNNAV, FalconLocalSession);		

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	push	eax
	push	334					; 0000014eH
	mov	ecx, DWORD PTR _approaching$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$[ebp], eax

; 1901 : 	FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	push	ecx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8

; 1902 : 
; 1903 : /*	radioMessage = CreateCallFromATC (self, , rcROGER, FalconLocalGame);
; 1904 : 	radioMessage->dataBlock.edata[0] = -1;
; 1905 : 	radioMessage->dataBlock.edata[1] = 1;	// just "Roger"
; 1906 : 	radioMessage->dataBlock.time_to_play= 2*CampaignSeconds;
; 1907 : 	FalconSendMessage(radioMessage, FALSE);
; 1908 : */
; 1909 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?AbortApproach@ATCBrain@@QAEXPAVAircraftClass@@@Z ENDP	; ATCBrain::AbortApproach
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
$T1 = -112						; size = 8
$T2 = -104						; size = 8
$T3 = -96						; size = 8
$T4 = -88						; size = 8
tv728 = -80						; size = 4
tv680 = -76						; size = 4
tv639 = -72						; size = 4
tv448 = -68						; size = 4
_takeoffNum$5 = -64					; size = 4
tv413 = -60						; size = 4
tv375 = -56						; size = 4
tv325 = -52						; size = 4
tv287 = -48						; size = 4
tv218 = -44						; size = 4
tv169 = -40						; size = 4
_flight$ = -36						; size = 4
tv149 = -32						; size = 4
_queue$ = -28						; size = 4
_nextTakeoff$ = -24					; size = 4
_takeoffTime$ = -20					; size = 4
_rwindex$ = -16						; size = 4
_info$ = -12						; size = 4
_this$ = -8						; size = 4
_radioMessage$ = -4					; size = 4
_departing$ = 8						; size = 4
?RequestTaxi@ATCBrain@@QAEXPAVAircraftClass@@@Z PROC	; ATCBrain::RequestTaxi
; _this$ = ecx

; 1700 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	DWORD PTR _this$[ebp], ecx

; 1701 : 	int queue = 0, rwindex = 0;

	mov	DWORD PTR _queue$[ebp], 0
	mov	DWORD PTR _rwindex$[ebp], 0

; 1702 : 	VU_TIME takeoffTime = 0;

	mov	DWORD PTR _takeoffTime$[ebp], 0

; 1703 : 	Flight flight;
; 1704 : 	runwayQueueStruct *info = NULL;

	mov	DWORD PTR _info$[ebp], 0

; 1705 : 	runwayQueueStruct *nextTakeoff = NULL;

	mov	DWORD PTR _nextTakeoff$[ebp], 0

; 1706 : 	FalconRadioChatterMessage	*radioMessage = NULL;

	mov	DWORD PTR _radioMessage$[ebp], 0

; 1707 : 	
; 1708 : 	if(!departing || !self || !departing->OnGround())

	cmp	DWORD PTR _departing$[ebp], 0
	je	SHORT $LN40@RequestTax
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN40@RequestTax
	mov	ecx, DWORD PTR _departing$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _departing$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	jne	SHORT $LN41@RequestTax
$LN40@RequestTax:

; 1709 : 		return;

	jmp	$LN42@RequestTax
$LN41@RequestTax:

; 1710 : 
; 1711 : 	if(GetTTRelations(self->GetTeam(), departing->GetTeam()) >= Hostile)

	mov	ecx, DWORD PTR _departing$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _departing$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	call	?GetTTRelations@@YAHEE@Z		; GetTTRelations
	add	esp, 8
	cmp	eax, 4
	jl	SHORT $LN39@RequestTax

; 1712 : 		return;

	jmp	$LN42@RequestTax
$LN39@RequestTax:

; 1713 : 	
; 1714 : 	info = InList(departing->Id());

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _departing$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InList@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@@Z ; ATCBrain::InList
	mov	DWORD PTR _info$[ebp], eax

; 1715 : 	if(info)

	cmp	DWORD PTR _info$[ebp], 0
	je	$LN38@RequestTax

; 1716 : 	{
; 1717 : 		if(info->schedTime + 60 * CampaignSeconds > SimLibElapsedTime ||
; 1718 : 			(info->status == tTakeoff ))

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 60000				; 0000ea60H
	cmp	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	ja	SHORT $LN36@RequestTax
	mov	edx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [edx+8], 27			; 0000001bH
	jne	$LN38@RequestTax
$LN36@RequestTax:

; 1719 : 		{
; 1720 : 			int takeoffNum;
; 1721 : 			switch(info->status)

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv149[ebp], ecx
	mov	edx, DWORD PTR tv149[ebp]
	sub	edx, 22					; 00000016H
	mov	DWORD PTR tv149[ebp], edx
	cmp	DWORD PTR tv149[ebp], 5
	ja	$LN34@RequestTax
	mov	eax, DWORD PTR tv149[ebp]
	jmp	DWORD PTR $LN66@RequestTax[eax*4]
$LN33@RequestTax:

; 1722 : 			{
; 1723 : 			case tTakeoff:
; 1724 : 				if(info->schedTime + 120 * CampaignSeconds < SimLibElapsedTime)	 // 06FEB04 - FRB - was 60 seconds

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, 120000				; 0001d4c0H
	cmp	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	$LN32@RequestTax

; 1725 : 				{
; 1726 : 					radioMessage = CreateCallFromATC (self, departing, rcEXPEDITEDEPARTURE, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN44@RequestTax
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv169[ebp], eax
	jmp	SHORT $LN45@RequestTax
$LN44@RequestTax:
	mov	DWORD PTR tv169[ebp], 0
$LN45@RequestTax:
	mov	ecx, DWORD PTR tv169[ebp]
	push	ecx
	push	307					; 00000133H
	mov	edx, DWORD PTR _departing$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$[ebp], eax

; 1727 : 					//if(runwayQueue[queue]->status == lOnFinal)
; 1728 : 					if(!F4IsBadReadPtr(*runwayQueue, sizeof(runwayQueueStruct)) && runwayQueue[queue]->status == lOnFinal) // JB 010326 CTD

	push	32					; 00000020H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?F4IsBadReadPtr@@YA_NPBXI@Z		; F4IsBadReadPtr
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN31@RequestTax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _queue$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	DWORD PTR [eax+8], 11			; 0000000bH
	jne	SHORT $LN31@RequestTax

; 1729 : 						radioMessage->dataBlock.edata[3] = 1;

	mov	ecx, 2
	imul	ecx, 3
	mov	edx, 1
	mov	eax, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [eax+ecx+64], dx

; 1730 : 					else

	jmp	SHORT $LN30@RequestTax
$LN31@RequestTax:

; 1731 : 						radioMessage->dataBlock.edata[3] = 0;

	mov	ecx, 2
	imul	ecx, 3
	xor	edx, edx
	mov	eax, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [eax+ecx+64], dx
$LN30@RequestTax:

; 1732 : 					FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	push	ecx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8

; 1733 : 				}
; 1734 : 				else

	jmp	SHORT $LN29@RequestTax
$LN32@RequestTax:

; 1735 : 				{
; 1736 : 					radioMessage = CreateCallFromATC (self, departing, rcCLEAREDONRUNWAY, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN46@RequestTax
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv218[ebp], eax
	jmp	SHORT $LN47@RequestTax
$LN46@RequestTax:
	mov	DWORD PTR tv218[ebp], 0
$LN47@RequestTax:
	mov	eax, DWORD PTR tv218[ebp]
	push	eax
	push	39					; 00000027H
	mov	ecx, DWORD PTR _departing$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$[ebp], eax

; 1737 : 					radioMessage->dataBlock.edata[3] = (short)GetRunwayName(info->rwindex);

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRunwayName@ATCBrain@@QAEHH@Z	; ATCBrain::GetRunwayName
	mov	ecx, 2
	imul	ecx, 3
	mov	edx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [edx+ecx+64], ax

; 1738 : 					FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	eax, DWORD PTR _radioMessage$[ebp]
	push	eax
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN29@RequestTax:

; 1739 : 				}
; 1740 : 				break;

	jmp	$LN34@RequestTax
$LN28@RequestTax:

; 1741 : 
; 1742 : 			case tTakeRunway:
; 1743 : 				radioMessage = CreateCallFromATC (self, departing, rcPOSITIONANDHOLD, FalconLocalSession);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	push	eax
	push	306					; 00000132H
	mov	ecx, DWORD PTR _departing$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$[ebp], eax

; 1744 : 				radioMessage->dataBlock.edata[3] = (short)GetRunwayName(info->rwindex);

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRunwayName@ATCBrain@@QAEHH@Z	; ATCBrain::GetRunwayName
	mov	ecx, 2
	imul	ecx, 3
	mov	edx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [edx+ecx+64], ax

; 1745 : 				FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	eax, DWORD PTR _radioMessage$[ebp]
	push	eax
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8

; 1746 : 				break;

	jmp	$LN34@RequestTax
$LN27@RequestTax:

; 1747 : 
; 1748 : 			case tWait:
; 1749 : 			case tHoldShort:
; 1750 : 			case tPrepToTakeRunway:
; 1751 : 				//Cobra Holdshort is often first call and doesn't give the runway to taxi to
; 1752 : 				radioMessage = CreateCallFromATC (self, departing, rcCLEARTOTAXI, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN48@RequestTax
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv287[ebp], eax
	jmp	SHORT $LN49@RequestTax
$LN48@RequestTax:
	mov	DWORD PTR tv287[ebp], 0
$LN49@RequestTax:
	mov	edx, DWORD PTR tv287[ebp]
	push	edx
	push	284					; 0000011cH
	mov	eax, DWORD PTR _departing$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$[ebp], eax

; 1753 : 				radioMessage->dataBlock.edata[2] = (short)GetRunwayName(info->rwindex);

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRunwayName@ATCBrain@@QAEHH@Z	; ATCBrain::GetRunwayName
	mov	edx, 2
	shl	edx, 1
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [ecx+edx+64], ax

; 1754 : 				FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	edx, DWORD PTR _radioMessage$[ebp]
	push	edx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8

; 1755 : 
; 1756 : 				radioMessage = CreateCallFromATC (self, departing, rcHOLDSHORT, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN50@RequestTax
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv325[ebp], eax
	jmp	SHORT $LN51@RequestTax
$LN50@RequestTax:
	mov	DWORD PTR tv325[ebp], 0
$LN51@RequestTax:
	mov	ecx, DWORD PTR tv325[ebp]
	push	ecx
	push	95					; 0000005fH
	mov	edx, DWORD PTR _departing$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$[ebp], eax

; 1757 : 				radioMessage->dataBlock.edata[3] = 0;

	mov	edx, 2
	imul	edx, 3
	xor	eax, eax
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [ecx+edx+64], ax

; 1758 : 				if(info->prev && info->prev->status < lCrashed)

	mov	edx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $LN26@RequestTax
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	cmp	DWORD PTR [ecx+8], 18			; 00000012H
	jge	SHORT $LN26@RequestTax

; 1759 : 					radioMessage->dataBlock.edata[3] = (short)(1 + (rand()%4));

	call	_rand
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN64@RequestTax
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN64@RequestTax:
	add	eax, 1
	mov	edx, 2
	imul	edx, 3
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [ecx+edx+64], ax
$LN26@RequestTax:

; 1760 : 				FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	edx, DWORD PTR _radioMessage$[ebp]
	push	edx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8

; 1761 : 				break;

	jmp	$LN34@RequestTax
$LN25@RequestTax:

; 1762 : 
; 1763 : 			case tTaxi:
; 1764 : 				takeoffNum = GetTakeoffNumber(info);

	mov	eax, DWORD PTR _info$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTakeoffNumber@ATCBrain@@QAEHPAUrunwayQueueStruct@@@Z ; ATCBrain::GetTakeoffNumber
	mov	DWORD PTR _takeoffNum$5[ebp], eax

; 1765 : 				if(takeoffNum)

	cmp	DWORD PTR _takeoffNum$5[ebp], 0
	je	$LN24@RequestTax

; 1766 : 				{
; 1767 : 					//Cobra Holdshort is often first call and doesn't give the runway to taxi to
; 1768 : 					radioMessage = CreateCallFromATC (self, departing, rcCLEARTOTAXI, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN52@RequestTax
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv375[ebp], eax
	jmp	SHORT $LN53@RequestTax
$LN52@RequestTax:
	mov	DWORD PTR tv375[ebp], 0
$LN53@RequestTax:
	mov	edx, DWORD PTR tv375[ebp]
	push	edx
	push	284					; 0000011cH
	mov	eax, DWORD PTR _departing$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$[ebp], eax

; 1769 : 					radioMessage->dataBlock.edata[2] = (short)GetRunwayName(info->rwindex);

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRunwayName@ATCBrain@@QAEHH@Z	; ATCBrain::GetRunwayName
	mov	edx, 2
	shl	edx, 1
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [ecx+edx+64], ax

; 1770 : 					FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	edx, DWORD PTR _radioMessage$[ebp]
	push	edx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8

; 1771 : 
; 1772 : 					radioMessage = CreateCallFromATC (self, departing, rcTAXISEQUENCE, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN54@RequestTax
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv413[ebp], eax
	jmp	SHORT $LN55@RequestTax
$LN54@RequestTax:
	mov	DWORD PTR tv413[ebp], 0
$LN55@RequestTax:
	mov	ecx, DWORD PTR tv413[ebp]
	push	ecx
	push	310					; 00000136H
	mov	edx, DWORD PTR _departing$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$[ebp], eax

; 1773 : 					radioMessage->dataBlock.edata[3] = (short)(takeoffNum - 1);

	mov	edx, DWORD PTR _takeoffNum$5[ebp]
	sub	edx, 1
	mov	eax, 2
	imul	eax, 3
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [ecx+eax+64], dx

; 1774 : 					FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	edx, DWORD PTR _radioMessage$[ebp]
	push	edx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8

; 1775 : 				}
; 1776 : 				else

	jmp	SHORT $LN34@RequestTax
$LN24@RequestTax:

; 1777 : 				{
; 1778 : 					radioMessage = CreateCallFromATC (self, departing, rcCLEARTOTAXI, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN56@RequestTax
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv448[ebp], eax
	jmp	SHORT $LN57@RequestTax
$LN56@RequestTax:
	mov	DWORD PTR tv448[ebp], 0
$LN57@RequestTax:
	mov	ecx, DWORD PTR tv448[ebp]
	push	ecx
	push	284					; 0000011cH
	mov	edx, DWORD PTR _departing$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$[ebp], eax

; 1779 : 					radioMessage->dataBlock.edata[2] = (short)GetRunwayName(info->rwindex);

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRunwayName@ATCBrain@@QAEHH@Z	; ATCBrain::GetRunwayName
	mov	ecx, 2
	shl	ecx, 1
	mov	edx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [edx+ecx+64], ax

; 1780 : 					FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	eax, DWORD PTR _radioMessage$[ebp]
	push	eax
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN34@RequestTax:

; 1781 : 				}
; 1782 : 				// sfr: ATC test, changed to TRUE
; 1783 : 				//FalconSendMessage(radioMessage, FALSE);
; 1784 : 				break;
; 1785 : 			case tEmerStop:
; 1786 : 				break;
; 1787 : 			case tReqTakeoff:
; 1788 : 			case tReqTaxi:
; 1789 : 				break;
; 1790 : 			}
; 1791 : 			return;

	jmp	$LN42@RequestTax
$LN38@RequestTax:

; 1792 : 		}
; 1793 : 	}
; 1794 : 
; 1795 : 	RemoveFromAllATCs(departing);

	mov	ecx, DWORD PTR _departing$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveFromAllATCs@ATCBrain@@QAEXPAVAircraftClass@@@Z ; ATCBrain::RemoveFromAllATCs

; 1796 : 
; 1797 : 	flight = (Flight)departing->GetCampaignObject();

	mov	ecx, DWORD PTR _departing$[ebp]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	DWORD PTR _flight$[ebp], eax

; 1798 : 
; 1799 : 	info = InList(flight->Id());

	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _flight$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InList@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@@Z ; ATCBrain::InList
	mov	DWORD PTR _info$[ebp], eax

; 1800 : 	if(info)

	cmp	DWORD PTR _info$[ebp], 0
	je	SHORT $LN20@RequestTax

; 1801 : 	{
; 1802 : 		rwindex = info->rwindex;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _rwindex$[ebp], ecx

; 1803 : 		queue = GetQueue(rwindex);

	mov	edx, DWORD PTR _rwindex$[ebp]
	push	edx
	call	?GetQueue@@YAHH@Z			; GetQueue
	add	esp, 4
	mov	DWORD PTR _queue$[ebp], eax

; 1804 : 		takeoffTime = info->schedTime;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _takeoffTime$[ebp], ecx
$LN20@RequestTax:

; 1805 : 	}
; 1806 : 
; 1807 : 	//make sure we remove any placeholders even if we aren't legitimately requesting a takeoff
; 1808 : 	RemovePlaceHolders(flight->Id());

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _flight$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemovePlaceHolders@ATCBrain@@QAEKVVU_ID@@@Z ; ATCBrain::RemovePlaceHolders

; 1809 : 
; 1810 : 	if(!rwindex)

	cmp	DWORD PTR _rwindex$[ebp], 0
	jne	SHORT $LN19@RequestTax

; 1811 : 	{
; 1812 : 		rwindex = FindBestTakeoffRunway(TRUE);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindBestTakeoffRunway@ATCBrain@@QAEHH@Z ; ATCBrain::FindBestTakeoffRunway
	mov	DWORD PTR _rwindex$[ebp], eax

; 1813 : 		queue = GetQueue(rwindex);

	mov	eax, DWORD PTR _rwindex$[ebp]
	push	eax
	call	?GetQueue@@YAHH@Z			; GetQueue
	add	esp, 4
	mov	DWORD PTR _queue$[ebp], eax
$LN19@RequestTax:

; 1814 : 	}
; 1815 : 	
; 1816 : 	if(rwindex)

	cmp	DWORD PTR _rwindex$[ebp], 0
	je	$LN18@RequestTax

; 1817 : 	{
; 1818 : 		if(!takeoffTime)

	cmp	DWORD PTR _takeoffTime$[ebp], 0
	jne	SHORT $LN17@RequestTax

; 1819 : 		{
; 1820 : //			takeoffTime = GetNextAvailRunwayTime(queue, flight->GetCurrentUnitWP()->GetWPDepartureTime(), TAKEOFF_TIME_DELTA*2);
; 1821 : 			takeoffTime = GetNextAvailRunwayTime(queue, flight->GetCurrentUnitWP()->GetWPDepartureTime(), TAKEOFF_TIME_DELTA);	  // 27JAN04 - FRB - Bunch flight TO's closer together

	push	10000					; 00002710H
	mov	ecx, DWORD PTR _flight$[ebp]
	call	?GetCurrentUnitWP@UnitClass@@QBEPAVWayPointClass@@XZ ; UnitClass::GetCurrentUnitWP
	mov	ecx, eax
	call	?GetWPDepartureTime@WayPointClass@@QAEKXZ ; WayPointClass::GetWPDepartureTime
	push	eax
	mov	ecx, DWORD PTR _queue$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextAvailRunwayTime@ATCBrain@@QAEKHKK@Z ; ATCBrain::GetNextAvailRunwayTime
	mov	DWORD PTR _takeoffTime$[ebp], eax

; 1822 : 		}
; 1823 : 		else

	jmp	SHORT $LN16@RequestTax
$LN17@RequestTax:

; 1824 : 		{
; 1825 : //			takeoffTime = takeoffTime + TAKEOFF_TIME_DELTA * departing->vehicleInUnit;
; 1826 : 			takeoffTime = takeoffTime + (TAKEOFF_TIME_DELTA/2) * departing->vehicleInUnit;	  // 27JAN04 - FRB - Bunch flight TO's closer together

	mov	edx, DWORD PTR _departing$[ebp]
	movzx	eax, BYTE PTR [edx+664]
	imul	eax, 5000				; 00001388H
	add	eax, DWORD PTR _takeoffTime$[ebp]
	mov	DWORD PTR _takeoffTime$[ebp], eax
$LN16@RequestTax:

; 1827 : 		}
; 1828 : 		info = AddTraffic(departing->Id(),tTaxi, rwindex, takeoffTime );

	mov	ecx, DWORD PTR _takeoffTime$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rwindex$[ebp]
	push	edx
	push	22					; 00000016H
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _departing$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddTraffic@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@W4AtcStatusEnum@@HJ@Z ; ATCBrain::AddTraffic
	mov	DWORD PTR _info$[ebp], eax

; 1829 : 		if(!info)

	cmp	DWORD PTR _info$[ebp], 0
	jne	SHORT $LN15@RequestTax

; 1830 : 			return;

	jmp	$LN42@RequestTax
$LN15@RequestTax:

; 1831 : 
; 1832 : 		if(IsOnRunway(departing))

	mov	eax, DWORD PTR _departing$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsOnRunway@ATCBrain@@QAEHPAVAircraftClass@@@Z ; ATCBrain::IsOnRunway
	test	eax, eax
	je	SHORT $LN14@RequestTax

; 1833 : 		{
; 1834 : 			nextTakeoff = NextToTakeoff(GetQueue(rwindex));

	mov	ecx, DWORD PTR _rwindex$[ebp]
	push	ecx
	call	?GetQueue@@YAHH@Z			; GetQueue
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NextToTakeoff@ATCBrain@@AAEPAUrunwayQueueStruct@@H@Z ; ATCBrain::NextToTakeoff
	mov	DWORD PTR _nextTakeoff$[ebp], eax

; 1835 : 			if(nextTakeoff == info || 
; 1836 : 				(UseSectionTakeoff((Flight)departing->GetCampaignObject(), rwindex ) && departing->DBrain()->IsMyWingman(nextTakeoff->aircraftID)) )

	mov	edx, DWORD PTR _nextTakeoff$[ebp]
	cmp	edx, DWORD PTR _info$[ebp]
	je	SHORT $LN12@RequestTax
	mov	eax, DWORD PTR _rwindex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _departing$[ebp]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UseSectionTakeoff@ATCBrain@@QAEHPAVFlightClass@@H@Z ; ATCBrain::UseSectionTakeoff
	test	eax, eax
	je	SHORT $LN13@RequestTax
	mov	ecx, DWORD PTR _nextTakeoff$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR [ecx]
	push	eax
	mov	ecx, DWORD PTR _departing$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?IsMyWingman@DigitalBrain@@QAEHVVU_ID@@@Z ; DigitalBrain::IsMyWingman
	test	eax, eax
	je	SHORT $LN13@RequestTax
$LN12@RequestTax:

; 1837 : 					info->status = tTakeoff;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+8], 27			; 0000001bH
$LN13@RequestTax:

; 1838 : 		}

	jmp	SHORT $LN11@RequestTax
$LN14@RequestTax:

; 1839 : 		else if(info->schedTime > SimLibElapsedTime + 30*CampaignSeconds)

	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	edx, 30000				; 00007530H
	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax+12], edx
	jbe	SHORT $LN11@RequestTax

; 1840 : 		{
; 1841 : 			nextTakeoff = NextToTakeoff(GetQueue(rwindex));

	mov	ecx, DWORD PTR _rwindex$[ebp]
	push	ecx
	call	?GetQueue@@YAHH@Z			; GetQueue
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NextToTakeoff@ATCBrain@@AAEPAUrunwayQueueStruct@@H@Z ; ATCBrain::NextToTakeoff
	mov	DWORD PTR _nextTakeoff$[ebp], eax

; 1842 : 			if(nextTakeoff == info )

	mov	edx, DWORD PTR _nextTakeoff$[ebp]
	cmp	edx, DWORD PTR _info$[ebp]
	jne	SHORT $LN11@RequestTax

; 1843 : 				info->status = tHoldShort;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+8], 24			; 00000018H
$LN11@RequestTax:

; 1844 : 		}
; 1845 : 
; 1846 : 		if(runwayStats[queue].nextEmergency != FalconNullId)

	push	OFFSET ?FalconNullId@@3VVU_ID@@A	; FalconNullId
	mov	ecx, DWORD PTR _queue$[ebp]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	lea	ecx, DWORD PTR [eax+ecx+32]
	call	??9VU_ID@@QBE_NABV0@@Z			; VU_ID::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN8@RequestTax

; 1847 : 			info->status = tEmerStop;

	mov	edx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [edx+8], 21			; 00000015H
$LN8@RequestTax:

; 1848 : 
; 1849 : 		SendCmdMessage(departing, info);

	mov	eax, DWORD PTR _info$[ebp]
	push	eax
	mov	ecx, DWORD PTR _departing$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage

; 1850 : 		if(departing->IsPlayer() || departing->vehicleInUnit == 0)

	mov	ecx, DWORD PTR _departing$[ebp]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	jne	SHORT $LN6@RequestTax
	mov	edx, DWORD PTR _departing$[ebp]
	movzx	eax, BYTE PTR [edx+664]
	test	eax, eax
	jne	$LN7@RequestTax
$LN6@RequestTax:

; 1851 : 		{
; 1852 : 			if(info->status == tTaxi)

	mov	ecx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [ecx+8], 22			; 00000016H
	jne	$LN5@RequestTax

; 1853 : 			{
; 1854 : 				radioMessage = CreateCallFromATC (self, departing, rcCLEARTOTAXI, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN58@RequestTax
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv639[ebp], eax
	jmp	SHORT $LN59@RequestTax
$LN58@RequestTax:
	mov	DWORD PTR tv639[ebp], 0
$LN59@RequestTax:
	mov	eax, DWORD PTR tv639[ebp]
	push	eax
	push	284					; 0000011cH
	mov	ecx, DWORD PTR _departing$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$[ebp], eax

; 1855 : 				radioMessage->dataBlock.edata[2] = (short)GetRunwayName(rwindex);

	mov	ecx, DWORD PTR _rwindex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRunwayName@ATCBrain@@QAEHH@Z	; ATCBrain::GetRunwayName
	mov	edx, 2
	shl	edx, 1
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [ecx+edx+64], ax

; 1856 : 				radioMessage->dataBlock.time_to_play= 2*CampaignSeconds;

	mov	edx, DWORD PTR _radioMessage$[ebp]
	mov	DWORD PTR [edx+56], 2000		; 000007d0H

; 1857 : 				FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	eax, DWORD PTR _radioMessage$[ebp]
	push	eax
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
	jmp	$LN7@RequestTax
$LN5@RequestTax:

; 1858 : 			}
; 1859 : 			else if(info->status == tHoldShort)

	mov	ecx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [ecx+8], 24			; 00000018H
	jne	$LN7@RequestTax

; 1860 : 			{
; 1861 : 				radioMessage = CreateCallFromATC (self, departing, rcHOLDSHORT, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN60@RequestTax
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv680[ebp], eax
	jmp	SHORT $LN61@RequestTax
$LN60@RequestTax:
	mov	DWORD PTR tv680[ebp], 0
$LN61@RequestTax:
	mov	eax, DWORD PTR tv680[ebp]
	push	eax
	push	95					; 0000005fH
	mov	ecx, DWORD PTR _departing$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$[ebp], eax

; 1862 : 				radioMessage->dataBlock.edata[3] = 0;

	mov	ecx, 2
	imul	ecx, 3
	xor	edx, edx
	mov	eax, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [eax+ecx+64], dx

; 1863 : 				if(info->prev && info->prev->status < lCrashed)

	mov	ecx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	je	SHORT $LN2@RequestTax
	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+28]
	cmp	DWORD PTR [eax+8], 18			; 00000012H
	jge	SHORT $LN2@RequestTax

; 1864 : 					radioMessage->dataBlock.edata[3] = (short)(1 + (rand()%4));

	call	_rand
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN65@RequestTax
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN65@RequestTax:
	add	eax, 1
	mov	ecx, 2
	imul	ecx, 3
	mov	edx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [edx+ecx+64], ax
$LN2@RequestTax:

; 1865 : 				radioMessage->dataBlock.time_to_play= 2*CampaignSeconds;

	mov	eax, DWORD PTR _radioMessage$[ebp]
	mov	DWORD PTR [eax+56], 2000		; 000007d0H

; 1866 : 				FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	push	ecx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN7@RequestTax:

; 1867 : 			}
; 1868 : 		}
; 1869 : 	}
; 1870 : 	else

	jmp	SHORT $LN42@RequestTax
$LN18@RequestTax:

; 1871 : 	{
; 1872 : 		//all runways are currently destroyed
; 1873 : 		radioMessage = CreateCallFromATC (self, departing, rcATCCANCELMISSION, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN62@RequestTax
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv728[ebp], eax
	jmp	SHORT $LN63@RequestTax
$LN62@RequestTax:
	mov	DWORD PTR tv728[ebp], 0
$LN63@RequestTax:
	mov	eax, DWORD PTR tv728[ebp]
	push	eax
	push	308					; 00000134H
	mov	ecx, DWORD PTR _departing$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$[ebp], eax

; 1874 : 		//M.N. changed to 32767 -> flexibly use randomized value of max available eval indexes
; 1875 : 		radioMessage->dataBlock.edata[3] = 32767;

	mov	ecx, 2
	imul	ecx, 3
	mov	edx, 32767				; 00007fffH
	mov	eax, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [eax+ecx+64], dx

; 1876 : 		radioMessage->dataBlock.time_to_play= 2*CampaignSeconds;

	mov	ecx, DWORD PTR _radioMessage$[ebp]
	mov	DWORD PTR [ecx+56], 2000		; 000007d0H

; 1877 : 		FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	edx, DWORD PTR _radioMessage$[ebp]
	push	edx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN42@RequestTax:

; 1878 : 	}
; 1879 : 	
; 1880 : }

	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN66@RequestTax:
	DD	$LN25@RequestTax
	DD	$LN27@RequestTax
	DD	$LN27@RequestTax
	DD	$LN27@RequestTax
	DD	$LN28@RequestTax
	DD	$LN33@RequestTax
?RequestTaxi@ATCBrain@@QAEXPAVAircraftClass@@@Z ENDP	; ATCBrain::RequestTaxi
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
$T2 = -168						; size = 8
$T3 = -160						; size = 8
$T4 = -152						; size = 8
$T5 = -144						; size = 8
$T6 = -136						; size = 8
_flightIter$7 = -128					; size = 12
_flightIter$8 = -116					; size = 12
tv385 = -104						; size = 4
_info$9 = -100						; size = 4
_takeoffNum$10 = -96					; size = 4
tv544 = -92						; size = 4
tv189 = -88						; size = 4
tv724 = -84						; size = 4
tv350 = -80						; size = 4
tv803 = -76						; size = 4
tv231 = -72						; size = 4
tv765 = -68						; size = 4
tv300 = -64						; size = 4
_time$11 = -60						; size = 4
tv169 = -56						; size = 4
_queue$12 = -52						; size = 4
_nextTakeoff$ = -48					; size = 4
_takeoffTime$13 = -44					; size = 4
_flight$14 = -40					; size = 4
_rwindex$15 = -36					; size = 4
_info$16 = -32						; size = 4
_info$ = -28						; size = 4
_aircraft$17 = -24					; size = 4
_radioMessage$18 = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_departing$ = 8						; size = 4
?RequestTakeoff@ATCBrain@@QAEXPAVAircraftClass@@@Z PROC	; ATCBrain::RequestTakeoff
; _this$ = ecx

; 1475 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?RequestTakeoff@ATCBrain@@QAEXPAVAircraftClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 156				; 0000009cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1476 : 	runwayQueueStruct *info = NULL;

	mov	DWORD PTR _info$[ebp], 0

; 1477 : 	runwayQueueStruct *nextTakeoff = NULL;

	mov	DWORD PTR _nextTakeoff$[ebp], 0

; 1478 : 
; 1479 : 	if(!departing || !self || !departing->OnGround())

	cmp	DWORD PTR _departing$[ebp], 0
	je	SHORT $LN54@RequestTak
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN54@RequestTak
	mov	ecx, DWORD PTR _departing$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _departing$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	jne	SHORT $LN55@RequestTak
$LN54@RequestTak:

; 1480 : 			return;

	jmp	$LN56@RequestTak
$LN55@RequestTak:

; 1481 : 
; 1482 : 	if(GetTTRelations(self->GetTeam(), departing->GetTeam()) >= Hostile)

	mov	ecx, DWORD PTR _departing$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _departing$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	call	?GetTTRelations@@YAHEE@Z		; GetTTRelations
	add	esp, 8
	cmp	eax, 4
	jl	SHORT $LN53@RequestTak

; 1483 : 			return;

	jmp	$LN56@RequestTak
$LN53@RequestTak:

; 1484 : 
; 1485 : 	if( departing->DBrain()->isWing )

	mov	ecx, DWORD PTR _departing$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN52@RequestTak

; 1486 : 	{
; 1487 : 		RequestTaxi(departing);

	mov	edx, DWORD PTR _departing$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RequestTaxi@ATCBrain@@QAEXPAVAircraftClass@@@Z ; ATCBrain::RequestTaxi

; 1488 : 	}
; 1489 : 	else

	jmp	$LN56@RequestTak
$LN52@RequestTak:

; 1490 : 	{
; 1491 : 		ulong					takeoffTime = 0, time;

	mov	DWORD PTR _takeoffTime$13[ebp], 0

; 1492 : 		int						queue = 0, rwindex = 0;

	mov	DWORD PTR _queue$12[ebp], 0
	mov	DWORD PTR _rwindex$15[ebp], 0

; 1493 : 		AircraftClass			*aircraft = NULL;

	mov	DWORD PTR _aircraft$17[ebp], 0

; 1494 : 		FalconRadioChatterMessage	*radioMessage = NULL;

	mov	DWORD PTR _radioMessage$18[ebp], 0

; 1495 : 		Flight					flight = (Flight)departing->GetCampaignObject();

	mov	ecx, DWORD PTR _departing$[ebp]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	DWORD PTR _flight$14[ebp], eax

; 1496 : 
; 1497 : 		info = InList(departing->Id());

	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	mov	ecx, DWORD PTR _departing$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InList@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@@Z ; ATCBrain::InList
	mov	DWORD PTR _info$[ebp], eax

; 1498 : 		if( info )

	cmp	DWORD PTR _info$[ebp], 0
	je	$LN50@RequestTak

; 1499 : 		{
; 1500 : 			if(info->schedTime + 60 * CampaignSeconds > SimLibElapsedTime ||	//RAS - Change to 60sec prior to takeoff???
; 1501 : 				(info->status == tTakeoff ))

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 60000				; 0000ea60H
	cmp	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	ja	SHORT $LN48@RequestTak
	mov	edx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [edx+8], 27			; 0000001bH
	jne	$LN50@RequestTak
$LN48@RequestTak:

; 1502 : 			{
; 1503 : 				int takeoffNum;
; 1504 : 				switch(info->status)

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv169[ebp], ecx
	mov	edx, DWORD PTR tv169[ebp]
	sub	edx, 22					; 00000016H
	mov	DWORD PTR tv169[ebp], edx
	cmp	DWORD PTR tv169[ebp], 5
	ja	$LN46@RequestTak
	mov	eax, DWORD PTR tv169[ebp]
	jmp	DWORD PTR $LN83@RequestTak[eax*4]
$LN45@RequestTak:

; 1505 : 				{
; 1506 : 				case tTakeoff:
; 1507 : 					if(info->schedTime + 120 * CampaignSeconds < SimLibElapsedTime)	 // 06FEB04 - FRB - was 60 seconds

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, 120000				; 0001d4c0H
	cmp	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	$LN44@RequestTak

; 1508 : 					{
; 1509 : 						radioMessage = CreateCallFromATC (self, departing, rcEXPEDITEDEPARTURE, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN58@RequestTak
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv189[ebp], eax
	jmp	SHORT $LN59@RequestTak
$LN58@RequestTak:
	mov	DWORD PTR tv189[ebp], 0
$LN59@RequestTak:
	mov	ecx, DWORD PTR tv189[ebp]
	push	ecx
	push	307					; 00000133H
	mov	edx, DWORD PTR _departing$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$18[ebp], eax

; 1510 : 						if(runwayQueue[queue]->status == lOnFinal)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _queue$12[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	cmp	DWORD PTR [edx+8], 11			; 0000000bH
	jne	SHORT $LN43@RequestTak

; 1511 : 							radioMessage->dataBlock.edata[3] = 1;

	mov	eax, 2
	imul	eax, 3
	mov	ecx, 1
	mov	edx, DWORD PTR _radioMessage$18[ebp]
	mov	WORD PTR [edx+eax+64], cx

; 1512 : 						else

	jmp	SHORT $LN42@RequestTak
$LN43@RequestTak:

; 1513 : 							radioMessage->dataBlock.edata[3] = 0;

	mov	eax, 2
	imul	eax, 3
	xor	ecx, ecx
	mov	edx, DWORD PTR _radioMessage$18[ebp]
	mov	WORD PTR [edx+eax+64], cx
$LN42@RequestTak:

; 1514 : 						FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	eax, DWORD PTR _radioMessage$18[ebp]
	push	eax
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8

; 1515 : 					}
; 1516 : 					else

	jmp	SHORT $LN41@RequestTak
$LN44@RequestTak:

; 1517 : 					{
; 1518 : 							radioMessage = CreateCallFromATC (self, departing, rcCLEAREDONRUNWAY, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN60@RequestTak
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv231[ebp], eax
	jmp	SHORT $LN61@RequestTak
$LN60@RequestTak:
	mov	DWORD PTR tv231[ebp], 0
$LN61@RequestTak:
	mov	edx, DWORD PTR tv231[ebp]
	push	edx
	push	39					; 00000027H
	mov	eax, DWORD PTR _departing$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$18[ebp], eax

; 1519 : 						radioMessage->dataBlock.edata[3] = (short)GetRunwayName(info->rwindex);

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRunwayName@ATCBrain@@QAEHH@Z	; ATCBrain::GetRunwayName
	mov	edx, 2
	imul	edx, 3
	mov	ecx, DWORD PTR _radioMessage$18[ebp]
	mov	WORD PTR [ecx+edx+64], ax

; 1520 : 						FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	edx, DWORD PTR _radioMessage$18[ebp]
	push	edx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN41@RequestTak:

; 1521 : 					}
; 1522 : 					break;

	jmp	$LN46@RequestTak
$LN40@RequestTak:

; 1523 : 
; 1524 : 				case tTakeRunway:
; 1525 : 					radioMessage = CreateCallFromATC (self, departing, rcPOSITIONANDHOLD, FalconLocalSession);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	push	eax
	push	306					; 00000132H
	mov	eax, DWORD PTR _departing$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$18[ebp], eax

; 1526 : 					radioMessage->dataBlock.edata[3] = (short)GetRunwayName(info->rwindex);

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRunwayName@ATCBrain@@QAEHH@Z	; ATCBrain::GetRunwayName
	mov	edx, 2
	imul	edx, 3
	mov	ecx, DWORD PTR _radioMessage$18[ebp]
	mov	WORD PTR [ecx+edx+64], ax

; 1527 : 					FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	edx, DWORD PTR _radioMessage$18[ebp]
	push	edx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8

; 1528 : 					break;

	jmp	$LN46@RequestTak
$LN39@RequestTak:

; 1529 : 
; 1530 : 				case tWait:
; 1531 : 				case tHoldShort:
; 1532 : 				case tPrepToTakeRunway:
; 1533 : 					radioMessage = CreateCallFromATC (self, departing, rcHOLDSHORT, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN62@RequestTak
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv300[ebp], eax
	jmp	SHORT $LN63@RequestTak
$LN62@RequestTak:
	mov	DWORD PTR tv300[ebp], 0
$LN63@RequestTak:
	mov	ecx, DWORD PTR tv300[ebp]
	push	ecx
	push	95					; 0000005fH
	mov	edx, DWORD PTR _departing$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$18[ebp], eax

; 1534 : 					radioMessage->dataBlock.edata[3] = 0;

	mov	edx, 2
	imul	edx, 3
	xor	eax, eax
	mov	ecx, DWORD PTR _radioMessage$18[ebp]
	mov	WORD PTR [ecx+edx+64], ax

; 1535 : 					if(info->prev && info->prev->status < lCrashed)

	mov	edx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $LN38@RequestTak
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	cmp	DWORD PTR [ecx+8], 18			; 00000012H
	jge	SHORT $LN38@RequestTak

; 1536 : 						radioMessage->dataBlock.edata[3] = (short)(1 + (rand()%4));

	call	_rand
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN81@RequestTak
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN81@RequestTak:
	add	eax, 1
	mov	edx, 2
	imul	edx, 3
	mov	ecx, DWORD PTR _radioMessage$18[ebp]
	mov	WORD PTR [ecx+edx+64], ax
$LN38@RequestTak:

; 1537 : 					FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	edx, DWORD PTR _radioMessage$18[ebp]
	push	edx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8

; 1538 : 					break;

	jmp	$LN46@RequestTak
$LN37@RequestTak:

; 1539 : 
; 1540 : 				case tTaxi:
; 1541 : 					takeoffNum = GetTakeoffNumber(info);

	mov	eax, DWORD PTR _info$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTakeoffNumber@ATCBrain@@QAEHPAUrunwayQueueStruct@@@Z ; ATCBrain::GetTakeoffNumber
	mov	DWORD PTR _takeoffNum$10[ebp], eax

; 1542 : 					if(takeoffNum)

	cmp	DWORD PTR _takeoffNum$10[ebp], 0
	je	SHORT $LN36@RequestTak

; 1543 : 					{
; 1544 : 						radioMessage = CreateCallFromATC (self, departing, rcTAXISEQUENCE, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN64@RequestTak
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv350[ebp], eax
	jmp	SHORT $LN65@RequestTak
$LN64@RequestTak:
	mov	DWORD PTR tv350[ebp], 0
$LN65@RequestTak:
	mov	edx, DWORD PTR tv350[ebp]
	push	edx
	push	310					; 00000136H
	mov	eax, DWORD PTR _departing$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$18[ebp], eax

; 1545 : 						radioMessage->dataBlock.edata[3] = (short)(takeoffNum - 1);

	mov	eax, DWORD PTR _takeoffNum$10[ebp]
	sub	eax, 1
	mov	ecx, 2
	imul	ecx, 3
	mov	edx, DWORD PTR _radioMessage$18[ebp]
	mov	WORD PTR [edx+ecx+64], ax

; 1546 : 						FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	eax, DWORD PTR _radioMessage$18[ebp]
	push	eax
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8

; 1547 : 					}
; 1548 : 					else

	jmp	SHORT $LN46@RequestTak
$LN36@RequestTak:

; 1549 : 					{
; 1550 : 						radioMessage = CreateCallFromATC (self, departing, rcCLEARTOTAXI, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN66@RequestTak
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv385[ebp], eax
	jmp	SHORT $LN67@RequestTak
$LN66@RequestTak:
	mov	DWORD PTR tv385[ebp], 0
$LN67@RequestTak:
	mov	edx, DWORD PTR tv385[ebp]
	push	edx
	push	284					; 0000011cH
	mov	eax, DWORD PTR _departing$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$18[ebp], eax

; 1551 : 						radioMessage->dataBlock.edata[2] = (short)GetRunwayName(info->rwindex);

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRunwayName@ATCBrain@@QAEHH@Z	; ATCBrain::GetRunwayName
	mov	edx, 2
	shl	edx, 1
	mov	ecx, DWORD PTR _radioMessage$18[ebp]
	mov	WORD PTR [ecx+edx+64], ax

; 1552 : 						FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	edx, DWORD PTR _radioMessage$18[ebp]
	push	edx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN46@RequestTak:

; 1553 : 					}
; 1554 : 					break;
; 1555 : 
; 1556 : 				case tEmerStop:
; 1557 : 					break;
; 1558 : 				case tReqTakeoff:
; 1559 : 				case tReqTaxi:
; 1560 : 					break;
; 1561 : 				}
; 1562 : 				return;

	jmp	$LN56@RequestTak
$LN50@RequestTak:

; 1563 : 			}
; 1564 : 		}
; 1565 : 
; 1566 : 		info = InList(flight->Id());

	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _flight$14[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InList@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@@Z ; ATCBrain::InList
	mov	DWORD PTR _info$[ebp], eax

; 1567 : 		if(info)

	cmp	DWORD PTR _info$[ebp], 0
	je	SHORT $LN32@RequestTak

; 1568 : 		{
; 1569 : 			rwindex = info->rwindex;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _rwindex$15[ebp], ecx

; 1570 : 			queue = GetQueue(rwindex);

	mov	edx, DWORD PTR _rwindex$15[ebp]
	push	edx
	call	?GetQueue@@YAHH@Z			; GetQueue
	add	esp, 4
	mov	DWORD PTR _queue$12[ebp], eax

; 1571 : 			takeoffTime = info->schedTime;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _takeoffTime$13[ebp], ecx
$LN32@RequestTak:

; 1572 : 		}
; 1573 : 
; 1574 : 		//make sure we remove any placeholders even if we aren't legitimately requesting a takeoff
; 1575 : 		RemovePlaceHolders(flight->Id());

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _flight$14[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemovePlaceHolders@ATCBrain@@QAEKVVU_ID@@@Z ; ATCBrain::RemovePlaceHolders

; 1576 : 
; 1577 : 		
; 1578 : 
; 1579 : 		// protect against no components
; 1580 : 		if ( !flight->GetComponents() )

	mov	ecx, DWORD PTR _flight$14[ebp]
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	test	eax, eax
	jne	SHORT $LN31@RequestTak

; 1581 : 			return;

	jmp	$LN56@RequestTak
$LN31@RequestTak:

; 1582 : 
; 1583 : 		{
; 1584 : 			// destroy iterator here
; 1585 : 			VuListIterator	flightIter(flight->GetComponents());

	mov	ecx, DWORD PTR _flight$14[ebp]
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	push	eax
	lea	ecx, DWORD PTR _flightIter$7[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1586 : 			aircraft = (AircraftClass*) flightIter.GetFirst();

	lea	ecx, DWORD PTR _flightIter$7[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _aircraft$17[ebp], eax
$LN30@RequestTak:

; 1587 : 			while(aircraft)

	cmp	DWORD PTR _aircraft$17[ebp], 0
	je	SHORT $LN29@RequestTak

; 1588 : 			{
; 1589 : 				RemoveFromAllATCs(aircraft);

	mov	eax, DWORD PTR _aircraft$17[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveFromAllATCs@ATCBrain@@QAEXPAVAircraftClass@@@Z ; ATCBrain::RemoveFromAllATCs

; 1590 : 				aircraft = (AircraftClass*) flightIter.GetNext();	

	lea	ecx, DWORD PTR _flightIter$7[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _aircraft$17[ebp], eax

; 1591 : 			}

	jmp	SHORT $LN30@RequestTak
$LN29@RequestTak:

; 1592 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _flightIter$7[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator

; 1593 : 
; 1594 : 		if(!rwindex)

	cmp	DWORD PTR _rwindex$15[ebp], 0
	jne	SHORT $LN28@RequestTak

; 1595 : 		{		
; 1596 : 			rwindex = FindBestTakeoffRunway(TRUE);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindBestTakeoffRunway@ATCBrain@@QAEHH@Z ; ATCBrain::FindBestTakeoffRunway
	mov	DWORD PTR _rwindex$15[ebp], eax

; 1597 : 			queue = GetQueue(rwindex);

	mov	ecx, DWORD PTR _rwindex$15[ebp]
	push	ecx
	call	?GetQueue@@YAHH@Z			; GetQueue
	add	esp, 4
	mov	DWORD PTR _queue$12[ebp], eax
$LN28@RequestTak:

; 1598 : 		}
; 1599 : 
; 1600 : 		if(!takeoffTime)

	cmp	DWORD PTR _takeoffTime$13[ebp], 0
	jne	SHORT $LN27@RequestTak

; 1601 : 			takeoffTime = FindFlightTakeoffTime(flight, queue);

	mov	edx, DWORD PTR _queue$12[ebp]
	push	edx
	mov	eax, DWORD PTR _flight$14[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindFlightTakeoffTime@ATCBrain@@QAEKPAVFlightClass@@H@Z ; ATCBrain::FindFlightTakeoffTime
	mov	DWORD PTR _takeoffTime$13[ebp], eax
$LN27@RequestTak:

; 1602 : 
; 1603 : 		VuListIterator	flightIter(flight->GetComponents());

	mov	ecx, DWORD PTR _flight$14[ebp]
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	push	eax
	lea	ecx, DWORD PTR _flightIter$8[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1604 : 		aircraft = (AircraftClass*) flightIter.GetFirst();

	lea	ecx, DWORD PTR _flightIter$8[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _aircraft$17[ebp], eax
$LN26@RequestTak:

; 1605 : 		while(aircraft)

	cmp	DWORD PTR _aircraft$17[ebp], 0
	je	$LN25@RequestTak

; 1606 : 		{
; 1607 : 			if(aircraft->OnGround())

	mov	ecx, DWORD PTR _aircraft$17[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _aircraft$17[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	$LN24@RequestTak

; 1608 : 			{
; 1609 : 				if(!FindBestTakeoffRunway(TRUE))

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindBestTakeoffRunway@ATCBrain@@QAEHH@Z ; ATCBrain::FindBestTakeoffRunway
	test	eax, eax
	jne	$LN23@RequestTak

; 1610 : 				{
; 1611 : 					if(aircraft->IsPlayer() || aircraft->vehicleInUnit == 0)

	mov	ecx, DWORD PTR _aircraft$17[ebp]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	jne	SHORT $LN21@RequestTak
	mov	ecx, DWORD PTR _aircraft$17[ebp]
	movzx	edx, BYTE PTR [ecx+664]
	test	edx, edx
	jne	SHORT $LN22@RequestTak
$LN21@RequestTak:

; 1612 : 					{
; 1613 : 						//all runways are currently destroyed
; 1614 : 						radioMessage = CreateCallFromATC (self, departing, rcATCCANCELMISSION, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN68@RequestTak
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv544[ebp], eax
	jmp	SHORT $LN69@RequestTak
$LN68@RequestTak:
	mov	DWORD PTR tv544[ebp], 0
$LN69@RequestTak:
	mov	ecx, DWORD PTR tv544[ebp]
	push	ecx
	push	308					; 00000134H
	mov	edx, DWORD PTR _departing$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$18[ebp], eax

; 1615 : 						radioMessage->dataBlock.edata[3] = 32767;

	mov	edx, 2
	imul	edx, 3
	mov	eax, 32767				; 00007fffH
	mov	ecx, DWORD PTR _radioMessage$18[ebp]
	mov	WORD PTR [ecx+edx+64], ax

; 1616 : 						FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	edx, DWORD PTR _radioMessage$18[ebp]
	push	edx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN22@RequestTak:

; 1617 : 					}
; 1618 : 					if(rwindex)

	cmp	DWORD PTR _rwindex$15[ebp], 0
	je	SHORT $LN20@RequestTak

; 1619 : 					{
; 1620 : 						runwayQueueStruct *info = AddTraffic(aircraft->Id(),tTaxiBack, rwindex, SimLibElapsedTime );

	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	push	eax
	mov	ecx, DWORD PTR _rwindex$15[ebp]
	push	ecx
	push	29					; 0000001dH
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _aircraft$17[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddTraffic@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@W4AtcStatusEnum@@HJ@Z ; ATCBrain::AddTraffic
	mov	DWORD PTR _info$9[ebp], eax

; 1621 : 						if(info)

	cmp	DWORD PTR _info$9[ebp], 0
	je	SHORT $LN20@RequestTak

; 1622 : 							SendCmdMessage(aircraft, info);

	mov	eax, DWORD PTR _info$9[ebp]
	push	eax
	mov	ecx, DWORD PTR _aircraft$17[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage
$LN20@RequestTak:

; 1623 : 					}
; 1624 : 					aircraft = (AircraftClass*) flightIter.GetNext();

	lea	ecx, DWORD PTR _flightIter$8[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _aircraft$17[ebp], eax

; 1625 : 					continue;

	jmp	$LN26@RequestTak
$LN23@RequestTak:

; 1626 : 				}
; 1627 : 
; 1628 : 				if ( UseSectionTakeoff((Flight)aircraft->GetCampaignObject(), rwindex ) )

	mov	edx, DWORD PTR _rwindex$15[ebp]
	push	edx
	mov	ecx, DWORD PTR _aircraft$17[ebp]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UseSectionTakeoff@ATCBrain@@QAEHPAVFlightClass@@H@Z ; ATCBrain::UseSectionTakeoff
	test	eax, eax
	je	SHORT $LN18@RequestTak

; 1629 : 				{
; 1630 : 					if(aircraft->vehicleInUnit > 1)

	mov	eax, DWORD PTR _aircraft$17[ebp]
	movzx	ecx, BYTE PTR [eax+664]
	cmp	ecx, 1
	jle	SHORT $LN17@RequestTak

; 1631 : //						time = takeoffTime + SLOT_TIME * 2;
; 1632 : 						time = takeoffTime + SLOT_TIME;	 // 30JAN04 - FRB

	mov	edx, DWORD PTR _takeoffTime$13[ebp]
	add	edx, 10000				; 00002710H
	mov	DWORD PTR _time$11[ebp], edx

; 1633 : 					else

	jmp	SHORT $LN16@RequestTak
$LN17@RequestTak:

; 1634 : 						time = takeoffTime;

	mov	eax, DWORD PTR _takeoffTime$13[ebp]
	mov	DWORD PTR _time$11[ebp], eax
$LN16@RequestTak:

; 1635 : 				}
; 1636 : 				else

	jmp	SHORT $LN15@RequestTak
$LN18@RequestTak:

; 1637 : 				{
; 1638 : 					time = takeoffTime + SLOT_TIME * aircraft->vehicleInUnit;

	mov	ecx, DWORD PTR _aircraft$17[ebp]
	movzx	edx, BYTE PTR [ecx+664]
	imul	edx, 10000				; 00002710H
	add	edx, DWORD PTR _takeoffTime$13[ebp]
	mov	DWORD PTR _time$11[ebp], edx
$LN15@RequestTak:

; 1639 : 				}
; 1640 : 
; 1641 : 				runwayQueueStruct *info = AddTraffic(aircraft->Id(),tTaxi, rwindex, time );

	mov	eax, DWORD PTR _time$11[ebp]
	push	eax
	mov	ecx, DWORD PTR _rwindex$15[ebp]
	push	ecx
	push	22					; 00000016H
	lea	edx, DWORD PTR $T5[ebp]
	push	edx
	mov	ecx, DWORD PTR _aircraft$17[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddTraffic@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@W4AtcStatusEnum@@HJ@Z ; ATCBrain::AddTraffic
	mov	DWORD PTR _info$16[ebp], eax

; 1642 : 
; 1643 : 				if(!info)

	cmp	DWORD PTR _info$16[ebp], 0
	jne	SHORT $LN14@RequestTak

; 1644 : 				{
; 1645 : 					aircraft = (AircraftClass*) flightIter.GetNext();

	lea	ecx, DWORD PTR _flightIter$8[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _aircraft$17[ebp], eax

; 1646 : 					continue;

	jmp	$LN26@RequestTak
$LN14@RequestTak:

; 1647 : 				}
; 1648 : 
; 1649 : 				if(IsOnRunway(aircraft))

	mov	eax, DWORD PTR _aircraft$17[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsOnRunway@ATCBrain@@QAEHPAVAircraftClass@@@Z ; ATCBrain::IsOnRunway
	test	eax, eax
	je	SHORT $LN13@RequestTak

; 1650 : 				{
; 1651 : 					nextTakeoff = NextToTakeoff(GetQueue(rwindex));

	mov	ecx, DWORD PTR _rwindex$15[ebp]
	push	ecx
	call	?GetQueue@@YAHH@Z			; GetQueue
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NextToTakeoff@ATCBrain@@AAEPAUrunwayQueueStruct@@H@Z ; ATCBrain::NextToTakeoff
	mov	DWORD PTR _nextTakeoff$[ebp], eax

; 1652 : 					if(nextTakeoff == info || 
; 1653 : 						(UseSectionTakeoff((Flight)aircraft->GetCampaignObject(), rwindex ) && aircraft->DBrain()->IsMyWingman(nextTakeoff->aircraftID)) )

	mov	edx, DWORD PTR _nextTakeoff$[ebp]
	cmp	edx, DWORD PTR _info$16[ebp]
	je	SHORT $LN11@RequestTak
	mov	eax, DWORD PTR _rwindex$15[ebp]
	push	eax
	mov	ecx, DWORD PTR _aircraft$17[ebp]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UseSectionTakeoff@ATCBrain@@QAEHPAVFlightClass@@H@Z ; ATCBrain::UseSectionTakeoff
	test	eax, eax
	je	SHORT $LN12@RequestTak
	mov	ecx, DWORD PTR _nextTakeoff$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR [ecx]
	push	eax
	mov	ecx, DWORD PTR _aircraft$17[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?IsMyWingman@DigitalBrain@@QAEHVVU_ID@@@Z ; DigitalBrain::IsMyWingman
	test	eax, eax
	je	SHORT $LN12@RequestTak
$LN11@RequestTak:

; 1654 : 							info->status = tTakeoff;

	mov	ecx, DWORD PTR _info$16[ebp]
	mov	DWORD PTR [ecx+8], 27			; 0000001bH
$LN12@RequestTak:

; 1655 : 				}

	jmp	SHORT $LN10@RequestTak
$LN13@RequestTak:

; 1656 : 				else if(info->schedTime > SimLibElapsedTime + 30*CampaignSeconds)

	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	edx, 30000				; 00007530H
	mov	eax, DWORD PTR _info$16[ebp]
	cmp	DWORD PTR [eax+12], edx
	jbe	SHORT $LN10@RequestTak

; 1657 : 				{
; 1658 : 					nextTakeoff = NextToTakeoff(GetQueue(rwindex));

	mov	ecx, DWORD PTR _rwindex$15[ebp]
	push	ecx
	call	?GetQueue@@YAHH@Z			; GetQueue
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NextToTakeoff@ATCBrain@@AAEPAUrunwayQueueStruct@@H@Z ; ATCBrain::NextToTakeoff
	mov	DWORD PTR _nextTakeoff$[ebp], eax

; 1659 : 					if(nextTakeoff == info)

	mov	edx, DWORD PTR _nextTakeoff$[ebp]
	cmp	edx, DWORD PTR _info$16[ebp]
	jne	SHORT $LN10@RequestTak

; 1660 : 						info->status = tHoldShort;

	mov	eax, DWORD PTR _info$16[ebp]
	mov	DWORD PTR [eax+8], 24			; 00000018H
$LN10@RequestTak:

; 1661 : 				}
; 1662 : 
; 1663 : 				if(runwayStats[queue].nextEmergency != FalconNullId)

	push	OFFSET ?FalconNullId@@3VVU_ID@@A	; FalconNullId
	mov	ecx, DWORD PTR _queue$12[ebp]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	lea	ecx, DWORD PTR [eax+ecx+32]
	call	??9VU_ID@@QBE_NABV0@@Z			; VU_ID::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN7@RequestTak

; 1664 : 					info->status = tEmerStop;

	mov	edx, DWORD PTR _info$16[ebp]
	mov	DWORD PTR [edx+8], 21			; 00000015H
$LN7@RequestTak:

; 1665 : 
; 1666 : 				SendCmdMessage(aircraft, info);

	mov	eax, DWORD PTR _info$16[ebp]
	push	eax
	mov	ecx, DWORD PTR _aircraft$17[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage

; 1667 : 				if(aircraft->IsPlayer() || aircraft->vehicleInUnit == 0)

	mov	ecx, DWORD PTR _aircraft$17[ebp]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	jne	SHORT $LN5@RequestTak
	mov	edx, DWORD PTR _aircraft$17[ebp]
	movzx	eax, BYTE PTR [edx+664]
	test	eax, eax
	jne	$LN24@RequestTak
$LN5@RequestTak:

; 1668 : 				{
; 1669 : 					if(info->status == tTaxi)

	mov	ecx, DWORD PTR _info$16[ebp]
	cmp	DWORD PTR [ecx+8], 22			; 00000016H
	jne	$LN4@RequestTak

; 1670 : 					{
; 1671 : 						radioMessage = CreateCallFromATC (self, aircraft, rcCLEARTOTAXI, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN70@RequestTak
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv724[ebp], eax
	jmp	SHORT $LN71@RequestTak
$LN70@RequestTak:
	mov	DWORD PTR tv724[ebp], 0
$LN71@RequestTak:
	mov	eax, DWORD PTR tv724[ebp]
	push	eax
	push	284					; 0000011cH
	mov	ecx, DWORD PTR _aircraft$17[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$18[ebp], eax

; 1672 : 						radioMessage->dataBlock.edata[2] = (short)GetRunwayName(rwindex);

	mov	ecx, DWORD PTR _rwindex$15[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRunwayName@ATCBrain@@QAEHH@Z	; ATCBrain::GetRunwayName
	mov	edx, 2
	shl	edx, 1
	mov	ecx, DWORD PTR _radioMessage$18[ebp]
	mov	WORD PTR [ecx+edx+64], ax

; 1673 : 						radioMessage->dataBlock.time_to_play= 2*CampaignSeconds;

	mov	edx, DWORD PTR _radioMessage$18[ebp]
	mov	DWORD PTR [edx+56], 2000		; 000007d0H

; 1674 : 						FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	eax, DWORD PTR _radioMessage$18[ebp]
	push	eax
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
	jmp	$LN24@RequestTak
$LN4@RequestTak:

; 1675 : 					}
; 1676 : 					else if(info->status == tHoldShort)

	mov	ecx, DWORD PTR _info$16[ebp]
	cmp	DWORD PTR [ecx+8], 24			; 00000018H
	jne	$LN24@RequestTak

; 1677 : 					{
; 1678 : 					//Cobra Holdshort is often first call and doesn't give the runway to taxi to
; 1679 : 						radioMessage = CreateCallFromATC (self, departing, rcCLEARTOTAXI, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN72@RequestTak
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv765[ebp], eax
	jmp	SHORT $LN73@RequestTak
$LN72@RequestTak:
	mov	DWORD PTR tv765[ebp], 0
$LN73@RequestTak:
	mov	eax, DWORD PTR tv765[ebp]
	push	eax
	push	284					; 0000011cH
	mov	ecx, DWORD PTR _departing$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$18[ebp], eax

; 1680 : 						radioMessage->dataBlock.edata[2] = (short)GetRunwayName(info->rwindex);

	mov	ecx, DWORD PTR _info$16[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRunwayName@ATCBrain@@QAEHH@Z	; ATCBrain::GetRunwayName
	mov	ecx, 2
	shl	ecx, 1
	mov	edx, DWORD PTR _radioMessage$18[ebp]
	mov	WORD PTR [edx+ecx+64], ax

; 1681 : 						FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	eax, DWORD PTR _radioMessage$18[ebp]
	push	eax
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8

; 1682 : 
; 1683 : 						radioMessage = CreateCallFromATC (self, aircraft, rcHOLDSHORT, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN74@RequestTak
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv803[ebp], eax
	jmp	SHORT $LN75@RequestTak
$LN74@RequestTak:
	mov	DWORD PTR tv803[ebp], 0
$LN75@RequestTak:
	mov	edx, DWORD PTR tv803[ebp]
	push	edx
	push	95					; 0000005fH
	mov	eax, DWORD PTR _aircraft$17[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$18[ebp], eax

; 1684 : 						radioMessage->dataBlock.edata[3] = 0;

	mov	eax, 2
	imul	eax, 3
	xor	ecx, ecx
	mov	edx, DWORD PTR _radioMessage$18[ebp]
	mov	WORD PTR [edx+eax+64], cx

; 1685 : 						if(info->prev && info->prev->status < lCrashed)

	mov	eax, DWORD PTR _info$16[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $LN1@RequestTak
	mov	ecx, DWORD PTR _info$16[ebp]
	mov	edx, DWORD PTR [ecx+28]
	cmp	DWORD PTR [edx+8], 18			; 00000012H
	jge	SHORT $LN1@RequestTak

; 1686 : 							radioMessage->dataBlock.edata[3] = (short)(1 + (rand()%4));

	call	_rand
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN82@RequestTak
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN82@RequestTak:
	add	eax, 1
	mov	ecx, 2
	imul	ecx, 3
	mov	edx, DWORD PTR _radioMessage$18[ebp]
	mov	WORD PTR [edx+ecx+64], ax
$LN1@RequestTak:

; 1687 : 						radioMessage->dataBlock.time_to_play= 2*CampaignSeconds;

	mov	eax, DWORD PTR _radioMessage$18[ebp]
	mov	DWORD PTR [eax+56], 2000		; 000007d0H

; 1688 : 						FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	ecx, DWORD PTR _radioMessage$18[ebp]
	push	ecx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN24@RequestTak:

; 1689 : 					}
; 1690 : 				}
; 1691 : 			}
; 1692 : 
; 1693 : 			aircraft = (AircraftClass*) flightIter.GetNext();			

	lea	ecx, DWORD PTR _flightIter$8[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _aircraft$17[ebp], eax

; 1694 : 		}

	jmp	$LN26@RequestTak
$LN25@RequestTak:

; 1695 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _flightIter$8[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
$LN56@RequestTak:

; 1696 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN83@RequestTak:
	DD	$LN37@RequestTak
	DD	$LN39@RequestTak
	DD	$LN39@RequestTak
	DD	$LN39@RequestTak
	DD	$LN40@RequestTak
	DD	$LN45@RequestTak
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?RequestTakeoff@ATCBrain@@QAEXPAVAircraftClass@@@Z$0:
	lea	ecx, DWORD PTR _flightIter$7[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__unwindfunclet$?RequestTakeoff@ATCBrain@@QAEXPAVAircraftClass@@@Z$1:
	lea	ecx, DWORD PTR _flightIter$8[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__ehhandler$?RequestTakeoff@ATCBrain@@QAEXPAVAircraftClass@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-160]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?RequestTakeoff@ATCBrain@@QAEXPAVAircraftClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?RequestTakeoff@ATCBrain@@QAEXPAVAircraftClass@@@Z ENDP	; ATCBrain::RequestTakeoff
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
$T2 = -116						; size = 8
$T3 = -108						; size = 8
$T4 = -100						; size = 8
$T5 = -92						; size = 8
_max$ = -84						; size = 4
_min$ = -80						; size = 4
$T6 = -76						; size = 4
tv395 = -72						; size = 4
_status$ = -68						; size = 4
_cosAngle$ = -64					; size = 4
tv290 = -60						; size = 4
$T7 = -56						; size = 4
tv279 = -52						; size = 4
tv217 = -48						; size = 4
tv165 = -44						; size = 4
_landTime$ = -40					; size = 4
_ATCCmdMessage$8 = -36					; size = 4
_queue$ = -32						; size = 4
_rwindex$ = -28						; size = 4
_radioMessage$ = -24					; size = 4
_info$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_approaching$ = 8					; size = 4
?RequestEmerClearance@ATCBrain@@QAEXPAVAircraftClass@@@Z PROC ; ATCBrain::RequestEmerClearance
; _this$ = ecx

; 1363 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?RequestEmerClearance@ATCBrain@@QAEXPAVAircraftClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1364 : 	int queue,rwindex;
; 1365 : 	runwayQueueStruct *info;
; 1366 : 	float cosAngle;
; 1367 : 	ulong min, max, landTime;
; 1368 : 	AtcStatusEnum status;
; 1369 : 	FalconRadioChatterMessage	*radioMessage = NULL;

	mov	DWORD PTR _radioMessage$[ebp], 0

; 1370 : 
; 1371 : 	if(!approaching || !self || approaching->OnGround())

	cmp	DWORD PTR _approaching$[ebp], 0
	je	SHORT $LN15@RequestEme
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN15@RequestEme
	mov	ecx, DWORD PTR _approaching$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _approaching$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	SHORT $LN16@RequestEme
$LN15@RequestEme:

; 1372 : 		return;

	jmp	$LN17@RequestEme
$LN16@RequestEme:

; 1373 : 
; 1374 : 	if(GetTTRelations(self->GetTeam(), approaching->GetTeam()) >= Hostile)

	mov	ecx, DWORD PTR _approaching$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _approaching$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	call	?GetTTRelations@@YAHEE@Z		; GetTTRelations
	add	esp, 8
	cmp	eax, 4
	jl	SHORT $LN14@RequestEme

; 1375 : 		return;

	jmp	$LN17@RequestEme
$LN14@RequestEme:

; 1376 : 
; 1377 : 	RemoveFromAllOtherATCs(approaching);

	mov	edx, DWORD PTR _approaching$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveFromAllOtherATCs@ATCBrain@@QAEXPAVAircraftClass@@@Z ; ATCBrain::RemoveFromAllOtherATCs

; 1378 : 
; 1379 : 	info = InList(approaching->Id());

	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	mov	ecx, DWORD PTR _approaching$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InList@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@@Z ; ATCBrain::InList
	mov	DWORD PTR _info$[ebp], eax

; 1380 : 	if(info)

	cmp	DWORD PTR _info$[ebp], 0
	je	$LN10@RequestEme

; 1381 : 	{
; 1382 : 		if(info->status >= lEmergencyToBase && info->status <= lEmergencyOnFinal)

	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax+8], 15			; 0000000fH
	jl	$LN12@RequestEme
	mov	ecx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [ecx+8], 17			; 00000011H
	jg	$LN12@RequestEme

; 1383 : 		{
; 1384 : 			//send confirmation message
; 1385 : 			radioMessage = CreateCallFromATC (self, approaching, rcCLEAREDEMERGLAND, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN19@RequestEme
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv165[ebp], eax
	jmp	SHORT $LN20@RequestEme
$LN19@RequestEme:
	mov	DWORD PTR tv165[ebp], 0
$LN20@RequestEme:
	mov	eax, DWORD PTR tv165[ebp]
	push	eax
	push	36					; 00000024H
	mov	ecx, DWORD PTR _approaching$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$[ebp], eax

; 1386 : 			//M.N. changed to 32767 -> flexibly use randomized value of max available eval indexes
; 1387 : 			radioMessage->dataBlock.edata[3] = 32767;

	mov	ecx, 2
	imul	ecx, 3
	mov	edx, 32767				; 00007fffH
	mov	eax, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [eax+ecx+64], dx

; 1388 : 
; 1389 : 			radioMessage->dataBlock.edata[4] = (short)GetRunwayName(GetOppositeRunway(info->rwindex));

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOppositeRunway@ATCBrain@@QAEHH@Z	; ATCBrain::GetOppositeRunway
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRunwayName@ATCBrain@@QAEHH@Z	; ATCBrain::GetRunwayName
	mov	ecx, 2
	shl	ecx, 2
	mov	edx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [edx+ecx+64], ax

; 1390 : 			//M.N. changed to 32767 -> flexibly use randomized value of max available eval indexes
; 1391 : 			radioMessage->dataBlock.edata[5] = 32767;

	mov	eax, 2
	imul	eax, 5
	mov	ecx, 32767				; 00007fffH
	mov	edx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [edx+eax+64], cx

; 1392 : 			FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	eax, DWORD PTR _radioMessage$[ebp]
	push	eax
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8

; 1393 : 
; 1394 : 			//MI inform ground
; 1395 : 			if((rand()%100) < 75)

	call	_rand
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	cmp	edx, 75					; 0000004bH
	jge	SHORT $LN11@RequestEme

; 1396 : 			{
; 1397 : 				radioMessage = CreateCallFromATC (self, approaching, rcACCIDENT, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN21@RequestEme
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv217[ebp], eax
	jmp	SHORT $LN22@RequestEme
$LN21@RequestEme:
	mov	DWORD PTR tv217[ebp], 0
$LN22@RequestEme:
	mov	eax, DWORD PTR tv217[ebp]
	push	eax
	push	338					; 00000152H
	mov	ecx, DWORD PTR _approaching$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$[ebp], eax

; 1398 : 				//Get some delay till this get's played. 8 Seconds is our clearance to land,
; 1399 : 				//and we want another 3 to 7 seconds delay.
; 1400 : 				radioMessage->dataBlock.time_to_play = ((rand()%5) + 11) * CampaignSeconds;

	call	_rand
	cdq
	mov	ecx, 5
	idiv	ecx
	add	edx, 11					; 0000000bH
	imul	edx, 1000				; 000003e8H
	mov	eax, DWORD PTR _radioMessage$[ebp]
	mov	DWORD PTR [eax+56], edx

; 1401 : 				FalconSendMessage(radioMessage, TRUE);

	push	1
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	push	ecx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN11@RequestEme:

; 1402 : 			}
; 1403 : 			return;

	jmp	$LN17@RequestEme

; 1404 : 		}
; 1405 : 		else

	jmp	SHORT $LN10@RequestEme
$LN12@RequestEme:

; 1406 : 		{
; 1407 : 			RemoveTraffic(info->aircraftID, PtHeaderDataTable[info->rwindex].runwayNum);

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+20]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	edx, BYTE PTR [ecx+eax+24]
	push	edx
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveTraffic@ATCBrain@@QAEXVVU_ID@@H@Z ; ATCBrain::RemoveTraffic
$LN10@RequestEme:

; 1408 : 		}
; 1409 : 	}
; 1410 : 
; 1411 : 	rwindex = FindBestLandingRunway(approaching, TRUE);	

	push	1
	mov	eax, DWORD PTR _approaching$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindBestLandingRunway@ATCBrain@@QAEHPAVFalconEntity@@H@Z ; ATCBrain::FindBestLandingRunway
	mov	DWORD PTR _rwindex$[ebp], eax

; 1412 : 	queue = GetQueue(rwindex);

	mov	ecx, DWORD PTR _rwindex$[ebp]
	push	ecx
	call	?GetQueue@@YAHH@Z			; GetQueue
	add	esp, 4
	mov	DWORD PTR _queue$[ebp], eax

; 1413 : 
; 1414 : 	if(!rwindex)

	cmp	DWORD PTR _rwindex$[ebp], 0
	jne	$LN9@RequestEme

; 1415 : 	{
; 1416 : 		//all runways destroyed, divert 'em
; 1417 : 		FalconATCCmdMessage* ATCCmdMessage = new FalconATCCmdMessage( approaching->Id(), FalconLocalGame );

	push	74					; 0000004aH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T7[ebp], 0
	je	SHORT $LN25@RequestEme
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN23@RequestEme
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv279[ebp], eax
	jmp	SHORT $LN24@RequestEme
$LN23@RequestEme:
	mov	DWORD PTR tv279[ebp], 0
$LN24@RequestEme:
	push	1
	mov	eax, DWORD PTR tv279[ebp]
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, DWORD PTR _approaching$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR $T7[ebp]
	call	??0FalconATCCmdMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconATCCmdMessage::FalconATCCmdMessage
	mov	DWORD PTR tv290[ebp], eax
	jmp	SHORT $LN26@RequestEme
$LN25@RequestEme:
	mov	DWORD PTR tv290[ebp], 0
$LN26@RequestEme:
	mov	ecx, DWORD PTR tv290[ebp]
	mov	DWORD PTR $T6[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T6[ebp]
	mov	DWORD PTR _ATCCmdMessage$8[ebp], edx

; 1418 : 		ATCCmdMessage->dataBlock.from		= self->Id();

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _ATCCmdMessage$8[ebp]
	mov	DWORD PTR [ecx+48], edx
	mov	DWORD PTR [ecx+52], eax

; 1419 : 		ATCCmdMessage->dataBlock.type		= FalconATCCmdMessage::Divert;

	mov	edx, DWORD PTR _ATCCmdMessage$8[ebp]
	mov	DWORD PTR [edx+56], 22			; 00000016H

; 1420 : 		ATCCmdMessage->dataBlock.rwindex	= 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _ATCCmdMessage$8[ebp]
	mov	WORD PTR [ecx+64], ax

; 1421 : 		FalconSendMessage(ATCCmdMessage, FALSE);						// Send it

	push	0
	mov	edx, DWORD PTR _ATCCmdMessage$8[ebp]
	push	edx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8

; 1422 : 		return;

	jmp	$LN17@RequestEme
$LN9@RequestEme:

; 1423 : 	}
; 1424 : 
; 1425 : 	cosAngle = DetermineAngle(approaching, rwindex, lHolding);

	push	7
	mov	eax, DWORD PTR _rwindex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _approaching$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DetermineAngle@ATCBrain@@QAEMPAVAircraftClass@@HW4AtcStatusEnum@@@Z ; ATCBrain::DetermineAngle
	fstp	DWORD PTR _cosAngle$[ebp]

; 1426 : 	CalculateMinMaxTime(approaching, rwindex, lHolding, &min, &max, cosAngle);

	push	ecx
	movss	xmm0, DWORD PTR _cosAngle$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _max$[ebp]
	push	edx
	lea	eax, DWORD PTR _min$[ebp]
	push	eax
	push	7
	mov	ecx, DWORD PTR _rwindex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _approaching$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateMinMaxTime@ATCBrain@@QAEXPAVAircraftClass@@HW4AtcStatusEnum@@PAK2M@Z ; ATCBrain::CalculateMinMaxTime

; 1427 : 	info = runwayQueue[queue];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _queue$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _info$[ebp], eax

; 1428 : 
; 1429 : 	landTime = SimLibElapsedTime + min;

	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	ecx, DWORD PTR _min$[ebp]
	mov	DWORD PTR _landTime$[ebp], ecx

; 1430 : 
; 1431 : 	//multiple emergencies, you have to wait your turn
; 1432 : 	if(runwayStats[queue].nextEmergency != FalconNullId)

	push	OFFSET ?FalconNullId@@3VVU_ID@@A	; FalconNullId
	mov	edx, DWORD PTR _queue$[ebp]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	lea	ecx, DWORD PTR [ecx+edx+32]
	call	??9VU_ID@@QBE_NABV0@@Z			; VU_ID::operator!=
	movzx	edx, al
	test	edx, edx
	je	$LN6@RequestEme

; 1433 : 	{
; 1434 : 		info = InList(runwayStats[queue].nextEmergency);

	mov	eax, DWORD PTR _queue$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR [edx+eax+36]
	push	ecx
	mov	edx, DWORD PTR [edx+eax+32]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InList@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@@Z ; ATCBrain::InList
	mov	DWORD PTR _info$[ebp], eax
$LN7@RequestEme:

; 1435 : 		while(info)

	cmp	DWORD PTR _info$[ebp], 0
	je	SHORT $LN6@RequestEme

; 1436 : 		{
; 1437 : 			if(info->status >= lEmergencyToBase && info->status <= lEmergencyOnFinal && landTime + EMER_SLOT*2 < info->schedTime)

	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax+8], 15			; 0000000fH
	jl	SHORT $LN5@RequestEme
	mov	ecx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [ecx+8], 17			; 00000011H
	jg	SHORT $LN5@RequestEme
	mov	edx, DWORD PTR _landTime$[ebp]
	add	edx, 120000				; 0001d4c0H
	mov	eax, DWORD PTR _info$[ebp]
	cmp	edx, DWORD PTR [eax+12]
	jae	SHORT $LN5@RequestEme

; 1438 : 				break;

	jmp	SHORT $LN6@RequestEme
$LN5@RequestEme:

; 1439 : 			if(info->status >= lEmergencyToBase && info->status <= lEmergencyOnFinal && landTime < info->schedTime + EMER_SLOT*2)

	mov	ecx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [ecx+8], 15			; 0000000fH
	jl	SHORT $LN4@RequestEme
	mov	edx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [edx+8], 17			; 00000011H
	jg	SHORT $LN4@RequestEme
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 120000				; 0001d4c0H
	cmp	DWORD PTR _landTime$[ebp], ecx
	jae	SHORT $LN4@RequestEme

; 1440 : 				landTime = info->schedTime + EMER_SLOT*2;

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, 120000				; 0001d4c0H
	mov	DWORD PTR _landTime$[ebp], eax
$LN4@RequestEme:

; 1441 : 			info = info->next;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _info$[ebp], edx

; 1442 : 		}

	jmp	SHORT $LN7@RequestEme
$LN6@RequestEme:

; 1443 : 	}
; 1444 : 		
; 1445 : 	if(cosAngle < 0.0F)

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _cosAngle$[ebp]
	jbe	SHORT $LN3@RequestEme

; 1446 : 		status = lEmergencyToBase;

	mov	DWORD PTR _status$[ebp], 15		; 0000000fH

; 1447 : 	else

	jmp	SHORT $LN2@RequestEme
$LN3@RequestEme:

; 1448 : 		status = lEmergencyToFinal;

	mov	DWORD PTR _status$[ebp], 16		; 00000010H
$LN2@RequestEme:

; 1449 : 
; 1450 : 	info = AddTraffic(approaching->Id(), status, rwindex, landTime );

	mov	eax, DWORD PTR _landTime$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rwindex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _status$[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _approaching$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddTraffic@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@W4AtcStatusEnum@@HJ@Z ; ATCBrain::AddTraffic
	mov	DWORD PTR _info$[ebp], eax

; 1451 : 	if(!info)

	cmp	DWORD PTR _info$[ebp], 0
	jne	SHORT $LN1@RequestEme

; 1452 : 		return;

	jmp	$LN17@RequestEme
$LN1@RequestEme:

; 1453 : 	
; 1454 : 	SendCmdMessage(approaching, info);

	mov	eax, DWORD PTR _info$[ebp]
	push	eax
	mov	ecx, DWORD PTR _approaching$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage

; 1455 : 	
; 1456 : 	radioMessage = CreateCallFromATC (self, approaching, rcCLEAREDEMERGLAND, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN27@RequestEme
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv395[ebp], eax
	jmp	SHORT $LN28@RequestEme
$LN27@RequestEme:
	mov	DWORD PTR tv395[ebp], 0
$LN28@RequestEme:
	mov	eax, DWORD PTR tv395[ebp]
	push	eax
	push	36					; 00000024H
	mov	ecx, DWORD PTR _approaching$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$[ebp], eax

; 1457 : 	//M.N. changed to 32767 -> flexibly use randomized value of max available eval indexes
; 1458 : 	radioMessage->dataBlock.edata[3] = 32767;

	mov	ecx, 2
	imul	ecx, 3
	mov	edx, 32767				; 00007fffH
	mov	eax, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [eax+ecx+64], dx

; 1459 : 
; 1460 : 	radioMessage->dataBlock.edata[4] = (short)GetRunwayName(GetOppositeRunway(info->rwindex));

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetOppositeRunway@ATCBrain@@QAEHH@Z	; ATCBrain::GetOppositeRunway
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRunwayName@ATCBrain@@QAEHH@Z	; ATCBrain::GetRunwayName
	mov	ecx, 2
	shl	ecx, 2
	mov	edx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [edx+ecx+64], ax

; 1461 : 	radioMessage->dataBlock.edata[5] = 32767;

	mov	eax, 2
	imul	eax, 5
	mov	ecx, 32767				; 00007fffH
	mov	edx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [edx+eax+64], cx

; 1462 : 	FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	eax, DWORD PTR _radioMessage$[ebp]
	push	eax
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8

; 1463 : 	//need to tell all that are in the way to hold, abort, etc...
; 1464 : 	//send emergencyhold and emergencystop messages to all planes in list for specified runway
; 1465 : 	FindNextEmergency(queue);

	mov	ecx, DWORD PTR _queue$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindNextEmergency@ATCBrain@@QAEXH@Z	; ATCBrain::FindNextEmergency

; 1466 : 
; 1467 : 	SetEmergency(queue);

	mov	edx, DWORD PTR _queue$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetEmergency@ATCBrain@@QAEXH@Z		; ATCBrain::SetEmergency
$LN17@RequestEme:

; 1468 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?RequestEmerClearance@ATCBrain@@QAEXPAVAircraftClass@@@Z$0:
	mov	eax, DWORD PTR $T7[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?RequestEmerClearance@ATCBrain@@QAEXPAVAircraftClass@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-108]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?RequestEmerClearance@ATCBrain@@QAEXPAVAircraftClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?RequestEmerClearance@ATCBrain@@QAEXPAVAircraftClass@@@Z ENDP ; ATCBrain::RequestEmerClearance
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_flightIter$2 = -140					; size = 12
$T3 = -128						; size = 8
$T4 = -120						; size = 8
$T5 = -112						; size = 8
$T6 = -104						; size = 8
_max$ = -96						; size = 4
$T7 = -92						; size = 4
_queue$ = -88						; size = 4
_flight$8 = -84						; size = 4
tv190 = -80						; size = 4
$T9 = -76						; size = 4
tv179 = -72						; size = 4
_x$ = -68						; size = 4
_y$ = -64						; size = 4
_baseX$ = -60						; size = 4
_baseY$ = -56						; size = 4
_min$ = -52						; size = 4
_finalX$ = -48						; size = 4
_finalY$ = -44						; size = 4
_ATCCmdMessage$10 = -40					; size = 4
_cosAngle$ = -36					; size = 4
_landTime$ = -32					; size = 4
_rwindex$ = -28						; size = 4
_aircraft$11 = -24					; size = 4
_info$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_approaching$ = 8					; size = 4
_addflight$ = 12					; size = 4
?RequestClearance@ATCBrain@@QAEXPAVAircraftClass@@H@Z PROC ; ATCBrain::RequestClearance
; _this$ = ecx

; 1225 : {	

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?RequestClearance@ATCBrain@@QAEXPAVAircraftClass@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1226 : 	int queue,rwindex;
; 1227 : 	ulong landTime, max, min;
; 1228 : 	float cosAngle;
; 1229 : 	runwayQueueStruct *info;
; 1230 : 	float finalX, finalY, baseX, baseY, x ,y;
; 1231 : 
; 1232 : 	if(!approaching || approaching->OnGround())

	cmp	DWORD PTR _approaching$[ebp], 0
	je	SHORT $LN22@RequestCle
	mov	eax, DWORD PTR _approaching$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _approaching$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	SHORT $LN23@RequestCle
$LN22@RequestCle:

; 1233 : 		return;

	jmp	$LN24@RequestCle
$LN23@RequestCle:

; 1234 : 
; 1235 : 	// OW - sylvains refuelling fix
; 1236 : #if 1
; 1237 : // ADDED BY S.G. - FIX FOR THE CTD WHEN TUNED TO THE TANKER TACAN AND ASKING FOR LANDING
; 1238 : // WHY SELF IS NULL, I DON'T KNOW, BUT IT IS :-(
; 1239 : 	if (!self)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN21@RequestCle

; 1240 : 		return;

	jmp	$LN24@RequestCle
$LN21@RequestCle:

; 1241 : // END OF ADDED SECTION
; 1242 : #endif
; 1243 : 
; 1244 : 	if (F4IsBadReadPtr(self, sizeof(ObjectiveClass)) || F4IsBadReadPtr(approaching, sizeof(AircraftClass))) // JB 010326 CTD

	push	244					; 000000f4H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?F4IsBadReadPtr@@YA_NPBXI@Z		; F4IsBadReadPtr
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN19@RequestCle
	push	3624					; 00000e28H
	mov	edx, DWORD PTR _approaching$[ebp]
	push	edx
	call	?F4IsBadReadPtr@@YA_NPBXI@Z		; F4IsBadReadPtr
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN20@RequestCle
$LN19@RequestCle:

; 1245 : 		return;

	jmp	$LN24@RequestCle
$LN20@RequestCle:

; 1246 : 
; 1247 : 	if(GetTTRelations(self->GetTeam(), approaching->GetTeam()) >= Hostile)

	mov	ecx, DWORD PTR _approaching$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _approaching$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	call	?GetTTRelations@@YAHEE@Z		; GetTTRelations
	add	esp, 8
	cmp	eax, 4
	jl	SHORT $LN18@RequestCle

; 1248 : 		return;

	jmp	$LN24@RequestCle
$LN18@RequestCle:

; 1249 : 
; 1250 : 	/*
; 1251 : 	if (underAttack)
; 1252 : 	{
; 1253 : 	   FalconRadioChatterMessage* radioMessage = new FalconRadioChatterMessage( approaching->Id(), FalconLocalSession );
; 1254 : 	   radioMessage->dataBlock.from = ((ATCBrain*)self)->Self()->Id();
; 1255 : 	   radioMessage->dataBlock.to = MESSAGE_FOR_FLIGHT;
; 1256 : 	   radioMessage->dataBlock.voice_id = ((int)self) % 12;
; 1257 : 	   radioMessage->dataBlock.message = rcBASEUNDERATTACK;
; 1258 : 	   radioMessage->dataBlock.edata[0] = approaching->GetCallsignIdx();
; 1259 : 	   radioMessage->dataBlock.edata[1] = ((Flight)approaching->GetCampaignObject())->GetPilotCallNumber(approaching->vehicleInUnit);
; 1260 : 	   FalconSendMessage(radioMessage, FALSE);
; 1261 : 	   //PlayRadioMessage(rcBASEUNDERATTACK)
; 1262 : 	   //approaching is the AC asking for clearance
; 1263 : 	   //self is ATC
; 1264 : 	   return;
; 1265 : }*/
; 1266 : 	
; 1267 : 	RemoveFromAllATCs(approaching);

	mov	edx, DWORD PTR _approaching$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveFromAllATCs@ATCBrain@@QAEXPAVAircraftClass@@@Z ; ATCBrain::RemoveFromAllATCs

; 1268 : 
; 1269 : 	rwindex = FindBestLandingRunway(approaching, TRUE);	

	push	1
	mov	eax, DWORD PTR _approaching$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindBestLandingRunway@ATCBrain@@QAEHPAVFalconEntity@@H@Z ; ATCBrain::FindBestLandingRunway
	mov	DWORD PTR _rwindex$[ebp], eax

; 1270 : 	queue = GetQueue(rwindex);

	mov	ecx, DWORD PTR _rwindex$[ebp]
	push	ecx
	call	?GetQueue@@YAHH@Z			; GetQueue
	add	esp, 4
	mov	DWORD PTR _queue$[ebp], eax

; 1271 : 
; 1272 : 	if(!rwindex)

	cmp	DWORD PTR _rwindex$[ebp], 0
	jne	$LN17@RequestCle

; 1273 : 	{
; 1274 : 		//all runways destroyed, divert 'em
; 1275 : 		FalconATCCmdMessage* ATCCmdMessage = new FalconATCCmdMessage( approaching->Id(), FalconLocalGame );

	push	74					; 0000004aH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T9[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T9[ebp], 0
	je	SHORT $LN28@RequestCle
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN26@RequestCle
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv179[ebp], eax
	jmp	SHORT $LN27@RequestCle
$LN26@RequestCle:
	mov	DWORD PTR tv179[ebp], 0
$LN27@RequestCle:
	push	1
	mov	eax, DWORD PTR tv179[ebp]
	push	eax
	lea	ecx, DWORD PTR $T6[ebp]
	push	ecx
	mov	ecx, DWORD PTR _approaching$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR $T9[ebp]
	call	??0FalconATCCmdMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconATCCmdMessage::FalconATCCmdMessage
	mov	DWORD PTR tv190[ebp], eax
	jmp	SHORT $LN29@RequestCle
$LN28@RequestCle:
	mov	DWORD PTR tv190[ebp], 0
$LN29@RequestCle:
	mov	ecx, DWORD PTR tv190[ebp]
	mov	DWORD PTR $T7[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T7[ebp]
	mov	DWORD PTR _ATCCmdMessage$10[ebp], edx

; 1276 : 		ATCCmdMessage->dataBlock.from		= self->Id();

	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _ATCCmdMessage$10[ebp]
	mov	DWORD PTR [ecx+48], edx
	mov	DWORD PTR [ecx+52], eax

; 1277 : 		ATCCmdMessage->dataBlock.type		= FalconATCCmdMessage::Divert;

	mov	edx, DWORD PTR _ATCCmdMessage$10[ebp]
	mov	DWORD PTR [edx+56], 22			; 00000016H

; 1278 : 		ATCCmdMessage->dataBlock.rwindex	= 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _ATCCmdMessage$10[ebp]
	mov	WORD PTR [ecx+64], ax

; 1279 : 		FalconSendMessage(ATCCmdMessage, FALSE);						// Send it

	push	0
	mov	edx, DWORD PTR _ATCCmdMessage$10[ebp]
	push	edx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8

; 1280 : 		return;

	jmp	$LN24@RequestCle
$LN17@RequestCle:

; 1281 : 	}
; 1282 : 
; 1283 : 	FindFinalPt(approaching, rwindex, &finalX, &finalY);

	lea	eax, DWORD PTR _finalY$[ebp]
	push	eax
	lea	ecx, DWORD PTR _finalX$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rwindex$[ebp]
	push	edx
	mov	eax, DWORD PTR _approaching$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindFinalPt@ATCBrain@@QAEXPAVAircraftClass@@HPAM1@Z ; ATCBrain::FindFinalPt

; 1284 : 
; 1285 : 	if( !addflight )

	cmp	DWORD PTR _addflight$[ebp], 0
	jne	$LN16@RequestCle

; 1286 : 	{
; 1287 : 		RemoveFromAllATCs(approaching);

	mov	ecx, DWORD PTR _approaching$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveFromAllATCs@ATCBrain@@QAEXPAVAircraftClass@@@Z ; ATCBrain::RemoveFromAllATCs

; 1288 : 
; 1289 : 		cosAngle = DetermineAngle(approaching, rwindex, lHolding);

	push	7
	mov	edx, DWORD PTR _rwindex$[ebp]
	push	edx
	mov	eax, DWORD PTR _approaching$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DetermineAngle@ATCBrain@@QAEMPAVAircraftClass@@HW4AtcStatusEnum@@@Z ; ATCBrain::DetermineAngle
	fstp	DWORD PTR _cosAngle$[ebp]

; 1290 : 		CalculateMinMaxTime(approaching, rwindex, lReqClearance, &min, &max, cosAngle);

	push	ecx
	movss	xmm0, DWORD PTR _cosAngle$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _max$[ebp]
	push	ecx
	lea	edx, DWORD PTR _min$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _rwindex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _approaching$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateMinMaxTime@ATCBrain@@QAEXPAVAircraftClass@@HW4AtcStatusEnum@@PAK2M@Z ; ATCBrain::CalculateMinMaxTime

; 1291 : 		landTime = GetNextAvailRunwayTime(queue, SimLibElapsedTime + min, LAND_TIME_DELTA);

	push	60000					; 0000ea60H
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	edx, DWORD PTR _min$[ebp]
	push	edx
	mov	eax, DWORD PTR _queue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextAvailRunwayTime@ATCBrain@@QAEKHKK@Z ; ATCBrain::GetNextAvailRunwayTime
	mov	DWORD PTR _landTime$[ebp], eax

; 1292 : 
; 1293 : 		info = AddTraffic(approaching->Id(), lHolding, rwindex, landTime);

	mov	ecx, DWORD PTR _landTime$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rwindex$[ebp]
	push	edx
	push	7
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _approaching$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddTraffic@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@W4AtcStatusEnum@@HJ@Z ; ATCBrain::AddTraffic
	mov	DWORD PTR _info$[ebp], eax

; 1294 : 		if(!info)

	cmp	DWORD PTR _info$[ebp], 0
	jne	SHORT $LN15@RequestCle

; 1295 : 			return;

	jmp	$LN24@RequestCle
$LN15@RequestCle:

; 1296 : 
; 1297 : 		if(landTime - SimLibElapsedTime < FINAL_TIME)

	mov	eax, DWORD PTR _landTime$[ebp]
	sub	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	cmp	eax, 120000				; 0001d4c0H
	jae	SHORT $LN14@RequestCle

; 1298 : 		{
; 1299 : 			info->status = lOnFinal;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+8], 11			; 0000000bH
	jmp	$LN11@RequestCle
$LN14@RequestCle:

; 1300 : 		}
; 1301 : 		else if(cosAngle < 0.0F)

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _cosAngle$[ebp]
	jbe	SHORT $LN12@RequestCle

; 1302 : 		{
; 1303 : 			FindBasePt(approaching, info->rwindex, finalX, finalY, &baseX, &baseY);

	lea	edx, DWORD PTR _baseY$[ebp]
	push	edx
	lea	eax, DWORD PTR _baseX$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _finalY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _finalX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _approaching$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindBasePt@ATCBrain@@QAE?AW4AtcStatusEnum@@PAVAircraftClass@@HMMPAM1@Z ; ATCBrain::FindBasePt

; 1304 : 			info->status = FindFirstLegPt(approaching, info->rwindex, info->schedTime, baseX, baseY, TRUE, &x, &y);

	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	push	1
	push	ecx
	movss	xmm0, DWORD PTR _baseY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _baseX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _approaching$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindFirstLegPt@ATCBrain@@QAE?AW4AtcStatusEnum@@PAVAircraftClass@@HKMMHPAM1@Z ; ATCBrain::FindFirstLegPt
	mov	edx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1305 : 		}
; 1306 : 		else

	jmp	SHORT $LN11@RequestCle
$LN12@RequestCle:

; 1307 : 		{
; 1308 : 			info->status = FindFirstLegPt(approaching, info->rwindex, info->schedTime, finalX, finalY, FALSE, &x, &y);

	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	push	0
	push	ecx
	movss	xmm0, DWORD PTR _finalY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _finalX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _approaching$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindFirstLegPt@ATCBrain@@QAE?AW4AtcStatusEnum@@PAVAircraftClass@@HKMMHPAM1@Z ; ATCBrain::FindFirstLegPt
	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN11@RequestCle:

; 1309 : 		}	
; 1310 : 
; 1311 : 		SendCmdMessage(approaching, info);

	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	mov	eax, DWORD PTR _approaching$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage

; 1312 : 		info->lastContacted = SimLibElapsedTime;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [ecx+16], edx

; 1313 : 	}
; 1314 : 	else

	jmp	$LN10@RequestCle
$LN16@RequestCle:

; 1315 : 	{
; 1316 : 		AircraftClass			*aircraft = NULL;

	mov	DWORD PTR _aircraft$11[ebp], 0

; 1317 : 		Flight					flight = (Flight)approaching->GetCampaignObject();

	mov	ecx, DWORD PTR _approaching$[ebp]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	DWORD PTR _flight$8[ebp], eax

; 1318 : 
; 1319 : 		// protect against no components
; 1320 : 		if ( !flight->GetComponents() )

	mov	ecx, DWORD PTR _flight$8[ebp]
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	test	eax, eax
	jne	SHORT $LN9@RequestCle

; 1321 : 			return;

	jmp	$LN24@RequestCle
$LN9@RequestCle:

; 1322 : 
; 1323 : 		VuListIterator			flightIter(flight->GetComponents());

	mov	ecx, DWORD PTR _flight$8[ebp]
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	push	eax
	lea	ecx, DWORD PTR _flightIter$2[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1324 : 		aircraft = (AircraftClass*) flightIter.GetFirst();

	lea	ecx, DWORD PTR _flightIter$2[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _aircraft$11[ebp], eax
$LN8@RequestCle:

; 1325 : 		while(aircraft)

	cmp	DWORD PTR _aircraft$11[ebp], 0
	je	$LN7@RequestCle

; 1326 : 		{
; 1327 : 			if(!aircraft->OnGround())

	mov	eax, DWORD PTR _aircraft$11[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _aircraft$11[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	jne	$LN6@RequestCle

; 1328 : 			{
; 1329 : 				RemoveFromAllATCs(aircraft);

	mov	ecx, DWORD PTR _aircraft$11[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveFromAllATCs@ATCBrain@@QAEXPAVAircraftClass@@@Z ; ATCBrain::RemoveFromAllATCs

; 1330 : 
; 1331 : 				cosAngle = DetermineAngle(aircraft, rwindex, lHolding);

	push	7
	mov	edx, DWORD PTR _rwindex$[ebp]
	push	edx
	mov	eax, DWORD PTR _aircraft$11[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DetermineAngle@ATCBrain@@QAEMPAVAircraftClass@@HW4AtcStatusEnum@@@Z ; ATCBrain::DetermineAngle
	fstp	DWORD PTR _cosAngle$[ebp]

; 1332 : 				CalculateMinMaxTime(aircraft, rwindex, lHolding, &min, &max, cosAngle);

	push	ecx
	movss	xmm0, DWORD PTR _cosAngle$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _max$[ebp]
	push	ecx
	lea	edx, DWORD PTR _min$[ebp]
	push	edx
	push	7
	mov	eax, DWORD PTR _rwindex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _aircraft$11[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateMinMaxTime@ATCBrain@@QAEXPAVAircraftClass@@HW4AtcStatusEnum@@PAK2M@Z ; ATCBrain::CalculateMinMaxTime

; 1333 : 				landTime = GetNextAvailRunwayTime(queue, SimLibElapsedTime + min, LAND_TIME_DELTA);

	push	60000					; 0000ea60H
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	edx, DWORD PTR _min$[ebp]
	push	edx
	mov	eax, DWORD PTR _queue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNextAvailRunwayTime@ATCBrain@@QAEKHKK@Z ; ATCBrain::GetNextAvailRunwayTime
	mov	DWORD PTR _landTime$[ebp], eax

; 1334 : 
; 1335 : 				info = AddTraffic(aircraft->Id(), lHolding, rwindex, landTime);

	mov	ecx, DWORD PTR _landTime$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rwindex$[ebp]
	push	edx
	push	7
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _aircraft$11[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddTraffic@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@W4AtcStatusEnum@@HJ@Z ; ATCBrain::AddTraffic
	mov	DWORD PTR _info$[ebp], eax

; 1336 : 				if(!info)

	cmp	DWORD PTR _info$[ebp], 0
	jne	SHORT $LN5@RequestCle

; 1337 : 					return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _flightIter$2[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
	jmp	$LN24@RequestCle
$LN5@RequestCle:

; 1338 : 
; 1339 : 				if(landTime - SimLibElapsedTime < FINAL_TIME)

	mov	eax, DWORD PTR _landTime$[ebp]
	sub	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	cmp	eax, 120000				; 0001d4c0H
	jae	SHORT $LN4@RequestCle

; 1340 : 				{
; 1341 : 					info->status = lOnFinal;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+8], 11			; 0000000bH
	jmp	$LN1@RequestCle
$LN4@RequestCle:

; 1342 : 				}
; 1343 : 				else if(cosAngle < 0.0F)

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _cosAngle$[ebp]
	jbe	SHORT $LN2@RequestCle

; 1344 : 				{
; 1345 : 					FindBasePt(aircraft, info->rwindex, finalX, finalY, &baseX, &baseY);

	lea	edx, DWORD PTR _baseY$[ebp]
	push	edx
	lea	eax, DWORD PTR _baseX$[ebp]
	push	eax
	push	ecx
	movss	xmm0, DWORD PTR _finalY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _finalX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _aircraft$11[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindBasePt@ATCBrain@@QAE?AW4AtcStatusEnum@@PAVAircraftClass@@HMMPAM1@Z ; ATCBrain::FindBasePt

; 1346 : 					info->status = FindFirstLegPt(aircraft, info->rwindex, info->schedTime, baseX, baseY, TRUE, &x, &y);

	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	push	1
	push	ecx
	movss	xmm0, DWORD PTR _baseY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _baseX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _aircraft$11[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindFirstLegPt@ATCBrain@@QAE?AW4AtcStatusEnum@@PAVAircraftClass@@HKMMHPAM1@Z ; ATCBrain::FindFirstLegPt
	mov	edx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1347 : 				}
; 1348 : 				else

	jmp	SHORT $LN1@RequestCle
$LN2@RequestCle:

; 1349 : 				{
; 1350 : 					info->status = FindFirstLegPt(aircraft, info->rwindex, info->schedTime, finalX, finalY, FALSE, &x, &y);

	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	push	0
	push	ecx
	movss	xmm0, DWORD PTR _finalY$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	movss	xmm0, DWORD PTR _finalX$[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _aircraft$11[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindFirstLegPt@ATCBrain@@QAE?AW4AtcStatusEnum@@PAVAircraftClass@@HKMMHPAM1@Z ; ATCBrain::FindFirstLegPt
	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN1@RequestCle:

; 1351 : 				}				
; 1352 : 
; 1353 : 				SendCmdMessage(aircraft, info);

	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	mov	eax, DWORD PTR _aircraft$11[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage

; 1354 : 				info->lastContacted = SimLibElapsedTime;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [ecx+16], edx
$LN6@RequestCle:

; 1355 : 			}
; 1356 : 			aircraft = (AircraftClass*) flightIter.GetNext();

	lea	ecx, DWORD PTR _flightIter$2[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _aircraft$11[ebp], eax

; 1357 : 		}

	jmp	$LN8@RequestCle
$LN7@RequestCle:

; 1358 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _flightIter$2[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
$LN10@RequestCle:
$LN24@RequestCle:

; 1359 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?RequestClearance@ATCBrain@@QAEXPAVAircraftClass@@H@Z$0:
	mov	eax, DWORD PTR $T9[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?RequestClearance@ATCBrain@@QAEXPAVAircraftClass@@H@Z$1:
	lea	ecx, DWORD PTR _flightIter$2[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__ehhandler$?RequestClearance@ATCBrain@@QAEXPAVAircraftClass@@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-132]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?RequestClearance@ATCBrain@@QAEXPAVAircraftClass@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?RequestClearance@ATCBrain@@QAEXPAVAircraftClass@@H@Z ENDP ; ATCBrain::RequestClearance
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_i$ = -12						; size = 4
_this$ = -8						; size = 4
_temp$ = -4						; size = 4
_aircraftID$ = 8					; size = 8
?InList@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@@Z PROC ; ATCBrain::InList
; _this$ = ecx

; 3590 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 3591 : 	int i;
; 3592 : 	runwayQueueStruct *temp = NULL;

	mov	DWORD PTR _temp$[ebp], 0

; 3593 : 
; 3594 : 	// OW - sylvains refuelling fix
; 3595 : #if 1
; 3596 : 	// ADDED BY S.G. - FIX FOR THE CTD WHEN TUNED TO THE TANKER TACAN AND ASKING FOR LANDING
; 3597 : 	// THERE ARE NO RUNWAYS ASSIGNED TO A TANKER!
; 3598 : 	//if (!runwayQueue) // JB 010304 CTD
; 3599 : 	//if (F4IsBadReadPtr(runwayQueue, sizeof(runwayQueueStruct*)) || !runwayQueue) // JB 010304 CTD
; 3600 : 	if (
; 3601 : 		F4IsBadReadPtr(this, sizeof(ATCBrain)) || 
; 3602 : 		F4IsBadReadPtr(runwayQueue, sizeof(runwayQueueStruct*)) || !runwayQueue) // JB 010317 CTD

	push	60					; 0000003cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?F4IsBadReadPtr@@YA_NPBXI@Z		; F4IsBadReadPtr
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN10@InList
	push	4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	?F4IsBadReadPtr@@YA_NPBXI@Z		; F4IsBadReadPtr
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN10@InList
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+20], 0
	jne	SHORT $LN11@InList
$LN10@InList:

; 3603 : 	{
; 3604 : 		return NULL;

	xor	eax, eax
	jmp	$LN12@InList
$LN11@InList:

; 3605 : 	}
; 3606 : 	// END OF ADDED SECTION
; 3607 : #endif
; 3608 : 
; 3609 : 	for(i = 0; i < numRwys; i++){

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN9@InList
$LN8@InList:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN9@InList:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jge	SHORT $LN7@InList

; 3610 : 		temp = runwayQueue[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _temp$[ebp], eax
$LN6@InList:

; 3611 : 		while(temp){

	cmp	DWORD PTR _temp$[ebp], 0
	je	SHORT $LN5@InList

; 3612 : 			if(temp->aircraftID == aircraftID){

	lea	ecx, DWORD PTR _aircraftID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _temp$[ebp]
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN4@InList

; 3613 : 				return temp;

	mov	eax, DWORD PTR _temp$[ebp]
	jmp	SHORT $LN12@InList
$LN4@InList:

; 3614 : 			}
; 3615 : 			temp = temp->next;

	mov	eax, DWORD PTR _temp$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _temp$[ebp], ecx

; 3616 : 		}

	jmp	SHORT $LN6@InList
$LN5@InList:

; 3617 : 	}

	jmp	SHORT $LN8@InList
$LN7@InList:

; 3618 : 
; 3619 : 	temp = inboundQueue;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _temp$[ebp], eax
$LN3@InList:

; 3620 : 	while(temp){

	cmp	DWORD PTR _temp$[ebp], 0
	je	SHORT $LN2@InList

; 3621 : 		if(temp->aircraftID == aircraftID){

	lea	ecx, DWORD PTR _aircraftID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _temp$[ebp]
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@InList

; 3622 : 			return temp;

	mov	eax, DWORD PTR _temp$[ebp]
	jmp	SHORT $LN12@InList
$LN1@InList:

; 3623 : 		}
; 3624 : 		temp = temp->next;

	mov	eax, DWORD PTR _temp$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _temp$[ebp], ecx

; 3625 : 	}

	jmp	SHORT $LN3@InList
$LN2@InList:

; 3626 : 
; 3627 : 	return temp;

	mov	eax, DWORD PTR _temp$[ebp]
$LN12@InList:

; 3628 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?InList@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@@Z ENDP ; ATCBrain::InList
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
tv88 = -16						; size = 4
_num$ = -12						; size = 4
_this$ = -8						; size = 4
_i$ = -4						; size = 4
?NumOperableRunways@ATCBrain@@QAEHXZ PROC		; ATCBrain::NumOperableRunways
; _this$ = ecx

; 4667 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 4668 : 	int num = 0, i;

	mov	DWORD PTR _num$[ebp], 0

; 4669 : 
; 4670 : 	if (!runwayStats) // JB 010531

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN5@NumOperabl

; 4671 : 		return 0;

	xor	eax, eax
	jmp	$LN6@NumOperabl
$LN5@NumOperabl:

; 4672 : 
; 4673 : 	for(i = 0; i < numRwys; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@NumOperabl
$LN3@NumOperabl:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@NumOperabl:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jge	$LN2@NumOperabl

; 4674 : 	{
; 4675 : 	//cobra
; 4676 : 	runwayStats[i].state = CheckHeaderStatus (self, runwayStats[i].rwIndexes[0]);

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	add	eax, ecx
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR [eax+ecx]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?CheckHeaderStatus@@YAHPAVCampBaseClass@@H@Z ; CheckHeaderStatus
	add	esp, 8
	mov	DWORD PTR tv88[ebp], eax
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	ax, WORD PTR tv88[ebp]
	and	ax, 7
	mov	esi, 65528				; 0000fff8H
	and	si, WORD PTR [ecx+edx+24]
	or	si, ax
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	WORD PTR [eax+ecx+24], si

; 4677 : 	//end
; 4678 : 		if(runwayStats[i].state < VIS_DAMAGED)

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	cx, WORD PTR [eax+ecx+24]
	and	cx, 7
	movzx	edx, cx
	cmp	edx, 2
	jge	SHORT $LN1@NumOperabl

; 4679 : 			num++;

	mov	eax, DWORD PTR _num$[ebp]
	add	eax, 1
	mov	DWORD PTR _num$[ebp], eax
$LN1@NumOperabl:

; 4680 : 	}

	jmp	$LN3@NumOperabl
$LN2@NumOperabl:

; 4681 : 	return num;

	mov	eax, DWORD PTR _num$[ebp]
$LN6@NumOperabl:

; 4682 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?NumOperableRunways@ATCBrain@@QAEHXZ ENDP		; ATCBrain::NumOperableRunways
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
$T2 = -64						; size = 8
$T3 = -56						; size = 8
tv232 = -48						; size = 4
$T4 = -44						; size = 4
$T5 = -40						; size = 4
tv147 = -36						; size = 4
_this$ = -32						; size = 4
tv129 = -28						; size = 4
$T6 = -24						; size = 4
$T7 = -20						; size = 4
_ATCCmdMessage$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_aircraft$ = 8						; size = 4
_info$ = 12						; size = 4
?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z PROC ; ATCBrain::SendCmdMessage
; _this$ = ecx

; 3926 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3927 : 	if (F4IsBadReadPtr(self, sizeof(ObjectiveClass))) // JB 010408 CTD

	push	244					; 000000f4H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?F4IsBadReadPtr@@YA_NPBXI@Z		; F4IsBadReadPtr
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN28@SendCmdMes

; 3928 : 		return;

	jmp	$LN29@SendCmdMes
$LN28@SendCmdMes:

; 3929 : 
; 3930 : 	FalconATCCmdMessage* ATCCmdMessage	= new FalconATCCmdMessage( aircraft->Id(), FalconLocalSession/*me123 from localgame*/ );

	push	74					; 0000004aH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T6[ebp], 0
	je	SHORT $LN31@SendCmdMes
	push	1
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	push	eax
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR $T6[ebp]
	call	??0FalconATCCmdMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconATCCmdMessage::FalconATCCmdMessage
	mov	DWORD PTR tv129[ebp], eax
	jmp	SHORT $LN32@SendCmdMes
$LN31@SendCmdMes:
	mov	DWORD PTR tv129[ebp], 0
$LN32@SendCmdMes:
	mov	eax, DWORD PTR tv129[ebp]
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T5[ebp]
	mov	DWORD PTR _ATCCmdMessage$[ebp], ecx

; 3931 : 	ATCCmdMessage->dataBlock.from		= self->Id();

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _ATCCmdMessage$[ebp]
	mov	DWORD PTR [eax+48], ecx
	mov	DWORD PTR [eax+52], edx

; 3932 : 	//I am sending an actual time instead of a delta, because of the huge time differences between different
; 3933 : 	//machines at startup
; 3934 : 	ATCCmdMessage->dataBlock.rwtime = info->schedTime;

	mov	ecx, DWORD PTR _ATCCmdMessage$[ebp]
	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+60], eax

; 3935 : 	ATCCmdMessage->dataBlock.rwindex	= (short)info->rwindex;

	mov	ecx, DWORD PTR _ATCCmdMessage$[ebp]
	mov	edx, DWORD PTR _info$[ebp]
	mov	ax, WORD PTR [edx+20]
	mov	WORD PTR [ecx+64], ax

; 3936 : 
; 3937 : 	switch(info->status)

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv147[ebp], edx
	cmp	DWORD PTR tv147[ebp], 29		; 0000001dH
	ja	$LN1@SendCmdMes
	mov	eax, DWORD PTR tv147[ebp]
	jmp	DWORD PTR $LN37@SendCmdMes[eax*4]
$LN25@SendCmdMes:

; 3938 : 	{
; 3939 : 	case lIngressing:
; 3940 : 		ATCCmdMessage->dataBlock.type		= FalconATCCmdMessage::TakePosition;

	mov	ecx, DWORD PTR _ATCCmdMessage$[ebp]
	mov	DWORD PTR [ecx+56], 0

; 3941 : 		info->lastContacted = SimLibElapsedTime;

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [edx+16], eax

; 3942 : 		break;

	jmp	$LN26@SendCmdMes
$LN24@SendCmdMes:

; 3943 : 	case lTakingPosition:
; 3944 : 		ATCCmdMessage->dataBlock.type		= FalconATCCmdMessage::TakePosition;

	mov	ecx, DWORD PTR _ATCCmdMessage$[ebp]
	mov	DWORD PTR [ecx+56], 0

; 3945 : 		info->lastContacted = SimLibElapsedTime;

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [edx+16], eax

; 3946 : 		break;

	jmp	$LN26@SendCmdMes
$LN23@SendCmdMes:

; 3947 : 	case lAborted:
; 3948 : 		ATCCmdMessage->dataBlock.type		= FalconATCCmdMessage::Abort;

	mov	ecx, DWORD PTR _ATCCmdMessage$[ebp]
	mov	DWORD PTR [ecx+56], 3

; 3949 : 		info->lastContacted = SimLibElapsedTime;

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [edx+16], eax

; 3950 : 		break;

	jmp	$LN26@SendCmdMes
$LN22@SendCmdMes:

; 3951 : 	case lEmerHold:
; 3952 : 		ATCCmdMessage->dataBlock.type		= FalconATCCmdMessage::EmergencyHold;

	mov	ecx, DWORD PTR _ATCCmdMessage$[ebp]
	mov	DWORD PTR [ecx+56], 1

; 3953 : 		info->lastContacted = SimLibElapsedTime;

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [edx+16], eax

; 3954 : 		break;

	jmp	$LN26@SendCmdMes
$LN21@SendCmdMes:

; 3955 : 	case lHolding:
; 3956 : 		ATCCmdMessage->dataBlock.type		= FalconATCCmdMessage::Hold;

	mov	ecx, DWORD PTR _ATCCmdMessage$[ebp]
	mov	DWORD PTR [ecx+56], 2

; 3957 : 		info->lastContacted = SimLibElapsedTime;

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [edx+16], eax

; 3958 : 		break;

	jmp	$LN26@SendCmdMes
$LN20@SendCmdMes:

; 3959 : 	case lFirstLeg:
; 3960 : 		ATCCmdMessage->dataBlock.type		= FalconATCCmdMessage::ToFirstLeg;

	mov	ecx, DWORD PTR _ATCCmdMessage$[ebp]
	mov	DWORD PTR [ecx+56], 4

; 3961 : 		break;

	jmp	$LN26@SendCmdMes
$LN19@SendCmdMes:

; 3962 : 	case lToBase:
; 3963 : 		ATCCmdMessage->dataBlock.type		= FalconATCCmdMessage::ToBase;

	mov	edx, DWORD PTR _ATCCmdMessage$[ebp]
	mov	DWORD PTR [edx+56], 5

; 3964 : 		break;

	jmp	$LN26@SendCmdMes
$LN18@SendCmdMes:

; 3965 : 	case lToFinal:
; 3966 : 		ATCCmdMessage->dataBlock.type		= FalconATCCmdMessage::ToFinal;

	mov	eax, DWORD PTR _ATCCmdMessage$[ebp]
	mov	DWORD PTR [eax+56], 6

; 3967 : 		break;

	jmp	$LN26@SendCmdMes
$LN17@SendCmdMes:

; 3968 : 	case lOnFinal:
; 3969 : 		ATCCmdMessage->dataBlock.type		= FalconATCCmdMessage::OnFinal;

	mov	ecx, DWORD PTR _ATCCmdMessage$[ebp]
	mov	DWORD PTR [ecx+56], 7

; 3970 : 		info->lastContacted = SimLibElapsedTime + 30 * CampaignSeconds;

	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	edx, 30000				; 00007530H
	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+16], edx

; 3971 : 		break;

	jmp	$LN26@SendCmdMes
$LN16@SendCmdMes:

; 3972 : 	case lClearToLand:
; 3973 : 		ATCCmdMessage->dataBlock.type		= FalconATCCmdMessage::ClearToLand;

	mov	ecx, DWORD PTR _ATCCmdMessage$[ebp]
	mov	DWORD PTR [ecx+56], 8

; 3974 : 		info->lastContacted = SimLibElapsedTime + 30 * CampaignSeconds;

	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	edx, 30000				; 00007530H
	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+16], edx

; 3975 : 		break;

	jmp	$LN26@SendCmdMes
$LN15@SendCmdMes:

; 3976 : 	case lLanded:
; 3977 : 		ATCCmdMessage->dataBlock.type		= FalconATCCmdMessage::Landed;

	mov	ecx, DWORD PTR _ATCCmdMessage$[ebp]
	mov	DWORD PTR [ecx+56], 9

; 3978 : 		info->lastContacted = SimLibElapsedTime + 30 * CampaignSeconds;

	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	edx, 30000				; 00007530H
	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+16], edx

; 3979 : 		break;

	jmp	$LN26@SendCmdMes
$LN14@SendCmdMes:

; 3980 : 	case lTaxiOff:
; 3981 : 		ATCCmdMessage->dataBlock.type		= FalconATCCmdMessage::TaxiOff;

	mov	ecx, DWORD PTR _ATCCmdMessage$[ebp]
	mov	DWORD PTR [ecx+56], 10			; 0000000aH

; 3982 : 		break;

	jmp	$LN26@SendCmdMes
$LN13@SendCmdMes:

; 3983 : 	case lEmergencyToBase:
; 3984 : 		ATCCmdMessage->dataBlock.type		= FalconATCCmdMessage::EmerToBase;

	mov	edx, DWORD PTR _ATCCmdMessage$[ebp]
	mov	DWORD PTR [edx+56], 11			; 0000000bH

; 3985 : 		info->lastContacted = SimLibElapsedTime;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [eax+16], ecx

; 3986 : 		break;

	jmp	$LN26@SendCmdMes
$LN12@SendCmdMes:

; 3987 : 	case lEmergencyToFinal:
; 3988 : 		ATCCmdMessage->dataBlock.type		= FalconATCCmdMessage::EmerToFinal;

	mov	edx, DWORD PTR _ATCCmdMessage$[ebp]
	mov	DWORD PTR [edx+56], 12			; 0000000cH

; 3989 : 		info->lastContacted = SimLibElapsedTime;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [eax+16], ecx

; 3990 : 		break;

	jmp	$LN26@SendCmdMes
$LN11@SendCmdMes:

; 3991 : 	case lEmergencyOnFinal:
; 3992 : 		ATCCmdMessage->dataBlock.type		= FalconATCCmdMessage::EmerOnFinal;

	mov	edx, DWORD PTR _ATCCmdMessage$[ebp]
	mov	DWORD PTR [edx+56], 13			; 0000000dH

; 3993 : 		info->lastContacted = SimLibElapsedTime;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [eax+16], ecx

; 3994 : 		break;

	jmp	$LN26@SendCmdMes
$LN10@SendCmdMes:

; 3995 : 	case tEmerStop:
; 3996 : 		ATCCmdMessage->dataBlock.type		= FalconATCCmdMessage::EmergencyStop;

	mov	edx, DWORD PTR _ATCCmdMessage$[ebp]
	mov	DWORD PTR [edx+56], 14			; 0000000eH

; 3997 : 		info->lastContacted = SimLibElapsedTime;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [eax+16], ecx

; 3998 : 		break;

	jmp	$LN26@SendCmdMes
$LN9@SendCmdMes:

; 3999 : 	case tWait:
; 4000 : 		ATCCmdMessage->dataBlock.type		= FalconATCCmdMessage::Wait;

	mov	edx, DWORD PTR _ATCCmdMessage$[ebp]
	mov	DWORD PTR [edx+56], 17			; 00000011H

; 4001 : 		info->lastContacted = SimLibElapsedTime;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [eax+16], ecx

; 4002 : 		break;

	jmp	$LN26@SendCmdMes
$LN8@SendCmdMes:

; 4003 : 	case tTaxi:
; 4004 : 		ATCCmdMessage->dataBlock.type		= FalconATCCmdMessage::Taxi;

	mov	edx, DWORD PTR _ATCCmdMessage$[ebp]
	mov	DWORD PTR [edx+56], 16			; 00000010H

; 4005 : 		info->lastContacted = SimLibElapsedTime;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [eax+16], ecx

; 4006 : 		break;

	jmp	$LN26@SendCmdMes
$LN7@SendCmdMes:

; 4007 : 	case tHoldShort:
; 4008 : 		ATCCmdMessage->dataBlock.type		= FalconATCCmdMessage::HoldShort;

	mov	edx, DWORD PTR _ATCCmdMessage$[ebp]
	mov	DWORD PTR [edx+56], 18			; 00000012H

; 4009 : 		info->lastContacted = SimLibElapsedTime;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [eax+16], ecx

; 4010 : 		break;

	jmp	$LN26@SendCmdMes
$LN6@SendCmdMes:

; 4011 : 
; 4012 : 	case tPrepToTakeRunway:
; 4013 : 		ATCCmdMessage->dataBlock.type		= FalconATCCmdMessage::PrepToTakeRunway;

	mov	edx, DWORD PTR _ATCCmdMessage$[ebp]
	mov	DWORD PTR [edx+56], 19			; 00000013H

; 4014 : 		info->lastContacted = SimLibElapsedTime;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [eax+16], ecx

; 4015 : 		break;

	jmp	$LN26@SendCmdMes
$LN5@SendCmdMes:

; 4016 : 
; 4017 : 	case tTakeRunway:
; 4018 : 		ATCCmdMessage->dataBlock.type		= FalconATCCmdMessage::TakeRunway;

	mov	edx, DWORD PTR _ATCCmdMessage$[ebp]
	mov	DWORD PTR [edx+56], 20			; 00000014H

; 4019 : 		info->lastContacted = SimLibElapsedTime;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [eax+16], ecx

; 4020 : 		break;

	jmp	SHORT $LN26@SendCmdMes
$LN4@SendCmdMes:

; 4021 : 
; 4022 : 	case tTakeoff:
; 4023 : 		ATCCmdMessage->dataBlock.type		= FalconATCCmdMessage::Takeoff;

	mov	edx, DWORD PTR _ATCCmdMessage$[ebp]
	mov	DWORD PTR [edx+56], 21			; 00000015H

; 4024 : 		info->lastContacted = SimLibElapsedTime;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [eax+16], ecx

; 4025 : 		break;

	jmp	SHORT $LN26@SendCmdMes
$LN3@SendCmdMes:

; 4026 : 	case noATC:
; 4027 : 	case tFlyOut:
; 4028 : 		ATCCmdMessage->dataBlock.type		= FalconATCCmdMessage::Release;

	mov	edx, DWORD PTR _ATCCmdMessage$[ebp]
	mov	DWORD PTR [edx+56], 23			; 00000017H

; 4029 : 		ATCCmdMessage->dataBlock.rwtime		= 0;

	mov	eax, DWORD PTR _ATCCmdMessage$[ebp]
	mov	DWORD PTR [eax+60], 0

; 4030 : 		ATCCmdMessage->dataBlock.rwindex	= 0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _ATCCmdMessage$[ebp]
	mov	WORD PTR [edx+64], cx

; 4031 : 		break;

	jmp	SHORT $LN26@SendCmdMes
$LN2@SendCmdMes:

; 4032 : 	case tTaxiBack:
; 4033 : 		ATCCmdMessage->dataBlock.type		= FalconATCCmdMessage::TaxiBack;

	mov	eax, DWORD PTR _ATCCmdMessage$[ebp]
	mov	DWORD PTR [eax+56], 15			; 0000000fH

; 4034 : 		info->lastContacted = SimLibElapsedTime;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [ecx+16], edx

; 4035 : 		break;

	jmp	SHORT $LN26@SendCmdMes
$LN1@SendCmdMes:

; 4036 : 	default:
; 4037 : 		//we shouldn't get here
; 4038 : 		ShiWarning("This ATCCmd message type doesn't exist");
; 4039 : 		delete ATCCmdMessage;

	mov	eax, DWORD PTR _ATCCmdMessage$[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	ecx, DWORD PTR $T4[ebp]
	mov	DWORD PTR $T7[ebp], ecx
	cmp	DWORD PTR $T7[ebp], 0
	je	SHORT $LN33@SendCmdMes
	push	1
	mov	edx, DWORD PTR $T7[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T7[ebp]
	mov	edx, DWORD PTR [eax]
	call	edx
	mov	DWORD PTR tv232[ebp], eax
	jmp	SHORT $LN34@SendCmdMes
$LN33@SendCmdMes:
	mov	DWORD PTR tv232[ebp], 0
$LN34@SendCmdMes:

; 4040 : 		return;

	jmp	SHORT $LN29@SendCmdMes
$LN26@SendCmdMes:

; 4041 : 		
; 4042 : 	}
; 4043 : 
; 4044 : 	FalconSendMessage(ATCCmdMessage, TRUE);

	push	1
	mov	eax, DWORD PTR _ATCCmdMessage$[ebp]
	push	eax
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN29@SendCmdMes:

; 4045 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN37@SendCmdMes:
	DD	$LN3@SendCmdMes
	DD	$LN1@SendCmdMes
	DD	$LN1@SendCmdMes
	DD	$LN25@SendCmdMes
	DD	$LN24@SendCmdMes
	DD	$LN23@SendCmdMes
	DD	$LN22@SendCmdMes
	DD	$LN21@SendCmdMes
	DD	$LN20@SendCmdMes
	DD	$LN19@SendCmdMes
	DD	$LN18@SendCmdMes
	DD	$LN17@SendCmdMes
	DD	$LN16@SendCmdMes
	DD	$LN15@SendCmdMes
	DD	$LN14@SendCmdMes
	DD	$LN13@SendCmdMes
	DD	$LN12@SendCmdMes
	DD	$LN11@SendCmdMes
	DD	$LN1@SendCmdMes
	DD	$LN1@SendCmdMes
	DD	$LN1@SendCmdMes
	DD	$LN10@SendCmdMes
	DD	$LN8@SendCmdMes
	DD	$LN9@SendCmdMes
	DD	$LN7@SendCmdMes
	DD	$LN6@SendCmdMes
	DD	$LN5@SendCmdMes
	DD	$LN4@SendCmdMes
	DD	$LN3@SendCmdMes
	DD	$LN2@SendCmdMes
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z$0:
	mov	eax, DWORD PTR $T6[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ENDP ; ATCBrain::SendCmdMessage
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Exec@ATCBrain@@QAEXXZ PROC				; ATCBrain::Exec
; _this$ = ecx

; 231  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 232  : /* 2002-04-08 MN fix for taxiing order:
; 233  : 	we had AI taking off at 09:37, us at 09:36, and AI waiting in front of us. Reversing
; 234  : 	ProcessPlayers and ProcessRunways fixes that.	*/
; 235  : 
; 236  : 	if (g_nATCTaxiOrderFix & 0x01)

	mov	eax, DWORD PTR ?g_nATCTaxiOrderFix@@3HA	; g_nATCTaxiOrderFix
	and	eax, 1
	je	SHORT $LN4@Exec

; 237  : 	{
; 238  : 		ProcessPlayers();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ProcessPlayers@ATCBrain@@AAEXXZ	; ATCBrain::ProcessPlayers

; 239  : 		ProcessRunways();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ProcessRunways@ATCBrain@@AAEXXZ	; ATCBrain::ProcessRunways

; 240  : 		ProcessInbound();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ProcessInbound@ATCBrain@@AAEXXZ	; ATCBrain::ProcessInbound
	jmp	SHORT $LN5@Exec
$LN4@Exec:

; 241  : 	}
; 242  : // to experiment...
; 243  : 	else if (g_nATCTaxiOrderFix & 0x02)

	mov	ecx, DWORD PTR ?g_nATCTaxiOrderFix@@3HA	; g_nATCTaxiOrderFix
	and	ecx, 2
	je	SHORT $LN2@Exec

; 244  : 	{
; 245  : 		ProcessInbound();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ProcessInbound@ATCBrain@@AAEXXZ	; ATCBrain::ProcessInbound

; 246  : 		ProcessPlayers();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ProcessPlayers@ATCBrain@@AAEXXZ	; ATCBrain::ProcessPlayers

; 247  : 		ProcessRunways();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ProcessRunways@ATCBrain@@AAEXXZ	; ATCBrain::ProcessRunways

; 248  : 	}
; 249  : 	else

	jmp	SHORT $LN5@Exec
$LN2@Exec:

; 250  : 	{
; 251  : 		ProcessRunways();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ProcessRunways@ATCBrain@@AAEXXZ	; ATCBrain::ProcessRunways

; 252  : 		ProcessPlayers();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ProcessPlayers@ATCBrain@@AAEXXZ	; ATCBrain::ProcessPlayers

; 253  : 		ProcessInbound();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ProcessInbound@ATCBrain@@AAEXXZ	; ATCBrain::ProcessInbound
$LN5@Exec:

; 254  : 	}
; 255  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Exec@ATCBrain@@QAEXXZ ENDP				; ATCBrain::Exec
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_i$ = -8						; size = 4
_this$ = -4						; size = 4
??1ATCBrain@@QAE@XZ PROC				; ATCBrain::~ATCBrain
; _this$ = ecx

; 200  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 201  : 	int i;
; 202  : 	
; 203  : 	for(i = 0; i < numRwys; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@ATCBrain
$LN6@ATCBrain:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@ATCBrain:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jge	SHORT $LN2@ATCBrain
$LN4@ATCBrain:

; 204  : 	{
; 205  : 		//cleanup runway queue
; 206  : 		while(runwayQueue[i])

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	je	SHORT $LN3@ATCBrain

; 207  : 		{
; 208  : 			RemoveTraffic( runwayQueue[i]->aircraftID, i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR [ecx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveTraffic@ATCBrain@@QAEXVVU_ID@@H@Z ; ATCBrain::RemoveTraffic

; 209  : 		}

	jmp	SHORT $LN4@ATCBrain
$LN3@ATCBrain:

; 210  : 	}

	jmp	SHORT $LN6@ATCBrain
$LN2@ATCBrain:

; 211  : 
; 212  : 	while(inboundQueue)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	je	SHORT $LN1@ATCBrain

; 213  : 	{
; 214  : 		RemoveInbound(inboundQueue);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveInbound@ATCBrain@@QAEXPAUrunwayQueueStruct@@@Z ; ATCBrain::RemoveInbound

; 215  : 	}

	jmp	SHORT $LN2@ATCBrain
$LN1@ATCBrain:

; 216  : 
; 217  : 	#ifdef USE_SH_POOLS
; 218  : 	MemFreePtr( runwayStats );
; 219  : 	MemFreePtr( runwayQueue );
; 220  : 	#else
; 221  : 	delete [] runwayStats;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 222  : 	delete [] runwayQueue;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 223  : 	#endif
; 224  : 	runwayStats = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 225  : 	runwayQueue = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 226  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1ATCBrain@@QAE@XZ ENDP				; ATCBrain::~ATCBrain
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
$T2 = -64						; size = 4
$T3 = -60						; size = 4
_tempcall$ = -56					; size = 4
_oc$ = -52						; size = 4
tv130 = -48						; size = 4
$T4 = -44						; size = 4
$T5 = -40						; size = 4
_shortest$ = -36					; size = 4
_count$ = -32						; size = 4
_ptindex$ = -28						; size = 4
_i$ = -24						; size = 4
_rwindex$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_mySelf$ = 8						; size = 4
??0ATCBrain@@QAE@PAVObjectiveClass@@@Z PROC		; ATCBrain::ATCBrain
; _this$ = ecx

; 65   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0ATCBrain@@QAE@PAVObjectiveClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 66   : 	int i, rwindex, count, shortest, ptindex;
; 67   : 	ObjClassDataType	*oc;
; 68   : 	
; 69   : 	self = mySelf;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _mySelf$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 70   : 
; 71   : 	oc = mySelf->GetObjectiveClassData();

	mov	ecx, DWORD PTR _mySelf$[ebp]
	call	?GetObjectiveClassData@ObjectiveClass@@QAEPAUObjClassDataType@@XZ ; ObjectiveClass::GetObjectiveClassData
	mov	DWORD PTR _oc$[ebp], eax

; 72   : 	numRwys = oc->DataRate;

	mov	edx, DWORD PTR _oc$[ebp]
	movsx	eax, WORD PTR [edx+22]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 73   : 	//DSP HACK
; 74   : 	if(numRwys > 4)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], 4
	jle	SHORT $LN18@ATCBrain

; 75   : 		numRwys = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 1
$LN18@ATCBrain:

; 76   : 	minDeagTime = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 77   : 	shortest = 100;

	mov	DWORD PTR _shortest$[ebp], 100		; 00000064H

; 78   : 	count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 79   : 
; 80   : 	// RAS - 16Jan04 - Traffic check Variables
; 81   : 	checkTrafficTime = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], 0

; 82   : 	lastTrafficCallTime = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32], 0

; 83   : 	pLastTraffic = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+36], 0

; 84   : 	trafficCheck = noTraffic;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+52], 0

; 85   : 	trafficRange = 0;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+40], xmm0

; 86   : 	oldTrafficRange = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [ecx+44], xmm0

; 87   : 	trafficAltitude = 0;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+48], xmm0

; 88   : 	trafficInSightFlag = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+56], 0

; 89   : 	
; 90   : 
; 91   : 	#ifdef USE_SH_POOLS
; 92   : 	runwayStats = (runwayStatsStruct *)MemAllocPtr( runwayQueueStruct::pool,  sizeof(runwayStatsStruct)*(numRwys), 0);
; 93   : 	runwayQueue = (runwayQueueStruct **)MemAllocPtr( runwayQueueStruct::pool,  sizeof(runwayQueueStruct *)*(numRwys), 0);
; 94   : 	#else
; 95   : 	runwayStats = new runwayStatsStruct[numRwys];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T4[ebp], edx
	xor	ecx, ecx
	mov	eax, DWORD PTR $T4[ebp]
	mov	edx, 40					; 00000028H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN21@ATCBrain
	push	OFFSET ??0runwayStatsStruct@@QAE@XZ
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	push	40					; 00000028H
	mov	ecx, DWORD PTR $T5[ebp]
	push	ecx
	call	??_H@YGXPAXIHP6EPAX0@Z@Z
	mov	edx, DWORD PTR $T5[ebp]
	mov	DWORD PTR tv130[ebp], edx
	jmp	SHORT $LN22@ATCBrain
$LN21@ATCBrain:
	mov	DWORD PTR tv130[ebp], 0
$LN22@ATCBrain:
	mov	eax, DWORD PTR tv130[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR [ecx+16], edx

; 96   : 	runwayQueue = new runwayQueueStruct *[numRwys];

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [eax+20], ecx

; 97   : 	#endif
; 98   : 	
; 99   : 	for(i = 0; i < numRwys; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN17@ATCBrain
$LN16@ATCBrain:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN17@ATCBrain:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jge	$LN15@ATCBrain

; 100  : 	{
; 101  : 		runwayStats[i].rwIndexes[0] = 0;

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+16]
	mov	ecx, 4
	imul	ecx, 0
	mov	DWORD PTR [edx+ecx], 0

; 102  : 		runwayStats[i].rwIndexes[1] = 0;

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+16]
	mov	ecx, 4
	shl	ecx, 0
	mov	DWORD PTR [edx+ecx], 0

; 103  : 		runwayStats[i].nextEmergency = FalconNullId;

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [ecx+edx+32], eax
	mov	eax, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [ecx+edx+36], eax

; 104  : 		runwayQueue[i] = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR [edx+eax*4], 0

; 105  : 		runwayStats[i].numInQueue = 0;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	cx, WORD PTR [eax+ecx+24]
	and	cx, 7
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	mov	WORD PTR [eax+edx+24], cx

; 106  : 		runwayStats[i].state = VIS_NORMAL;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	edx, 65528				; 0000fff8H
	and	dx, WORD PTR [eax+ecx+24]
	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+16]
	mov	WORD PTR [ecx+eax+24], dx

; 107  : 	}

	jmp	$LN16@ATCBrain
$LN15@ATCBrain:

; 108  : 	
; 109  : 	rwindex = oc->PtDataIndex;

	mov	edx, DWORD PTR _oc$[ebp]
	movsx	eax, WORD PTR [edx+26]
	mov	DWORD PTR _rwindex$[ebp], eax
$LN14@ATCBrain:

; 110  : 	while(rwindex)

	cmp	DWORD PTR _rwindex$[ebp], 0
	je	$LN13@ATCBrain

; 111  : 	{
; 112  : 		if(GetQueue(rwindex) < numRwys)

	mov	ecx, DWORD PTR _rwindex$[ebp]
	push	ecx
	call	?GetQueue@@YAHH@Z			; GetQueue
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jge	$LN5@ATCBrain

; 113  : 		{
; 114  : 			if (PtHeaderDataTable[rwindex].type == RunwayPt)

	mov	eax, DWORD PTR _rwindex$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movzx	edx, BYTE PTR [ecx+eax+2]
	cmp	edx, 1
	jne	$LN6@ATCBrain

; 115  : 			{
; 116  : 				if(runwayStats[GetQueue(rwindex)].rwIndexes[0])

	mov	eax, DWORD PTR _rwindex$[ebp]
	push	eax
	call	?GetQueue@@YAHH@Z			; GetQueue
	add	esp, 4
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	mov	edx, 4
	imul	edx, 0
	cmp	DWORD PTR [eax+edx], 0
	je	SHORT $LN10@ATCBrain

; 117  : 				{
; 118  : 					ShiAssert (rwindex >= 0);
; 119  : 					runwayStats[GetQueue(rwindex)].rwIndexes[1] = rwindex;

	mov	eax, DWORD PTR _rwindex$[ebp]
	push	eax
	call	?GetQueue@@YAHH@Z			; GetQueue
	add	esp, 4
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	mov	edx, 4
	shl	edx, 0
	mov	ecx, DWORD PTR _rwindex$[ebp]
	mov	DWORD PTR [eax+edx], ecx

; 120  : 				}
; 121  : 				else

	jmp	SHORT $LN9@ATCBrain
$LN10@ATCBrain:

; 122  : 				{
; 123  : 					ShiAssert (rwindex >= 0);
; 124  : 					runwayStats[GetQueue(rwindex)].rwIndexes[0] = rwindex;

	mov	edx, DWORD PTR _rwindex$[ebp]
	push	edx
	call	?GetQueue@@YAHH@Z			; GetQueue
	add	esp, 4
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	mov	edx, 4
	imul	edx, 0
	mov	ecx, DWORD PTR _rwindex$[ebp]
	mov	DWORD PTR [eax+edx], ecx
$LN9@ATCBrain:

; 125  : 				}
; 126  : 
; 127  : 				count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 128  : 				ptindex = PtHeaderDataTable[rwindex].first;

	mov	edx, DWORD PTR _rwindex$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	ecx, WORD PTR [eax+edx+20]
	mov	DWORD PTR _ptindex$[ebp], ecx

; 129  : 				ptindex = GetNextTaxiPt(ptindex);

	mov	edx, DWORD PTR _ptindex$[ebp]
	push	edx
	call	?GetNextTaxiPt@@YAHH@Z			; GetNextTaxiPt
	add	esp, 4
	mov	DWORD PTR _ptindex$[ebp], eax
$LN8@ATCBrain:

; 130  : 				while(ptindex)

	cmp	DWORD PTR _ptindex$[ebp], 0
	je	SHORT $LN7@ATCBrain

; 131  : 				{
; 132  : 					ptindex = GetNextTaxiPt(ptindex);

	mov	eax, DWORD PTR _ptindex$[ebp]
	push	eax
	call	?GetNextTaxiPt@@YAHH@Z			; GetNextTaxiPt
	add	esp, 4
	mov	DWORD PTR _ptindex$[ebp], eax

; 133  : 					count++;

	mov	ecx, DWORD PTR _count$[ebp]
	add	ecx, 1
	mov	DWORD PTR _count$[ebp], ecx

; 134  : 				}

	jmp	SHORT $LN8@ATCBrain
$LN7@ATCBrain:

; 135  : 				if(count < shortest)	// FRB - shortest, longest or mean - could effect time to start taxiing (minDeagTime)????

	mov	edx, DWORD PTR _count$[ebp]
	cmp	edx, DWORD PTR _shortest$[ebp]
	jge	SHORT $LN6@ATCBrain

; 136  : 					shortest = count;

	mov	eax, DWORD PTR _count$[ebp]
	mov	DWORD PTR _shortest$[ebp], eax
$LN6@ATCBrain:

; 137  : #if 0 // JPO - I don't see why its rewriting all these. I think this is what screws up Osan.
; 138  : 				float x1, y1, x2, y2, dx, dy, norm;
; 139  : 				ptindex = PtHeaderDataTable[rwindex].first;
; 140  : 				TranslatePointData(self, ptindex, &x1, &y1);
; 141  : 				ptindex = GetNextPt(ptindex);
; 142  : 				TranslatePointData(self, ptindex, &x2, &y2);
; 143  : 
; 144  : 				dx = x1 - x2;
; 145  : 				dy = y1 - y2;
; 146  : 				norm = 1.0F/(float)sqrt(dx*dx + dy*dy);
; 147  : 				dx *= norm;
; 148  : 				dy *= norm;
; 149  : 
; 150  : 				PtHeaderDataTable[rwindex].cosHeading = dx;
; 151  : 				PtHeaderDataTable[rwindex].sinHeading = dy;
; 152  : 				float hdg = (float)atan2(dy,dx)*RTD/10.0F;
; 153  : 
; 154  : 				if(hdg < 0.0F)
; 155  : 					hdg += 36.0F;
; 156  : 
; 157  : 				int iHdg = FloatToInt32(hdg + 0.5F);
; 158  : 
; 159  : 				PtHeaderDataTable[rwindex].data = (short)(iHdg*10);
; 160  : 				PtHeaderDataTable[rwindex].texIdx = GetTextureIdFromHdg(iHdg, PtHeaderDataTable[rwindex].ltrt);
; 161  : #endif
; 162  : 			}
; 163  : 
; 164  : 			if (PtHeaderDataTable[rwindex].type == RunwayDimPt)

	mov	ecx, DWORD PTR _rwindex$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movzx	eax, BYTE PTR [edx+ecx+2]
	cmp	eax, 8
	jne	SHORT $LN5@ATCBrain

; 165  : 			{
; 166  : 				CalcRunwayDimensions(rwindex);

	mov	ecx, DWORD PTR _rwindex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcRunwayDimensions@ATCBrain@@AAEXH@Z	; ATCBrain::CalcRunwayDimensions
$LN5@ATCBrain:

; 167  : 			}
; 168  : 		}
; 169  : 		rwindex = PtHeaderDataTable[rwindex].nextHeader;

	mov	edx, DWORD PTR _rwindex$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	ecx, WORD PTR [eax+edx+26]
	mov	DWORD PTR _rwindex$[ebp], ecx

; 170  : 	}

	jmp	$LN14@ATCBrain
$LN13@ATCBrain:

; 171  : 	if(shortest > 1)

	cmp	DWORD PTR _shortest$[ebp], 1
	jle	SHORT $LN4@ATCBrain

; 172  : 		minDeagTime = (shortest - 1) * 15 *CampaignSeconds + 1;	 // FRB - checkpoint

	mov	edx, DWORD PTR _shortest$[ebp]
	sub	edx, 1
	imul	edx, 15					; 0000000fH
	imul	edx, 1000				; 000003e8H
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 173  : 	else

	jmp	SHORT $LN3@ATCBrain
$LN4@ATCBrain:

; 174  : 		minDeagTime = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
$LN3@ATCBrain:

; 175  : 
; 176  : 	inboundQueue = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24], 0

; 177  : 
; 178  : 	int tempcall = callsign;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR _tempcall$[ebp], ecx

; 179  : 	//this will work for now
; 180  : 	if(!gTacanList->GetCallsignFromCampID(self->GetCampId(), &tempcall))

	lea	edx, DWORD PTR _tempcall$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetCampId@CampBaseClass@@QBEFXZ	; CampBaseClass::GetCampId
	movzx	ecx, ax
	push	ecx
	mov	ecx, DWORD PTR ?gTacanList@@3PAVTacanList@@A ; gTacanList
	call	?GetCallsignFromCampID@TacanList@@QAEHFPAH@Z ; TacanList::GetCallsignFromCampID
	test	eax, eax
	jne	SHORT $LN2@ATCBrain

; 181  : 	{
; 182  : 		callsign = 0;

	xor	edx, edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+2], dx

; 183  : #ifdef DAVE_DBG
; 184  : 		if(self->GetType() == TYPE_AIRBASE)
; 185  : 			ShiAssert(!"We have an airbase that is not listed in the tacan data file");
; 186  : #endif
; 187  : 	}
; 188  : 
; 189  : 	else

	jmp	SHORT $LN1@ATCBrain
$LN2@ATCBrain:

; 190  : 		callsign = tempcall;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR _tempcall$[ebp]
	mov	WORD PTR [ecx+2], dx
$LN1@ATCBrain:

; 191  : 
; 192  : 	voice = g_voicemap.PickVoice(VoiceMapper::VOICE_ATC, self->GetCountry()); // (uchar)(12 + rand()%2);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [eax+120]
	call	edx
	movzx	eax, al
	push	eax
	push	2
	mov	ecx, OFFSET ?g_voicemap@@3VVoiceMapper@@A ; g_voicemap
	call	?PickVoice@VoiceMapper@@QAEHHH@Z	; VoiceMapper::PickVoice
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx], al

; 193  : 	F4Assert (numRwys > 0);
; 194  : 	
; 195  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0ATCBrain@@QAE@PAVObjectiveClass@@@Z$0:
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__ehhandler$??0ATCBrain@@QAE@PAVObjectiveClass@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0ATCBrain@@QAE@PAVObjectiveClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0ATCBrain@@QAE@PAVObjectiveClass@@@Z ENDP		; ATCBrain::ATCBrain
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_list$ = 8						; size = 4
?CheckList@ATCBrain@@AAEXPAUrunwayQueueStruct@@@Z PROC	; ATCBrain::CheckList
; _this$ = ecx

; 5025 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5026 : //it seems to be ok, so I'm going to stop this for now.
; 5027 : #if 0
; 5028 : 	runwayQueueStruct *prev = NULL;
; 5029 : 	runwayQueueStruct *cirCheck = NULL;
; 5030 : 	int count;
; 5031 : 
; 5032 : #ifdef DEBUG
; 5033 : /*	if(GetCurrentThreadId() != gSimThreadID)
; 5034 : 	{
; 5035 : 		ShiAssert(!"Tell Dave Power you hit the ATC assert (x4373) Don't ignore this!");
; 5036 : 		ShiAssert(!"Tell Dave Power you hit the ATC assert (x4373) Don't ignore this!");
; 5037 : 		//*((unsigned int *) 0x00) = 0; //told you not to ignore it
; 5038 : 	}*/
; 5039 : 
; 5040 : 	while(list)
; 5041 : 	{
; 5042 : #ifdef TEST_HACK_THAT_LEAKS
; 5043 : 		if (list->deleteLine)
; 5044 : #else
; 5045 : 		if((int)list->next == 0xdddddddd)
; 5046 : #endif
; 5047 : 		{
; 5048 : 			ShiAssert(!"Tell Dave Power you hit the ATC assert (x4373)");
; 5049 : 			ShiAssert(!"Tell Dave Power you hit the ATC assert (x4373) Don't ignore this!");
; 5050 : 			ShiAssert(!"Tell Dave Power you hit the ATC assert (x4373) Don't ignore this!");
; 5051 : 			//*((unsigned int *) 0x00) = 0; //told you not to ignore it
; 5052 : 			if(prev)
; 5053 : 				prev->next = NULL;
; 5054 : 		}
; 5055 : 		count = 1;
; 5056 : 		cirCheck = list;
; 5057 : 		while(cirCheck && count)
; 5058 : 		{
; 5059 : 			ShiAssert(cirCheck->next != list);
; 5060 : 			if(cirCheck->next == list)
; 5061 : 				cirCheck->next = NULL;
; 5062 : 			cirCheck = cirCheck->next;
; 5063 : 			count = count++ % 100;
; 5064 : 		}
; 5065 : 		prev = list;
; 5066 : 		list = list->next;
; 5067 : 	}
; 5068 : #else
; 5069 : 	//big time DSP hack
; 5070 : 	while(list)
; 5071 : 	{
; 5072 : #ifdef TEST_HACK_THAT_LEAKS
; 5073 : 		if (list->deleteLine)
; 5074 : #else
; 5075 : 		if((int)list->next == 0xdddddddd)
; 5076 : #endif
; 5077 : 		{
; 5078 : 			//for now i'll just fix it
; 5079 : 			if(prev)
; 5080 : 				prev->next = NULL;
; 5081 : 		}
; 5082 : 
; 5083 : 		count = 1;
; 5084 : 		cirCheck = list;
; 5085 : 		while(cirCheck && count)
; 5086 : 		{
; 5087 : 			//for now i'll just fix it
; 5088 : 			if(cirCheck->next == list)
; 5089 : 				cirCheck->next = NULL;
; 5090 : 
; 5091 : 			cirCheck = cirCheck->next;
; 5092 : 			count = count++ % 100;
; 5093 : 		}
; 5094 : 		prev = list;
; 5095 : 		list = list->next;
; 5096 : 	}
; 5097 : #endif
; 5098 : #else
; 5099 : 	list;
; 5100 : #endif
; 5101 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?CheckList@ATCBrain@@AAEXPAUrunwayQueueStruct@@@Z ENDP	; ATCBrain::CheckList
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
tv232 = -44						; size = 4
tv221 = -40						; size = 4
_y3$ = -36						; size = 4
_y1$ = -32						; size = 4
_x3$ = -28						; size = 4
_x1$ = -24						; size = 4
_queue$ = -20						; size = 4
_y2$ = -16						; size = 4
_x2$ = -12						; size = 4
_this$ = -8						; size = 4
_point$ = -4						; size = 4
_index$ = 8						; size = 4
?CalcRunwayDimensions@ATCBrain@@AAEXH@Z PROC		; ATCBrain::CalcRunwayDimensions
; _this$ = ecx

; 2407 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 2408 : 	int point;
; 2409 : 	int queue = PtHeaderDataTable[index].runwayNum;

	mov	eax, DWORD PTR _index$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	edx, BYTE PTR [ecx+eax+24]
	mov	DWORD PTR _queue$[ebp], edx

; 2410 : 	float x1, y1, x2, y2, x3, y3;
; 2411 : 
; 2412 : 	point = PtHeaderDataTable[index].first;

	mov	eax, DWORD PTR _index$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	edx, WORD PTR [ecx+eax+20]
	mov	DWORD PTR _point$[ebp], edx

; 2413 : 	TranslatePointData (self, point, &x1, &y1);

	lea	eax, DWORD PTR _y1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _point$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData
	add	esp, 16					; 00000010H

; 2414 : 
; 2415 : 	point = GetNextPtLoop(point);

	mov	edx, DWORD PTR _point$[ebp]
	push	edx
	call	?GetNextPtLoop@@YAHH@Z			; GetNextPtLoop
	add	esp, 4
	mov	DWORD PTR _point$[ebp], eax

; 2416 : 	TranslatePointData (self, point, &x2, &y2);

	lea	eax, DWORD PTR _y2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _point$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData
	add	esp, 16					; 00000010H

; 2417 : 
; 2418 : 	point = GetNextPtLoop(point);

	mov	edx, DWORD PTR _point$[ebp]
	push	edx
	call	?GetNextPtLoop@@YAHH@Z			; GetNextPtLoop
	add	esp, 4
	mov	DWORD PTR _point$[ebp], eax

; 2419 : 	TranslatePointData (self, point, &x3, &y3);

	lea	eax, DWORD PTR _y3$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x3$[ebp]
	push	ecx
	mov	edx, DWORD PTR _point$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData
	add	esp, 16					; 00000010H

; 2420 : 
; 2421 : 	runwayStats[queue].halfwidth = (float)sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2))*0.5F;

	movss	xmm0, DWORD PTR _x1$[ebp]
	subss	xmm0, DWORD PTR _x2$[ebp]
	movss	xmm1, DWORD PTR _x1$[ebp]
	subss	xmm1, DWORD PTR _x2$[ebp]
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR _y1$[ebp]
	subss	xmm1, DWORD PTR _y2$[ebp]
	movss	xmm2, DWORD PTR _y1$[ebp]
	subss	xmm2, DWORD PTR _y2$[ebp]
	mulss	xmm1, xmm2
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv221[ebp]
	movss	xmm0, DWORD PTR tv221[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	edx, DWORD PTR _queue$[ebp]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	movss	DWORD PTR [ecx+edx+8], xmm0

; 2422 : 	runwayStats[queue].halfheight = (float)sqrt((x2 - x3) * (x2 - x3) + (y2 - y3) * (y2 - y3))*0.5F;

	movss	xmm0, DWORD PTR _x2$[ebp]
	subss	xmm0, DWORD PTR _x3$[ebp]
	movss	xmm1, DWORD PTR _x2$[ebp]
	subss	xmm1, DWORD PTR _x3$[ebp]
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR _y2$[ebp]
	subss	xmm1, DWORD PTR _y3$[ebp]
	movss	xmm2, DWORD PTR _y2$[ebp]
	subss	xmm2, DWORD PTR _y3$[ebp]
	mulss	xmm1, xmm2
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR tv232[ebp]
	movss	xmm0, DWORD PTR tv232[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	edx, DWORD PTR _queue$[ebp]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	movss	DWORD PTR [ecx+edx+12], xmm0

; 2423 : 	runwayStats[queue].centerX = (x1 + x3)*0.5F;

	movss	xmm0, DWORD PTR _x1$[ebp]
	addss	xmm0, DWORD PTR _x3$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	edx, DWORD PTR _queue$[ebp]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	movss	DWORD PTR [ecx+edx+16], xmm0

; 2424 : 	runwayStats[queue].centerY = (y1 + y3)*0.5F;

	movss	xmm0, DWORD PTR _y1$[ebp]
	addss	xmm0, DWORD PTR _y3$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	edx, DWORD PTR _queue$[ebp]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	movss	DWORD PTR [ecx+edx+20], xmm0

; 2425 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?CalcRunwayDimensions@ATCBrain@@AAEXH@Z ENDP		; ATCBrain::CalcRunwayDimensions
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
$T1 = -20						; size = 8
_aircraft$ = -12					; size = 4
_this$ = -8						; size = 4
_temp$ = -4						; size = 4
_queue$ = 8						; size = 4
?NextToLand@ATCBrain@@AAEPAUrunwayQueueStruct@@H@Z PROC	; ATCBrain::NextToLand
; _this$ = ecx

; 2975 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 2976 : 	runwayQueueStruct *temp = NULL;

	mov	DWORD PTR _temp$[ebp], 0

; 2977 : 	AircraftClass *aircraft = (AircraftClass*)vuDatabase->Find(runwayStats[queue].nextEmergency);

	mov	eax, DWORD PTR _queue$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR [edx+eax+36]
	push	ecx
	mov	edx, DWORD PTR [edx+eax+32]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _aircraft$[ebp], eax

; 2978 : 
; 2979 : 	if(aircraft)

	cmp	DWORD PTR _aircraft$[ebp], 0
	je	SHORT $LN5@NextToLand

; 2980 : 	{	
; 2981 : 		temp = InList(aircraft->Id());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InList@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@@Z ; ATCBrain::InList
	mov	DWORD PTR _temp$[ebp], eax

; 2982 : 		if(temp)

	cmp	DWORD PTR _temp$[ebp], 0
	je	SHORT $LN5@NextToLand

; 2983 : 			return temp;

	mov	eax, DWORD PTR _temp$[ebp]
	jmp	SHORT $LN6@NextToLand
$LN5@NextToLand:

; 2984 : 	}
; 2985 : 
; 2986 : 	temp = runwayQueue[queue];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _queue$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _temp$[ebp], eax
$LN3@NextToLand:

; 2987 : 	
; 2988 : 	while(temp)

	cmp	DWORD PTR _temp$[ebp], 0
	je	SHORT $LN2@NextToLand

; 2989 : 	{
; 2990 : 		if(temp->status >= lReqClearance && temp->status < lLanded )

	mov	ecx, DWORD PTR _temp$[ebp]
	cmp	DWORD PTR [ecx+8], 1
	jl	SHORT $LN1@NextToLand
	mov	edx, DWORD PTR _temp$[ebp]
	cmp	DWORD PTR [edx+8], 13			; 0000000dH
	jge	SHORT $LN1@NextToLand

; 2991 : 		{
; 2992 : 			return temp;

	mov	eax, DWORD PTR _temp$[ebp]
	jmp	SHORT $LN6@NextToLand
$LN1@NextToLand:

; 2993 : 		}
; 2994 : 		temp = temp->next;

	mov	eax, DWORD PTR _temp$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _temp$[ebp], ecx

; 2995 : 	}

	jmp	SHORT $LN3@NextToLand
$LN2@NextToLand:

; 2996 : 	return NULL;

	xor	eax, eax
$LN6@NextToLand:

; 2997 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?NextToLand@ATCBrain@@AAEPAUrunwayQueueStruct@@H@Z ENDP	; ATCBrain::NextToLand
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_this$ = -20						; size = 4
_taxi$ = -16						; size = 4
_wait$ = -12						; size = 4
_holdshort$ = -8					; size = 4
_temp$ = -4						; size = 4
_queue$ = 8						; size = 4
?NextToTakeoff@ATCBrain@@AAEPAUrunwayQueueStruct@@H@Z PROC ; ATCBrain::NextToTakeoff
; _this$ = ecx

; 2935 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 2936 : 	runwayQueueStruct *temp = runwayQueue[queue];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _queue$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _temp$[ebp], eax

; 2937 : 	runwayQueueStruct *holdshort = NULL;

	mov	DWORD PTR _holdshort$[ebp], 0

; 2938 : 	runwayQueueStruct *taxi = NULL;

	mov	DWORD PTR _taxi$[ebp], 0

; 2939 : 	runwayQueueStruct *wait = NULL;

	mov	DWORD PTR _wait$[ebp], 0
$LN15@NextToTake:

; 2940 : 	
; 2941 : 	while(temp)

	cmp	DWORD PTR _temp$[ebp], 0
	je	$LN14@NextToTake

; 2942 : 	{
; 2943 : 		if(temp->status == noATC && !holdshort && !taxi && !wait)

	mov	ecx, DWORD PTR _temp$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	jne	SHORT $LN13@NextToTake
	cmp	DWORD PTR _holdshort$[ebp], 0
	jne	SHORT $LN13@NextToTake
	cmp	DWORD PTR _taxi$[ebp], 0
	jne	SHORT $LN13@NextToTake
	cmp	DWORD PTR _wait$[ebp], 0
	jne	SHORT $LN13@NextToTake

; 2944 : 		{
; 2945 : 			return temp;

	mov	eax, DWORD PTR _temp$[ebp]
	jmp	$LN16@NextToTake
	jmp	SHORT $LN12@NextToTake
$LN13@NextToTake:

; 2946 : 		}
; 2947 : 		else if(temp->status >= tPrepToTakeRunway && temp->status <= tTakeoff )

	mov	edx, DWORD PTR _temp$[ebp]
	cmp	DWORD PTR [edx+8], 25			; 00000019H
	jl	SHORT $LN11@NextToTake
	mov	eax, DWORD PTR _temp$[ebp]
	cmp	DWORD PTR [eax+8], 27			; 0000001bH
	jg	SHORT $LN11@NextToTake

; 2948 : 		{
; 2949 : 			return temp;

	mov	eax, DWORD PTR _temp$[ebp]
	jmp	SHORT $LN16@NextToTake
	jmp	SHORT $LN12@NextToTake
$LN11@NextToTake:

; 2950 : 		}
; 2951 : 		else if(!holdshort && temp->status == tHoldShort)

	cmp	DWORD PTR _holdshort$[ebp], 0
	jne	SHORT $LN9@NextToTake
	mov	ecx, DWORD PTR _temp$[ebp]
	cmp	DWORD PTR [ecx+8], 24			; 00000018H
	jne	SHORT $LN9@NextToTake

; 2952 : 		{
; 2953 : 			holdshort = temp;

	mov	edx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR _holdshort$[ebp], edx
	jmp	SHORT $LN12@NextToTake
$LN9@NextToTake:

; 2954 : 		}
; 2955 : 		else if(!wait && temp->status == tWait)

	cmp	DWORD PTR _wait$[ebp], 0
	jne	SHORT $LN7@NextToTake
	mov	eax, DWORD PTR _temp$[ebp]
	cmp	DWORD PTR [eax+8], 23			; 00000017H
	jne	SHORT $LN7@NextToTake

; 2956 : 		{
; 2957 : 			wait = temp;

	mov	ecx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR _wait$[ebp], ecx
	jmp	SHORT $LN12@NextToTake
$LN7@NextToTake:

; 2958 : 		}
; 2959 : 		else if(!taxi && temp->status >= tTaxi && temp->status < tHoldShort)

	cmp	DWORD PTR _taxi$[ebp], 0
	jne	SHORT $LN12@NextToTake
	mov	edx, DWORD PTR _temp$[ebp]
	cmp	DWORD PTR [edx+8], 22			; 00000016H
	jl	SHORT $LN12@NextToTake
	mov	eax, DWORD PTR _temp$[ebp]
	cmp	DWORD PTR [eax+8], 24			; 00000018H
	jge	SHORT $LN12@NextToTake

; 2960 : 		{
; 2961 : 			taxi = temp;

	mov	ecx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR _taxi$[ebp], ecx
$LN12@NextToTake:

; 2962 : 		}
; 2963 : 		temp = temp->next;

	mov	edx, DWORD PTR _temp$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _temp$[ebp], eax

; 2964 : 	}

	jmp	$LN15@NextToTake
$LN14@NextToTake:

; 2965 : 
; 2966 : 	if(holdshort)

	cmp	DWORD PTR _holdshort$[ebp], 0
	je	SHORT $LN4@NextToTake

; 2967 : 		return holdshort;

	mov	eax, DWORD PTR _holdshort$[ebp]
	jmp	SHORT $LN16@NextToTake
	jmp	SHORT $LN16@NextToTake
$LN4@NextToTake:

; 2968 : 	else if(wait)

	cmp	DWORD PTR _wait$[ebp], 0
	je	SHORT $LN2@NextToTake

; 2969 : 		return wait;

	mov	eax, DWORD PTR _wait$[ebp]
	jmp	SHORT $LN16@NextToTake

; 2970 : 	else

	jmp	SHORT $LN16@NextToTake
$LN2@NextToTake:

; 2971 : 		return taxi;

	mov	eax, DWORD PTR _taxi$[ebp]
$LN16@NextToTake:

; 2972 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?NextToTakeoff@ATCBrain@@AAEPAUrunwayQueueStruct@@H@Z ENDP ; ATCBrain::NextToTakeoff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
tv147 = -20						; size = 4
_this$ = -16						; size = 4
_radioMessage$ = -12					; size = 4
_info$ = -8						; size = 4
_aircraft$ = -4						; size = 4
_queue$ = 8						; size = 4
_flight$ = 12						; size = 4
_status$ = 16						; size = 4
?ReorderFlight@ATCBrain@@AAEXHPAVFlightClass@@W4AtcStatusEnum@@@Z PROC ; ATCBrain::ReorderFlight
; _this$ = ecx

; 2098 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 2099 : 	AircraftClass		*aircraft = NULL;

	mov	DWORD PTR _aircraft$[ebp], 0

; 2100 : 	runwayQueueStruct	*info = NULL;

	mov	DWORD PTR _info$[ebp], 0

; 2101 : 	FalconRadioChatterMessage	*radioMessage = NULL;

	mov	DWORD PTR _radioMessage$[ebp], 0

; 2102 : 
; 2103 : 	info = runwayQueue[queue];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _queue$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _info$[ebp], eax
$LN4@ReorderFli:

; 2104 : 
; 2105 : 	while(info)

	cmp	DWORD PTR _info$[ebp], 0
	je	$LN5@ReorderFli

; 2106 : 	{
; 2107 : 		aircraft = (AircraftClass*)vuDatabase->Find(info->aircraftID);

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR [ecx]
	push	eax
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _aircraft$[ebp], eax

; 2108 : 		
; 2109 : 		if(aircraft && aircraft->GetCampaignObject() == flight && aircraft->OnGround())

	cmp	DWORD PTR _aircraft$[ebp], 0
	je	$LN2@ReorderFli
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	cmp	eax, DWORD PTR _flight$[ebp]
	jne	$LN2@ReorderFli
	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	$LN2@ReorderFli

; 2110 : 		{
; 2111 : 			info->status = status;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 2112 : 			if(status == tHoldShort)

	cmp	DWORD PTR _status$[ebp], 24		; 00000018H
	jne	SHORT $LN1@ReorderFli

; 2113 : 			{
; 2114 : 				status = tTaxi;

	mov	DWORD PTR _status$[ebp], 22		; 00000016H

; 2115 : 				radioMessage = CreateCallFromATC (self, aircraft, rcHOLDSHORT, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@ReorderFli
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv147[ebp], eax
	jmp	SHORT $LN8@ReorderFli
$LN7@ReorderFli:
	mov	DWORD PTR tv147[ebp], 0
$LN8@ReorderFli:
	mov	ecx, DWORD PTR tv147[ebp]
	push	ecx
	push	95					; 0000005fH
	mov	edx, DWORD PTR _aircraft$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$[ebp], eax

; 2116 : 				radioMessage->dataBlock.edata[3] = 0;

	mov	edx, 2
	imul	edx, 3
	xor	eax, eax
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [ecx+edx+64], ax

; 2117 : 				FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	edx, DWORD PTR _radioMessage$[ebp]
	push	edx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN1@ReorderFli:

; 2118 : 			}
; 2119 : 			SendCmdMessage(aircraft, info);

	mov	eax, DWORD PTR _info$[ebp]
	push	eax
	mov	ecx, DWORD PTR _aircraft$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage
$LN2@ReorderFli:

; 2120 : 		}
; 2121 : 		info = info->next;

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _info$[ebp], eax

; 2122 : 	}

	jmp	$LN4@ReorderFli
$LN5@ReorderFli:

; 2123 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?ReorderFlight@ATCBrain@@AAEXHPAVFlightClass@@W4AtcStatusEnum@@@Z ENDP ; ATCBrain::ReorderFlight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_flightIter$ = -56					; size = 12
$T2 = -44						; size = 8
_deleteInfo$ = -36					; size = 4
_takeoffTime$ = -32					; size = 4
_rwindex$ = -28						; size = 4
_this$ = -24						; size = 4
_info$ = -20						; size = 4
_aircraft$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_queue$ = 8						; size = 4
_flight$ = 12						; size = 4
?RescheduleFlightTakeoff@ATCBrain@@AAEXHPAVFlightClass@@@Z PROC ; ATCBrain::RescheduleFlightTakeoff
; _this$ = ecx

; 2034 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?RescheduleFlightTakeoff@ATCBrain@@AAEXHPAVFlightClass@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2035 : 	AircraftClass		*aircraft = NULL;

	mov	DWORD PTR _aircraft$[ebp], 0

; 2036 : 	runwayQueueStruct	*info = NULL;

	mov	DWORD PTR _info$[ebp], 0

; 2037 : 	runwayQueueStruct	*deleteInfo = NULL;

	mov	DWORD PTR _deleteInfo$[ebp], 0

; 2038 : 	int rwindex=0;

	mov	DWORD PTR _rwindex$[ebp], 0

; 2039 : 
; 2040 : 	deleteInfo = info = runwayQueue[queue];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _queue$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _info$[ebp], eax
	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR _deleteInfo$[ebp], ecx
$LN13@Reschedule:

; 2041 : 
; 2042 : 	while(info)

	cmp	DWORD PTR _info$[ebp], 0
	je	SHORT $LN12@Reschedule

; 2043 : 	{
; 2044 : 		aircraft = (AircraftClass*)vuDatabase->Find(info->aircraftID);

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR [edx]
	push	ecx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _aircraft$[ebp], eax

; 2045 : 		info = info->next;

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _info$[ebp], eax

; 2046 : 		if(aircraft && aircraft->GetCampaignObject() == flight && aircraft->OnGround())

	cmp	DWORD PTR _aircraft$[ebp], 0
	je	SHORT $LN11@Reschedule
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	cmp	eax, DWORD PTR _flight$[ebp]
	jne	SHORT $LN11@Reschedule
	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	SHORT $LN11@Reschedule

; 2047 : 		{
; 2048 : 			rwindex = info->rwindex;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _rwindex$[ebp], edx

; 2049 : 			RemoveTraffic(deleteInfo->aircraftID, queue);

	mov	eax, DWORD PTR _queue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _deleteInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR [ecx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveTraffic@ATCBrain@@QAEXVVU_ID@@H@Z ; ATCBrain::RemoveTraffic
$LN11@Reschedule:

; 2050 : 		}
; 2051 : 		deleteInfo = info;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR _deleteInfo$[ebp], ecx

; 2052 : 	}

	jmp	SHORT $LN13@Reschedule
$LN12@Reschedule:

; 2053 : 
; 2054 : 	if(!rwindex)

	cmp	DWORD PTR _rwindex$[ebp], 0
	jne	SHORT $LN10@Reschedule

; 2055 : 	{
; 2056 : 		rwindex = FindBestTakeoffRunway(TRUE);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindBestTakeoffRunway@ATCBrain@@QAEHH@Z ; ATCBrain::FindBestTakeoffRunway
	mov	DWORD PTR _rwindex$[ebp], eax

; 2057 : 		queue = GetQueue(rwindex);

	mov	edx, DWORD PTR _rwindex$[ebp]
	push	edx
	call	?GetQueue@@YAHH@Z			; GetQueue
	add	esp, 4
	mov	DWORD PTR _queue$[ebp], eax
$LN10@Reschedule:

; 2058 : 	}
; 2059 : 	ulong takeoffTime = FindFlightTakeoffTime(flight, queue);

	mov	eax, DWORD PTR _queue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _flight$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindFlightTakeoffTime@ATCBrain@@QAEKPAVFlightClass@@H@Z ; ATCBrain::FindFlightTakeoffTime
	mov	DWORD PTR _takeoffTime$[ebp], eax

; 2060 : 
; 2061 : 	VuListIterator	flightIter(flight->GetComponents());

	mov	ecx, DWORD PTR _flight$[ebp]
	call	?GetComponents@CampBaseClass@@QBEPAVTailInsertList@@XZ ; CampBaseClass::GetComponents
	push	eax
	lea	ecx, DWORD PTR _flightIter$[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2062 : 	aircraft = (AircraftClass*) flightIter.GetFirst();

	lea	ecx, DWORD PTR _flightIter$[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _aircraft$[ebp], eax
$LN9@Reschedule:

; 2063 : 	while(aircraft)

	cmp	DWORD PTR _aircraft$[ebp], 0
	je	$LN8@Reschedule

; 2064 : 	{
; 2065 : 		if(aircraft->OnGround())

	mov	edx, DWORD PTR _aircraft$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	test	eax, eax
	je	$LN7@Reschedule

; 2066 : 		{
; 2067 : 			if ( UseSectionTakeoff((Flight)aircraft->GetCampaignObject(), rwindex ) )

	mov	eax, DWORD PTR _rwindex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UseSectionTakeoff@ATCBrain@@QAEHPAVFlightClass@@H@Z ; ATCBrain::UseSectionTakeoff
	test	eax, eax
	je	SHORT $LN6@Reschedule

; 2068 : 			{
; 2069 : 				if(aircraft->vehicleInUnit == 2)

	mov	ecx, DWORD PTR _aircraft$[ebp]
	movzx	edx, BYTE PTR [ecx+664]
	cmp	edx, 2
	jne	SHORT $LN5@Reschedule

; 2070 : //					takeoffTime += SLOT_TIME * 2;
; 2071 : 					takeoffTime += SLOT_TIME;	 // 30JAN04 - FRB

	mov	eax, DWORD PTR _takeoffTime$[ebp]
	add	eax, 10000				; 00002710H
	mov	DWORD PTR _takeoffTime$[ebp], eax
$LN5@Reschedule:

; 2072 : 			}

	jmp	SHORT $LN4@Reschedule
$LN6@Reschedule:

; 2073 : 			else if(aircraft->vehicleInUnit)

	mov	ecx, DWORD PTR _aircraft$[ebp]
	movzx	edx, BYTE PTR [ecx+664]
	test	edx, edx
	je	SHORT $LN4@Reschedule

; 2074 : 			{
; 2075 : 				takeoffTime += SLOT_TIME;

	mov	eax, DWORD PTR _takeoffTime$[ebp]
	add	eax, 10000				; 00002710H
	mov	DWORD PTR _takeoffTime$[ebp], eax
$LN4@Reschedule:

; 2076 : 			}
; 2077 : 
; 2078 : 			info = AddTraffic(aircraft->Id(),tTaxi, rwindex, takeoffTime );

	mov	ecx, DWORD PTR _takeoffTime$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rwindex$[ebp]
	push	edx
	push	22					; 00000016H
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddTraffic@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@W4AtcStatusEnum@@HJ@Z ; ATCBrain::AddTraffic
	mov	DWORD PTR _info$[ebp], eax

; 2079 : 			if(!info)

	cmp	DWORD PTR _info$[ebp], 0
	jne	SHORT $LN2@Reschedule

; 2080 : 			{
; 2081 : 				aircraft = (AircraftClass*) flightIter.GetNext();

	lea	ecx, DWORD PTR _flightIter$[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _aircraft$[ebp], eax

; 2082 : 				continue;

	jmp	$LN9@Reschedule
$LN2@Reschedule:

; 2083 : 			}
; 2084 : 
; 2085 : 			if(runwayStats[queue].nextEmergency != FalconNullId)

	push	OFFSET ?FalconNullId@@3VVU_ID@@A	; FalconNullId
	mov	eax, DWORD PTR _queue$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	lea	ecx, DWORD PTR [edx+eax+32]
	call	??9VU_ID@@QBE_NABV0@@Z			; VU_ID::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@Reschedule

; 2086 : 				info->status = tEmerStop;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+8], 21			; 00000015H
$LN1@Reschedule:

; 2087 : 
; 2088 : 			SendCmdMessage(aircraft, info);

	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage
$LN7@Reschedule:

; 2089 : 		}
; 2090 : 
; 2091 : 		aircraft = (AircraftClass*) flightIter.GetNext();

	lea	ecx, DWORD PTR _flightIter$[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _aircraft$[ebp], eax

; 2092 : 	}

	jmp	$LN9@Reschedule
$LN8@Reschedule:

; 2093 : 
; 2094 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _flightIter$[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?RescheduleFlightTakeoff@ATCBrain@@AAEXHPAVFlightClass@@@Z$0:
	lea	ecx, DWORD PTR _flightIter$[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__ehhandler$?RescheduleFlightTakeoff@ATCBrain@@AAEXHPAVFlightClass@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?RescheduleFlightTakeoff@ATCBrain@@AAEXHPAVFlightClass@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?RescheduleFlightTakeoff@ATCBrain@@AAEXHPAVFlightClass@@@Z ENDP ; ATCBrain::RescheduleFlightTakeoff
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
tv146 = -24						; size = 4
_radioMessage$ = -20					; size = 4
_deleteInfo$ = -16					; size = 4
_aircraft$ = -12					; size = 4
_this$ = -8						; size = 4
_info$ = -4						; size = 4
_queue$ = 8						; size = 4
?ReschedulePlanes@ATCBrain@@AAEXH@Z PROC		; ATCBrain::ReschedulePlanes
; _this$ = ecx

; 1990 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1991 : 	AircraftClass		*aircraft = NULL;

	mov	DWORD PTR _aircraft$[ebp], 0

; 1992 : 	runwayQueueStruct	*info = NULL;

	mov	DWORD PTR _info$[ebp], 0

; 1993 : 	runwayQueueStruct	*deleteInfo = NULL;

	mov	DWORD PTR _deleteInfo$[ebp], 0

; 1994 : 	FalconRadioChatterMessage	*radioMessage = NULL;

	mov	DWORD PTR _radioMessage$[ebp], 0

; 1995 : 
; 1996 : 	deleteInfo = info = runwayQueue[queue];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _queue$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _info$[ebp], eax
	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR _deleteInfo$[ebp], ecx
$LN7@Reschedule:

; 1997 : 
; 1998 : 	while(info)

	cmp	DWORD PTR _info$[ebp], 0
	je	$LN8@Reschedule

; 1999 : 	{
; 2000 : 		aircraft = (AircraftClass*)vuDatabase->Find(info->aircraftID);

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR [edx]
	push	ecx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _aircraft$[ebp], eax

; 2001 : 		if(aircraft && info->status != noATC)

	cmp	DWORD PTR _aircraft$[ebp], 0
	je	$LN5@Reschedule
	mov	edx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	$LN5@Reschedule

; 2002 : 		{
; 2003 : 			if(info->status > lCrashed)

	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax+8], 18			; 00000012H
	jle	$LN4@Reschedule

; 2004 : 			{
; 2005 : 				info->status = tTaxiBack;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+8], 29			; 0000001dH

; 2006 : 				SendCmdMessage(aircraft, info);

	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage

; 2007 : 				info = info->next;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _info$[ebp], edx

; 2008 : 				RemoveTraffic(deleteInfo->aircraftID, queue);

	mov	eax, DWORD PTR _queue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _deleteInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR [ecx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveTraffic@ATCBrain@@QAEXVVU_ID@@H@Z ; ATCBrain::RemoveTraffic

; 2009 : 				if(!aircraft->DBrain()->isWing)

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN3@Reschedule

; 2010 : 				{
; 2011 : 					radioMessage = CreateCallFromATC (self, aircraft, rcATCCANCELMISSION, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN10@Reschedule
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv146[ebp], eax
	jmp	SHORT $LN11@Reschedule
$LN10@Reschedule:
	mov	DWORD PTR tv146[ebp], 0
$LN11@Reschedule:
	mov	edx, DWORD PTR tv146[ebp]
	push	edx
	push	308					; 00000134H
	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$[ebp], eax

; 2012 : 					radioMessage->dataBlock.edata[3] = 32767;

	mov	eax, 2
	imul	eax, 3
	mov	ecx, 32767				; 00007fffH
	mov	edx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [edx+eax+64], cx

; 2013 : 					FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	eax, DWORD PTR _radioMessage$[ebp]
	push	eax
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN3@Reschedule:

; 2014 : 				}
; 2015 : 			}
; 2016 : 			else

	jmp	SHORT $LN2@Reschedule
$LN4@Reschedule:

; 2017 : 			{
; 2018 : 				info = info->next;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _info$[ebp], edx

; 2019 : 				RemoveTraffic(deleteInfo->aircraftID, queue);

	mov	eax, DWORD PTR _queue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _deleteInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR [ecx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveTraffic@ATCBrain@@QAEXVVU_ID@@H@Z ; ATCBrain::RemoveTraffic

; 2020 : 				RequestClearance(aircraft);

	push	0
	mov	ecx, DWORD PTR _aircraft$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RequestClearance@ATCBrain@@QAEXPAVAircraftClass@@H@Z ; ATCBrain::RequestClearance
$LN2@Reschedule:

; 2021 : 			}
; 2022 : 		}
; 2023 : 		else

	jmp	SHORT $LN1@Reschedule
$LN5@Reschedule:

; 2024 : 		{
; 2025 : 			info = info->next;

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _info$[ebp], eax

; 2026 : 			RemoveTraffic(deleteInfo->aircraftID, queue);

	mov	ecx, DWORD PTR _queue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _deleteInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR [edx]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveTraffic@ATCBrain@@QAEXVVU_ID@@H@Z ; ATCBrain::RemoveTraffic
$LN1@Reschedule:

; 2027 : 		}
; 2028 : 		deleteInfo = info;

	mov	edx, DWORD PTR _info$[ebp]
	mov	DWORD PTR _deleteInfo$[ebp], edx

; 2029 : 	}

	jmp	$LN7@Reschedule
$LN8@Reschedule:

; 2030 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ReschedulePlanes@ATCBrain@@AAEXH@Z ENDP		; ATCBrain::ReschedulePlanes
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_nextLand$ = -56					; size = 4
tv304 = -52						; size = 4
tv277 = -48						; size = 4
_y$ = -44						; size = 4
tv272 = -40						; size = 4
_x$ = -36						; size = 4
_curTaxiPoint$ = -32					; size = 4
_radioMessage$ = -28					; size = 4
_queue$ = -24						; size = 4
_cosAngle$ = -20					; size = 4
_dy$ = -16						; size = 4
_dx$ = -12						; size = 4
_dist$ = -8						; size = 4
_this$ = -4						; size = 4
_aircraft$ = 8						; size = 4
_info$ = 12						; size = 4
?CheckFinalApproach@ATCBrain@@AAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z PROC ; ATCBrain::CheckFinalApproach
; _this$ = ecx

; 4781 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 4782 : 	int			curTaxiPoint, queue;
; 4783 : 	float		x, y, dx, dy, dist, cosAngle;
; 4784 : 
; 4785 : 	queue = PtHeaderDataTable[info->rwindex].runwayNum;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	eax, BYTE PTR [edx+ecx+24]
	mov	DWORD PTR _queue$[ebp], eax

; 4786 : 
; 4787 : 	runwayQueueStruct *nextLand = NextToLand(queue);

	mov	ecx, DWORD PTR _queue$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NextToLand@ATCBrain@@AAEPAUrunwayQueueStruct@@H@Z ; ATCBrain::NextToLand
	mov	DWORD PTR _nextLand$[ebp], eax

; 4788 : 	
; 4789 : 	//curTaxiPoint = aircraft->DBrain()->GetTaxiPoint();
; 4790 : 	curTaxiPoint = GetFirstPt(info->rwindex);

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	?GetFirstPt@@YAHH@Z			; GetFirstPt
	add	esp, 4
	mov	DWORD PTR _curTaxiPoint$[ebp], eax

; 4791 : 
; 4792 : 	TranslatePointData (self, curTaxiPoint, &x, &y);

	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	eax, DWORD PTR _curTaxiPoint$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?TranslatePointData@@YAXPAVCampBaseClass@@HPAM1@Z ; TranslatePointData
	add	esp, 16					; 00000010H

; 4793 : 	dx = x - aircraft->XPos();

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv272[ebp]
	movss	xmm0, DWORD PTR _x$[ebp]
	subss	xmm0, DWORD PTR tv272[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 4794 : 	dy = y - aircraft->YPos();

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv277[ebp]
	movss	xmm0, DWORD PTR _y$[ebp]
	subss	xmm0, DWORD PTR tv277[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 4795 : 	dist = (float)sqrt(dx*dx + dy*dy);

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _dist$[ebp]

; 4796 : 
; 4797 : 	dx /= dist;

	movss	xmm0, DWORD PTR _dx$[ebp]
	divss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 4798 : 	dy /= dist;

	movss	xmm0, DWORD PTR _dy$[ebp]
	divss	xmm0, DWORD PTR _dist$[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 4799 : 
; 4800 : 	cosAngle =	dx * PtHeaderDataTable[info->rwindex].cosHeading + 
; 4801 : 				dy * PtHeaderDataTable[info->rwindex].sinHeading; 

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR [edx+ecx+16]
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR [edx+ecx+12]
	addss	xmm0, xmm1
	movss	DWORD PTR _cosAngle$[ebp], xmm0

; 4802 : 
; 4803 : 	if(dist > 500.0F && cosAngle > -0.7071F && cosAngle < 0.939692F)

	movss	xmm0, DWORD PTR _dist$[ebp]
	comiss	xmm0, DWORD PTR __real@43fa0000
	jbe	SHORT $LN11@CheckFinal
	movss	xmm0, DWORD PTR _cosAngle$[ebp]
	comiss	xmm0, DWORD PTR __real@bf350481
	jbe	SHORT $LN11@CheckFinal
	movss	xmm0, DWORD PTR __real@3f708fa8
	comiss	xmm0, DWORD PTR _cosAngle$[ebp]
	jbe	SHORT $LN11@CheckFinal

; 4804 : 	{
; 4805 : 		info->status = lAborted;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+8], 5

; 4806 : 		SendCmdMessage(aircraft,info);		

	mov	ecx, DWORD PTR _info$[ebp]
	push	ecx
	mov	edx, DWORD PTR _aircraft$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage
	jmp	$LN4@CheckFinal
$LN11@CheckFinal:

; 4807 : 	}
; 4808 : 	else if(dist < 0.8F * aircraft->af->MinVcas() * KNOTS_TO_FTPSEC * 60.0F)

	mov	eax, DWORD PTR _aircraft$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	call	?MinVcas@AirframeClass@@QAEMXZ		; AirframeClass::MinVcas
	fstp	DWORD PTR tv304[ebp]
	movss	xmm0, DWORD PTR tv304[ebp]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	mulss	xmm0, DWORD PTR __real@3fd80b03
	mulss	xmm0, DWORD PTR __real@42700000
	comiss	xmm0, DWORD PTR _dist$[ebp]
	jbe	SHORT $LN9@CheckFinal

; 4809 : 	{
; 4810 : 		if( runwayStats[queue].rnwyInUse )

	mov	ecx, DWORD PTR _queue$[ebp]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	DWORD PTR [eax+ecx+28], 0
	je	SHORT $LN8@CheckFinal

; 4811 : 		{
; 4812 : 			info->status = lAborted;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+8], 5

; 4813 : 			SendCmdMessage(aircraft,info);					

	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage
	jmp	SHORT $LN6@CheckFinal
$LN8@CheckFinal:

; 4814 : 		}
; 4815 : 		else if(!aircraft->DBrain()->IsSetATC(DigitalBrain::ClearToLand) && nextLand == info)

	push	1024					; 00000400H
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?IsSetATC@DigitalBrain@@QAEHH@Z		; DigitalBrain::IsSetATC
	test	eax, eax
	jne	SHORT $LN6@CheckFinal
	mov	ecx, DWORD PTR _nextLand$[ebp]
	cmp	ecx, DWORD PTR _info$[ebp]
	jne	SHORT $LN6@CheckFinal

; 4816 : 		{
; 4817 : 			aircraft->DBrain()->SetATCFlag(DigitalBrain::ClearToLand);

	push	1024					; 00000400H
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?SetATCFlag@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetATCFlag

; 4818 : 			info->status = lClearToLand;

	mov	edx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [edx+8], 12			; 0000000cH

; 4819 : 			SendCmdMessage(aircraft,info);

	mov	eax, DWORD PTR _info$[ebp]
	push	eax
	mov	ecx, DWORD PTR _aircraft$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage
$LN6@CheckFinal:

; 4820 : 			//info->status = lOnFinal;
; 4821 : 		}
; 4822 : 	}

	jmp	SHORT $LN4@CheckFinal
$LN9@CheckFinal:

; 4823 : 	else if(info->next && info->next->schedTime + 15 * CampaignSeconds < SimLibElapsedTime && info->next->status == lOnFinal)

	mov	edx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN4@CheckFinal
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, 15000				; 00003a98H
	cmp	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	SHORT $LN4@CheckFinal
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	DWORD PTR [ecx+8], 11			; 0000000bH
	jne	SHORT $LN4@CheckFinal

; 4824 : 	{
; 4825 : 		info->status = lAborted;

	mov	edx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [edx+8], 5

; 4826 : 		SendCmdMessage(aircraft,info);	

	mov	eax, DWORD PTR _info$[ebp]
	push	eax
	mov	ecx, DWORD PTR _aircraft$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage
$LN4@CheckFinal:

; 4827 : 	}
; 4828 : //Cobra let's have some fun.  Check for gear down, give warning, then abort them of they still don't have the gear down
; 4829 : FalconRadioChatterMessage	*radioMessage = NULL;

	mov	DWORD PTR _radioMessage$[ebp], 0

; 4830 : if (aircraft->IsPlayer() && (dist < 12000.0f && dist > 6000.0f) && aircraft->af->gearPos < 0.5f) 

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	je	SHORT $LN3@CheckFinal
	movss	xmm0, DWORD PTR __real@463b8000
	comiss	xmm0, DWORD PTR _dist$[ebp]
	jbe	SHORT $LN3@CheckFinal
	movss	xmm0, DWORD PTR _dist$[ebp]
	comiss	xmm0, DWORD PTR __real@45bb8000
	jbe	SHORT $LN3@CheckFinal
	mov	edx, DWORD PTR _aircraft$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR __real@3f000000
	comiss	xmm0, DWORD PTR [eax+1552]
	jbe	SHORT $LN3@CheckFinal

; 4831 : 	{
; 4832 : 		//rcLANDINGCHECK 
; 4833 : 		//Cobra
; 4834 : 		radioMessage = CreateCallFromATC( self, aircraft, rcLANDINGCHECK, FalconLocalSession);		

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	push	eax
	push	335					; 0000014fH
	mov	ecx, DWORD PTR _aircraft$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$[ebp], eax

; 4835 : 		FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	push	ecx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
	jmp	SHORT $LN1@CheckFinal
$LN3@CheckFinal:

; 4836 : 
; 4837 : 	}
; 4838 : else if (aircraft->IsPlayer() && dist < 6000.0f && aircraft->af->gearPos < 0.5f)

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	je	SHORT $LN1@CheckFinal
	movss	xmm0, DWORD PTR __real@45bb8000
	comiss	xmm0, DWORD PTR _dist$[ebp]
	jbe	SHORT $LN1@CheckFinal
	mov	edx, DWORD PTR _aircraft$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR __real@3f000000
	comiss	xmm0, DWORD PTR [eax+1552]
	jbe	SHORT $LN1@CheckFinal

; 4839 : 		 //rcATCGOAROUND
; 4840 : 	{
; 4841 : 		info->status = lAborted;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+8], 5

; 4842 : 		SendCmdMessage(aircraft,info);

	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage
$LN1@CheckFinal:

; 4843 : 	}
; 4844 : 
; 4845 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?CheckFinalApproach@ATCBrain@@AAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ENDP ; ATCBrain::CheckFinalApproach
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_pNLAircraft$ = -88					; size = 4
tv1021 = -84						; size = 4
tv908 = -80						; size = 4
tv798 = -76						; size = 4
tv608 = -72						; size = 4
tv551 = -68						; size = 4
tv480 = -64						; size = 4
tv360 = -60						; size = 4
tv289 = -56						; size = 4
tv215 = -52						; size = 4
tv207 = -48						; size = 4
_accelerateTakeoffs$ = -44				; size = 4
_temp$ = -40						; size = 4
_nextLand$ = -36					; size = 4
_waitforlanding$ = -32					; size = 4
_nextTakeoff$ = -28					; size = 4
_pNTOAircraft$ = -24					; size = 4
_deleteInfo$ = -20					; size = 4
_radioMessage$ = -16					; size = 4
_this$ = -12						; size = 4
_aircraft$ = -8						; size = 4
_info$ = -4						; size = 4
_queue$ = 8						; size = 4
?ProcessQueue@ATCBrain@@AAEXH@Z PROC			; ATCBrain::ProcessQueue
; _this$ = ecx

; 416  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 417  : 	AircraftClass		*aircraft = NULL;

	mov	DWORD PTR _aircraft$[ebp], 0

; 418  : 	runwayQueueStruct	*info = NULL;

	mov	DWORD PTR _info$[ebp], 0

; 419  : 	runwayQueueStruct	*deleteInfo = NULL;

	mov	DWORD PTR _deleteInfo$[ebp], 0

; 420  : 	runwayQueueStruct	*nextTakeoff = NULL;

	mov	DWORD PTR _nextTakeoff$[ebp], 0

; 421  : 	runwayQueueStruct	*nextLand = NULL;

	mov	DWORD PTR _nextLand$[ebp], 0

; 422  : 	runwayQueueStruct	*temp = NULL;

	mov	DWORD PTR _temp$[ebp], 0

; 423  : 	AircraftClass		*pNTOAircraft = NULL;

	mov	DWORD PTR _pNTOAircraft$[ebp], 0

; 424  : 	AircraftClass		*pNLAircraft = NULL;

	mov	DWORD PTR _pNLAircraft$[ebp], 0

; 425  : 	FalconRadioChatterMessage	*radioMessage = NULL;

	mov	DWORD PTR _radioMessage$[ebp], 0

; 426  : 	int waitforlanding = FALSE;

	mov	DWORD PTR _waitforlanding$[ebp], 0

; 427  : 	int accelerateTakeoffs = FALSE;

	mov	DWORD PTR _accelerateTakeoffs$[ebp], 0

; 428  : 
; 429  : 	deleteInfo = info = runwayQueue[queue];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _queue$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _info$[ebp], eax
	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR _deleteInfo$[ebp], ecx

; 430  : 
; 431  : 	nextTakeoff = NextToTakeoff(queue);

	mov	edx, DWORD PTR _queue$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NextToTakeoff@ATCBrain@@AAEPAUrunwayQueueStruct@@H@Z ; ATCBrain::NextToTakeoff
	mov	DWORD PTR _nextTakeoff$[ebp], eax

; 432  : 	if(nextTakeoff)

	cmp	DWORD PTR _nextTakeoff$[ebp], 0
	je	SHORT $LN114@ProcessQue

; 433  : 		pNTOAircraft = (AircraftClass*)vuDatabase->Find(nextTakeoff->aircraftID);

	mov	eax, DWORD PTR _nextTakeoff$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _pNTOAircraft$[ebp], eax
$LN114@ProcessQue:

; 434  : 
; 435  : 	nextLand = NextToLand(queue);

	mov	eax, DWORD PTR _queue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NextToLand@ATCBrain@@AAEPAUrunwayQueueStruct@@H@Z ; ATCBrain::NextToLand
	mov	DWORD PTR _nextLand$[ebp], eax

; 436  : 	if(nextLand)

	cmp	DWORD PTR _nextLand$[ebp], 0
	je	SHORT $LN113@ProcessQue

; 437  : 		pNLAircraft = (AircraftClass*)vuDatabase->Find(nextLand->aircraftID);

	mov	ecx, DWORD PTR _nextLand$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR [ecx]
	push	eax
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _pNLAircraft$[ebp], eax
$LN113@ProcessQue:

; 438  : 	
; 439  : 	// RAS - if within 58 seconds of landing time, hold short
; 440  : 	if(nextLand && SimLibElapsedTime + LAND_TIME_DELTA - 2*CampaignSeconds > nextLand->schedTime)

	cmp	DWORD PTR _nextLand$[ebp], 0
	je	SHORT $LN112@ProcessQue
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	ecx, 58000				; 0000e290H
	mov	edx, DWORD PTR _nextLand$[ebp]
	cmp	ecx, DWORD PTR [edx+12]
	jbe	SHORT $LN112@ProcessQue

; 441  : 		waitforlanding = TRUE;

	mov	DWORD PTR _waitforlanding$[ebp], 1
$LN112@ProcessQue:

; 442  : 
; 443  : 	// RAS - if TO scheduled, and TO time has passed, get them off the ground ASAP
; 444  : 	if(nextTakeoff && nextTakeoff->schedTime < SimLibElapsedTime)

	cmp	DWORD PTR _nextTakeoff$[ebp], 0
	je	SHORT $LN110@ProcessQue
	mov	eax, DWORD PTR _nextTakeoff$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	SHORT $LN110@ProcessQue

; 445  : 	{
; 446  : 		if(!pNTOAircraft || (pNTOAircraft->IsAirplane() && pNTOAircraft->af->vt > 80.0F*KNOTS_TO_FTPSEC) )

	cmp	DWORD PTR _pNTOAircraft$[ebp], 0
	je	SHORT $LN109@ProcessQue
	mov	edx, DWORD PTR _pNTOAircraft$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pNTOAircraft$[ebp]
	mov	edx, DWORD PTR [eax+192]
	call	edx
	test	eax, eax
	je	SHORT $LN110@ProcessQue
	mov	eax, DWORD PTR _pNTOAircraft$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR [ecx+1120]
	comiss	xmm0, DWORD PTR __real@430706e2
	jbe	SHORT $LN110@ProcessQue
$LN109@ProcessQue:

; 447  : 			accelerateTakeoffs = TRUE;

	mov	DWORD PTR _accelerateTakeoffs$[ebp], 1
$LN110@ProcessQue:

; 448  : 	}
; 449  : 
; 450  : 	// RAS - While we have aircraft in the runway queue
; 451  : 	while (info){

	cmp	DWORD PTR _info$[ebp], 0
	je	$LN107@ProcessQue

; 452  : 		aircraft = (AircraftClass*)vuDatabase->Find(info->aircraftID);

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR [edx]
	push	ecx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _aircraft$[ebp], eax

; 453  : 		if(aircraft && aircraft->IsAirplane()){

	cmp	DWORD PTR _aircraft$[ebp], 0
	je	$LN106@ProcessQue
	mov	edx, DWORD PTR _aircraft$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	edx, DWORD PTR [eax+192]
	call	edx
	test	eax, eax
	je	$LN106@ProcessQue

; 454  : 			//total hack to make sure this variable is correct
; 455  : 			aircraft->DBrain()->isWing = aircraft->GetCampaignObject()->GetComponentIndex(aircraft);

	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	esi, eax
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	DWORD PTR [eax+24], esi

; 456  : 			if(!aircraft->IsPlayer() && SimLibElapsedTime > info->schedTime + FalconLocalGame->rules.AiPullTime){

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	jne	SHORT $LN105@ProcessQue
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN117@ProcessQue
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv207[ebp], eax
	jmp	SHORT $LN118@ProcessQue
$LN117@ProcessQue:
	mov	DWORD PTR tv207[ebp], 0
$LN118@ProcessQue:
	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR tv207[ebp]
	add	eax, DWORD PTR [ecx+416]
	cmp	DWORD PTR ?SimLibElapsedTime@@3KA, eax	; SimLibElapsedTime
	jbe	SHORT $LN105@ProcessQue

; 457  : 				// sfr: we had an infinite loop in some situations, since info never got updated
; 458  : 				// maybe this should go just after the while(info)
; 459  : 				info = info->next;

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _info$[ebp], eax

; 460  : 				RegroupAircraft (aircraft);

	mov	ecx, DWORD PTR _aircraft$[ebp]
	push	ecx
	call	?RegroupAircraft@@YAXPAVAircraftClass@@@Z ; RegroupAircraft
	add	esp, 4

; 461  : 			}
; 462  : 			else {

	jmp	$LN102@ProcessQue
$LN105@ProcessQue:

; 463  : 				switch(info->status)

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR tv215[ebp], eax
	cmp	DWORD PTR tv215[ebp], 29		; 0000001dH
	ja	$LN4@ProcessQue
	mov	ecx, DWORD PTR tv215[ebp]
	jmp	DWORD PTR $LN141@ProcessQue[ecx*4]
$LN101@ProcessQue:

; 464  : 				{
; 465  : 				case noATC:
; 466  : 					info = info->next;

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _info$[ebp], eax

; 467  : 					if(deleteInfo->schedTime < SimLibElapsedTime)

	mov	ecx, DWORD PTR _deleteInfo$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	SHORT $LN100@ProcessQue

; 468  : 						RemoveTraffic(deleteInfo->aircraftID, queue);

	mov	eax, DWORD PTR _queue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _deleteInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR [ecx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveTraffic@ATCBrain@@QAEXVVU_ID@@H@Z ; ATCBrain::RemoveTraffic
$LN100@ProcessQue:

; 469  : 					break;

	jmp	$LN102@ProcessQue
$LN99@ProcessQue:

; 470  : 
; 471  : 				case tWait:
; 472  : 					if( nextTakeoff->aircraftID == info->aircraftID )

	mov	ecx, DWORD PTR _info$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _nextTakeoff$[ebp]
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	edx, al
	test	edx, edx
	je	$LN87@ProcessQue

; 473  : 					{
; 474  : 						if(info->prev)

	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	$LN97@ProcessQue

; 475  : 						{
; 476  : 							// RAS - if we're within 30 sec of T/O, and there is a previous aircraft
; 477  : 							// and we aren't waiting for a landing, and we're in accelerate TO or
; 478  : 							// status is lLanded, then enter this section 
; 479  : 							// don't know why it is status lLanded???
; 480  : 							if(	info->schedTime < SimLibElapsedTime + 30*CampaignSeconds &&
; 481  : 								info->prev == runwayQueue[queue] && !waitforlanding &&
; 482  : 								(accelerateTakeoffs || runwayQueue[queue]->status ==  lLanded))

	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	ecx, 30000				; 00007530H
	mov	edx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [edx+12], ecx
	jae	$LN96@ProcessQue
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR _queue$[ebp]
	mov	edx, DWORD PTR [edx+28]
	cmp	edx, DWORD PTR [ecx+eax*4]
	jne	SHORT $LN96@ProcessQue
	cmp	DWORD PTR _waitforlanding$[ebp], 0
	jne	SHORT $LN96@ProcessQue
	cmp	DWORD PTR _accelerateTakeoffs$[ebp], 0
	jne	SHORT $LN95@ProcessQue
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _queue$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	DWORD PTR [eax+8], 13			; 0000000dH
	jne	SHORT $LN96@ProcessQue
$LN95@ProcessQue:

; 483  : 							{
; 484  : 								info->status = tTakeRunway;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+8], 26			; 0000001aH

; 485  : 								SendCmdMessage(aircraft, info);

	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage

; 486  : 								GiveOrderToWingman(aircraft, info->status);

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GiveOrderToWingman@ATCBrain@@QAEXPAVAircraftClass@@W4AtcStatusEnum@@@Z ; ATCBrain::GiveOrderToWingman

; 487  : 								if(aircraft->vehicleInUnit < 2)

	mov	ecx, DWORD PTR _aircraft$[ebp]
	movzx	edx, BYTE PTR [ecx+664]
	cmp	edx, 2
	jge	SHORT $LN94@ProcessQue

; 488  : 									GiveOrderToSection(aircraft, tPrepToTakeRunway, 1);

	push	1
	push	25					; 00000019H
	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GiveOrderToSection@ATCBrain@@QAEXPAVAircraftClass@@W4AtcStatusEnum@@H@Z ; ATCBrain::GiveOrderToSection
$LN94@ProcessQue:

; 489  : 							}

	jmp	$LN92@ProcessQue
$LN96@ProcessQue:

; 490  : 							// RAS - if previous aircraft has requested T/O, then enter here
; 491  : 							else if(info->prev->status < tReqTaxi)

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	cmp	DWORD PTR [edx+8], 19			; 00000013H
	jge	$LN92@ProcessQue

; 492  : 							{
; 493  : 								info->status = tHoldShort;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+8], 24			; 00000018H

; 494  : 								SendCmdMessage(aircraft, info);

	mov	ecx, DWORD PTR _info$[ebp]
	push	ecx
	mov	edx, DWORD PTR _aircraft$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage

; 495  : 
; 496  : 								radioMessage = CreateCallFromATC (self, aircraft, rcHOLDSHORT, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN119@ProcessQue
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv289[ebp], eax
	jmp	SHORT $LN120@ProcessQue
$LN119@ProcessQue:
	mov	DWORD PTR tv289[ebp], 0
$LN120@ProcessQue:
	mov	ecx, DWORD PTR tv289[ebp]
	push	ecx
	push	95					; 0000005fH
	mov	edx, DWORD PTR _aircraft$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$[ebp], eax

; 497  : 								radioMessage->dataBlock.edata[3] = 0;

	mov	edx, 2
	imul	edx, 3
	xor	eax, eax
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [ecx+edx+64], ax

; 498  : 								if(info->prev->status < lCrashed)

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+28]
	cmp	DWORD PTR [eax+8], 18			; 00000012H
	jge	SHORT $LN91@ProcessQue

; 499  : 									radioMessage->dataBlock.edata[3] = (short)(1 + (rand()%4));

	call	_rand
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN135@ProcessQue
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN135@ProcessQue:
	add	eax, 1
	mov	ecx, 2
	imul	ecx, 3
	mov	edx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [edx+ecx+64], ax
$LN91@ProcessQue:

; 500  : 								FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	eax, DWORD PTR _radioMessage$[ebp]
	push	eax
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN92@ProcessQue:

; 501  : 							}
; 502  : 						}

	jmp	$LN87@ProcessQue
$LN97@ProcessQue:

; 503  : 						//RAS - if no previous aircraft in the queue
; 504  : 						//if we're within 30 sec of T/O and we're not waiting for a landing  
; 505  : 						else if( info->schedTime < SimLibElapsedTime + 30*CampaignSeconds && !waitforlanding)

	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	ecx, 30000				; 00007530H
	mov	edx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [edx+12], ecx
	jae	SHORT $LN89@ProcessQue
	cmp	DWORD PTR _waitforlanding$[ebp], 0
	jne	SHORT $LN89@ProcessQue

; 506  : 						{
; 507  : 							info->status = tTakeoff;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+8], 27			; 0000001bH

; 508  : 							SendCmdMessage(aircraft, info);

	mov	ecx, DWORD PTR _info$[ebp]
	push	ecx
	mov	edx, DWORD PTR _aircraft$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage

; 509  : 							GiveOrderToWingman(aircraft, info->status);

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _aircraft$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GiveOrderToWingman@ATCBrain@@QAEXPAVAircraftClass@@W4AtcStatusEnum@@@Z ; ATCBrain::GiveOrderToWingman

; 510  : 							if(aircraft->vehicleInUnit < 2)

	mov	eax, DWORD PTR _aircraft$[ebp]
	movzx	ecx, BYTE PTR [eax+664]
	cmp	ecx, 2
	jge	SHORT $LN88@ProcessQue

; 511  : 								GiveOrderToSection(aircraft, tPrepToTakeRunway, 1);

	push	1
	push	25					; 00000019H
	mov	edx, DWORD PTR _aircraft$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GiveOrderToSection@ATCBrain@@QAEXPAVAircraftClass@@W4AtcStatusEnum@@H@Z ; ATCBrain::GiveOrderToSection
$LN88@ProcessQue:

; 512  : 						}
; 513  : 						//RAS - we haven't reached T/O time so hold short
; 514  : 						else

	jmp	$LN87@ProcessQue
$LN89@ProcessQue:

; 515  : 						{
; 516  : 							info->status = tHoldShort;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+8], 24			; 00000018H

; 517  : 							SendCmdMessage(aircraft, info);

	mov	ecx, DWORD PTR _info$[ebp]
	push	ecx
	mov	edx, DWORD PTR _aircraft$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage

; 518  : 
; 519  : 							radioMessage = CreateCallFromATC (self, aircraft, rcHOLDSHORT, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN121@ProcessQue
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv360[ebp], eax
	jmp	SHORT $LN122@ProcessQue
$LN121@ProcessQue:
	mov	DWORD PTR tv360[ebp], 0
$LN122@ProcessQue:
	mov	ecx, DWORD PTR tv360[ebp]
	push	ecx
	push	95					; 0000005fH
	mov	edx, DWORD PTR _aircraft$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$[ebp], eax

; 520  : 							radioMessage->dataBlock.edata[3] = 0;

	mov	edx, 2
	imul	edx, 3
	xor	eax, eax
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [ecx+edx+64], ax

; 521  : 							if(info->prev && info->prev->status < lCrashed)

	mov	edx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $LN86@ProcessQue
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	cmp	DWORD PTR [ecx+8], 18			; 00000012H
	jge	SHORT $LN86@ProcessQue

; 522  : 								radioMessage->dataBlock.edata[3] = (short)(1 + (rand()%4));

	call	_rand
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN136@ProcessQue
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN136@ProcessQue:
	add	eax, 1
	mov	edx, 2
	imul	edx, 3
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [ecx+edx+64], ax
$LN86@ProcessQue:

; 523  : 							FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	edx, DWORD PTR _radioMessage$[ebp]
	push	edx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN87@ProcessQue:

; 524  : 						}
; 525  : 					}
; 526  : 					info = info->next;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _info$[ebp], ecx

; 527  : 					if (!aircraft->IsPlayer() && !aircraft->OnGround()){

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	jne	SHORT $LN85@ProcessQue
	mov	edx, DWORD PTR _aircraft$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	test	eax, eax
	jne	SHORT $LN85@ProcessQue

; 528  : 						RemoveTraffic(deleteInfo->aircraftID, queue);

	mov	eax, DWORD PTR _queue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _deleteInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR [ecx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveTraffic@ATCBrain@@QAEXVVU_ID@@H@Z ; ATCBrain::RemoveTraffic
$LN85@ProcessQue:

; 529  : 					}
; 530  : 				break;

	jmp	$LN102@ProcessQue
$LN84@ProcessQue:

; 531  : 				case tTaxi:
; 532  : 					
; 533  : 					//RAS - we have aircraft in the queue
; 534  : 					if( nextTakeoff->aircraftID == info->aircraftID )

	mov	ecx, DWORD PTR _info$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _nextTakeoff$[ebp]
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	edx, al
	test	edx, edx
	je	$LN83@ProcessQue

; 535  : 					{
; 536  : 						//RAS - we have someone in the queue in front of us
; 537  : 						if(info->prev)

	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	$LN82@ProcessQue

; 538  : 						{
; 539  : 							// we're within 30 sec of T/O time and someone in the queue in front of us
; 540  : 							// and we're not waiting on a landing aircraft
; 541  : 							// and we're in accelerated T/O mode or status queue = lLanded
; 542  : 							if(	info->schedTime < SimLibElapsedTime + 30*CampaignSeconds && 
; 543  : 								info->prev == runwayQueue[queue] && !waitforlanding &&
; 544  : 								(accelerateTakeoffs || runwayQueue[queue]->status ==  lLanded) 	)

	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	ecx, 30000				; 00007530H
	mov	edx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [edx+12], ecx
	jae	$LN81@ProcessQue
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR _queue$[ebp]
	mov	edx, DWORD PTR [edx+28]
	cmp	edx, DWORD PTR [ecx+eax*4]
	jne	SHORT $LN81@ProcessQue
	cmp	DWORD PTR _waitforlanding$[ebp], 0
	jne	SHORT $LN81@ProcessQue
	cmp	DWORD PTR _accelerateTakeoffs$[ebp], 0
	jne	SHORT $LN80@ProcessQue
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _queue$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	DWORD PTR [eax+8], 13			; 0000000dH
	jne	SHORT $LN81@ProcessQue
$LN80@ProcessQue:

; 545  : 							{
; 546  : 								//RAS - lead and 2 take the runway
; 547  : 								info->status = tTakeRunway;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+8], 26			; 0000001aH

; 548  : 								SendCmdMessage(aircraft, info);

	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage

; 549  : 								GiveOrderToWingman(aircraft, info->status);

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GiveOrderToWingman@ATCBrain@@QAEXPAVAircraftClass@@W4AtcStatusEnum@@@Z ; ATCBrain::GiveOrderToWingman

; 550  : 								//RAS - 3 and 4 prep to take runway
; 551  : 								if(aircraft->vehicleInUnit < 2)

	mov	ecx, DWORD PTR _aircraft$[ebp]
	movzx	edx, BYTE PTR [ecx+664]
	cmp	edx, 2
	jge	SHORT $LN79@ProcessQue

; 552  : 									GiveOrderToSection(aircraft, tPrepToTakeRunway, 1);

	push	1
	push	25					; 00000019H
	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GiveOrderToSection@ATCBrain@@QAEXPAVAircraftClass@@W4AtcStatusEnum@@H@Z ; ATCBrain::GiveOrderToSection
$LN79@ProcessQue:

; 553  : 							}

	jmp	$LN77@ProcessQue
$LN81@ProcessQue:

; 554  : 							else if(info->prev->status < tReqTaxi && info->prev->status > noATC)

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	cmp	DWORD PTR [edx+8], 19			; 00000013H
	jge	$LN77@ProcessQue
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	cmp	DWORD PTR [ecx+8], 0
	jle	$LN77@ProcessQue

; 555  : 							{
; 556  : 								info->status = tHoldShort;

	mov	edx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [edx+8], 24			; 00000018H

; 557  : 								SendCmdMessage(aircraft, info);

	mov	eax, DWORD PTR _info$[ebp]
	push	eax
	mov	ecx, DWORD PTR _aircraft$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage

; 558  : 
; 559  : 								radioMessage = CreateCallFromATC (self, aircraft, rcHOLDSHORT, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN123@ProcessQue
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv480[ebp], eax
	jmp	SHORT $LN124@ProcessQue
$LN123@ProcessQue:
	mov	DWORD PTR tv480[ebp], 0
$LN124@ProcessQue:
	mov	eax, DWORD PTR tv480[ebp]
	push	eax
	push	95					; 0000005fH
	mov	ecx, DWORD PTR _aircraft$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$[ebp], eax

; 560  : 								radioMessage->dataBlock.edata[3] = 0;

	mov	ecx, 2
	imul	ecx, 3
	xor	edx, edx
	mov	eax, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [eax+ecx+64], dx

; 561  : 								if(info->prev->status < lCrashed)

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	cmp	DWORD PTR [edx+8], 18			; 00000012H
	jge	SHORT $LN76@ProcessQue

; 562  : 									radioMessage->dataBlock.edata[3] = (short)(1 + (rand()%4));

	call	_rand
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN137@ProcessQue
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN137@ProcessQue:
	add	eax, 1
	mov	ecx, 2
	imul	ecx, 3
	mov	edx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [edx+ecx+64], ax
$LN76@ProcessQue:

; 563  : 								FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	eax, DWORD PTR _radioMessage$[ebp]
	push	eax
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN77@ProcessQue:

; 564  : 							}
; 565  : 						}

	jmp	$LN72@ProcessQue
$LN82@ProcessQue:

; 566  : 						//RAS - we're first in queue and within 30 sec of T/O and not waiting for ldg
; 567  : 						else if( info->schedTime < SimLibElapsedTime + 30*CampaignSeconds && !waitforlanding)

	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	ecx, 30000				; 00007530H
	mov	edx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [edx+12], ecx
	jae	SHORT $LN74@ProcessQue
	cmp	DWORD PTR _waitforlanding$[ebp], 0
	jne	SHORT $LN74@ProcessQue

; 568  : 						{
; 569  : 							// RAS - 1 and 2 takeoff
; 570  : 							info->status = tTakeoff;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+8], 27			; 0000001bH

; 571  : 							SendCmdMessage(aircraft, info);

	mov	ecx, DWORD PTR _info$[ebp]
	push	ecx
	mov	edx, DWORD PTR _aircraft$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage

; 572  : 							GiveOrderToWingman(aircraft, info->status);

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _aircraft$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GiveOrderToWingman@ATCBrain@@QAEXPAVAircraftClass@@W4AtcStatusEnum@@@Z ; ATCBrain::GiveOrderToWingman

; 573  : 							// RAS - 3 and 4 prep to take runway
; 574  : 							if(aircraft->vehicleInUnit < 2)

	mov	eax, DWORD PTR _aircraft$[ebp]
	movzx	ecx, BYTE PTR [eax+664]
	cmp	ecx, 2
	jge	SHORT $LN73@ProcessQue

; 575  : 								GiveOrderToSection(aircraft, tPrepToTakeRunway, 1);

	push	1
	push	25					; 00000019H
	mov	edx, DWORD PTR _aircraft$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GiveOrderToSection@ATCBrain@@QAEXPAVAircraftClass@@W4AtcStatusEnum@@H@Z ; ATCBrain::GiveOrderToSection
$LN73@ProcessQue:

; 576  : 						}
; 577  : 						//RAS - not with 30sec of T/O time so hold short
; 578  : 						else

	jmp	$LN72@ProcessQue
$LN74@ProcessQue:

; 579  : 						{
; 580  : 							info->status = tHoldShort;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+8], 24			; 00000018H

; 581  : 							SendCmdMessage(aircraft, info);

	mov	ecx, DWORD PTR _info$[ebp]
	push	ecx
	mov	edx, DWORD PTR _aircraft$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage

; 582  : 
; 583  : 							radioMessage = CreateCallFromATC (self, aircraft, rcHOLDSHORT, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN125@ProcessQue
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv551[ebp], eax
	jmp	SHORT $LN126@ProcessQue
$LN125@ProcessQue:
	mov	DWORD PTR tv551[ebp], 0
$LN126@ProcessQue:
	mov	ecx, DWORD PTR tv551[ebp]
	push	ecx
	push	95					; 0000005fH
	mov	edx, DWORD PTR _aircraft$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$[ebp], eax

; 584  : 							radioMessage->dataBlock.edata[3] = 0;

	mov	edx, 2
	imul	edx, 3
	xor	eax, eax
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [ecx+edx+64], ax

; 585  : 							if(info->prev && info->prev->status < lCrashed)

	mov	edx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $LN71@ProcessQue
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	cmp	DWORD PTR [ecx+8], 18			; 00000012H
	jge	SHORT $LN71@ProcessQue

; 586  : 								radioMessage->dataBlock.edata[3] = (short)(1 + (rand()%4));

	call	_rand
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN138@ProcessQue
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN138@ProcessQue:
	add	eax, 1
	mov	edx, 2
	imul	edx, 3
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [ecx+edx+64], ax
$LN71@ProcessQue:

; 587  : 							FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	edx, DWORD PTR _radioMessage$[ebp]
	push	edx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN72@ProcessQue:

; 588  : 						}
; 589  : 					}
; 590  : 					//RAS - need to get here if taxi order is messed up I beleive
; 591  : 					//RAS - if next T/O acft and it's an airplane, and scheudle T/O time + ATC patience hasn't been reached
; 592  : 					//and acft is going less than 5 kts (should that be conferted to ft/sec??), and T/O time has passed
; 593  : 					//and next acft to T/O is not current obj???, and next acft to T/O is not on rwy, then
; 594  : 					else if(pNTOAircraft && pNTOAircraft->IsAirplane() && nextTakeoff->schedTime + FalconLocalGame->rules.AtcPatience < SimLibElapsedTime  && 

	jmp	$LN66@ProcessQue
$LN83@ProcessQue:

; 595  : 							pNTOAircraft->af->vt < 5.0F * KNOTS_TO_FTPSEC &&	info->schedTime < SimLibElapsedTime  &&
; 596  : 							pNTOAircraft->GetCampaignObject() != aircraft->GetCampaignObject() && !IsOnRunway(pNTOAircraft) )

	cmp	DWORD PTR _pNTOAircraft$[ebp], 0
	je	$LN66@ProcessQue
	mov	eax, DWORD PTR _pNTOAircraft$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pNTOAircraft$[ebp]
	mov	eax, DWORD PTR [edx+192]
	call	eax
	test	eax, eax
	je	$LN66@ProcessQue
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN127@ProcessQue
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv608[ebp], eax
	jmp	SHORT $LN128@ProcessQue
$LN127@ProcessQue:
	mov	DWORD PTR tv608[ebp], 0
$LN128@ProcessQue:
	mov	edx, DWORD PTR _nextTakeoff$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR tv608[ebp]
	add	eax, DWORD PTR [ecx+424]
	cmp	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	$LN66@ProcessQue
	mov	edx, DWORD PTR _pNTOAircraft$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR __real@410706e2
	comiss	xmm0, DWORD PTR [eax+1120]
	jbe	$LN66@ProcessQue
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	$LN66@ProcessQue
	mov	ecx, DWORD PTR _pNTOAircraft$[ebp]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	esi, eax
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	cmp	esi, eax
	je	$LN66@ProcessQue
	mov	eax, DWORD PTR _pNTOAircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsOnRunway@ATCBrain@@QAEHPAVAircraftClass@@@Z ; ATCBrain::IsOnRunway
	test	eax, eax
	jne	SHORT $LN66@ProcessQue

; 597  : 					{
; 598  : 						//RAS - no aircraft on final and past T/O time + delta(60sec)
; 599  : 						if(!nextLand || SimLibElapsedTime + LAND_TIME_DELTA > nextLand->schedTime)

	cmp	DWORD PTR _nextLand$[ebp], 0
	je	SHORT $LN67@ProcessQue
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	ecx, 60000				; 0000ea60H
	mov	edx, DWORD PTR _nextLand$[ebp]
	cmp	ecx, DWORD PTR [edx+12]
	jbe	SHORT $LN66@ProcessQue
$LN67@ProcessQue:

; 600  : 						{
; 601  : 							ReorderFlight(queue, (Flight)pNTOAircraft->GetCampaignObject(), tWait);

	push	23					; 00000017H
	mov	ecx, DWORD PTR _pNTOAircraft$[ebp]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	push	eax
	mov	eax, DWORD PTR _queue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReorderFlight@ATCBrain@@AAEXHPAVFlightClass@@W4AtcStatusEnum@@@Z ; ATCBrain::ReorderFlight

; 602  : 							
; 603  : 							info->status = tTakeoff;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+8], 27			; 0000001bH

; 604  : 							SendCmdMessage(aircraft, info);

	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage

; 605  : 							GiveOrderToWingman(aircraft, info->status);

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GiveOrderToWingman@ATCBrain@@QAEXPAVAircraftClass@@W4AtcStatusEnum@@@Z ; ATCBrain::GiveOrderToWingman

; 606  : 							if(aircraft->vehicleInUnit < 2)

	mov	ecx, DWORD PTR _aircraft$[ebp]
	movzx	edx, BYTE PTR [ecx+664]
	cmp	edx, 2
	jge	SHORT $LN66@ProcessQue

; 607  : 								GiveOrderToSection(aircraft, tPrepToTakeRunway, 1);

	push	1
	push	25					; 00000019H
	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GiveOrderToSection@ATCBrain@@QAEXPAVAircraftClass@@W4AtcStatusEnum@@H@Z ; ATCBrain::GiveOrderToSection
$LN66@ProcessQue:

; 608  : 						}
; 609  : 					}
; 610  : 					info = info->next;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _info$[ebp], edx

; 611  : 					if(!aircraft->IsPlayer() && !aircraft->OnGround())

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	jne	SHORT $LN65@ProcessQue
	mov	eax, DWORD PTR _aircraft$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	jne	SHORT $LN65@ProcessQue

; 612  : 						RemoveTraffic(deleteInfo->aircraftID, queue);

	mov	ecx, DWORD PTR _queue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _deleteInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR [edx]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveTraffic@ATCBrain@@QAEXVVU_ID@@H@Z ; ATCBrain::RemoveTraffic
$LN65@ProcessQue:

; 613  : 					break;

	jmp	$LN102@ProcessQue
$LN64@ProcessQue:

; 614  : 
; 615  : 				case tPrepToTakeRunway:
; 616  : 					if(nextTakeoff->aircraftID == info->aircraftID)

	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	mov	ecx, DWORD PTR _nextTakeoff$[ebp]
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN61@ProcessQue

; 617  : 					{	
; 618  : 						//RAS - no aircraft on final
; 619  : 						if(!waitforlanding)

	cmp	DWORD PTR _waitforlanding$[ebp], 0
	jne	SHORT $LN61@ProcessQue

; 620  : 						{
; 621  : 							info->status = tTakeoff;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+8], 27			; 0000001bH

; 622  : 							SendCmdMessage(aircraft, info);

	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage

; 623  : 							GiveOrderToWingman(aircraft, info->status);	

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GiveOrderToWingman@ATCBrain@@QAEXPAVAircraftClass@@W4AtcStatusEnum@@@Z ; ATCBrain::GiveOrderToWingman

; 624  : 							if(aircraft->vehicleInUnit < 2)

	mov	ecx, DWORD PTR _aircraft$[ebp]
	movzx	edx, BYTE PTR [ecx+664]
	cmp	edx, 2
	jge	SHORT $LN61@ProcessQue

; 625  : 								GiveOrderToSection(aircraft, tPrepToTakeRunway, 1);

	push	1
	push	25					; 00000019H
	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GiveOrderToSection@ATCBrain@@QAEXPAVAircraftClass@@W4AtcStatusEnum@@H@Z ; ATCBrain::GiveOrderToSection
$LN61@ProcessQue:

; 626  : 						}
; 627  : 					}
; 628  : 					info = info->next;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _info$[ebp], edx

; 629  : 					if(!aircraft->IsPlayer() && !aircraft->OnGround())

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	jne	SHORT $LN60@ProcessQue
	mov	eax, DWORD PTR _aircraft$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	jne	SHORT $LN60@ProcessQue

; 630  : 						RemoveTraffic(deleteInfo->aircraftID, queue);

	mov	ecx, DWORD PTR _queue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _deleteInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR [edx]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveTraffic@ATCBrain@@QAEXVVU_ID@@H@Z ; ATCBrain::RemoveTraffic
$LN60@ProcessQue:

; 631  : 					break;

	jmp	$LN102@ProcessQue
$LN59@ProcessQue:

; 632  : 
; 633  : 				case tHoldShort:
; 634  : 					if(nextTakeoff->aircraftID == info->aircraftID)

	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	mov	ecx, DWORD PTR _nextTakeoff$[ebp]
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN58@ProcessQue

; 635  : 					{		
; 636  : 						//RAS - within 30sec of T/O and not waiting for someone to land
; 637  : 						if(info->schedTime < SimLibElapsedTime + 30*CampaignSeconds && !waitforlanding)

	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	ecx, 30000				; 00007530H
	mov	edx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [edx+12], ecx
	jae	SHORT $LN56@ProcessQue
	cmp	DWORD PTR _waitforlanding$[ebp], 0
	jne	SHORT $LN56@ProcessQue

; 638  : 						{
; 639  : 							info->status = tTakeoff;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+8], 27			; 0000001bH

; 640  : 							SendCmdMessage(aircraft, info);

	mov	ecx, DWORD PTR _info$[ebp]
	push	ecx
	mov	edx, DWORD PTR _aircraft$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage

; 641  : 							GiveOrderToWingman(aircraft, info->status);	

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _aircraft$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GiveOrderToWingman@ATCBrain@@QAEXPAVAircraftClass@@W4AtcStatusEnum@@@Z ; ATCBrain::GiveOrderToWingman

; 642  : 							if(aircraft->vehicleInUnit < 2)

	mov	eax, DWORD PTR _aircraft$[ebp]
	movzx	ecx, BYTE PTR [eax+664]
	cmp	ecx, 2
	jge	SHORT $LN56@ProcessQue

; 643  : 								GiveOrderToSection(aircraft, tPrepToTakeRunway, 1);

	push	1
	push	25					; 00000019H
	mov	edx, DWORD PTR _aircraft$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GiveOrderToSection@ATCBrain@@QAEXPAVAircraftClass@@W4AtcStatusEnum@@H@Z ; ATCBrain::GiveOrderToSection
$LN56@ProcessQue:

; 644  : 						}
; 645  : 					}
; 646  : 					else if(pNTOAircraft && pNTOAircraft->IsAirplane() && nextTakeoff->schedTime + FalconLocalGame->rules.AtcPatience < SimLibElapsedTime  && 

	jmp	$LN51@ProcessQue
$LN58@ProcessQue:

; 647  : 							pNTOAircraft->af->vt < 5.0F * KNOTS_TO_FTPSEC &&	info->schedTime < SimLibElapsedTime &&
; 648  : 							pNTOAircraft->GetCampaignObject() != aircraft->GetCampaignObject() && !IsOnRunway(pNTOAircraft) )

	cmp	DWORD PTR _pNTOAircraft$[ebp], 0
	je	$LN51@ProcessQue
	mov	eax, DWORD PTR _pNTOAircraft$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pNTOAircraft$[ebp]
	mov	eax, DWORD PTR [edx+192]
	call	eax
	test	eax, eax
	je	$LN51@ProcessQue
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN129@ProcessQue
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv798[ebp], eax
	jmp	SHORT $LN130@ProcessQue
$LN129@ProcessQue:
	mov	DWORD PTR tv798[ebp], 0
$LN130@ProcessQue:
	mov	edx, DWORD PTR _nextTakeoff$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR tv798[ebp]
	add	eax, DWORD PTR [ecx+424]
	cmp	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	$LN51@ProcessQue
	mov	edx, DWORD PTR _pNTOAircraft$[ebp]
	mov	eax, DWORD PTR [edx+932]
	movss	xmm0, DWORD PTR __real@410706e2
	comiss	xmm0, DWORD PTR [eax+1120]
	jbe	$LN51@ProcessQue
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	$LN51@ProcessQue
	mov	ecx, DWORD PTR _pNTOAircraft$[ebp]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	esi, eax
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	cmp	esi, eax
	je	$LN51@ProcessQue
	mov	eax, DWORD PTR _pNTOAircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsOnRunway@ATCBrain@@QAEHPAVAircraftClass@@@Z ; ATCBrain::IsOnRunway
	test	eax, eax
	jne	SHORT $LN51@ProcessQue

; 649  : 					{
; 650  : 						if(!nextLand || SimLibElapsedTime + LAND_TIME_DELTA > nextLand->schedTime)

	cmp	DWORD PTR _nextLand$[ebp], 0
	je	SHORT $LN52@ProcessQue
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	ecx, 60000				; 0000ea60H
	mov	edx, DWORD PTR _nextLand$[ebp]
	cmp	ecx, DWORD PTR [edx+12]
	jbe	SHORT $LN51@ProcessQue
$LN52@ProcessQue:

; 651  : 						{
; 652  : 							ReorderFlight(queue, (Flight)pNTOAircraft->GetCampaignObject(), tWait);

	push	23					; 00000017H
	mov	ecx, DWORD PTR _pNTOAircraft$[ebp]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	push	eax
	mov	eax, DWORD PTR _queue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReorderFlight@ATCBrain@@AAEXHPAVFlightClass@@W4AtcStatusEnum@@@Z ; ATCBrain::ReorderFlight

; 653  : 							
; 654  : 							info->status = tTakeoff;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+8], 27			; 0000001bH

; 655  : 							SendCmdMessage(aircraft, info);

	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage

; 656  : 							GiveOrderToWingman(aircraft, info->status);

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GiveOrderToWingman@ATCBrain@@QAEXPAVAircraftClass@@W4AtcStatusEnum@@@Z ; ATCBrain::GiveOrderToWingman

; 657  : 							if(aircraft->vehicleInUnit < 2)

	mov	ecx, DWORD PTR _aircraft$[ebp]
	movzx	edx, BYTE PTR [ecx+664]
	cmp	edx, 2
	jge	SHORT $LN51@ProcessQue

; 658  : 								GiveOrderToSection(aircraft, tPrepToTakeRunway, 1);

	push	1
	push	25					; 00000019H
	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GiveOrderToSection@ATCBrain@@QAEXPAVAircraftClass@@W4AtcStatusEnum@@H@Z ; ATCBrain::GiveOrderToSection
$LN51@ProcessQue:

; 659  : 						}
; 660  : 					}
; 661  : 					info = info->next;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _info$[ebp], edx

; 662  : 					if(!aircraft->IsPlayer() && !aircraft->OnGround())

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	jne	SHORT $LN50@ProcessQue
	mov	eax, DWORD PTR _aircraft$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	jne	SHORT $LN50@ProcessQue

; 663  : 						RemoveTraffic(deleteInfo->aircraftID, queue);

	mov	ecx, DWORD PTR _queue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _deleteInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR [edx]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveTraffic@ATCBrain@@QAEXVVU_ID@@H@Z ; ATCBrain::RemoveTraffic
$LN50@ProcessQue:

; 664  : 					break;

	jmp	$LN102@ProcessQue
$LN49@ProcessQue:

; 665  : 
; 666  : 				case tTakeRunway:
; 667  : 					//RAS - if not on runway and waiting for someone to land
; 668  : 					if(waitforlanding && !IsOnRunway(aircraft) )

	cmp	DWORD PTR _waitforlanding$[ebp], 0
	je	$LN48@ProcessQue
	mov	edx, DWORD PTR _aircraft$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsOnRunway@ATCBrain@@QAEHPAVAircraftClass@@@Z ; ATCBrain::IsOnRunway
	test	eax, eax
	jne	$LN48@ProcessQue

; 669  : 					{
; 670  : 						//TODO: RAS - maybe this should be hold short???
; 671  : 						info->status = tPrepToTakeRunway;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax+8], 25			; 00000019H

; 672  : 						SendCmdMessage(aircraft, info);

	mov	ecx, DWORD PTR _info$[ebp]
	push	ecx
	mov	edx, DWORD PTR _aircraft$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage

; 673  : 
; 674  : 						radioMessage = CreateCallFromATC (self, aircraft, rcHOLDSHORT, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN131@ProcessQue
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv908[ebp], eax
	jmp	SHORT $LN132@ProcessQue
$LN131@ProcessQue:
	mov	DWORD PTR tv908[ebp], 0
$LN132@ProcessQue:
	mov	ecx, DWORD PTR tv908[ebp]
	push	ecx
	push	95					; 0000005fH
	mov	edx, DWORD PTR _aircraft$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$[ebp], eax

; 675  : 						radioMessage->dataBlock.edata[3] = 0;

	mov	edx, 2
	imul	edx, 3
	xor	eax, eax
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [ecx+edx+64], ax

; 676  : 						if(info->prev && info->prev->status < lCrashed)

	mov	edx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $LN47@ProcessQue
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	cmp	DWORD PTR [ecx+8], 18			; 00000012H
	jge	SHORT $LN47@ProcessQue

; 677  : 							radioMessage->dataBlock.edata[3] = (short)(1 + (rand()%4));

	call	_rand
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN139@ProcessQue
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN139@ProcessQue:
	add	eax, 1
	mov	edx, 2
	imul	edx, 3
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [ecx+edx+64], ax
$LN47@ProcessQue:

; 678  : 						FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	edx, DWORD PTR _radioMessage$[ebp]
	push	edx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
	jmp	$LN42@ProcessQue
$LN48@ProcessQue:

; 679  : 					}
; 680  : 					else if(nextTakeoff->aircraftID == info->aircraftID )

	mov	eax, DWORD PTR _info$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nextTakeoff$[ebp]
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN42@ProcessQue

; 681  : 					{
; 682  : 						//RAS - within 30 seconds of T/O time and not waiting on landing or we're on rwy
; 683  : 						if( info->schedTime < SimLibElapsedTime + 30*CampaignSeconds &&
; 684  : 							(!waitforlanding || IsOnRunway(aircraft)) )

	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	edx, 30000				; 00007530H
	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax+12], edx
	jae	SHORT $LN42@ProcessQue
	cmp	DWORD PTR _waitforlanding$[ebp], 0
	je	SHORT $LN43@ProcessQue
	mov	ecx, DWORD PTR _aircraft$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsOnRunway@ATCBrain@@QAEHPAVAircraftClass@@@Z ; ATCBrain::IsOnRunway
	test	eax, eax
	je	SHORT $LN42@ProcessQue
$LN43@ProcessQue:

; 685  : 						{
; 686  : 							info->status = tTakeoff;

	mov	edx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [edx+8], 27			; 0000001bH

; 687  : 							SendCmdMessage(aircraft, info);

	mov	eax, DWORD PTR _info$[ebp]
	push	eax
	mov	ecx, DWORD PTR _aircraft$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage

; 688  : 							GiveOrderToWingman(aircraft, info->status);	

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _aircraft$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GiveOrderToWingman@ATCBrain@@QAEXPAVAircraftClass@@W4AtcStatusEnum@@@Z ; ATCBrain::GiveOrderToWingman

; 689  : 							if(aircraft->vehicleInUnit < 2)

	mov	edx, DWORD PTR _aircraft$[ebp]
	movzx	eax, BYTE PTR [edx+664]
	cmp	eax, 2
	jge	SHORT $LN42@ProcessQue

; 690  : 								GiveOrderToSection(aircraft, tPrepToTakeRunway, 1);

	push	1
	push	25					; 00000019H
	mov	ecx, DWORD PTR _aircraft$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GiveOrderToSection@ATCBrain@@QAEXPAVAircraftClass@@W4AtcStatusEnum@@H@Z ; ATCBrain::GiveOrderToSection
$LN42@ProcessQue:

; 691  : 						}
; 692  : 					}
; 693  : 					info = info->next;

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _info$[ebp], eax

; 694  : 					if(!aircraft->IsPlayer() && !aircraft->OnGround())

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	jne	SHORT $LN41@ProcessQue
	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	jne	SHORT $LN41@ProcessQue

; 695  : 						RemoveTraffic(deleteInfo->aircraftID, queue);

	mov	ecx, DWORD PTR _queue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _deleteInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR [edx]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveTraffic@ATCBrain@@QAEXVVU_ID@@H@Z ; ATCBrain::RemoveTraffic
$LN41@ProcessQue:

; 696  : 					break;

	jmp	$LN102@ProcessQue
$LN40@ProcessQue:

; 697  : 
; 698  : 				//TODO: RAS - there only seems to be one case under takeoff which is waiting for aircraft to land
; 699  : 				// might need to add section if not waiting for aircraft to land?????
; 700  : 				case tTakeoff:
; 701  : 					//RAS - waiting for landing and not over rwy and speed less than 45kts
; 702  : 					if(waitforlanding && !IsOverRunway(aircraft) && aircraft->af->vt < 45.0F*KNOTS_TO_FTPSEC)

	cmp	DWORD PTR _waitforlanding$[ebp], 0
	je	$LN39@ProcessQue
	mov	edx, DWORD PTR _aircraft$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsOverRunway@ATCBrain@@QAEHPAVAircraftClass@@@Z ; ATCBrain::IsOverRunway
	test	eax, eax
	jne	$LN39@ProcessQue
	mov	eax, DWORD PTR _aircraft$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR __real@4297e7be
	comiss	xmm0, DWORD PTR [ecx+1120]
	jbe	$LN39@ProcessQue

; 703  : 					{
; 704  : 						//TODO: RAS - waiting for landing so should this be tHoldShort???
; 705  : 						info->status = tPrepToTakeRunway;

	mov	edx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [edx+8], 25			; 00000019H

; 706  : 						SendCmdMessage(aircraft, info);

	mov	eax, DWORD PTR _info$[ebp]
	push	eax
	mov	ecx, DWORD PTR _aircraft$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage

; 707  : 
; 708  : 						radioMessage = CreateCallFromATC (self, aircraft, rcHOLDSHORT, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN133@ProcessQue
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv1021[ebp], eax
	jmp	SHORT $LN134@ProcessQue
$LN133@ProcessQue:
	mov	DWORD PTR tv1021[ebp], 0
$LN134@ProcessQue:
	mov	eax, DWORD PTR tv1021[ebp]
	push	eax
	push	95					; 0000005fH
	mov	ecx, DWORD PTR _aircraft$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$[ebp], eax

; 709  : 						radioMessage->dataBlock.edata[3] = 0;

	mov	ecx, 2
	imul	ecx, 3
	xor	edx, edx
	mov	eax, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [eax+ecx+64], dx

; 710  : 						if(info->prev && info->prev->status < lCrashed)

	mov	ecx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	je	SHORT $LN38@ProcessQue
	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+28]
	cmp	DWORD PTR [eax+8], 18			; 00000012H
	jge	SHORT $LN38@ProcessQue

; 711  : 							radioMessage->dataBlock.edata[3] = (short)(1 + (rand()%4));

	call	_rand
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN140@ProcessQue
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN140@ProcessQue:
	add	eax, 1
	mov	ecx, 2
	imul	ecx, 3
	mov	edx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [edx+ecx+64], ax
$LN38@ProcessQue:

; 712  : 						FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	eax, DWORD PTR _radioMessage$[ebp]
	push	eax
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN39@ProcessQue:

; 713  : 					}
; 714  : 					info = info->next;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _info$[ebp], edx

; 715  : 					if(!aircraft->IsPlayer() && !aircraft->OnGround())

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	jne	SHORT $LN37@ProcessQue
	mov	eax, DWORD PTR _aircraft$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	jne	SHORT $LN37@ProcessQue

; 716  : 						RemoveTraffic(deleteInfo->aircraftID, queue);

	mov	ecx, DWORD PTR _queue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _deleteInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR [edx]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveTraffic@ATCBrain@@QAEXVVU_ID@@H@Z ; ATCBrain::RemoveTraffic
$LN37@ProcessQue:

; 717  : 					break;

	jmp	$LN102@ProcessQue
$LN36@ProcessQue:

; 718  : 
; 719  : 				case tEmerStop:
; 720  : 					if(runwayStats[GetQueue(info->rwindex)].nextEmergency == FalconNullId)

	push	OFFSET ?FalconNullId@@3VVU_ID@@A	; FalconNullId
	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	?GetQueue@@YAHH@Z			; GetQueue
	add	esp, 4
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	lea	ecx, DWORD PTR [edx+eax+32]
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN35@ProcessQue

; 721  : 					{
; 722  : 						info->status = tTaxi;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+8], 22			; 00000016H

; 723  : 						SendCmdMessage(aircraft, info);

	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage
$LN35@ProcessQue:

; 724  : 					}
; 725  : 					info = info->next;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _info$[ebp], edx

; 726  : 					if(!aircraft->IsPlayer() && !aircraft->OnGround())

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	jne	SHORT $LN34@ProcessQue
	mov	eax, DWORD PTR _aircraft$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	jne	SHORT $LN34@ProcessQue

; 727  : 						RemoveTraffic(deleteInfo->aircraftID, queue);

	mov	ecx, DWORD PTR _queue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _deleteInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR [edx]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveTraffic@ATCBrain@@QAEXVVU_ID@@H@Z ; ATCBrain::RemoveTraffic
$LN34@ProcessQue:

; 728  : 					break;

	jmp	$LN102@ProcessQue
$LN33@ProcessQue:

; 729  : 
; 730  : 				case lEmerHold:
; 731  : 					info = info->next;

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _info$[ebp], eax

; 732  : 					if(runwayStats[GetQueue(deleteInfo->rwindex)].nextEmergency == FalconNullId)

	push	OFFSET ?FalconNullId@@3VVU_ID@@A	; FalconNullId
	mov	ecx, DWORD PTR _deleteInfo$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	?GetQueue@@YAHH@Z			; GetQueue
	add	esp, 4
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	lea	ecx, DWORD PTR [edx+eax+32]
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN32@ProcessQue

; 733  : 					{
; 734  : 						RemoveTraffic(deleteInfo->aircraftID, queue);

	mov	ecx, DWORD PTR _queue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _deleteInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR [edx]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveTraffic@ATCBrain@@QAEXVVU_ID@@H@Z ; ATCBrain::RemoveTraffic

; 735  : 						RequestClearance(aircraft);

	push	0
	mov	edx, DWORD PTR _aircraft$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RequestClearance@ATCBrain@@QAEXPAVAircraftClass@@H@Z ; ATCBrain::RequestClearance
$LN32@ProcessQue:

; 736  : 					}
; 737  : 					break;

	jmp	$LN102@ProcessQue
$LN31@ProcessQue:

; 738  : 
; 739  : 				case lHolding:
; 740  : 				case lToBase:
; 741  : 					if(info->schedTime < SimLibElapsedTime + FINAL_TIME)

	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	eax, 120000				; 0001d4c0H
	mov	ecx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [ecx+12], eax
	jae	SHORT $LN30@ProcessQue

; 742  : 					{
; 743  : 						info->status = lAborted;

	mov	edx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [edx+8], 5

; 744  : 						SendCmdMessage(aircraft,info);	

	mov	eax, DWORD PTR _info$[ebp]
	push	eax
	mov	ecx, DWORD PTR _aircraft$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage
$LN30@ProcessQue:

; 745  : 					}
; 746  : 					info = info->next;

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _info$[ebp], eax

; 747  : 					if(!aircraft->IsPlayer() && aircraft->OnGround())

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	jne	SHORT $LN29@ProcessQue
	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	SHORT $LN29@ProcessQue

; 748  : 						RemoveTraffic(deleteInfo->aircraftID, queue);

	mov	ecx, DWORD PTR _queue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _deleteInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR [edx]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveTraffic@ATCBrain@@QAEXVVU_ID@@H@Z ; ATCBrain::RemoveTraffic
$LN29@ProcessQue:

; 749  : 					break;

	jmp	$LN102@ProcessQue
$LN28@ProcessQue:

; 750  : 
; 751  : 				case lFirstLeg:
; 752  : 				case lToFinal:
; 753  : 					if(info->schedTime < SimLibElapsedTime + CampaignMinutes)

	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	add	edx, 60000				; 0000ea60H
	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax+12], edx
	jae	SHORT $LN27@ProcessQue

; 754  : 					{
; 755  : 						info->status = lAborted;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+8], 5

; 756  : 						SendCmdMessage(aircraft,info);	

	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage
$LN27@ProcessQue:

; 757  : 					}
; 758  : 					info = info->next;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _info$[ebp], edx

; 759  : 					if(!aircraft->IsPlayer() && aircraft->OnGround())

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	jne	SHORT $LN26@ProcessQue
	mov	eax, DWORD PTR _aircraft$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	SHORT $LN26@ProcessQue

; 760  : 						RemoveTraffic(deleteInfo->aircraftID, queue);

	mov	ecx, DWORD PTR _queue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _deleteInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR [edx]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveTraffic@ATCBrain@@QAEXVVU_ID@@H@Z ; ATCBrain::RemoveTraffic
$LN26@ProcessQue:

; 761  : 					break;

	jmp	$LN102@ProcessQue
$LN25@ProcessQue:

; 762  : 
; 763  : 				case lOnFinal:					
; 764  : 				case lClearToLand:
; 765  : 					temp = info->next;

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _temp$[ebp], eax
$LN24@ProcessQue:

; 766  : 					while(temp)

	cmp	DWORD PTR _temp$[ebp], 0
	je	SHORT $LN23@ProcessQue

; 767  : 					{
; 768  : 						if(temp->status >= lReqClearance && temp->status < lLanded )

	mov	ecx, DWORD PTR _temp$[ebp]
	cmp	DWORD PTR [ecx+8], 1
	jl	SHORT $LN22@ProcessQue
	mov	edx, DWORD PTR _temp$[ebp]
	cmp	DWORD PTR [edx+8], 13			; 0000000dH
	jge	SHORT $LN22@ProcessQue

; 769  : 						{
; 770  : 							break;

	jmp	SHORT $LN23@ProcessQue
$LN22@ProcessQue:

; 771  : 						}
; 772  : 						temp = temp->next;

	mov	eax, DWORD PTR _temp$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _temp$[ebp], ecx

; 773  : 					}

	jmp	SHORT $LN24@ProcessQue
$LN23@ProcessQue:

; 774  : 
; 775  : 					if(info->schedTime < SimLibElapsedTime && (temp || runwayStats[queue].nextEmergency != FalconNullId) )

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+12]
	cmp	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	SHORT $LN19@ProcessQue
	cmp	DWORD PTR _temp$[ebp], 0
	jne	SHORT $LN20@ProcessQue
	push	OFFSET ?FalconNullId@@3VVU_ID@@A	; FalconNullId
	mov	ecx, DWORD PTR _queue$[ebp]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	lea	ecx, DWORD PTR [eax+ecx+32]
	call	??9VU_ID@@QBE_NABV0@@Z			; VU_ID::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN19@ProcessQue
$LN20@ProcessQue:

; 776  : 					{
; 777  : 						if(!aircraft->DBrain()->IsSetATC(DigitalBrain::ClearToLand) ||
; 778  : 							info->schedTime + CampaignMinutes < SimLibElapsedTime )

	push	1024					; 00000400H
	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?IsSetATC@DigitalBrain@@QAEHH@Z		; DigitalBrain::IsSetATC
	test	eax, eax
	je	SHORT $LN18@ProcessQue
	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, 60000				; 0000ea60H
	cmp	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	SHORT $LN19@ProcessQue
$LN18@ProcessQue:

; 779  : 						{
; 780  : 							//if there is someone who needs to use the runway after us
; 781  : 							info->status = lAborted;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [ecx+8], 5

; 782  : 							SendCmdMessage(aircraft,info);	

	mov	edx, DWORD PTR _info$[ebp]
	push	edx
	mov	eax, DWORD PTR _aircraft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage
$LN19@ProcessQue:

; 783  : 						}
; 784  : 					}
; 785  : 					//need to warn off if there is someone in the way
; 786  : 					CheckFinalApproach(aircraft, info);

	mov	ecx, DWORD PTR _info$[ebp]
	push	ecx
	mov	edx, DWORD PTR _aircraft$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckFinalApproach@ATCBrain@@AAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::CheckFinalApproach

; 787  : 					info = info->next;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _info$[ebp], ecx

; 788  : 					//if they land the land() function will update their status
; 789  : 					break;

	jmp	$LN102@ProcessQue
$LN17@ProcessQue:

; 790  : 				case lTaxiOff:
; 791  : 				case tFlyOut:
; 792  : 					info = info->next;

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _info$[ebp], eax

; 793  : 					RemoveTraffic(deleteInfo->aircraftID, queue);

	mov	ecx, DWORD PTR _queue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _deleteInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR [edx]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveTraffic@ATCBrain@@QAEXVVU_ID@@H@Z ; ATCBrain::RemoveTraffic

; 794  : 					break;

	jmp	$LN102@ProcessQue
$LN16@ProcessQue:

; 795  : 
; 796  : 				case tReqTaxi:
; 797  : 				case tReqTakeoff:	
; 798  : 				case tTaxiBack:
; 799  : 					info = info->next;

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _info$[ebp], eax

; 800  : 					if(!aircraft->IsPlayer() && !aircraft->OnGround())

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	jne	SHORT $LN15@ProcessQue
	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	jne	SHORT $LN15@ProcessQue

; 801  : 						RemoveTraffic(deleteInfo->aircraftID, queue);

	mov	ecx, DWORD PTR _queue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _deleteInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR [edx]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveTraffic@ATCBrain@@QAEXVVU_ID@@H@Z ; ATCBrain::RemoveTraffic
$LN15@ProcessQue:

; 802  : 					break;

	jmp	$LN102@ProcessQue
$LN14@ProcessQue:

; 803  : 
; 804  : 				case lReqClearance:				
; 805  : 					info = info->next;

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _info$[ebp], eax

; 806  : 					if(!aircraft->IsPlayer() && aircraft->OnGround())

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	jne	SHORT $LN13@ProcessQue
	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	SHORT $LN13@ProcessQue

; 807  : 						RemoveTraffic(deleteInfo->aircraftID, queue);

	mov	ecx, DWORD PTR _queue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _deleteInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR [edx]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveTraffic@ATCBrain@@QAEXVVU_ID@@H@Z ; ATCBrain::RemoveTraffic
$LN13@ProcessQue:

; 808  : 					break;

	jmp	$LN102@ProcessQue
$LN12@ProcessQue:

; 809  : 
; 810  : 				case lReqEmerClearance:				
; 811  : 					info = info->next;

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _info$[ebp], eax

; 812  : 					if(!aircraft->IsPlayer() && aircraft->OnGround())

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	jne	SHORT $LN11@ProcessQue
	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	SHORT $LN11@ProcessQue

; 813  : 						RemoveTraffic(deleteInfo->aircraftID, queue);

	mov	ecx, DWORD PTR _queue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _deleteInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR [edx]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveTraffic@ATCBrain@@QAEXVVU_ID@@H@Z ; ATCBrain::RemoveTraffic
$LN11@ProcessQue:

; 814  : 					break;

	jmp	$LN102@ProcessQue
$LN10@ProcessQue:

; 815  : 
; 816  : 				case lEmergencyToBase:
; 817  : 				case lEmergencyToFinal:	
; 818  : 				case lEmergencyOnFinal:
; 819  : 					info = info->next;

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _info$[ebp], eax

; 820  : 					if(!aircraft->IsPlayer() && aircraft->OnGround())

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	jne	SHORT $LN9@ProcessQue
	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	SHORT $LN9@ProcessQue

; 821  : 						RemoveTraffic(deleteInfo->aircraftID, queue);

	mov	ecx, DWORD PTR _queue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _deleteInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR [edx]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveTraffic@ATCBrain@@QAEXVVU_ID@@H@Z ; ATCBrain::RemoveTraffic
$LN9@ProcessQue:

; 822  : 					break;				

	jmp	SHORT $LN102@ProcessQue
$LN8@ProcessQue:

; 823  : 				
; 824  : 				case lCrashed:
; 825  : 					info = info->next;

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _info$[ebp], eax

; 826  : 					break;

	jmp	SHORT $LN102@ProcessQue
$LN7@ProcessQue:

; 827  : 
; 828  : 				case lIngressing:
; 829  : 				case lTakingPosition:
; 830  : 				case lAborted:
; 831  : 					info = info->next;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _info$[ebp], edx

; 832  : 					if(!aircraft->IsPlayer() && aircraft->OnGround())

	mov	ecx, DWORD PTR _aircraft$[ebp]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	jne	SHORT $LN6@ProcessQue
	mov	eax, DWORD PTR _aircraft$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	eax, DWORD PTR [edx+148]
	call	eax
	test	eax, eax
	je	SHORT $LN6@ProcessQue

; 833  : 						RemoveTraffic(deleteInfo->aircraftID, queue);

	mov	ecx, DWORD PTR _queue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _deleteInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR [edx]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveTraffic@ATCBrain@@QAEXVVU_ID@@H@Z ; ATCBrain::RemoveTraffic
$LN6@ProcessQue:

; 834  : 					break;

	jmp	SHORT $LN102@ProcessQue
$LN5@ProcessQue:

; 835  : 
; 836  : 				case lLanded:
; 837  : 					info = info->next;

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _info$[ebp], eax

; 838  : 					break;

	jmp	SHORT $LN102@ProcessQue
$LN4@ProcessQue:

; 839  : 
; 840  : 				default:
; 841  : 					info = info->next;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _info$[ebp], edx
$LN102@ProcessQue:

; 842  : 					//we should never get here
; 843  : 					ShiWarning("We are in an undefined state, we shouldn't be here");
; 844  : 				}
; 845  : 			}
; 846  : 				
; 847  : 			deleteInfo = info;

	mov	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR _deleteInfo$[ebp], eax

; 848  : 		}
; 849  : 		else

	jmp	SHORT $LN3@ProcessQue
$LN106@ProcessQue:

; 850  : 		{
; 851  : 			info = info->next;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _info$[ebp], edx

; 852  : 			if(!aircraft || (!aircraft->IsAirplane() && deleteInfo->schedTime + 30 * CampaignSeconds < SimLibElapsedTime))

	cmp	DWORD PTR _aircraft$[ebp], 0
	je	SHORT $LN1@ProcessQue
	mov	eax, DWORD PTR _aircraft$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	eax, DWORD PTR [edx+192]
	call	eax
	test	eax, eax
	jne	SHORT $LN2@ProcessQue
	mov	ecx, DWORD PTR _deleteInfo$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, 30000				; 00007530H
	cmp	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	SHORT $LN2@ProcessQue
$LN1@ProcessQue:

; 853  : 				RemoveTraffic(deleteInfo->aircraftID, queue);

	mov	eax, DWORD PTR _queue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _deleteInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR [ecx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveTraffic@ATCBrain@@QAEXVVU_ID@@H@Z ; ATCBrain::RemoveTraffic
$LN2@ProcessQue:

; 854  : 			deleteInfo = info;

	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR _deleteInfo$[ebp], ecx
$LN3@ProcessQue:

; 855  : 		}
; 856  : 	}

	jmp	$LN110@ProcessQue
$LN107@ProcessQue:

; 857  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
$LN141@ProcessQue:
	DD	$LN101@ProcessQue
	DD	$LN14@ProcessQue
	DD	$LN12@ProcessQue
	DD	$LN7@ProcessQue
	DD	$LN7@ProcessQue
	DD	$LN7@ProcessQue
	DD	$LN33@ProcessQue
	DD	$LN31@ProcessQue
	DD	$LN28@ProcessQue
	DD	$LN31@ProcessQue
	DD	$LN28@ProcessQue
	DD	$LN25@ProcessQue
	DD	$LN25@ProcessQue
	DD	$LN5@ProcessQue
	DD	$LN17@ProcessQue
	DD	$LN10@ProcessQue
	DD	$LN10@ProcessQue
	DD	$LN10@ProcessQue
	DD	$LN8@ProcessQue
	DD	$LN16@ProcessQue
	DD	$LN16@ProcessQue
	DD	$LN36@ProcessQue
	DD	$LN84@ProcessQue
	DD	$LN99@ProcessQue
	DD	$LN59@ProcessQue
	DD	$LN64@ProcessQue
	DD	$LN49@ProcessQue
	DD	$LN40@ProcessQue
	DD	$LN17@ProcessQue
	DD	$LN16@ProcessQue
?ProcessQueue@ATCBrain@@AAEXH@Z ENDP			; ATCBrain::ProcessQueue
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_info$2 = -348						; size = 32
$T3 = -316						; size = 8
_landInfo$4 = -308					; size = 32
$T5 = -276						; size = 8
$T6 = -268						; size = 8
$T7 = -260						; size = 8
$T8 = -252						; size = 8
$T9 = -244						; size = 8
$T10 = -236						; size = 8
$T11 = -228						; size = 8
_min$ = -220						; size = 4
_findWalker$12 = -216					; size = 12
_findWalker$13 = -204					; size = 12
_sit$ = -192						; size = 12
tv1422 = -180						; size = 4
tv1029 = -176						; size = 4
tv1038 = -172						; size = 4
_max$ = -168						; size = 4
_groundZ$14 = -164					; size = 4
tv1139 = -160						; size = 4
tv1424 = -156						; size = 4
tv1043 = -152						; size = 4
_groundZ$15 = -148					; size = 4
_queue$ = -144						; size = 4
_AirBase$16 = -140					; size = 4
tv1034 = -136						; size = 4
_dy$ = -132						; size = 4
_cosAngle$ = -128					; size = 4
_dx$ = -124						; size = 4
tv475 = -120						; size = 4
tv963 = -116						; size = 4
tv500 = -112						; size = 4
_AirBase$17 = -108					; size = 4
tv453 = -104						; size = 4
tv784 = -100						; size = 4
tv526 = -96						; size = 4
tv81 = -92						; size = 4
_gy$18 = -88						; size = 2
_gx$19 = -84						; size = 2
_gx$20 = -80						; size = 2
_gy$21 = -76						; size = 2
_session$ = -72						; size = 4
tv225 = -68						; size = 4
_curObj$22 = -64					; size = 4
_curObj$23 = -60					; size = 4
_radioMessage$ = -56					; size = 4
_playerInfo$ = -52					; size = 4
_this$ = -48						; size = 4
_player$ = -44						; size = 4
_pos$24 = -40						; size = 12
_pos$25 = -28						; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?ProcessPlayers@ATCBrain@@AAEXXZ PROC			; ATCBrain::ProcessPlayers
; _this$ = ecx

; 864  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ProcessPlayers@ATCBrain@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 336				; 00000150H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 865  : 	float				dx, dy, cosAngle;
; 866  : 	int					queue;
; 867  : 	runwayQueueStruct	*playerInfo;
; 868  : 	FalconSessionEntity	*session;
; 869  : 	ulong				min, max;
; 870  : 	AircraftClass		*player;
; 871  : 	FalconRadioChatterMessage	*radioMessage;
; 872  : 	
; 873  : 	VuSessionsIterator		sit(FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN78@ProcessPla
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv81[ebp], eax
	jmp	SHORT $LN79@ProcessPla
$LN78@ProcessPla:
	mov	DWORD PTR tv81[ebp], 0
$LN79@ProcessPla:
	mov	ecx, DWORD PTR tv81[ebp]
	push	ecx
	lea	ecx, DWORD PTR _sit$[ebp]
	call	??0VuSessionsIterator@@QAE@PAVVuGroupEntity@@@Z ; VuSessionsIterator::VuSessionsIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 874  : 	session = (FalconSessionEntity*) sit.GetFirst();

	lea	ecx, DWORD PTR _sit$[ebp]
	call	?GetFirst@VuSessionsIterator@@QAEPAVVuSessionEntity@@XZ ; VuSessionsIterator::GetFirst
	mov	DWORD PTR _session$[ebp], eax
$LN75@ProcessPla:

; 875  : 	while (session)

	cmp	DWORD PTR _session$[ebp], 0
	je	$LN74@ProcessPla

; 876  : 	{
; 877  : 		player = (AircraftClass*) session->GetPlayerEntity();

	mov	ecx, DWORD PTR _session$[ebp]
	call	?GetPlayerEntity@FalconSessionEntity@@QBEPAVFalconEntity@@XZ ; FalconSessionEntity::GetPlayerEntity
	mov	DWORD PTR _player$[ebp], eax

; 878  : 		if (player && player->IsAirplane())

	cmp	DWORD PTR _player$[ebp], 0
	je	$LN3@ProcessPla
	mov	edx, DWORD PTR _player$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _player$[ebp]
	mov	edx, DWORD PTR [eax+192]
	call	edx
	test	eax, eax
	je	$LN3@ProcessPla

; 879  : 		{
; 880  : 			dx = player->XPos() - self->XPos();

	mov	ecx, DWORD PTR _player$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv1029[ebp]
	movss	xmm0, DWORD PTR tv1029[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movss	DWORD PTR tv1422[ebp], xmm0
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv1034[ebp]
	movss	xmm0, DWORD PTR tv1422[ebp]
	subss	xmm0, DWORD PTR tv1034[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 881  : 			dy = player->YPos() - self->YPos();

	mov	ecx, DWORD PTR _player$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv1038[ebp]
	movss	xmm0, DWORD PTR tv1038[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	movss	DWORD PTR tv1424[ebp], xmm0
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv1043[ebp]
	movss	xmm0, DWORD PTR tv1424[ebp]
	subss	xmm0, DWORD PTR tv1043[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 882  : 			
; 883  : 			//if they're more than 30nm away, we don't care what they're doing
; 884  : 			if(dx*dx + dy*dy < APPROACH_RANGE * NM_TO_FT * NM_TO_FT)

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@50f791f7
	comiss	xmm1, xmm0
	jbe	$LN3@ProcessPla

; 885  : 			{
; 886  : 				playerInfo = InList(player->Id());

	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _player$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InList@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@@Z ; ATCBrain::InList
	mov	DWORD PTR _playerInfo$[ebp], eax

; 887  : 				if( playerInfo )

	cmp	DWORD PTR _playerInfo$[ebp], 0
	je	$LN71@ProcessPla

; 888  : 				{
; 889  : 					//total hack to make sure this variable is correct
; 890  : 					player->DBrain()->isWing = player->GetCampaignObject()->GetComponentIndex(player);

	mov	eax, DWORD PTR _player$[ebp]
	push	eax
	mov	ecx, DWORD PTR _player$[ebp]
	call	?GetCampaignObject@SimBaseClass@@QAEPAVCampBaseClass@@XZ ; SimBaseClass::GetCampaignObject
	mov	ecx, eax
	call	?GetComponentIndex@CampBaseClass@@QAEHPAVVuEntity@@@Z ; CampBaseClass::GetComponentIndex
	mov	esi, eax
	mov	ecx, DWORD PTR _player$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	DWORD PTR [eax+24], esi

; 891  : 
; 892  : 					queue = PtHeaderDataTable[playerInfo->rwindex].runwayNum;

	mov	ecx, DWORD PTR _playerInfo$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	ecx, BYTE PTR [eax+edx+24]
	mov	DWORD PTR _queue$[ebp], ecx

; 893  : 
; 894  : 					cosAngle = DetermineAngle(player, playerInfo->rwindex, playerInfo->status);

	mov	edx, DWORD PTR _playerInfo$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _playerInfo$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _player$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DetermineAngle@ATCBrain@@QAEMPAVAircraftClass@@HW4AtcStatusEnum@@@Z ; ATCBrain::DetermineAngle
	fstp	DWORD PTR _cosAngle$[ebp]

; 895  : 
; 896  : 					CalculateMinMaxTime(player, playerInfo->rwindex, 
; 897  : 								playerInfo->status, &min, &max, cosAngle);

	push	ecx
	movss	xmm0, DWORD PTR _cosAngle$[ebp]
	movss	DWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _max$[ebp]
	push	ecx
	lea	edx, DWORD PTR _min$[ebp]
	push	edx
	mov	eax, DWORD PTR _playerInfo$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _playerInfo$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _player$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateMinMaxTime@ATCBrain@@QAEXPAVAircraftClass@@HW4AtcStatusEnum@@PAK2M@Z ; ATCBrain::CalculateMinMaxTime

; 898  : 
; 899  : 
; 900  : 					switch(playerInfo->status)

	mov	edx, DWORD PTR _playerInfo$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR tv225[ebp], eax
	mov	ecx, DWORD PTR tv225[ebp]
	sub	ecx, 3
	mov	DWORD PTR tv225[ebp], ecx
	cmp	DWORD PTR tv225[ebp], 26		; 0000001aH
	ja	$LN21@ProcessPla
	mov	edx, DWORD PTR tv225[ebp]
	movzx	eax, BYTE PTR $LN95@ProcessPla[edx]
	jmp	DWORD PTR $LN97@ProcessPla[eax*4]

; 901  : 					{
; 902  : 					case lCrashed:
; 903  : 						//maybe I should do something here?
; 904  : 						break;

	jmp	$LN69@ProcessPla
$LN67@ProcessPla:

; 905  : 
; 906  : 					case lAborted:
; 907  : 						CheckLanding(player, playerInfo);

	mov	ecx, DWORD PTR _playerInfo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _player$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckLanding@ATCBrain@@QAEHPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::CheckLanding

; 908  : 						break;

	jmp	$LN69@ProcessPla
$LN66@ProcessPla:

; 909  : 
; 910  : 					case lIngressing:
; 911  : 						//we're more than 30nm
; 912  : 					case lTakingPosition:
; 913  : 						//the inbound processor will put the player into a runway queue when 
; 914  : 						//he breaks 15nm.
; 915  : 					case lEmerHold:
; 916  : 						CheckLanding(player, playerInfo);

	mov	eax, DWORD PTR _playerInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _player$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckLanding@ATCBrain@@QAEHPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::CheckLanding

; 917  : 						break;

	jmp	$LN69@ProcessPla
$LN65@ProcessPla:

; 918  : 
; 919  : 					case lHolding:
; 920  : 						if(CheckLanding(player, playerInfo))

	mov	edx, DWORD PTR _playerInfo$[ebp]
	push	edx
	mov	eax, DWORD PTR _player$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckLanding@ATCBrain@@QAEHPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::CheckLanding
	test	eax, eax
	je	SHORT $LN64@ProcessPla

; 921  : 							break;

	jmp	$LN69@ProcessPla
$LN64@ProcessPla:

; 922  : 						
; 923  : 						if(playerInfo->schedTime < SimLibElapsedTime + max - CampaignSeconds * 5)

	mov	ecx, DWORD PTR _max$[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	lea	eax, DWORD PTR [edx+ecx-5000]
	mov	ecx, DWORD PTR _playerInfo$[ebp]
	cmp	DWORD PTR [ecx+12], eax
	jae	SHORT $LN61@ProcessPla

; 924  : 						{
; 925  : 							if(cosAngle < 0.0F)

	movss	xmm0, DWORD PTR __real@00000000
	comiss	xmm0, DWORD PTR _cosAngle$[ebp]
	jbe	SHORT $LN62@ProcessPla

; 926  : 							{
; 927  : 								playerInfo->status 	= lToBase;

	mov	edx, DWORD PTR _playerInfo$[ebp]
	mov	DWORD PTR [edx+8], 9

; 928  : 								SendCmdMessage(player, playerInfo);

	mov	eax, DWORD PTR _playerInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _player$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage

; 929  : 							}
; 930  : 							else

	jmp	SHORT $LN61@ProcessPla
$LN62@ProcessPla:

; 931  : 							{
; 932  : 								playerInfo->status 	= lToFinal;

	mov	edx, DWORD PTR _playerInfo$[ebp]
	mov	DWORD PTR [edx+8], 10			; 0000000aH

; 933  : 								SendCmdMessage(player, playerInfo);

	mov	eax, DWORD PTR _playerInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _player$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage
$LN61@ProcessPla:

; 934  : 							}
; 935  : 						}
; 936  : 						break;

	jmp	$LN69@ProcessPla
$LN60@ProcessPla:

; 937  : 
; 938  : 					case lEmergencyToBase:
; 939  : 					case lEmergencyToFinal:
; 940  : 						CheckForTraffic(player, playerInfo);      //RAS - 20Jan04 - traffic calls

	mov	edx, DWORD PTR _playerInfo$[ebp]
	push	edx
	mov	eax, DWORD PTR _player$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckForTraffic@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::CheckForTraffic

; 941  : 						CheckLanding(player, playerInfo);

	mov	ecx, DWORD PTR _playerInfo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _player$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckLanding@ATCBrain@@QAEHPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::CheckLanding

; 942  : 						break;

	jmp	$LN69@ProcessPla
$LN59@ProcessPla:

; 943  : 
; 944  : 					case lFirstLeg:
; 945  : 					case lToBase:
; 946  : 					case lToFinal:
; 947  : 						CheckForTraffic(player, playerInfo);		//RAS - 20Jan04 -  traffic calls

	mov	eax, DWORD PTR _playerInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _player$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckForTraffic@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::CheckForTraffic

; 948  : 						if(CheckLanding(player, playerInfo))

	mov	edx, DWORD PTR _playerInfo$[ebp]
	push	edx
	mov	eax, DWORD PTR _player$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckLanding@ATCBrain@@QAEHPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::CheckLanding
	test	eax, eax
	je	SHORT $LN58@ProcessPla

; 949  : 							break;

	jmp	$LN69@ProcessPla
$LN58@ProcessPla:

; 950  : 
; 951  : 						if(CheckVector(player, playerInfo))

	mov	ecx, DWORD PTR _playerInfo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _player$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckVector@ATCBrain@@QAEHPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::CheckVector
	test	eax, eax
	je	SHORT $LN57@ProcessPla

; 952  : 							SendCmdMessage(player, playerInfo);

	mov	eax, DWORD PTR _playerInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _player$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage
$LN57@ProcessPla:

; 953  : 						break;

	jmp	$LN69@ProcessPla
$LN56@ProcessPla:

; 954  : 
; 955  : 					case lEmergencyOnFinal:
; 956  : 						CheckForTraffic(player, playerInfo);	//RAS - 20Jan04 -  traffic calls

	mov	edx, DWORD PTR _playerInfo$[ebp]
	push	edx
	mov	eax, DWORD PTR _player$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckForTraffic@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::CheckForTraffic

; 957  : 						CheckLanding(player, playerInfo);

	mov	ecx, DWORD PTR _playerInfo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _player$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckLanding@ATCBrain@@QAEHPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::CheckLanding

; 958  : 						break;

	jmp	$LN69@ProcessPla
$LN55@ProcessPla:

; 959  : 
; 960  : 					case lOnFinal:
; 961  : 					case lClearToLand:
; 962  : //						CheckForTraffic(player, playerInfo);	//RAS - 20Jan04 -  add later
; 963  : 						if(CheckLanding(player, playerInfo))

	mov	eax, DWORD PTR _playerInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _player$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckLanding@ATCBrain@@QAEHPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::CheckLanding
	test	eax, eax
	je	SHORT $LN54@ProcessPla

; 964  : 							break;

	jmp	$LN69@ProcessPla
$LN54@ProcessPla:

; 965  : 
; 966  : 						if(CheckVector(player, playerInfo))

	mov	edx, DWORD PTR _playerInfo$[ebp]
	push	edx
	mov	eax, DWORD PTR _player$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckVector@ATCBrain@@QAEHPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::CheckVector
	test	eax, eax
	je	SHORT $LN53@ProcessPla

; 967  : 							SendCmdMessage(player, playerInfo);

	mov	ecx, DWORD PTR _playerInfo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _player$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage
$LN53@ProcessPla:

; 968  : 						break;

	jmp	$LN69@ProcessPla
$LN52@ProcessPla:

; 969  : 
; 970  : 					case lLanded:
; 971  : 						if(CheckTakeoff(player, playerInfo))

	mov	eax, DWORD PTR _playerInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _player$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckTakeoff@ATCBrain@@QAEHPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::CheckTakeoff
	test	eax, eax
	je	SHORT $LN51@ProcessPla

; 972  : 							break;

	jmp	$LN69@ProcessPla
$LN51@ProcessPla:

; 973  : 
; 974  : 						if(CheckLanding(player, playerInfo))

	mov	edx, DWORD PTR _playerInfo$[ebp]
	push	edx
	mov	eax, DWORD PTR _player$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckLanding@ATCBrain@@QAEHPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::CheckLanding
	test	eax, eax
	je	SHORT $LN50@ProcessPla

; 975  : 							break;

	jmp	$LN69@ProcessPla
$LN50@ProcessPla:

; 976  : 
; 977  : 						CheckIfBlockingRunway(player, playerInfo);

	mov	ecx, DWORD PTR _playerInfo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _player$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckIfBlockingRunway@ATCBrain@@QAEHPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::CheckIfBlockingRunway

; 978  : 
; 979  : 					// OW: Jackals "scold-on-bounce" fix
; 980  : 					#if 1
; 981  : 					// JB 000421
; 982  : 						  if (player->GetKias() < 50)

	mov	eax, DWORD PTR _player$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _player$[ebp]
	mov	eax, DWORD PTR [edx+224]
	call	eax
	fstp	DWORD PTR tv1139[ebp]
	movss	xmm0, DWORD PTR __real@42480000
	comiss	xmm0, DWORD PTR tv1139[ebp]
	jbe	SHORT $LN49@ProcessPla

; 983  : 						  {
; 984  : 							   player->DBrain()->SetWaitTimer(SimLibElapsedTime);

	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	push	ecx
	mov	ecx, DWORD PTR _player$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?SetWaitTimer@DigitalBrain@@QAEXK@Z	; DigitalBrain::SetWaitTimer

; 985  : 							   RemoveTraffic(player->Id(), PtHeaderDataTable[playerInfo->rwindex].runwayNum);

	mov	edx, DWORD PTR _playerInfo$[ebp]
	mov	eax, DWORD PTR [edx+20]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	edx, BYTE PTR [ecx+eax+24]
	push	edx
	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	mov	ecx, DWORD PTR _player$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveTraffic@ATCBrain@@QAEXVVU_ID@@H@Z ; ATCBrain::RemoveTraffic
$LN49@ProcessPla:

; 986  : 						  }
; 987  : 					// JB 000421
; 988  : 					#endif
; 989  : 
; 990  : 						break;

	jmp	$LN69@ProcessPla
$LN48@ProcessPla:

; 991  : 
; 992  : 					case lTaxiOff:
; 993  : 						if(CheckTakeoff(player, playerInfo))

	mov	eax, DWORD PTR _playerInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _player$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckTakeoff@ATCBrain@@QAEHPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::CheckTakeoff
	test	eax, eax
	je	SHORT $LN47@ProcessPla

; 994  : 							break;

	jmp	$LN69@ProcessPla
$LN47@ProcessPla:

; 995  : 
; 996  : 						RemoveTraffic(player->Id(), PtHeaderDataTable[playerInfo->rwindex].runwayNum);

	mov	edx, DWORD PTR _playerInfo$[ebp]
	mov	eax, DWORD PTR [edx+20]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	edx, BYTE PTR [ecx+eax+24]
	push	edx
	lea	eax, DWORD PTR $T11[ebp]
	push	eax
	mov	ecx, DWORD PTR _player$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveTraffic@ATCBrain@@QAEXVVU_ID@@H@Z ; ATCBrain::RemoveTraffic

; 997  : 
; 998  : 						CheckIfBlockingRunway(player, playerInfo);

	mov	eax, DWORD PTR _playerInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _player$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckIfBlockingRunway@ATCBrain@@QAEHPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::CheckIfBlockingRunway

; 999  : 						break;

	jmp	$LN69@ProcessPla
$LN46@ProcessPla:

; 1000 : 
; 1001 : 					case tEmerStop:
; 1002 : 						CheckTakeoff(player, playerInfo);						

	mov	edx, DWORD PTR _playerInfo$[ebp]
	push	edx
	mov	eax, DWORD PTR _player$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckTakeoff@ATCBrain@@QAEHPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::CheckTakeoff

; 1003 : 						//check to see if emergency is over, if so continue on
; 1004 : 						break;

	jmp	$LN69@ProcessPla
$LN45@ProcessPla:

; 1005 : 
; 1006 : 					case tWait:
; 1007 : 					case tPrepToTakeRunway:
; 1008 : 					case tTaxi:
; 1009 : 					case tTaxiBack:
; 1010 : 						if(CheckTakeoff(player, playerInfo))

	mov	ecx, DWORD PTR _playerInfo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _player$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckTakeoff@ATCBrain@@QAEHPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::CheckTakeoff
	test	eax, eax
	je	SHORT $LN44@ProcessPla

; 1011 : 						{
; 1012 : 							break;

	jmp	$LN69@ProcessPla
	jmp	SHORT $LN42@ProcessPla
$LN44@ProcessPla:

; 1013 : 						}
; 1014 : 						else if(SimDriver.GetPlayerEntity() == player && gBumpFlag && gBumpTime < SimLibElapsedTime && playerInfo->schedTime + CampaignMinutes < SimLibElapsedTime)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ ; SimulationDriver::GetPlayerEntity
	cmp	eax, DWORD PTR _player$[ebp]
	jne	SHORT $LN42@ProcessPla
	cmp	DWORD PTR ?gBumpFlag@@3HA, 0		; gBumpFlag
	je	SHORT $LN42@ProcessPla
	mov	eax, DWORD PTR ?gBumpTime@@3KA		; gBumpTime
	cmp	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	SHORT $LN42@ProcessPla
	mov	ecx, DWORD PTR _playerInfo$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, 60000				; 0000ea60H
	cmp	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	SHORT $LN42@ProcessPla

; 1015 : 						{
; 1016 : 							player->DBrain()->SetATCFlag(DigitalBrain::TakeoffAborted);

	push	32					; 00000020H
	mov	ecx, DWORD PTR _player$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?SetATCFlag@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetATCFlag

; 1017 : 							OTWDriver.ExitMenu(DIK_E);

	push	18					; 00000012H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ExitMenu@OTWDriverClass@@QAEXK@Z	; OTWDriverClass::ExitMenu
$LN42@ProcessPla:

; 1018 : 						}
; 1019 : 						
; 1020 : 						CheckIfBlockingRunway(player, playerInfo);						

	mov	eax, DWORD PTR _playerInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _player$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckIfBlockingRunway@ATCBrain@@QAEHPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::CheckIfBlockingRunway

; 1021 : 						break;

	jmp	$LN69@ProcessPla
$LN41@ProcessPla:

; 1022 : 
; 1023 : 					case tHoldShort:
; 1024 : 						if(CheckTakeoff(player, playerInfo))

	mov	edx, DWORD PTR _playerInfo$[ebp]
	push	edx
	mov	eax, DWORD PTR _player$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckTakeoff@ATCBrain@@QAEHPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::CheckTakeoff
	test	eax, eax
	je	SHORT $LN40@ProcessPla

; 1025 : 						{
; 1026 : 							break;

	jmp	$LN69@ProcessPla
$LN40@ProcessPla:

; 1027 : 						}
; 1028 : 
; 1029 : 						CheckIfBlockingRunway(player, playerInfo);

	mov	ecx, DWORD PTR _playerInfo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _player$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckIfBlockingRunway@ATCBrain@@QAEHPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::CheckIfBlockingRunway

; 1030 : 						break;

	jmp	$LN69@ProcessPla
$LN39@ProcessPla:

; 1031 : 
; 1032 : 					case tTakeRunway:
; 1033 : 						CheckTakeoff(player, playerInfo);

	mov	eax, DWORD PTR _playerInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _player$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckTakeoff@ATCBrain@@QAEHPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::CheckTakeoff

; 1034 : 						break;

	jmp	$LN69@ProcessPla
$LN38@ProcessPla:

; 1035 : 
; 1036 : 					case tTakeoff:
; 1037 : 						if(!player->DBrain()->IsSetATC(DigitalBrain::MissionCanceled) && CheckTakeoff(player, playerInfo) )

	push	64					; 00000040H
	mov	ecx, DWORD PTR _player$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?IsSetATC@DigitalBrain@@QAEHH@Z		; DigitalBrain::IsSetATC
	test	eax, eax
	jne	SHORT $LN37@ProcessPla
	mov	edx, DWORD PTR _playerInfo$[ebp]
	push	edx
	mov	eax, DWORD PTR _player$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckTakeoff@ATCBrain@@QAEHPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::CheckTakeoff
	test	eax, eax
	je	SHORT $LN37@ProcessPla

; 1038 : 						{
; 1039 : 							break;

	jmp	$LN69@ProcessPla
	jmp	$LN33@ProcessPla
$LN37@ProcessPla:

; 1040 : 						}
; 1041 : 						else if(SimDriver.GetPlayerEntity() == player && gBumpFlag && gBumpTime < SimLibElapsedTime && playerInfo->schedTime + CampaignMinutes < SimLibElapsedTime)

	mov	ecx, OFFSET ?SimDriver@@3VSimulationDriver@@A ; SimDriver
	call	?GetPlayerEntity@SimulationDriver@@QBEPAVSimMoverClass@@XZ ; SimulationDriver::GetPlayerEntity
	cmp	eax, DWORD PTR _player$[ebp]
	jne	SHORT $LN35@ProcessPla
	cmp	DWORD PTR ?gBumpFlag@@3HA, 0		; gBumpFlag
	je	SHORT $LN35@ProcessPla
	mov	ecx, DWORD PTR ?gBumpTime@@3KA		; gBumpTime
	cmp	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	SHORT $LN35@ProcessPla
	mov	edx, DWORD PTR _playerInfo$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, 60000				; 0000ea60H
	cmp	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	SHORT $LN35@ProcessPla

; 1042 : 						{
; 1043 : 							player->DBrain()->SetATCFlag(DigitalBrain::TakeoffAborted);

	push	32					; 00000020H
	mov	ecx, DWORD PTR _player$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?SetATCFlag@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetATCFlag

; 1044 : 							OTWDriver.ExitMenu(DIK_E);

	push	18					; 00000012H
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?ExitMenu@OTWDriverClass@@QAEXK@Z	; OTWDriverClass::ExitMenu
	jmp	$LN33@ProcessPla
$LN35@ProcessPla:

; 1045 : 						}
; 1046 : 						else if(!player->af->IsSet(AirframeClass::GearBroken) && playerInfo->lastContacted + 60 * CampaignSeconds < SimLibElapsedTime)

	push	2048					; 00000800H
	mov	ecx, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [ecx+932]
	call	?IsSet@AirframeClass@@QBEHH@Z		; AirframeClass::IsSet
	test	eax, eax
	jne	$LN33@ProcessPla
	mov	edx, DWORD PTR _playerInfo$[ebp]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 60000				; 0000ea60H
	cmp	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	$LN33@ProcessPla

; 1047 : 						{
; 1048 : 							if(SimLibElapsedTime > playerInfo->schedTime + 4 * CampaignMinutes)	 // 06FEB04 - FRB - was 2 minutes

	mov	ecx, DWORD PTR _playerInfo$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, 240000				; 0003a980H
	cmp	DWORD PTR ?SimLibElapsedTime@@3KA, edx	; SimLibElapsedTime
	jbe	$LN32@ProcessPla

; 1049 : 							{					
; 1050 : 								if(rand()%3)

	call	_rand
	cdq
	mov	ecx, 3
	idiv	ecx
	test	edx, edx
	je	SHORT $LN31@ProcessPla

; 1051 : 									SendCallFromATC (self, player, rcDISRUPTINGTRAFFIC, FalconLocalGame);								

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN80@ProcessPla
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv453[ebp], eax
	jmp	SHORT $LN81@ProcessPla
$LN80@ProcessPla:
	mov	DWORD PTR tv453[ebp], 0
$LN81@ProcessPla:
	mov	eax, DWORD PTR tv453[ebp]
	push	eax
	push	48					; 00000030H
	mov	ecx, DWORD PTR _player$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?SendCallFromATC@@YAXPAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; SendCallFromATC
	add	esp, 16					; 00000010H

; 1052 : 								else

	jmp	SHORT $LN30@ProcessPla
$LN31@ProcessPla:

; 1053 : 									SendCallFromATC (self, player, rcHURRYUP, FalconLocalGame);		

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN82@ProcessPla
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv475[ebp], eax
	jmp	SHORT $LN83@ProcessPla
$LN82@ProcessPla:
	mov	DWORD PTR tv475[ebp], 0
$LN83@ProcessPla:
	mov	edx, DWORD PTR tv475[ebp]
	push	edx
	push	96					; 00000060H
	mov	eax, DWORD PTR _player$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?SendCallFromATC@@YAXPAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; SendCallFromATC
	add	esp, 16					; 00000010H
$LN30@ProcessPla:
	jmp	$LN26@ProcessPla
$LN32@ProcessPla:

; 1054 : 							}
; 1055 : 							else if(SimLibElapsedTime > playerInfo->schedTime + 2 * CampaignMinutes)	 // 06FEB04 - FRB - was 1 minute

	mov	eax, DWORD PTR _playerInfo$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 120000				; 0001d4c0H
	cmp	DWORD PTR ?SimLibElapsedTime@@3KA, ecx	; SimLibElapsedTime
	jbe	SHORT $LN28@ProcessPla

; 1056 : 							{
; 1057 : 								SendCallFromATC (self, player, rcHURRYUP, FalconLocalGame);									

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN84@ProcessPla
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv500[ebp], eax
	jmp	SHORT $LN85@ProcessPla
$LN84@ProcessPla:
	mov	DWORD PTR tv500[ebp], 0
$LN85@ProcessPla:
	mov	eax, DWORD PTR tv500[ebp]
	push	eax
	push	96					; 00000060H
	mov	ecx, DWORD PTR _player$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?SendCallFromATC@@YAXPAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; SendCallFromATC
	add	esp, 16					; 00000010H
	jmp	$LN26@ProcessPla
$LN28@ProcessPla:

; 1058 : 							}
; 1059 : 							else if(SimLibElapsedTime > playerInfo->schedTime + 60 * CampaignSeconds)	 // 06FEB04 - FRB - was 15 seconds

	mov	ecx, DWORD PTR _playerInfo$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, 60000				; 0000ea60H
	cmp	DWORD PTR ?SimLibElapsedTime@@3KA, edx	; SimLibElapsedTime
	jbe	$LN26@ProcessPla

; 1060 : 							{
; 1061 : 								//yell to hurry up
; 1062 : 								radioMessage = CreateCallFromATC (self, player, rcEXPEDITEDEPARTURE, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN86@ProcessPla
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv526[ebp], eax
	jmp	SHORT $LN87@ProcessPla
$LN86@ProcessPla:
	mov	DWORD PTR tv526[ebp], 0
$LN87@ProcessPla:
	mov	ecx, DWORD PTR tv526[ebp]
	push	ecx
	push	307					; 00000133H
	mov	edx, DWORD PTR _player$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$[ebp], eax

; 1063 : 								if(runwayQueue[queue]->status == lOnFinal)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _queue$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	cmp	DWORD PTR [edx+8], 11			; 0000000bH
	jne	SHORT $LN25@ProcessPla

; 1064 : 									radioMessage->dataBlock.edata[3] = 1;

	mov	eax, 2
	imul	eax, 3
	mov	ecx, 1
	mov	edx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [edx+eax+64], cx

; 1065 : 								else

	jmp	SHORT $LN24@ProcessPla
$LN25@ProcessPla:

; 1066 : 									radioMessage->dataBlock.edata[3] = 0;

	mov	eax, 2
	imul	eax, 3
	xor	ecx, ecx
	mov	edx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [edx+eax+64], cx
$LN24@ProcessPla:

; 1067 : 								FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	eax, DWORD PTR _radioMessage$[ebp]
	push	eax
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8
$LN26@ProcessPla:

; 1068 : 							}
; 1069 : 							playerInfo->lastContacted = SimLibElapsedTime;

	mov	ecx, DWORD PTR _playerInfo$[ebp]
	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR [ecx+16], edx
$LN33@ProcessPla:

; 1070 : 						}
; 1071 : 						break;

	jmp	SHORT $LN69@ProcessPla
$LN23@ProcessPla:

; 1072 : 					case tFlyOut:
; 1073 : 						if(player->AutopilotType() != AircraftClass::CombatAP)

	mov	ecx, DWORD PTR _player$[ebp]
	call	?AutopilotType@AircraftClass@@QAE?AW4AutoPilotType@1@XZ ; AircraftClass::AutopilotType
	cmp	eax, 2
	je	SHORT $LN22@ProcessPla

; 1074 : 						{
; 1075 : 							player->DBrain()->SetATCStatus(noATC);

	push	0
	mov	ecx, DWORD PTR _player$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?SetATCStatus@DigitalBrain@@QAEXW4AtcStatusEnum@@@Z ; DigitalBrain::SetATCStatus

; 1076 : 							//remove from list
; 1077 : 							RemoveTraffic(player->Id(), PtHeaderDataTable[playerInfo->rwindex].runwayNum);

	mov	eax, DWORD PTR _playerInfo$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR ?PtHeaderDataTable@@3PAUPtHeaderDataType@@A ; PtHeaderDataTable
	movsx	eax, BYTE PTR [edx+ecx+24]
	push	eax
	lea	ecx, DWORD PTR $T10[ebp]
	push	ecx
	mov	ecx, DWORD PTR _player$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveTraffic@ATCBrain@@QAEXVVU_ID@@H@Z ; ATCBrain::RemoveTraffic
$LN22@ProcessPla:
$LN21@ProcessPla:
$LN69@ProcessPla:

; 1078 : 						}
; 1079 : 						break;
; 1080 : 					default:
; 1081 : 						//we should never get here
; 1082 : 						ShiWarning("We are in an undefined state, we shouldn't be here");
; 1083 : 					}
; 1084 : 				}
; 1085 : 				else

	jmp	$LN3@ProcessPla
$LN71@ProcessPla:

; 1086 : 				{
; 1087 : 					if(GetTTRelations(self->GetTeam(), player->GetTeam()) < Hostile)

	mov	ecx, DWORD PTR _player$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _player$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	call	?GetTTRelations@@YAHEE@Z		; GetTTRelations
	add	esp, 8
	cmp	eax, 4
	jge	$LN3@ProcessPla

; 1088 : 					{
; 1089 : 						//they haven't called us yet
; 1090 : 						if(player->OnGround())

	mov	edx, DWORD PTR _player$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _player$[ebp]
	mov	edx, DWORD PTR [eax+148]
	call	edx
	test	eax, eax
	je	$LN18@ProcessPla

; 1091 : 						{
; 1092 : 							//check to see if at their takeoff waypoint, if so request takeoff
; 1093 : 							if(	player->curWaypoint && player->curWaypoint->GetWPAction() == WP_TAKEOFF && !player->DBrain()->isWing &&
; 1094 : 								player->DBrain()->Airbase() == self->Id() && player->DBrain()->IsSetATC(DigitalBrain::RequestTakeoff))

	mov	eax, DWORD PTR _player$[ebp]
	cmp	DWORD PTR [eax+728], 0
	je	$LN17@ProcessPla
	mov	ecx, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [ecx+728]
	call	?GetWPAction@WayPointClass@@QAEHXZ	; WayPointClass::GetWPAction
	cmp	eax, 1
	jne	$LN17@ProcessPla
	mov	ecx, DWORD PTR _player$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN17@ProcessPla
	lea	edx, DWORD PTR $T8[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	push	eax
	lea	ecx, DWORD PTR $T6[ebp]
	push	ecx
	mov	ecx, DWORD PTR _player$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?Airbase@DigitalBrain@@QAE?AVVU_ID@@XZ	; DigitalBrain::Airbase
	mov	ecx, eax
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN17@ProcessPla
	push	128					; 00000080H
	mov	ecx, DWORD PTR _player$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?IsSetATC@DigitalBrain@@QAEHH@Z		; DigitalBrain::IsSetATC
	test	eax, eax
	je	SHORT $LN17@ProcessPla

; 1095 : 							{
; 1096 : 								player->DBrain()->ClearATCFlag(DigitalBrain::RequestTakeoff);

	push	128					; 00000080H
	mov	ecx, DWORD PTR _player$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?ClearATCFlag@DigitalBrain@@QAEXH@Z	; DigitalBrain::ClearATCFlag

; 1097 : 								RequestTakeoff(player);

	mov	eax, DWORD PTR _player$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RequestTakeoff@ATCBrain@@QAEXPAVAircraftClass@@@Z ; ATCBrain::RequestTakeoff

; 1098 : 							}
; 1099 : 							else

	jmp	$LN16@ProcessPla
$LN17@ProcessPla:

; 1100 : 							{
; 1101 : 								//they may have landed without permission
; 1102 : 								if(!player->DBrain()->IsSetATC(DigitalBrain::Landed))

	push	1
	mov	ecx, DWORD PTR _player$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?IsSetATC@DigitalBrain@@QAEHH@Z		; DigitalBrain::IsSetATC
	test	eax, eax
	jne	$LN11@ProcessPla

; 1103 : 								{
; 1104 : 									//landed without permission
; 1105 : 									ObjectiveClass* curObj;
; 1106 : 									//does someone else already have us? if so let them deal with us
; 1107 : 									{
; 1108 : 										// iterator must be destroyed here
; 1109 : 										VuListIterator findWalker (SimDriver.atcList);

	mov	ecx, DWORD PTR ?SimDriver@@3VSimulationDriver@@A+32
	push	ecx
	lea	ecx, DWORD PTR _findWalker$12[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1110 : 										curObj = (ObjectiveClass*)findWalker.GetFirst();

	lea	ecx, DWORD PTR _findWalker$12[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _curObj$22[ebp], eax
$LN14@ProcessPla:

; 1111 : 										while (curObj )

	cmp	DWORD PTR _curObj$22[ebp], 0
	je	SHORT $LN13@ProcessPla

; 1112 : 										{
; 1113 : 											if (
; 1114 : 												curObj && 
; 1115 : 												(curObj != self) && 
; 1116 : 												(curObj->GetType() == TYPE_AIRBASE) && 
; 1117 : 												curObj->brain->InList(player->Id())
; 1118 : 											){

	cmp	DWORD PTR _curObj$22[ebp], 0
	je	SHORT $LN12@ProcessPla
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _curObj$22[ebp]
	cmp	eax, DWORD PTR [edx+4]
	je	SHORT $LN12@ProcessPla
	mov	ecx, DWORD PTR _curObj$22[ebp]
	call	?GetType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetType
	movzx	ecx, al
	cmp	ecx, 1
	jne	SHORT $LN12@ProcessPla
	lea	edx, DWORD PTR $T9[ebp]
	push	edx
	mov	ecx, DWORD PTR _player$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR _curObj$22[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?InList@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@@Z ; ATCBrain::InList
	test	eax, eax
	je	SHORT $LN12@ProcessPla

; 1119 : 												break;

	jmp	SHORT $LN13@ProcessPla
$LN12@ProcessPla:

; 1120 : 											}
; 1121 : 											curObj = (ObjectiveClass*)findWalker.GetNext();

	lea	ecx, DWORD PTR _findWalker$12[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _curObj$22[ebp], eax

; 1122 : 										}

	jmp	SHORT $LN14@ProcessPla
$LN13@ProcessPla:

; 1123 : 									}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _findWalker$12[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator

; 1124 : 
; 1125 : 									if(!curObj){

	cmp	DWORD PTR _curObj$22[ebp], 0
	jne	$LN11@ProcessPla

; 1126 : 										// sfr: fixing xy order 
; 1127 : 										GridIndex gx, gy;
; 1128 : 										//CX = SimToGrid(player->YPos());
; 1129 : 										//CY = SimToGrid(player->XPos());
; 1130 : 										::vector pos = {player->XPos(), player->YPos()};					

	mov	ecx, DWORD PTR _player$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR _pos$25[ebp]
	mov	ecx, DWORD PTR _player$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR _pos$25[ebp+4]
	xor	ecx, ecx
	mov	DWORD PTR _pos$25[ebp+8], ecx

; 1131 : 										ConvertSimToGrid(&pos, &gx, &gy);

	lea	edx, DWORD PTR _gy$18[ebp]
	push	edx
	lea	eax, DWORD PTR _gx$20[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$25[ebp]
	push	ecx
	call	?ConvertSimToGrid@@YAXPAUvector@@PAF1@Z	; ConvertSimToGrid
	add	esp, 12					; 0000000cH

; 1132 : 
; 1133 : 										//we're on our own, so if there is a nearby airbase, he will yell at us
; 1134 : 										Objective AirBase = FindNearbyAirbase(gx, gy);

	movzx	edx, WORD PTR _gy$18[ebp]
	push	edx
	movzx	eax, WORD PTR _gx$20[ebp]
	push	eax
	call	?FindNearbyAirbase@@YAPAVObjectiveClass@@FF@Z ; FindNearbyAirbase
	add	esp, 8
	mov	DWORD PTR _AirBase$17[ebp], eax

; 1135 : 										if(AirBase && player->pctStrength >= 0.99F)

	cmp	DWORD PTR _AirBase$17[ebp], 0
	je	$LN9@ProcessPla
	mov	ecx, DWORD PTR _player$[ebp]
	movss	xmm0, DWORD PTR [ecx+292]
	comiss	xmm0, DWORD PTR __real@3f7d70a4
	jb	$LN9@ProcessPla

; 1136 : 										{
; 1137 : 											float groundZ = OTWDriver.GetGroundLevel (player->XPos(), player->YPos());

	push	0
	mov	ecx, DWORD PTR _player$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _player$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR _groundZ$15[ebp]

; 1138 : 											player->FeatureCollision(groundZ);

	push	ecx
	movss	xmm0, DWORD PTR _groundZ$15[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _player$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _player$[ebp]
	mov	edx, DWORD PTR [eax+444]
	call	edx

; 1139 : 											if(player->onFlatFeature)

	mov	eax, DWORD PTR _player$[ebp]
	cmp	DWORD PTR [eax+668], 0
	je	$LN9@ProcessPla

; 1140 : 											{
; 1141 : 												radioMessage = CreateCallFromATC (AirBase, player, rcTOWERSCOLD3, FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN88@ProcessPla
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv784[ebp], eax
	jmp	SHORT $LN89@ProcessPla
$LN88@ProcessPla:
	mov	DWORD PTR tv784[ebp], 0
$LN89@ProcessPla:
	mov	edx, DWORD PTR tv784[ebp]
	push	edx
	push	312					; 00000138H
	mov	eax, DWORD PTR _player$[ebp]
	push	eax
	mov	ecx, DWORD PTR _AirBase$17[ebp]
	push	ecx
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$[ebp], eax

; 1142 : 												radioMessage->dataBlock.edata[3] = 32767;

	mov	edx, 2
	imul	edx, 3
	mov	eax, 32767				; 00007fffH
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [ecx+edx+64], ax

; 1143 : 												FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	edx, DWORD PTR _radioMessage$[ebp]
	push	edx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8

; 1144 : 												player->DBrain()->SetWaitTimer(SimLibElapsedTime);

	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	push	eax
	mov	ecx, DWORD PTR _player$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?SetWaitTimer@DigitalBrain@@QAEXK@Z	; DigitalBrain::SetWaitTimer
$LN9@ProcessPla:

; 1145 : 											}
; 1146 : 										}
; 1147 : 										runwayQueueStruct landInfo;

	lea	ecx, DWORD PTR _landInfo$4[ebp]
	call	??0runwayQueueStruct@@QAE@XZ

; 1148 : 										player->DBrain()->SetATCFlag(DigitalBrain::Landed);

	push	1
	mov	ecx, DWORD PTR _player$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?SetATCFlag@DigitalBrain@@QAEXH@Z	; DigitalBrain::SetATCFlag

; 1149 : 										landInfo.rwindex = 0;

	mov	DWORD PTR _landInfo$4[ebp+20], 0

; 1150 : 										landInfo.status = lLanded;

	mov	DWORD PTR _landInfo$4[ebp+8], 13	; 0000000dH

; 1151 : 										SendCmdMessage(player, &landInfo);

	lea	ecx, DWORD PTR _landInfo$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _player$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage
$LN11@ProcessPla:

; 1152 : 									}
; 1153 : 								}
; 1154 : 
; 1155 : 								CheckIfBlockingRunway(player, playerInfo);

	mov	eax, DWORD PTR _playerInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _player$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckIfBlockingRunway@ATCBrain@@QAEHPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::CheckIfBlockingRunway
$LN16@ProcessPla:

; 1156 : 							}
; 1157 : 						}
; 1158 : 						else

	jmp	$LN3@ProcessPla
$LN18@ProcessPla:

; 1159 : 						{
; 1160 : 							//they may have taken off without permission
; 1161 : 							if(player->DBrain()->IsSetATC(DigitalBrain::Landed))

	push	1
	mov	ecx, DWORD PTR _player$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?IsSetATC@DigitalBrain@@QAEHH@Z		; DigitalBrain::IsSetATC
	test	eax, eax
	je	$LN3@ProcessPla

; 1162 : 							{
; 1163 : 								//took off without permission
; 1164 : 								ObjectiveClass* curObj;
; 1165 : 								{
; 1166 : 									//does someone else already have us? if so let them deal with us
; 1167 : 									// destroy iterator here
; 1168 : 									VuListIterator findWalker (SimDriver.atcList);

	mov	edx, DWORD PTR ?SimDriver@@3VSimulationDriver@@A+32
	push	edx
	lea	ecx, DWORD PTR _findWalker$13[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1169 : 									curObj = (ObjectiveClass*)findWalker.GetFirst();

	lea	ecx, DWORD PTR _findWalker$13[ebp]
	call	?GetFirst@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetFirst
	mov	DWORD PTR _curObj$23[ebp], eax
$LN6@ProcessPla:

; 1170 : 									while (curObj){

	cmp	DWORD PTR _curObj$23[ebp], 0
	je	SHORT $LN5@ProcessPla

; 1171 : 										if(
; 1172 : 											curObj && (curObj != self) && 
; 1173 : 											(curObj->GetType() == TYPE_AIRBASE) && 
; 1174 : 											(curObj->brain->InList(player->Id()))
; 1175 : 										){

	cmp	DWORD PTR _curObj$23[ebp], 0
	je	SHORT $LN4@ProcessPla
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _curObj$23[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	je	SHORT $LN4@ProcessPla
	mov	ecx, DWORD PTR _curObj$23[ebp]
	call	?GetType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetType
	movzx	edx, al
	cmp	edx, 1
	jne	SHORT $LN4@ProcessPla
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	mov	ecx, DWORD PTR _player$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR _curObj$23[ebp]
	mov	ecx, DWORD PTR [eax+240]
	call	?InList@ATCBrain@@QAEPAUrunwayQueueStruct@@VVU_ID@@@Z ; ATCBrain::InList
	test	eax, eax
	je	SHORT $LN4@ProcessPla

; 1176 : 											break;

	jmp	SHORT $LN5@ProcessPla
$LN4@ProcessPla:

; 1177 : 										}
; 1178 : 										curObj = (ObjectiveClass*)findWalker.GetNext();

	lea	ecx, DWORD PTR _findWalker$13[ebp]
	call	?GetNext@VuListIterator@@QAEPAVVuEntity@@XZ ; VuListIterator::GetNext
	mov	DWORD PTR _curObj$23[ebp], eax

; 1179 : 									}

	jmp	SHORT $LN6@ProcessPla
$LN5@ProcessPla:

; 1180 : 								}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _findWalker$13[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator

; 1181 : 
; 1182 : 								if(!curObj){

	cmp	DWORD PTR _curObj$23[ebp], 0
	jne	$LN3@ProcessPla

; 1183 : 									// sfr: fixing xy order
; 1184 : 									GridIndex gx, gy;
; 1185 : 									//gx = SimToGrid(player->YPos());
; 1186 : 									//gy = SimToGrid(player->XPos());
; 1187 : 									::vector pos = {player->XPos(), player->YPos()};

	mov	ecx, DWORD PTR _player$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR _pos$24[ebp]
	mov	ecx, DWORD PTR _player$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR _pos$24[ebp+4]
	xor	ecx, ecx
	mov	DWORD PTR _pos$24[ebp+8], ecx

; 1188 : 									ConvertSimToGrid(&pos, &gx, &gy);

	lea	edx, DWORD PTR _gy$21[ebp]
	push	edx
	lea	eax, DWORD PTR _gx$19[ebp]
	push	eax
	lea	ecx, DWORD PTR _pos$24[ebp]
	push	ecx
	call	?ConvertSimToGrid@@YAXPAUvector@@PAF1@Z	; ConvertSimToGrid
	add	esp, 12					; 0000000cH

; 1189 : 									//we're on our own, so if there is a nearby airbase, he will yell at us
; 1190 : 									Objective AirBase = FindNearbyAirbase(gx, gy);

	movzx	edx, WORD PTR _gy$21[ebp]
	push	edx
	movzx	eax, WORD PTR _gx$19[ebp]
	push	eax
	call	?FindNearbyAirbase@@YAPAVObjectiveClass@@FF@Z ; FindNearbyAirbase
	add	esp, 8
	mov	DWORD PTR _AirBase$16[ebp], eax

; 1191 : 									if(AirBase){

	cmp	DWORD PTR _AirBase$16[ebp], 0
	je	$LN1@ProcessPla

; 1192 : 										float groundZ = OTWDriver.GetGroundLevel (player->XPos(), player->YPos());

	push	0
	mov	ecx, DWORD PTR _player$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _player$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, OFFSET ?OTWDriver@@3VOTWDriverClass@@A ; OTWDriver
	call	?GetGroundLevel@OTWDriverClass@@QAEMMMPAUTpoint@@@Z ; OTWDriverClass::GetGroundLevel
	fstp	DWORD PTR _groundZ$14[ebp]

; 1193 : 										player->FeatureCollision(groundZ);

	push	ecx
	movss	xmm0, DWORD PTR _groundZ$14[ebp]
	movss	DWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _player$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _player$[ebp]
	mov	eax, DWORD PTR [edx+444]
	call	eax

; 1194 : 										if(player->onFlatFeature){

	mov	ecx, DWORD PTR _player$[ebp]
	cmp	DWORD PTR [ecx+668], 0
	je	$LN1@ProcessPla

; 1195 : 											radioMessage = CreateCallFromATC(
; 1196 : 												self, player, rcTOWERSCOLD2, FalconLocalGame
; 1197 : 											);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN90@ProcessPla
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv963[ebp], eax
	jmp	SHORT $LN91@ProcessPla
$LN90@ProcessPla:
	mov	DWORD PTR tv963[ebp], 0
$LN91@ProcessPla:
	mov	eax, DWORD PTR tv963[ebp]
	push	eax
	push	311					; 00000137H
	mov	ecx, DWORD PTR _player$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?CreateCallFromATC@@YAPAVFalconRadioChatterMessage@@PAVObjectiveClass@@PAVAircraftClass@@FPAVVuTargetEntity@@@Z ; CreateCallFromATC
	add	esp, 16					; 00000010H
	mov	DWORD PTR _radioMessage$[ebp], eax

; 1198 : 											radioMessage->dataBlock.edata[3] = 32767;

	mov	ecx, 2
	imul	ecx, 3
	mov	edx, 32767				; 00007fffH
	mov	eax, DWORD PTR _radioMessage$[ebp]
	mov	WORD PTR [eax+ecx+64], dx

; 1199 : 											FalconSendMessage(radioMessage, FALSE);

	push	0
	mov	ecx, DWORD PTR _radioMessage$[ebp]
	push	ecx
	call	?FalconSendMessage@@YAXPAVVuMessage@@H@Z ; FalconSendMessage
	add	esp, 8

; 1200 : 											player->DBrain()->SetWaitTimer(SimLibElapsedTime);

	mov	edx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	push	edx
	mov	ecx, DWORD PTR _player$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?SetWaitTimer@DigitalBrain@@QAEXK@Z	; DigitalBrain::SetWaitTimer
$LN1@ProcessPla:

; 1201 : 										}
; 1202 : 									}
; 1203 : 
; 1204 : 									player->DBrain()->ClearATCFlag(DigitalBrain::Landed);

	push	1
	mov	ecx, DWORD PTR _player$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?ClearATCFlag@DigitalBrain@@QAEXH@Z	; DigitalBrain::ClearATCFlag

; 1205 : 									runwayQueueStruct info ;

	lea	ecx, DWORD PTR _info$2[ebp]
	call	??0runwayQueueStruct@@QAE@XZ

; 1206 : 									info.lastContacted = SimLibElapsedTime;

	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR _info$2[ebp+16], eax

; 1207 : 									info.status = tFlyOut;

	mov	DWORD PTR _info$2[ebp+8], 28		; 0000001cH

; 1208 : 									SendCmdMessage(player, &info);

	lea	ecx, DWORD PTR _info$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _player$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendCmdMessage@ATCBrain@@QAEXPAVAircraftClass@@PAUrunwayQueueStruct@@@Z ; ATCBrain::SendCmdMessage
$LN3@ProcessPla:

; 1209 : 								}
; 1210 : 							}
; 1211 : 						}
; 1212 : 					}
; 1213 : 				}
; 1214 : 			}
; 1215 : 		}
; 1216 : 		session = (FalconSessionEntity*) sit.GetNext();

	lea	ecx, DWORD PTR _sit$[ebp]
	call	?GetNext@VuSessionsIterator@@QAEPAVVuSessionEntity@@XZ ; VuSessionsIterator::GetNext
	mov	DWORD PTR _session$[ebp], eax

; 1217 : 	}

	jmp	$LN75@ProcessPla
$LN74@ProcessPla:

; 1218 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sit$[ebp]
	call	??1VuSessionsIterator@@UAE@XZ		; VuSessionsIterator::~VuSessionsIterator
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN97@ProcessPla:
	DD	$LN66@ProcessPla
	DD	$LN67@ProcessPla
	DD	$LN65@ProcessPla
	DD	$LN59@ProcessPla
	DD	$LN55@ProcessPla
	DD	$LN52@ProcessPla
	DD	$LN48@ProcessPla
	DD	$LN60@ProcessPla
	DD	$LN56@ProcessPla
	DD	$LN46@ProcessPla
	DD	$LN45@ProcessPla
	DD	$LN41@ProcessPla
	DD	$LN39@ProcessPla
	DD	$LN38@ProcessPla
	DD	$LN23@ProcessPla
	DD	$LN21@ProcessPla
$LN95@ProcessPla:
	DB	0
	DB	0
	DB	1
	DB	0
	DB	2
	DB	3
	DB	3
	DB	3
	DB	4
	DB	4
	DB	5
	DB	6
	DB	7
	DB	7
	DB	8
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	9
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	10					; 0000000aH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	10					; 0000000aH
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ProcessPlayers@ATCBrain@@AAEXXZ$0:
	lea	ecx, DWORD PTR _sit$[ebp]
	jmp	??1VuSessionsIterator@@UAE@XZ		; VuSessionsIterator::~VuSessionsIterator
__unwindfunclet$?ProcessPlayers@ATCBrain@@AAEXXZ$1:
	lea	ecx, DWORD PTR _findWalker$12[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__unwindfunclet$?ProcessPlayers@ATCBrain@@AAEXXZ$2:
	lea	ecx, DWORD PTR _findWalker$13[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__ehhandler$?ProcessPlayers@ATCBrain@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-344]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ProcessPlayers@ATCBrain@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ProcessPlayers@ATCBrain@@AAEXXZ ENDP			; ATCBrain::ProcessPlayers
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
_nextLand$ = -88					; size = 16
_sit$ = -72						; size = 12
tv293 = -60						; size = 4
_deltaTime$2 = -56					; size = 4
tv93 = -52						; size = 4
_session$ = -48						; size = 4
_deltaTime$3 = -44					; size = 4
_rwindex$ = -40						; size = 4
_aircraft$ = -36					; size = 4
_info$ = -32						; size = 4
_queue$ = -28						; size = 4
_player$ = -24						; size = 4
_this$ = -20						; size = 4
_i$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?ProcessRunways@ATCBrain@@AAEXXZ PROC			; ATCBrain::ProcessRunways
; _this$ = ecx

; 310  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ProcessRunways@ATCBrain@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 311  : 	int i, rwindex;
; 312  : 	runwayQueueStruct	*nextLand[4]; //room for bigger airbases :)
; 313  : 
; 314  : 	for(i = 0; i < numRwys; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN26@ProcessRun
$LN25@ProcessRun:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN26@ProcessRun:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jge	SHORT $LN24@ProcessRun

; 315  : 	{
; 316  : 		runwayStats[i].rnwyInUse = NULL;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+eax+28], 0

; 317  : 		nextLand[i] = NextToLand(i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NextToLand@ATCBrain@@AAEPAUrunwayQueueStruct@@H@Z ; ATCBrain::NextToLand
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _nextLand$[ebp+ecx*4], eax

; 318  : 	}

	jmp	SHORT $LN25@ProcessRun
$LN24@ProcessRun:

; 319  : 
; 320  : 	runwayQueueStruct	*info;
; 321  : 	FalconSessionEntity	*session;
; 322  : 	AircraftClass		*player;
; 323  : 	AircraftClass		*aircraft;
; 324  : 	int					queue = 0;

	mov	DWORD PTR _queue$[ebp], 0

; 325  : 
; 326  : 	VuSessionsIterator		sit(FalconLocalGame);

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN29@ProcessRun
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv93[ebp], eax
	jmp	SHORT $LN30@ProcessRun
$LN29@ProcessRun:
	mov	DWORD PTR tv93[ebp], 0
$LN30@ProcessRun:
	mov	eax, DWORD PTR tv93[ebp]
	push	eax
	lea	ecx, DWORD PTR _sit$[ebp]
	call	??0VuSessionsIterator@@QAE@PAVVuGroupEntity@@@Z ; VuSessionsIterator::VuSessionsIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 327  : 	session = (FalconSessionEntity*) sit.GetFirst();

	lea	ecx, DWORD PTR _sit$[ebp]
	call	?GetFirst@VuSessionsIterator@@QAEPAVVuSessionEntity@@XZ ; VuSessionsIterator::GetFirst
	mov	DWORD PTR _session$[ebp], eax
$LN23@ProcessRun:

; 328  : 	while (session)

	cmp	DWORD PTR _session$[ebp], 0
	je	$LN22@ProcessRun

; 329  : 	{
; 330  : 		player = (AircraftClass*) session->GetPlayerEntity();

	mov	ecx, DWORD PTR _session$[ebp]
	call	?GetPlayerEntity@FalconSessionEntity@@QBEPAVFalconEntity@@XZ ; FalconSessionEntity::GetPlayerEntity
	mov	DWORD PTR _player$[ebp], eax

; 331  : 		if (player && player->IsAirplane())

	cmp	DWORD PTR _player$[ebp], 0
	je	$LN14@ProcessRun
	mov	ecx, DWORD PTR _player$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _player$[ebp]
	mov	eax, DWORD PTR [edx+192]
	call	eax
	test	eax, eax
	je	$LN14@ProcessRun

; 332  : 		{
; 333  : 			unsigned long deltaTime;
; 334  : 
; 335  : 			rwindex = IsOnRunway(player);

	mov	ecx, DWORD PTR _player$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsOnRunway@ATCBrain@@QAEHPAVAircraftClass@@@Z ; ATCBrain::IsOnRunway
	mov	DWORD PTR _rwindex$[ebp], eax

; 336  : 			queue = GetQueue(rwindex);

	mov	edx, DWORD PTR _rwindex$[ebp]
	push	edx
	call	?GetQueue@@YAHH@Z			; GetQueue
	add	esp, 4
	mov	DWORD PTR _queue$[ebp], eax

; 337  : 
; 338  : 			if(nextLand[queue])

	mov	eax, DWORD PTR _queue$[ebp]
	cmp	DWORD PTR _nextLand$[ebp+eax*4], 0
	je	$LN14@ProcessRun

; 339  : 			{
; 340  : 				if(nextLand[queue]->schedTime < SimLibElapsedTime)

	mov	ecx, DWORD PTR _queue$[ebp]
	mov	edx, DWORD PTR _nextLand$[ebp+ecx*4]
	mov	eax, DWORD PTR [edx+12]
	cmp	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	SHORT $LN19@ProcessRun

; 341  : 					deltaTime = SimLibElapsedTime - nextLand[queue]->schedTime;

	mov	ecx, DWORD PTR _queue$[ebp]
	mov	edx, DWORD PTR _nextLand$[ebp+ecx*4]
	mov	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	sub	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _deltaTime$3[ebp], eax

; 342  : 				else

	jmp	SHORT $LN18@ProcessRun
$LN19@ProcessRun:

; 343  : 					deltaTime = nextLand[queue]->schedTime - SimLibElapsedTime;

	mov	ecx, DWORD PTR _queue$[ebp]
	mov	edx, DWORD PTR _nextLand$[ebp+ecx*4]
	mov	eax, DWORD PTR [edx+12]
	sub	eax, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR _deltaTime$3[ebp], eax
$LN18@ProcessRun:

; 344  : 				
; 345  : 				if(rwindex && player->af->vt < 30.0F*KNOTS_TO_FTPSEC && ( player->DBrain()->ATCStatus() == lCrashed ||
; 346  : 								(player->DBrain()->ATCStatus() > lLanded && deltaTime < LAND_TIME_DELTA/2) ||
; 347  : 								(player->DBrain()->ATCStatus() == lLanded && deltaTime < LAND_TIME_DELTA/4 && player->af->vt < 5.0F)))

	cmp	DWORD PTR _rwindex$[ebp], 0
	je	$LN17@ProcessRun
	mov	ecx, DWORD PTR _player$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	movss	xmm0, DWORD PTR __real@424a8a53
	comiss	xmm0, DWORD PTR [edx+1120]
	jbe	SHORT $LN17@ProcessRun
	mov	ecx, DWORD PTR _player$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?ATCStatus@DigitalBrain@@QAE?AW4AtcStatusEnum@@XZ ; DigitalBrain::ATCStatus
	cmp	eax, 18					; 00000012H
	je	SHORT $LN16@ProcessRun
	mov	ecx, DWORD PTR _player$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?ATCStatus@DigitalBrain@@QAE?AW4AtcStatusEnum@@XZ ; DigitalBrain::ATCStatus
	cmp	eax, 13					; 0000000dH
	jle	SHORT $LN15@ProcessRun
	cmp	DWORD PTR _deltaTime$3[ebp], 30000	; 00007530H
	jb	SHORT $LN16@ProcessRun
$LN15@ProcessRun:
	mov	ecx, DWORD PTR _player$[ebp]
	call	?DBrain@AircraftClass@@QAEPAVDigitalBrain@@XZ ; AircraftClass::DBrain
	mov	ecx, eax
	call	?ATCStatus@DigitalBrain@@QAE?AW4AtcStatusEnum@@XZ ; DigitalBrain::ATCStatus
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN17@ProcessRun
	cmp	DWORD PTR _deltaTime$3[ebp], 15000	; 00003a98H
	jae	SHORT $LN17@ProcessRun
	mov	eax, DWORD PTR _player$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR __real@40a00000
	comiss	xmm0, DWORD PTR [ecx+1120]
	jbe	SHORT $LN17@ProcessRun
$LN16@ProcessRun:

; 348  : 				{
; 349  : 					runwayStats[queue].rnwyInUse = player;

	mov	edx, DWORD PTR _queue$[ebp]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR _player$[ebp]
	mov	DWORD PTR [ecx+edx+28], eax
$LN17@ProcessRun:

; 350  : 				}
; 351  : 			//Cobra If a player is on the runway, we flag him.  This allows the landing check 
; 352  : 			//to catch it and abort Digi's on final.  
; 353  : 				if (rwindex)

	cmp	DWORD PTR _rwindex$[ebp], 0
	je	SHORT $LN14@ProcessRun

; 354  : 					{
; 355  : 					runwayStats[queue].rnwyInUse = player;

	mov	ecx, DWORD PTR _queue$[ebp]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	edx, DWORD PTR _player$[ebp]
	mov	DWORD PTR [eax+ecx+28], edx
$LN14@ProcessRun:

; 356  : 					}
; 357  : 				//end
; 358  : 
; 359  : 
; 360  : 
; 361  : 			}
; 362  : 		}
; 363  : 		session = (FalconSessionEntity*) sit.GetNext();

	lea	ecx, DWORD PTR _sit$[ebp]
	call	?GetNext@VuSessionsIterator@@QAEPAVVuSessionEntity@@XZ ; VuSessionsIterator::GetNext
	mov	DWORD PTR _session$[ebp], eax

; 364  : 	}	

	jmp	$LN23@ProcessRun
$LN22@ProcessRun:

; 365  : 
; 366  : 	//check runway status
; 367  : 	for(i = 0; i < numRwys; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@ProcessRun
$LN12@ProcessRun:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN13@ProcessRun:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jge	$LN11@ProcessRun

; 368  : 	{
; 369  : 		info = runwayQueue[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _info$[ebp], eax
$LN10@ProcessRun:

; 370  : 		while(nextLand[i] && !runwayStats[i].rnwyInUse && info)

	mov	ecx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _nextLand$[ebp+ecx*4], 0
	je	$LN9@ProcessRun
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx+edx+28], 0
	jne	$LN9@ProcessRun
	cmp	DWORD PTR _info$[ebp], 0
	je	$LN9@ProcessRun

; 371  : 		{
; 372  : 			unsigned long deltaTime;
; 373  : 			
; 374  : 			if(nextLand[i]->schedTime < SimLibElapsedTime)	//If aircraft is scheduled to land

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _nextLand$[ebp+edx*4]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	jae	SHORT $LN8@ProcessRun

; 375  : 				deltaTime = SimLibElapsedTime - nextLand[i]->schedTime;	//how much time do we have

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _nextLand$[ebp+edx*4]
	mov	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	sub	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _deltaTime$2[ebp], ecx

; 376  : 			else

	jmp	SHORT $LN7@ProcessRun
$LN8@ProcessRun:

; 377  : 				deltaTime = nextLand[i]->schedTime - SimLibElapsedTime;	//land time passed

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _nextLand$[ebp+edx*4]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, DWORD PTR ?SimLibElapsedTime@@3KA	; SimLibElapsedTime
	mov	DWORD PTR _deltaTime$2[ebp], ecx
$LN7@ProcessRun:

; 378  : 
; 379  : 			//if acft crashed, or schedule to takerwy or takeoff, and aircraft scheduled to land is less than LAND_TIME_DELTA/2 = 30sec away
; 380  : 			//if(	info->status == lCrashed || ((info->status == tTakeRunway || info->status == tTakeoff) && deltaTime < LAND_TIME_DELTA/2))
; 381  : 			//cobra
; 382  : 			if (info->status == lCrashed || info->status == tTakeRunway || info->status == tTakeoff)

	mov	edx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [edx+8], 18			; 00000012H
	je	SHORT $LN5@ProcessRun
	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax+8], 26			; 0000001aH
	je	SHORT $LN5@ProcessRun
	mov	ecx, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [ecx+8], 27			; 0000001bH
	jne	SHORT $LN3@ProcessRun
$LN5@ProcessRun:

; 383  : 			{				
; 384  : 				aircraft = (AircraftClass*)vuDatabase->Find(info->aircraftID);

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR [edx]
	push	ecx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _aircraft$[ebp], eax

; 385  : 				if(aircraft && aircraft->IsAirplane() && aircraft->af->vt < 70.0F*KNOTS_TO_FTPSEC)

	cmp	DWORD PTR _aircraft$[ebp], 0
	je	SHORT $LN3@ProcessRun
	mov	edx, DWORD PTR _aircraft$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	edx, DWORD PTR [eax+192]
	call	edx
	test	eax, eax
	je	SHORT $LN3@ProcessRun
	mov	eax, DWORD PTR _aircraft$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	movss	xmm0, DWORD PTR __real@42ec4c0b
	comiss	xmm0, DWORD PTR [ecx+1120]
	jbe	SHORT $LN3@ProcessRun

; 386  : 				{
; 387  : 					rwindex = IsOnRunway(aircraft);

	mov	edx, DWORD PTR _aircraft$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsOnRunway@ATCBrain@@QAEHPAVAircraftClass@@@Z ; ATCBrain::IsOnRunway
	mov	DWORD PTR _rwindex$[ebp], eax

; 388  : 					if(rwindex)

	cmp	DWORD PTR _rwindex$[ebp], 0
	je	SHORT $LN3@ProcessRun

; 389  : 						runwayStats[i].rnwyInUse = aircraft;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 40					; 00000028H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _aircraft$[ebp]
	mov	DWORD PTR [edx+eax+28], ecx
$LN3@ProcessRun:

; 390  : 				}
; 391  : 			}
; 392  : 			info = info->next;

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _info$[ebp], eax

; 393  : 		}

	jmp	$LN10@ProcessRun
$LN9@ProcessRun:

; 394  : 
; 395  : 		runwayStats[i].state = CheckHeaderStatus (self, runwayStats[i].rwIndexes[0]);

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	add	eax, ecx
	mov	ecx, 4
	imul	ecx, 0
	mov	edx, DWORD PTR [eax+ecx]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?CheckHeaderStatus@@YAHPAVCampBaseClass@@H@Z ; CheckHeaderStatus
	add	esp, 8
	mov	DWORD PTR tv293[ebp], eax
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	ax, WORD PTR tv293[ebp]
	and	ax, 7
	mov	esi, 65528				; 0000fff8H
	and	si, WORD PTR [ecx+edx+24]
	or	si, ax
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	WORD PTR [eax+ecx+24], si

; 396  : 		
; 397  : 		if(runwayStats[i].state >= VIS_DAMAGED && runwayQueue[i])

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 40					; 00000028H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	cx, WORD PTR [eax+ecx+24]
	and	cx, 7
	movzx	edx, cx
	cmp	edx, 2
	jl	SHORT $LN2@ProcessRun
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	je	SHORT $LN2@ProcessRun

; 398  : 		{
; 399  : 			// need to reschedule these planes
; 400  : 			ReschedulePlanes(i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReschedulePlanes@ATCBrain@@AAEXH@Z	; ATCBrain::ReschedulePlanes
$LN2@ProcessRun:

; 401  : 		}
; 402  : 		
; 403  : 		if(runwayQueue[i])

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	je	SHORT $LN1@ProcessRun

; 404  : 		{
; 405  : 			//need to check queues for planes on emergencyhold or emergencystop
; 406  : 			//the emergency is over we can bring 'em in, also remove any planes we
; 407  : 			//can no longer find in the database
; 408  : 			ProcessQueue(i);

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ProcessQueue@ATCBrain@@AAEXH@Z		; ATCBrain::ProcessQueue
$LN1@ProcessRun:

; 409  : 		}
; 410  : 	}

	jmp	$LN12@ProcessRun
$LN11@ProcessRun:

; 411  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sit$[ebp]
	call	??1VuSessionsIterator@@UAE@XZ		; VuSessionsIterator::~VuSessionsIterator
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ProcessRunways@ATCBrain@@AAEXXZ$0:
	lea	ecx, DWORD PTR _sit$[ebp]
	jmp	??1VuSessionsIterator@@UAE@XZ		; VuSessionsIterator::~VuSessionsIterator
__ehhandler$?ProcessRunways@ATCBrain@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-84]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ProcessRunways@ATCBrain@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ProcessRunways@ATCBrain@@AAEXXZ ENDP			; ATCBrain::ProcessRunways
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\atcbrain.cpp
_TEXT	SEGMENT
tv208 = -52						; size = 4
tv229 = -48						; size = 4
tv203 = -44						; size = 4
tv199 = -40						; size = 4
tv227 = -36						; size = 4
tv194 = -32						; size = 4
_distSq$ = -28						; size = 4
_dy$ = -24						; size = 4
_dx$ = -20						; size = 4
_deleteInfo$ = -16					; size = 4
_inboundInfo$ = -12					; size = 4
_inbound$ = -8						; size = 4
_this$ = -4						; size = 4
?ProcessInbound@ATCBrain@@AAEXXZ PROC			; ATCBrain::ProcessInbound
; _this$ = ecx

; 259  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 260  : 	float dx, dy, distSq;
; 261  : 	runwayQueueStruct *inboundInfo;
; 262  : 	runwayQueueStruct *deleteInfo;
; 263  : 	AircraftClass *inbound;
; 264  : 
; 265  : 	if (inboundQueue && F4IsBadReadPtr(inboundQueue, sizeof(runwayQueueStruct))) // JB 010801 CTD

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN10@ProcessInb
	push	32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	?F4IsBadReadPtr@@YA_NPBXI@Z		; F4IsBadReadPtr
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@ProcessInb

; 266  : 		return;

	jmp	$LN11@ProcessInb
$LN10@ProcessInb:

; 267  : 
; 268  : 	inboundInfo = inboundQueue;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _inboundInfo$[ebp], edx
$LN9@ProcessInb:

; 269  : 	while(inboundInfo)

	cmp	DWORD PTR _inboundInfo$[ebp], 0
	je	$LN8@ProcessInb

; 270  : 	{
; 271  : 		deleteInfo = inboundInfo;

	mov	eax, DWORD PTR _inboundInfo$[ebp]
	mov	DWORD PTR _deleteInfo$[ebp], eax

; 272  : 
; 273  : 
; 274  : 
; 275  : 		inbound = (AircraftClass *)vuDatabase->Find(inboundInfo->aircraftID);

	mov	ecx, DWORD PTR _inboundInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR [ecx]
	push	eax
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _inbound$[ebp], eax

; 276  : 		if(inbound)

	cmp	DWORD PTR _inbound$[ebp], 0
	je	$LN7@ProcessInb

; 277  : 		{
; 278  : 			dx = inbound->XPos() - self->XPos();

	mov	ecx, DWORD PTR _inbound$[ebp]
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv194[ebp]
	movss	xmm0, DWORD PTR tv194[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	movss	DWORD PTR tv227[ebp], xmm0
	call	?XPos@VuEntity@@QBEMXZ			; VuEntity::XPos
	fstp	DWORD PTR tv199[ebp]
	movss	xmm0, DWORD PTR tv227[ebp]
	subss	xmm0, DWORD PTR tv199[ebp]
	movss	DWORD PTR _dx$[ebp], xmm0

; 279  : 			dy = inbound->YPos() - self->YPos();

	mov	ecx, DWORD PTR _inbound$[ebp]
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv203[ebp]
	movss	xmm0, DWORD PTR tv203[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	movss	DWORD PTR tv229[ebp], xmm0
	call	?YPos@VuEntity@@QBEMXZ			; VuEntity::YPos
	fstp	DWORD PTR tv208[ebp]
	movss	xmm0, DWORD PTR tv229[ebp]
	subss	xmm0, DWORD PTR tv208[ebp]
	movss	DWORD PTR _dy$[ebp], xmm0

; 280  : 			distSq = dx*dx + dy*dy;						//distSq in feet

	movss	xmm0, DWORD PTR _dx$[ebp]
	mulss	xmm0, DWORD PTR _dx$[ebp]
	movss	xmm1, DWORD PTR _dy$[ebp]
	mulss	xmm1, DWORD PTR _dy$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _distSq$[ebp], xmm0

; 281  : 
; 282  : 			inboundInfo = inboundInfo->next;

	mov	eax, DWORD PTR _inboundInfo$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _inboundInfo$[ebp], ecx

; 283  : 			
; 284  : 			if(distSq < TOWER_RANGE * NM_TO_FT * NM_TO_FT)		

	movss	xmm0, DWORD PTR __real@50abec79
	comiss	xmm0, DWORD PTR _distSq$[ebp]
	jbe	SHORT $LN6@ProcessInb

; 285  : 			{
; 286  : 				RemoveInbound(deleteInfo);

	mov	edx, DWORD PTR _deleteInfo$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveInbound@ATCBrain@@QAEXPAUrunwayQueueStruct@@@Z ; ATCBrain::RemoveInbound

; 287  : 				//if they are within 15nm we need to start giving them vectors
; 288  : 				if(!inbound->IsPlayer() && inbound->pctStrength < 0.9F)

	mov	ecx, DWORD PTR _inbound$[ebp]
	call	?IsPlayer@FalconEntity@@QAEHXZ		; FalconEntity::IsPlayer
	test	eax, eax
	jne	SHORT $LN5@ProcessInb
	mov	eax, DWORD PTR _inbound$[ebp]
	movss	xmm0, DWORD PTR __real@3f666666
	comiss	xmm0, DWORD PTR [eax+292]
	jbe	SHORT $LN5@ProcessInb

; 289  : 					RequestEmerClearance(inbound);

	mov	ecx, DWORD PTR _inbound$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RequestEmerClearance@ATCBrain@@QAEXPAVAircraftClass@@@Z ; ATCBrain::RequestEmerClearance

; 290  : 				else

	jmp	SHORT $LN4@ProcessInb
$LN5@ProcessInb:

; 291  : 					RequestClearance(inbound);

	push	0
	mov	edx, DWORD PTR _inbound$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RequestClearance@ATCBrain@@QAEXPAVAircraftClass@@H@Z ; ATCBrain::RequestClearance
$LN4@ProcessInb:
	jmp	SHORT $LN2@ProcessInb
$LN6@ProcessInb:

; 292  : 			}
; 293  : 			else if(distSq > ATC_DROP_RANGE * NM_TO_FT * NM_TO_FT)

	movss	xmm0, DWORD PTR _distSq$[ebp]
	comiss	xmm0, DWORD PTR __real@515c0ff8
	jbe	SHORT $LN2@ProcessInb

; 294  : 			{
; 295  : 				//if they are farther than 40nm we don't care about them anymore
; 296  : 				RemoveInbound(deleteInfo);

	mov	eax, DWORD PTR _deleteInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveInbound@ATCBrain@@QAEXPAUrunwayQueueStruct@@@Z ; ATCBrain::RemoveInbound
$LN2@ProcessInb:

; 297  : 			}
; 298  : 		}
; 299  : 		else

	jmp	SHORT $LN1@ProcessInb
$LN7@ProcessInb:

; 300  : 		{
; 301  : 			//they went away, oh well
; 302  : 			inboundInfo = inboundInfo->next;

	mov	ecx, DWORD PTR _inboundInfo$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _inboundInfo$[ebp], edx

; 303  : 			RemoveInbound(deleteInfo);

	mov	eax, DWORD PTR _deleteInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveInbound@ATCBrain@@QAEXPAUrunwayQueueStruct@@@Z ; ATCBrain::RemoveInbound
$LN1@ProcessInb:

; 304  : 		}
; 305  : 	}

	jmp	$LN9@ProcessInb
$LN8@ProcessInb:
$LN11@ProcessInb:

; 306  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ProcessInbound@ATCBrain@@AAEXXZ ENDP			; ATCBrain::ProcessInbound
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0runwayStatsStruct@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0runwayStatsStruct@@QAE@XZ PROC			; runwayStatsStruct::runwayStatsStruct, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0runwayStatsStruct@@QAE@XZ ENDP			; runwayStatsStruct::runwayStatsStruct
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0runwayQueueStruct@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0runwayQueueStruct@@QAE@XZ PROC			; runwayQueueStruct::runwayQueueStruct, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0runwayQueueStruct@@QAE@XZ ENDP			; runwayQueueStruct::runwayQueueStruct
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\mltrig.h
;	COMDAT ?checked_atan2@@YANNN@Z
_TEXT	SEGMENT
_z$ = -8						; size = 8
_y$ = 8							; size = 8
_x$ = 16						; size = 8
?checked_atan2@@YANNN@Z PROC				; checked_atan2, COMDAT

; 46   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 47   : 	double z;
; 48   : 	
; 49   : 	if (x == -0.0)

	movsd	xmm0, QWORD PTR _x$[ebp]
	ucomisd	xmm0, QWORD PTR __real@8000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN8@checked_at

; 50   : 		x = 0.0;

	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR _x$[ebp], xmm0
$LN8@checked_at:

; 51   : 	
; 52   : 	if (x != 0)

	movsd	xmm0, QWORD PTR _x$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN7@checked_at

; 53   : 		z = atan(y / x);

	movsd	xmm0, QWORD PTR _y$[ebp]
	divsd	xmm0, QWORD PTR _x$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_atan
	add	esp, 8
	fstp	QWORD PTR _z$[ebp]
	jmp	SHORT $LN4@checked_at
$LN7@checked_at:

; 54   : 	else if (y > 0)

	movsd	xmm0, QWORD PTR _y$[ebp]
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	SHORT $LN5@checked_at

; 55   : 		z = HALF_DPI;

	movsd	xmm0, QWORD PTR __real@3ff921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0

; 56   : 	else

	jmp	SHORT $LN4@checked_at
$LN5@checked_at:

; 57   : 		z = -HALF_DPI;

	movsd	xmm0, QWORD PTR __real@bff921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0
$LN4@checked_at:

; 58   : 
; 59   : 	if (x < 0)

	movsd	xmm0, QWORD PTR __real@0000000000000000
	comisd	xmm0, QWORD PTR _x$[ebp]
	jbe	SHORT $LN1@checked_at

; 60   : 	{
; 61   : 		if (y < 0)

	movsd	xmm0, QWORD PTR __real@0000000000000000
	comisd	xmm0, QWORD PTR _y$[ebp]
	jbe	SHORT $LN2@checked_at

; 62   : 			z -= DPI;

	movsd	xmm0, QWORD PTR _z$[ebp]
	subsd	xmm0, QWORD PTR __real@400921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0

; 63   : 		else

	jmp	SHORT $LN1@checked_at
$LN2@checked_at:

; 64   : 			z += DPI;

	movsd	xmm0, QWORD PTR _z$[ebp]
	addsd	xmm0, QWORD PTR __real@400921fb54442d18
	movsd	QWORD PTR _z$[ebp], xmm0
$LN1@checked_at:

; 65   : 	}
; 66   : 
; 67   : 	return z;

	fld	QWORD PTR _z$[ebp]

; 68   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?checked_atan2@@YANNN@Z ENDP				; checked_atan2
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\mltrig.h
;	COMDAT ?mlSinCos@@YAXPAUmlTrig@@M@Z
_TEXT	SEGMENT
_trig$ = 8						; size = 4
_angle$ = 12						; size = 4
?mlSinCos@@YAXPAUmlTrig@@M@Z PROC			; mlSinCos, COMDAT

; 12   : {

	push	ebp
	mov	ebp, esp

; 13   : #if defined(_MSC_VER)
; 14   : 	__asm 
; 15   : 	{
; 16   : 		__asm	mov     ecx, trig;

	mov	ecx, DWORD PTR _trig$[ebp]

; 17   : 		__asm	fld     dword ptr [angle];

	fld	DWORD PTR _angle$[ebp]

; 18   : 		__asm	fsincos;

	fsincos

; 19   : 		__asm	fstp    dword ptr [ecx]trig.cos;

	fstp	DWORD PTR [ecx+4]

; 20   : 		__asm	fstp    dword ptr [ecx]trig.sin;

	fstp	DWORD PTR [ecx]

; 21   : 	}
; 22   : #else
; 23   : 	trig->sin = (Float32)sin(angle);
; 24   : 	trig->cos = (Float32)cos(angle);
; 25   : #endif
; 26   : }

	pop	ebp
	ret	0
?mlSinCos@@YAXPAUmlTrig@@M@Z ENDP			; mlSinCos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsPlayer@FalconEntity@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsPlayer@FalconEntity@@QAEHXZ PROC			; FalconEntity::IsPlayer, COMDAT
; _this$ = ecx

; 113  : 	int IsPlayer (void)							{ return IsSetFalcFlag(FEC_HASPLAYERS); };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSetFalcFlag@FalconEntity@@QAEHH@Z	; FalconEntity::IsSetFalcFlag
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPlayer@FalconEntity@@QAEHXZ ENDP			; FalconEntity::IsPlayer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsSetFalcFlag@FalconEntity@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flag$ = 8						; size = 4
?IsSetFalcFlag@FalconEntity@@QAEHH@Z PROC		; FalconEntity::IsSetFalcFlag, COMDAT
; _this$ = ecx

; 112  : 	int IsSetFalcFlag (int flag)				{ return falconFlags & flag; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+136]
	and	eax, DWORD PTR _flag$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?IsSetFalcFlag@FalconEntity@@QAEHH@Z ENDP		; FalconEntity::IsSetFalcFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ PROC ; VuBin<VuSessionEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ENDP ; VuBin<VuSessionEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ PROC		; VuBin<VuSessionEntity>::operator bool, COMDAT
; _this$ = ecx

; 40   : 	operator bool() const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		return e != NULL;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@operator
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv66[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv66[ebp]

; 42   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ ENDP		; VuBin<VuSessionEntity>::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2275 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2270 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2271 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2272 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2260 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2266 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2241 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2243 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2224 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2225 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2226 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2219 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -48						; size = 4
tv204 = -44						; size = 4
tv203 = -40						; size = 4
tv202 = -36						; size = 4
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+20]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN5@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Newres$[ebp], eax

; 2191 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2204 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2210 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2213 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1737 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1740 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1732 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1734 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1319 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1320 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], eax

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1327 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1309 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1310 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1311 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1312 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1142 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1136 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1139 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1106 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1107 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1108 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1117 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 792  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 793  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 794  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 688  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 635  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 636  : 		{	// construct allocator from _Al
; 637  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 525  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 518  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 499  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 500  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	push	ecx

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 65   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ PROC	; VuEntity::EntityType, COMDAT
; _this$ = ecx

; 176  : 	VuEntityType *EntityType() const { return const_cast<VuEntityType*>(entityTypePtr_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+112]
	mov	esp, ebp
	pop	ebp
	ret	0
?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ENDP	; VuEntity::EntityType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Yaw@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Yaw@VuEntity@@QBEMXZ PROC				; VuEntity::Yaw, COMDAT
; _this$ = ecx

; 164  : 	SM_SCALAR Yaw() const { return orient_.yaw_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+60]
	mov	esp, ebp
	pop	ebp
	ret	0
?Yaw@VuEntity@@QBEMXZ ENDP				; VuEntity::Yaw
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?YDelta@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?YDelta@VuEntity@@QBEMXZ PROC				; VuEntity::YDelta, COMDAT
; _this$ = ecx

; 162  : 	SM_SCALAR YDelta() const { return pos_.dy_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+52]
	mov	esp, ebp
	pop	ebp
	ret	0
?YDelta@VuEntity@@QBEMXZ ENDP				; VuEntity::YDelta
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?XDelta@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?XDelta@VuEntity@@QBEMXZ PROC				; VuEntity::XDelta, COMDAT
; _this$ = ecx

; 161  : 	SM_SCALAR XDelta() const { return pos_.dx_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+48]
	mov	esp, ebp
	pop	ebp
	ret	0
?XDelta@VuEntity@@QBEMXZ ENDP				; VuEntity::XDelta
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?ZPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ZPos@VuEntity@@QBEMXZ PROC				; VuEntity::ZPos, COMDAT
; _this$ = ecx

; 160  : 	BIG_SCALAR ZPos()	const { return pos_.z_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?ZPos@VuEntity@@QBEMXZ ENDP				; VuEntity::ZPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?YPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?YPos@VuEntity@@QBEMXZ PROC				; VuEntity::YPos, COMDAT
; _this$ = ecx

; 159  : 	BIG_SCALAR YPos()	const { return pos_.y_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?YPos@VuEntity@@QBEMXZ ENDP				; VuEntity::YPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?XPos@VuEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?XPos@VuEntity@@QBEMXZ PROC				; VuEntity::XPos, COMDAT
; _this$ = ecx

; 158  : 	BIG_SCALAR XPos() const { return pos_.x_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+36]
	mov	esp, ebp
	pop	ebp
	ret	0
?XPos@VuEntity@@QBEMXZ ENDP				; VuEntity::XPos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Id@VuEntity@@QBE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?Id@VuEntity@@QBE?AVVU_ID@@XZ PROC			; VuEntity::Id, COMDAT
; _this$ = ecx

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?Id@VuEntity@@QBE?AVVU_ID@@XZ ENDP			; VuEntity::Id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??9VU_ID@@QBE_NABV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -2						; size = 1
tv73 = -1						; size = 1
_rhs$ = 8						; size = 4
??9VU_ID@@QBE_NABV0@@Z PROC				; VU_ID::operator!=, COMDAT
; _this$ = ecx

; 111  : 	bool operator != (const VU_ID &rhs) const { 

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 112  : 		return (
; 113  : 			num_ == rhs.num_ ? 
; 114  : 			(creator_ == rhs.creator_ ? false : true) : 
; 115  : 			true
; 116  : 		); 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN5@operator
	mov	eax, DWORD PTR _rhs$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??8VU_SESSION_ID@@QBEHABV0@@Z		; VU_SESSION_ID::operator==
	test	eax, eax
	je	SHORT $LN3@operator
	mov	BYTE PTR tv73[ebp], 0
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	BYTE PTR tv73[ebp], 1
$LN4@operator:
	mov	cl, BYTE PTR tv73[ebp]
	mov	BYTE PTR tv74[ebp], cl
	jmp	SHORT $LN6@operator
$LN5@operator:
	mov	BYTE PTR tv74[ebp], 1
$LN6@operator:
	mov	al, BYTE PTR tv74[ebp]

; 117  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??9VU_ID@@QBE_NABV0@@Z ENDP				; VU_ID::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??8VU_ID@@QBE_NABV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -2						; size = 1
tv73 = -1						; size = 1
_rhs$ = 8						; size = 4
??8VU_ID@@QBE_NABV0@@Z PROC				; VU_ID::operator==, COMDAT
; _this$ = ecx

; 104  : 	bool operator == (const VU_ID &rhs) const { 

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 105  : 		return (
; 106  : 			num_ == rhs.num_ ? 
; 107  : 			(creator_ == rhs.creator_ ? true : false) : 
; 108  : 			false
; 109  : 		); 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN5@operator
	mov	eax, DWORD PTR _rhs$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??8VU_SESSION_ID@@QBEHABV0@@Z		; VU_SESSION_ID::operator==
	test	eax, eax
	je	SHORT $LN3@operator
	mov	BYTE PTR tv73[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	BYTE PTR tv73[ebp], 0
$LN4@operator:
	mov	cl, BYTE PTR tv73[ebp]
	mov	BYTE PTR tv74[ebp], cl
	jmp	SHORT $LN6@operator
$LN5@operator:
	mov	BYTE PTR tv74[ebp], 0
$LN6@operator:
	mov	al, BYTE PTR tv74[ebp]

; 110  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??8VU_ID@@QBE_NABV0@@Z ENDP				; VU_ID::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??0VU_ID@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0VU_ID@@QAE@XZ PROC					; VU_ID::VU_ID, COMDAT
; _this$ = ecx

; 100  : 	VU_ID() : num_(0), creator_(0){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0VU_SESSION_ID@@QAE@K@Z		; VU_SESSION_ID::VU_SESSION_ID
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0VU_ID@@QAE@XZ ENDP					; VU_ID::VU_ID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??8VU_SESSION_ID@@QBEHABV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_rhs$ = 8						; size = 4
??8VU_SESSION_ID@@QBEHABV0@@Z PROC			; VU_SESSION_ID::operator==, COMDAT
; _this$ = ecx

; 55   : 	int operator == (const VU_SESSION_ID &rhs) const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return (value_ == rhs.value_ ? TRUE : FALSE); 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv67[ebp], 0
$LN4@operator:
	mov	eax, DWORD PTR tv67[ebp]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??8VU_SESSION_ID@@QBEHABV0@@Z ENDP			; VU_SESSION_ID::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??0VU_SESSION_ID@@QAE@K@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??0VU_SESSION_ID@@QAE@K@Z PROC				; VU_SESSION_ID::VU_SESSION_ID, COMDAT
; _this$ = ecx

; 53   : 	VU_SESSION_ID(unsigned long value) : value_((unsigned long)value) { }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0VU_SESSION_ID@@QAE@K@Z ENDP				; VU_SESSION_ID::VU_SESSION_ID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?FloatToInt32@@YAHM@Z PROC				; FloatToInt32

; 179  : {

	push	ebp
	mov	ebp, esp

; 180  : #if WIN32
; 181  :   __asm {
; 182  :     fld dword ptr [x];

	fld	DWORD PTR _x$[ebp]

; 183  :     fistp dword ptr [x];

	fistp	DWORD PTR _x$[ebp]

; 184  :     mov eax,dword ptr [x];

	mov	eax, DWORD PTR _x$[ebp]

; 185  :   }
; 186  : #else 
; 187  : 	return static_cast<int>(x);	
; 188  : #endif
; 189  : }

	pop	ebp
	ret	0
?FloatToInt32@@YAHM@Z ENDP				; FloatToInt32
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?SqrtSSE@@YAMM@Z PROC					; SqrtSSE

; 91   : static inline float SqrtSSE(float x){ 

	push	ebp
	mov	ebp, esp

; 92   :     __asm 
; 93   :     { 
; 94   :         sqrtss xmm0,x 

	sqrtss	xmm0, DWORD PTR _x$[ebp]

; 95   :         movss x,xmm0 

	movss	XMMWORD PTR _x$[ebp], xmm0

; 96   :     } 
; 97   : 
; 98   :     return x; 

	fld	DWORD PTR _x$[ebp]

; 99   : } 

	pop	ebp
	ret	0
?SqrtSSE@@YAMM@Z ENDP					; SqrtSSE
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?fabs@@YAMM@Z PROC					; fabs, COMDAT

; 517  :         {return (fabsf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_fabsf
	add	esp, 4
	pop	ebp
	ret	0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?acos@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?acos@@YAMM@Z PROC					; acos, COMDAT

; 501  :         {return (acosf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_acosf
	add	esp, 4
	pop	ebp
	ret	0
?acos@@YAMM@Z ENDP					; acos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _acosf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_acosf	PROC						; COMDAT

; 400  :         {return ((float)acos((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_acos
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_acosf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 392  :         {return ((float)fabs((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_fabsf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
$LN2@vector:
	mov	eax, DWORD PTR ___n$[ebp]
	sub	eax, 1
	mov	DWORD PTR ___n$[ebp], eax
	js	SHORT $LN3@vector
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	ecx, DWORD PTR ___t$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], ecx
	jmp	SHORT $LN2@vector
$LN3@vector:
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
