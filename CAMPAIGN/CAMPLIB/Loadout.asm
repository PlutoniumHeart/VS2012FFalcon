; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\CAMPAIGN\CAMPLIB\Loadout.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
PUBLIC	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ		; VuBin<VuSessionEntity>::operator bool
PUBLIC	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
PUBLIC	?LoadWeapons@@YAHPAXHPAEW4MoveType@@HHHQAFQAE@Z	; LoadWeapons
PUBLIC	?LoadvsAir@@YAXHQAFQAE@Z			; LoadvsAir
PUBLIC	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
PUBLIC	?AdjustedWeaponCount@@YAEPAHEF@Z		; AdjustedWeaponCount
PUBLIC	?LoadWeapon@@YAHHHFHHPAVSquadronClass@@QAFQAEPAUVehicleClassDataType@@@Z ; LoadWeapon
PUBLIC	?WeaponLoadScore@@YAHHHPAEW4MoveType@@HHH@Z	; WeaponLoadScore
EXTRN	_rand:PROC
EXTRN	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ:PROC ; VuSessionEntity::Game
EXTRN	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ:PROC ; FalconGameEntity::GetGameType
EXTRN	?GetWeaponFireRate@@YAHH@Z:PROC			; GetWeaponFireRate
EXTRN	?GetWeaponScore@@YAHHPAEHH@Z:PROC		; GetWeaponScore
EXTRN	?TimeOfDayGeneral@@YAHK@Z:PROC			; TimeOfDayGeneral
EXTRN	?GetListEntryWeapon@@YAHHH@Z:PROC		; GetListEntryWeapon
EXTRN	?GetListEntryWeapons@@YAHHH@Z:PROC		; GetListEntryWeapons
EXTRN	?GetUnitClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ:PROC ; UnitClass::GetUnitClassData
EXTRN	?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A:DWORD ; vuLocalSessionEntity
EXTRN	?DefaultDamageMods@@3PAEA:BYTE			; DefaultDamageMods
EXTRN	?TheCampaign@@3VCampaignClass@@A:BYTE		; TheCampaign
EXTRN	?WeaponDataTable@@3PAUWeaponClassDataType@@A:DWORD ; WeaponDataTable
EXTRN	?SquadronStoresDataTable@@3PAUSquadronStoresDataType@@A:DWORD ; SquadronStoresDataTable
EXTRN	?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A:DWORD ; Falcon4ClassTable
EXTRN	?NumWeaponTypes@@3FA:WORD			; NumWeaponTypes
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\loadout.cpp
_TEXT	SEGMENT
_now$1 = -20						; size = 4
tv310 = -16						; size = 4
tv296 = -12						; size = 4
tv77 = -8						; size = 4
_score$ = -4						; size = 4
_wid$ = 8						; size = 4
_lw$ = 12						; size = 4
_dam$ = 16						; size = 4
_mt$ = 20						; size = 4
_type_flags$ = 24					; size = 4
_guide_flags$ = 28					; size = 4
_randomize$ = 32					; size = 4
?WeaponLoadScore@@YAHHHPAEW4MoveType@@HHH@Z PROC	; WeaponLoadScore

; 93   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 94   : 	int score;
; 95   : 		
; 96   : 	if (!wid || wid < 0 || wid >= NumWeaponTypes)

	cmp	DWORD PTR _wid$[ebp], 0
	je	SHORT $LN42@WeaponLoad
	cmp	DWORD PTR _wid$[ebp], 0
	jl	SHORT $LN42@WeaponLoad
	movsx	eax, WORD PTR ?NumWeaponTypes@@3FA	; NumWeaponTypes
	cmp	DWORD PTR _wid$[ebp], eax
	jl	SHORT $LN43@WeaponLoad
$LN42@WeaponLoad:

; 97   : 		return 0;

	xor	eax, eax
	jmp	$LN44@WeaponLoad
$LN43@WeaponLoad:

; 98   : 
; 99   : 	//LRKLUDGE
; 100  : 	//if (wid == 184)
; 101  : 	//	wid = 185;
; 102  : 
; 103  : 	score = GetWeaponScore(wid,dam,mt,0);

	push	0
	mov	ecx, DWORD PTR _mt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dam$[ebp]
	push	edx
	mov	eax, DWORD PTR _wid$[ebp]
	push	eax
	call	?GetWeaponScore@@YAHHPAEHH@Z		; GetWeaponScore
	add	esp, 16					; 00000010H
	mov	DWORD PTR _score$[ebp], eax

; 104  : 
; 105  : 	// 2002-03-24 MN Don't load Nukes by the AI
; 106  : 	if (WeaponDataTable[wid].DamageType == NuclearDam)

	mov	ecx, DWORD PTR _wid$[ebp]
	imul	ecx, 60					; 0000003cH
	mov	edx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	cmp	DWORD PTR [edx+ecx+4], 9
	jne	SHORT $LN41@WeaponLoad

; 107  : 		score = 0;

	mov	DWORD PTR _score$[ebp], 0
$LN41@WeaponLoad:

; 108  : 
; 109  : 	//	score = FloatToInt32((GetWeaponRange(wid,mt)+1)/5.0F*score);
; 110  : 
; 111  : 	// RV - Biker - Rework this later on
; 112  : 	switch (type_flags) {

	mov	eax, DWORD PTR _type_flags$[ebp]
	mov	DWORD PTR tv77[ebp], eax
	cmp	DWORD PTR tv77[ebp], 262144		; 00040000H
	je	SHORT $LN35@WeaponLoad
	cmp	DWORD PTR tv77[ebp], 524288		; 00080000H
	je	SHORT $LN32@WeaponLoad
	cmp	DWORD PTR tv77[ebp], 1048576		; 00100000H
	je	$LN29@WeaponLoad
	jmp	$LN39@WeaponLoad

; 113  : 		case WEAP_ECM:
; 114  : 			break;

	jmp	$LN39@WeaponLoad

; 115  : 		case WEAP_BAI_LOADOUT:
; 116  : 			break;

	jmp	$LN39@WeaponLoad

; 117  : 		case WEAP_DEAD_LOADOUT:
; 118  : 			break;

	jmp	$LN39@WeaponLoad
$LN35@WeaponLoad:

; 119  : 		case WEAP_LASER_POD:
; 120  : 			if ((type_flags & WEAP_LASER_POD) && (WeaponDataTable[wid].Flags & WEAP_RECON) && (WeaponDataTable[wid].GuidanceFlags & WEAP_LASER))

	mov	ecx, DWORD PTR _type_flags$[ebp]
	and	ecx, 262144				; 00040000H
	je	SHORT $LN34@WeaponLoad
	mov	edx, DWORD PTR _wid$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	ecx, WORD PTR [eax+edx+10]
	and	ecx, 1
	je	SHORT $LN34@WeaponLoad
	mov	edx, DWORD PTR _wid$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	ecx, WORD PTR [eax+edx+42]
	and	ecx, 8
	je	SHORT $LN34@WeaponLoad

; 121  : 				score = 10000;

	mov	DWORD PTR _score$[ebp], 10000		; 00002710H

; 122  : 			else

	jmp	SHORT $LN33@WeaponLoad
$LN34@WeaponLoad:

; 123  : 				score = 0;

	mov	DWORD PTR _score$[ebp], 0
$LN33@WeaponLoad:

; 124  : 			return score;

	mov	eax, DWORD PTR _score$[ebp]
	jmp	$LN44@WeaponLoad

; 125  : 			break;

	jmp	SHORT $LN39@WeaponLoad
$LN32@WeaponLoad:

; 126  : 		case WEAP_FAC_LOADOUT:
; 127  : 			if (WeaponDataTable[wid].Flags & WEAP_ROCKET_MARKER)

	mov	edx, DWORD PTR _wid$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	ecx, WORD PTR [eax+edx+10]
	and	ecx, 4096				; 00001000H
	je	SHORT $LN31@WeaponLoad

; 128  : 				score = 10000;

	mov	DWORD PTR _score$[ebp], 10000		; 00002710H

; 129  : 			else

	jmp	SHORT $LN30@WeaponLoad
$LN31@WeaponLoad:

; 130  : 				score = 0;

	mov	DWORD PTR _score$[ebp], 0
$LN30@WeaponLoad:

; 131  : 			return score;

	mov	eax, DWORD PTR _score$[ebp]
	jmp	$LN44@WeaponLoad
$LN29@WeaponLoad:

; 132  : 		case WEAP_CHAFF_POD:
; 133  : 			if ((type_flags & WEAP_CHAFF_POD) && (WeaponDataTable[wid].Flags & WEAP_RECON) && (WeaponDataTable[wid].Flags & WEAP_ECM))

	mov	edx, DWORD PTR _type_flags$[ebp]
	and	edx, 1048576				; 00100000H
	je	SHORT $LN28@WeaponLoad
	mov	eax, DWORD PTR _wid$[ebp]
	imul	eax, 60					; 0000003cH
	mov	ecx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	edx, WORD PTR [ecx+eax+10]
	and	edx, 1
	je	SHORT $LN28@WeaponLoad
	mov	eax, DWORD PTR _wid$[ebp]
	imul	eax, 60					; 0000003cH
	mov	ecx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	edx, WORD PTR [ecx+eax+10]
	and	edx, 4
	je	SHORT $LN28@WeaponLoad

; 134  : 				score = 10000;

	mov	DWORD PTR _score$[ebp], 10000		; 00002710H

; 135  : 			else

	jmp	SHORT $LN27@WeaponLoad
$LN28@WeaponLoad:

; 136  : 				score = 0;

	mov	DWORD PTR _score$[ebp], 0
$LN27@WeaponLoad:

; 137  : 			return score;

	mov	eax, DWORD PTR _score$[ebp]
	jmp	$LN44@WeaponLoad
$LN39@WeaponLoad:

; 138  : 			break;
; 139  : 		default:
; 140  : 			break;
; 141  : 	}
; 142  : 
; 143  : 
; 144  : 
; 145  : 	if (type_flags && !(type_flags & WeaponDataTable[wid].Flags) && !(type_flags & WEAP_BAI_LOADOUT) && !(type_flags & WEAP_DEAD_LOADOUT))

	cmp	DWORD PTR _type_flags$[ebp], 0
	je	SHORT $LN25@WeaponLoad
	mov	eax, DWORD PTR _wid$[ebp]
	imul	eax, 60					; 0000003cH
	mov	ecx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	edx, WORD PTR [ecx+eax+10]
	and	edx, DWORD PTR _type_flags$[ebp]
	jne	SHORT $LN25@WeaponLoad
	mov	eax, DWORD PTR _type_flags$[ebp]
	and	eax, 65536				; 00010000H
	jne	SHORT $LN25@WeaponLoad
	mov	ecx, DWORD PTR _type_flags$[ebp]
	and	ecx, 131072				; 00020000H
	jne	SHORT $LN25@WeaponLoad

; 146  : 		score = 0;

	mov	DWORD PTR _score$[ebp], 0
$LN25@WeaponLoad:

; 147  : 	if (type_flags && type_flags & WeaponDataTable[wid].Flags)

	cmp	DWORD PTR _type_flags$[ebp], 0
	je	SHORT $LN24@WeaponLoad
	mov	edx, DWORD PTR _wid$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	ecx, WORD PTR [eax+edx+10]
	and	ecx, DWORD PTR _type_flags$[ebp]
	je	SHORT $LN24@WeaponLoad

; 148  : 		score += 100;			// Needed so we load non-combat type things

	mov	edx, DWORD PTR _score$[ebp]
	add	edx, 100				; 00000064H
	mov	DWORD PTR _score$[ebp], edx
$LN24@WeaponLoad:

; 149  : 	if ((guide_flags & WEAP_GUIDED_MASK) && (guide_flags & WeaponDataTable[wid].GuidanceFlags) != guide_flags)

	mov	eax, DWORD PTR _guide_flags$[ebp]
	and	eax, 31					; 0000001fH
	je	SHORT $LN23@WeaponLoad
	mov	ecx, DWORD PTR _wid$[ebp]
	imul	ecx, 60					; 0000003cH
	mov	edx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	eax, WORD PTR [edx+ecx+42]
	and	eax, DWORD PTR _guide_flags$[ebp]
	cmp	eax, DWORD PTR _guide_flags$[ebp]
	je	SHORT $LN23@WeaponLoad

; 150  : 		score = 0;

	mov	DWORD PTR _score$[ebp], 0
$LN23@WeaponLoad:

; 151  : 	if (guide_flags == WEAP_DUMB_ONLY && (WeaponDataTable[wid].GuidanceFlags & WEAP_GUIDED_MASK))

	cmp	DWORD PTR _guide_flags$[ebp], 4096	; 00001000H
	jne	SHORT $LN22@WeaponLoad
	mov	ecx, DWORD PTR _wid$[ebp]
	imul	ecx, 60					; 0000003cH
	mov	edx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	eax, WORD PTR [edx+ecx+42]
	and	eax, 31					; 0000001fH
	je	SHORT $LN22@WeaponLoad

; 152  : 		score = 0;

	mov	DWORD PTR _score$[ebp], 0
$LN22@WeaponLoad:

; 153  : 	// 2002-01-26 ADDED BY S.G. Don't use HARMS if not requested...
; 154  : 	if (!guide_flags && (WeaponDataTable[wid].GuidanceFlags & WEAP_ANTIRADATION))

	cmp	DWORD PTR _guide_flags$[ebp], 0
	jne	SHORT $LN21@WeaponLoad
	mov	ecx, DWORD PTR _wid$[ebp]
	imul	ecx, 60					; 0000003cH
	mov	edx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	eax, WORD PTR [edx+ecx+42]
	and	eax, 1
	je	SHORT $LN21@WeaponLoad

; 155  : 	    score = 0;

	mov	DWORD PTR _score$[ebp], 0
$LN21@WeaponLoad:

; 156  : 	
; 157  : 	// END OF ADDED SECTION 2002-01-26
; 158  : 	if (type_flags & WEAP_BAI_LOADOUT)

	mov	ecx, DWORD PTR _type_flags$[ebp]
	and	ecx, 65536				; 00010000H
	je	$LN20@WeaponLoad

; 159  : 	{
; 160  : 		if (((WeaponDataTable[wid].GuidanceFlags & WEAP_LASER) && (wid != 68 || wid != 310)) || // 2002-01-24 MODIFIED BY S.G. Added () around the '&' statements since it has lower precedence than &&
; 161  : 			(WeaponDataTable[wid].GuidanceFlags & WEAP_RADAR) ||
; 162  : 			(WeaponDataTable[wid].GuidanceFlags & WEAP_ANTIRADATION))

	mov	edx, DWORD PTR _wid$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	ecx, WORD PTR [eax+edx+42]
	and	ecx, 8
	je	SHORT $LN17@WeaponLoad
	cmp	DWORD PTR _wid$[ebp], 68		; 00000044H
	jne	SHORT $LN18@WeaponLoad
	cmp	DWORD PTR _wid$[ebp], 310		; 00000136H
	jne	SHORT $LN18@WeaponLoad
$LN17@WeaponLoad:
	mov	edx, DWORD PTR _wid$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	ecx, WORD PTR [eax+edx+42]
	and	ecx, 4
	jne	SHORT $LN18@WeaponLoad
	mov	edx, DWORD PTR _wid$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	ecx, WORD PTR [eax+edx+42]
	and	ecx, 1
	je	SHORT $LN19@WeaponLoad
$LN18@WeaponLoad:

; 163  : 				score = 0;

	mov	DWORD PTR _score$[ebp], 0
$LN19@WeaponLoad:

; 164  : 
; 165  : 		//Cobra Test
; 166  : 		if ((WeaponDataTable[wid].GuidanceFlags & WEAP_REAR_ASPECT)|| (WeaponDataTable[wid].GuidanceFlags & WEAP_FRONT_ASPECT))

	mov	edx, DWORD PTR _wid$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	ecx, WORD PTR [eax+edx+42]
	and	ecx, 32					; 00000020H
	jne	SHORT $LN15@WeaponLoad
	mov	edx, DWORD PTR _wid$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	ecx, WORD PTR [eax+edx+42]
	and	ecx, 64					; 00000040H
	je	SHORT $LN16@WeaponLoad
$LN15@WeaponLoad:

; 167  : 			score=0;

	mov	DWORD PTR _score$[ebp], 0
$LN16@WeaponLoad:

; 168  : 
; 169  : 		// RV - Biker - Check for PEN type weapons here also
; 170  : 		if (WeaponDataTable[wid].GuidanceFlags == WEAP_VISUALONLY && WeaponDataTable[wid].DamageType == PenetrationDam)

	mov	edx, DWORD PTR _wid$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	ecx, WORD PTR [eax+edx+42]
	test	ecx, ecx
	jne	SHORT $LN20@WeaponLoad
	mov	edx, DWORD PTR _wid$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	cmp	DWORD PTR [eax+edx+4], 1
	jne	SHORT $LN20@WeaponLoad

; 171  : 			score = 0;

	mov	DWORD PTR _score$[ebp], 0
$LN20@WeaponLoad:

; 172  : 
; 173  : 		/*FILE	*fp = fopen("BAI.log","a");
; 174  : 		if (fp)
; 175  : 		{
; 176  : 			fprintf(fp, "WID: %3d Flags: %x Score: %d\n", wid, WeaponDataTable[wid].GuidanceFlags, score);
; 177  : 			fclose(fp);
; 178  : 		}*/
; 179  : 	}
; 180  : 
; 181  : 	// RV - Biker - Something special for DEAD -> rework LGB and JDAM
; 182  : 	if (type_flags & WEAP_DEAD_LOADOUT) {

	mov	ecx, DWORD PTR _type_flags$[ebp]
	and	ecx, 131072				; 00020000H
	je	$LN13@WeaponLoad

; 183  : 		score = score * WeaponDataTable[wid].Range/100;

	mov	edx, DWORD PTR _wid$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movsx	ecx, WORD PTR [eax+edx+8]
	mov	eax, ecx
	imul	eax, DWORD PTR _score$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _score$[ebp], eax

; 184  : 		if ((WeaponDataTable[wid].GuidanceFlags &  WEAP_LASER) ||
; 185  : 			(!(WeaponDataTable[wid].Flags & WEAP_CLUSTER) && (WeaponDataTable[wid].Flags & WEAP_BOMBGPS)))

	mov	edx, DWORD PTR _wid$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	ecx, WORD PTR [eax+edx+42]
	and	ecx, 8
	jne	SHORT $LN11@WeaponLoad
	mov	edx, DWORD PTR _wid$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	ecx, WORD PTR [eax+edx+10]
	and	ecx, 16					; 00000010H
	jne	SHORT $LN12@WeaponLoad
	mov	edx, DWORD PTR _wid$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	ecx, WORD PTR [eax+edx+10]
	and	ecx, 2048				; 00000800H
	je	SHORT $LN12@WeaponLoad
$LN11@WeaponLoad:

; 186  : 			score = score /(WeaponDataTable[wid].Strength+1)*200;

	mov	edx, DWORD PTR _wid$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	ecx, WORD PTR [eax+edx+2]
	add	ecx, 1
	mov	eax, DWORD PTR _score$[ebp]
	cdq
	idiv	ecx
	imul	eax, 200				; 000000c8H
	mov	DWORD PTR _score$[ebp], eax
$LN12@WeaponLoad:

; 187  : 		if (WeaponDataTable[wid].GuidanceFlags ==  WEAP_VISUALONLY && WeaponDataTable[wid].DamageType == PenetrationDam)

	mov	edx, DWORD PTR _wid$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	ecx, WORD PTR [eax+edx+42]
	test	ecx, ecx
	jne	SHORT $LN10@WeaponLoad
	mov	edx, DWORD PTR _wid$[ebp]
	imul	edx, 60					; 0000003cH
	mov	eax, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	cmp	DWORD PTR [eax+edx+4], 1
	jne	SHORT $LN10@WeaponLoad

; 188  : 			score = 0;

	mov	DWORD PTR _score$[ebp], 0
$LN10@WeaponLoad:

; 189  : 		if (WeaponDataTable[wid].GuidanceFlags ==  WEAP_LASER && WeaponDataTable[wid].DamageType == PenetrationDam)

	mov	ecx, DWORD PTR _wid$[ebp]
	imul	ecx, 60					; 0000003cH
	mov	edx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	eax, WORD PTR [edx+ecx+42]
	cmp	eax, 8
	jne	SHORT $LN13@WeaponLoad
	mov	ecx, DWORD PTR _wid$[ebp]
	imul	ecx, 60					; 0000003cH
	mov	edx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	cmp	DWORD PTR [edx+ecx+4], 1
	jne	SHORT $LN13@WeaponLoad

; 190  : 			score = 0;

	mov	DWORD PTR _score$[ebp], 0
$LN13@WeaponLoad:

; 191  : 	}
; 192  : 
; 193  : 	//Cobra 11/23/04 Removed the random thing; not needed.
; 194  : 	//Cobra 12/27/04 Put it back because Jim didn't get random loads of A/A weapons ;)
; 195  : 	if (score > 0 && randomize && FalconLocalGame && FalconLocalGame->GetGameType() != game_Dogfight) {

	cmp	DWORD PTR _score$[ebp], 0
	jle	$LN8@WeaponLoad
	cmp	DWORD PTR _randomize$[ebp], 0
	je	$LN8@WeaponLoad
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN46@WeaponLoad
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv296[ebp], eax
	jmp	SHORT $LN47@WeaponLoad
$LN46@WeaponLoad:
	mov	DWORD PTR tv296[ebp], 0
$LN47@WeaponLoad:
	cmp	DWORD PTR tv296[ebp], 0
	je	$LN8@WeaponLoad
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN48@WeaponLoad
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv310[ebp], eax
	jmp	SHORT $LN49@WeaponLoad
$LN48@WeaponLoad:
	mov	DWORD PTR tv310[ebp], 0
$LN49@WeaponLoad:
	mov	ecx, DWORD PTR tv310[ebp]
	call	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ ; FalconGameEntity::GetGameType
	cmp	eax, 2
	je	SHORT $LN8@WeaponLoad

; 196  : 		// Add some randomness in this
; 197  : 		if (rand()%2)

	call	_rand
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN50@WeaponLoad
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN50@WeaponLoad:
	test	eax, eax
	je	SHORT $LN7@WeaponLoad

; 198  : 			score /= 4;

	mov	eax, DWORD PTR _score$[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR _score$[ebp], eax
$LN7@WeaponLoad:

; 199  : 		if (wid == lw) {

	mov	edx, DWORD PTR _wid$[ebp]
	cmp	edx, DWORD PTR _lw$[ebp]
	jne	SHORT $LN8@WeaponLoad

; 200  : 			if (mt != Air)			// Keep air to ground weapons similar

	cmp	DWORD PTR _mt$[ebp], 5
	je	SHORT $LN5@WeaponLoad

; 201  : 				score *= 4;

	mov	eax, DWORD PTR _score$[ebp]
	shl	eax, 2
	mov	DWORD PTR _score$[ebp], eax

; 202  : 			else					// Keep air to air weapons different

	jmp	SHORT $LN8@WeaponLoad
$LN5@WeaponLoad:

; 203  : 				score /= 4;			

	mov	eax, DWORD PTR _score$[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR _score$[ebp], eax
$LN8@WeaponLoad:

; 204  : 		}
; 205  : 	}
; 206  : 
; 207  : 	// 2001-09-18 M.N. Prevent TV-Guided weapons from being picked for night /late dawndusk missions
; 208  : 	// stops if TimeOfDayGeneral returns dawndusk
; 209  : 	if (WeaponDataTable[wid].GuidanceFlags == WEAP_TV) {

	mov	ecx, DWORD PTR _wid$[ebp]
	imul	ecx, 60					; 0000003cH
	mov	edx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	eax, WORD PTR [edx+ecx+42]
	cmp	eax, 16					; 00000010H
	jne	SHORT $LN3@WeaponLoad

; 210  : 		CampaignTime	now = TheCampaign.CurrentTime;

	mov	ecx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	mov	DWORD PTR _now$1[ebp], ecx

; 211  : 
; 212  : 		if (TimeOfDayGeneral(now) < TOD_DAWNDUSK)

	mov	edx, DWORD PTR _now$1[ebp]
	push	edx
	call	?TimeOfDayGeneral@@YAHK@Z		; TimeOfDayGeneral
	add	esp, 4
	cmp	eax, 2
	jge	SHORT $LN2@WeaponLoad

; 213  : 			score = 0;

	mov	DWORD PTR _score$[ebp], 0
$LN2@WeaponLoad:

; 214  : 		if (TimeOfDayGeneral(now) == TOD_DAWNDUSK)

	mov	eax, DWORD PTR _now$1[ebp]
	push	eax
	call	?TimeOfDayGeneral@@YAHK@Z		; TimeOfDayGeneral
	add	esp, 4
	cmp	eax, 2
	jne	SHORT $LN3@WeaponLoad

; 215  : 			score /= 4;

	mov	eax, DWORD PTR _score$[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR _score$[ebp], eax
$LN3@WeaponLoad:

; 216  : 
; 217  : 	}
; 218  : 	// 2001-09-18 M.N.
; 219  : 	return score;

	mov	eax, DWORD PTR _score$[ebp]
$LN44@WeaponLoad:

; 220  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?WeaponLoadScore@@YAHHHPAEW4MoveType@@HHH@Z ENDP	; WeaponLoadScore
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\loadout.cpp
_TEXT	SEGMENT
_this_load$1 = -8					; size = 4
tv170 = -1						; size = 1
_hp$ = 8						; size = 4
_last_hp$ = 12						; size = 4
_wid$ = 16						; size = 2
_to_load$ = 20						; size = 4
_max$ = 24						; size = 4
_squadron$ = 28						; size = 4
_Weapon$ = 32						; size = 4
_Weapons$ = 36						; size = 4
_vc$ = 40						; size = 4
?LoadWeapon@@YAHHHFHHPAVSquadronClass@@QAFQAEPAUVehicleClassDataType@@@Z PROC ; LoadWeapon

; 42   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 43   : 	if ( wid < 0 || wid >= NumWeaponTypes)

	movsx	eax, WORD PTR _wid$[ebp]
	test	eax, eax
	jl	SHORT $LN12@LoadWeapon
	movsx	ecx, WORD PTR _wid$[ebp]
	movsx	edx, WORD PTR ?NumWeaponTypes@@3FA	; NumWeaponTypes
	cmp	ecx, edx
	jl	SHORT $LN13@LoadWeapon
$LN12@LoadWeapon:

; 44   : 		return 0;

	xor	eax, eax
	jmp	$LN14@LoadWeapon
$LN13@LoadWeapon:

; 45   : 
; 46   : 	if (squadron && !squadron->GetUnitStores(wid)) {

	cmp	DWORD PTR _squadron$[ebp], 0
	je	SHORT $LN11@LoadWeapon
	movsx	eax, WORD PTR _wid$[ebp]
	push	eax
	mov	ecx, DWORD PTR _squadron$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _squadron$[ebp]
	mov	eax, DWORD PTR [edx+788]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN11@LoadWeapon

; 47   : #ifndef INFINITE_AI_AMMO
; 48   : 		// Check for infinite weapons
; 49   : 		int					index;
; 50   : 		UnitClassDataType	*uc = squadron->GetUnitClassData();
; 51   : 		ShiAssert(uc);
; 52   : 		index = uc->SpecialIndex;
; 53   : 		if (wid != SquadronStoresDataTable[index].infiniteAA && wid != SquadronStoresDataTable[index].infiniteAG && wid != SquadronStoresDataTable[index].infiniteGun)
; 54   : 			return 0;
; 55   : #endif
; 56   : 		// If this is a multi-shot hp, only load one shot's worth
; 57   : 		// KCK NOTE: For non-visible (ie: internal) stores, load max
; 58   : 		if (max > 2) {

	cmp	DWORD PTR _max$[ebp], 2
	jle	SHORT $LN10@LoadWeapon

; 59   : 			if (!(vc->VisibleFlags & (0x01 << hp)))

	mov	edx, DWORD PTR _vc$[ebp]
	movzx	eax, WORD PTR [edx+62]
	mov	edx, 1
	mov	ecx, DWORD PTR _hp$[ebp]
	shl	edx, cl
	and	eax, edx
	jne	SHORT $LN9@LoadWeapon

; 60   : 				to_load = max;										// Bomb-bay or gun - So fill 'er up

	mov	eax, DWORD PTR _max$[ebp]
	mov	DWORD PTR _to_load$[ebp], eax

; 61   : 			else

	jmp	SHORT $LN8@LoadWeapon
$LN9@LoadWeapon:

; 62   : 				max = to_load = WeaponDataTable[wid].FireRate;		// Otherwise, load one shot's 

	movsx	ecx, WORD PTR _wid$[ebp]
	imul	ecx, 60					; 0000003cH
	mov	edx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	eax, BYTE PTR [edx+ecx+40]
	mov	DWORD PTR _to_load$[ebp], eax
	mov	ecx, DWORD PTR _to_load$[ebp]
	mov	DWORD PTR _max$[ebp], ecx
$LN8@LoadWeapon:

; 63   : 			if (last_hp+1-hp != hp)

	mov	edx, DWORD PTR _last_hp$[ebp]
	add	edx, 1
	sub	edx, DWORD PTR _hp$[ebp]
	cmp	edx, DWORD PTR _hp$[ebp]
	je	SHORT $LN10@LoadWeapon

; 64   : 				to_load *= 2;										// Twice as many, if we've got an opposite hp

	mov	eax, DWORD PTR _to_load$[ebp]
	shl	eax, 1
	mov	DWORD PTR _to_load$[ebp], eax
$LN10@LoadWeapon:

; 65   : 			}
; 66   : 		}
; 67   : 		else {

	jmp	SHORT $LN6@LoadWeapon
$LN11@LoadWeapon:

; 68   : 			// We have plenty of weapons.. check for special case crapola
; 69   : 			// Bomb-bay or gun - one shot is considered the whole thing, so adjust to_load
; 70   : 			if (!(vc->VisibleFlags & (0x01 << hp))) {

	mov	ecx, DWORD PTR _vc$[ebp]
	movzx	edx, WORD PTR [ecx+62]
	mov	eax, 1
	mov	ecx, DWORD PTR _hp$[ebp]
	shl	eax, cl
	and	edx, eax
	jne	SHORT $LN6@LoadWeapon

; 71   : 				to_load += max - 1;										// Adjust 1 pt worth of to_load to max;

	mov	ecx, DWORD PTR _max$[ebp]
	mov	edx, DWORD PTR _to_load$[ebp]
	lea	eax, DWORD PTR [edx+ecx-1]
	mov	DWORD PTR _to_load$[ebp], eax

; 72   : 				if (last_hp+1-hp != hp && to_load > max)

	mov	ecx, DWORD PTR _last_hp$[ebp]
	add	ecx, 1
	sub	ecx, DWORD PTR _hp$[ebp]
	cmp	ecx, DWORD PTR _hp$[ebp]
	je	SHORT $LN6@LoadWeapon
	mov	edx, DWORD PTR _to_load$[ebp]
	cmp	edx, DWORD PTR _max$[ebp]
	jle	SHORT $LN6@LoadWeapon

; 73   : 					to_load += max - 1;									// Symetrical - Adjust another point

	mov	eax, DWORD PTR _max$[ebp]
	mov	ecx, DWORD PTR _to_load$[ebp]
	lea	edx, DWORD PTR [ecx+eax-1]
	mov	DWORD PTR _to_load$[ebp], edx
$LN6@LoadWeapon:

; 74   : 			}
; 75   : 		}
; 76   : 	
; 77   : 	if (last_hp+1-hp == hp || to_load&0x01) {

	mov	eax, DWORD PTR _last_hp$[ebp]
	add	eax, 1
	sub	eax, DWORD PTR _hp$[ebp]
	cmp	eax, DWORD PTR _hp$[ebp]
	je	SHORT $LN2@LoadWeapon
	mov	ecx, DWORD PTR _to_load$[ebp]
	and	ecx, 1
	je	SHORT $LN3@LoadWeapon
$LN2@LoadWeapon:

; 78   : 		// Not loading symetrically
; 79   : 		Weapon[hp] = wid;

	mov	edx, DWORD PTR _hp$[ebp]
	mov	eax, DWORD PTR _Weapon$[ebp]
	mov	cx, WORD PTR _wid$[ebp]
	mov	WORD PTR [eax+edx*2], cx

; 80   : 		Weapons[hp] = AdjustedWeaponCount(&to_load,(uchar)max,Weapon[hp]);

	mov	edx, DWORD PTR _hp$[ebp]
	mov	eax, DWORD PTR _Weapon$[ebp]
	movzx	ecx, WORD PTR [eax+edx*2]
	push	ecx
	movzx	edx, BYTE PTR _max$[ebp]
	push	edx
	lea	eax, DWORD PTR _to_load$[ebp]
	push	eax
	call	?AdjustedWeaponCount@@YAEPAHEF@Z	; AdjustedWeaponCount
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _Weapons$[ebp]
	add	ecx, DWORD PTR _hp$[ebp]
	mov	BYTE PTR [ecx], al

; 81   : 	}
; 82   : 	else {

	jmp	SHORT $LN1@LoadWeapon
$LN3@LoadWeapon:

; 83   : 		// Load symetrically
; 84   : 		int this_load = to_load/2;

	mov	eax, DWORD PTR _to_load$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _this_load$1[ebp], eax

; 85   : 		Weapon[last_hp+1-hp] = Weapon[hp] = wid;

	mov	edx, DWORD PTR _hp$[ebp]
	mov	eax, DWORD PTR _Weapon$[ebp]
	mov	cx, WORD PTR _wid$[ebp]
	mov	WORD PTR [eax+edx*2], cx
	mov	edx, DWORD PTR _last_hp$[ebp]
	add	edx, 1
	sub	edx, DWORD PTR _hp$[ebp]
	mov	eax, DWORD PTR _Weapon$[ebp]
	mov	cx, WORD PTR _wid$[ebp]
	mov	WORD PTR [eax+edx*2], cx

; 86   : 		Weapons[last_hp+1-hp] = Weapons[hp] = AdjustedWeaponCount(&this_load,(uchar)max,Weapon[hp]);

	mov	edx, DWORD PTR _hp$[ebp]
	mov	eax, DWORD PTR _Weapon$[ebp]
	movzx	ecx, WORD PTR [eax+edx*2]
	push	ecx
	movzx	edx, BYTE PTR _max$[ebp]
	push	edx
	lea	eax, DWORD PTR _this_load$1[ebp]
	push	eax
	call	?AdjustedWeaponCount@@YAEPAHEF@Z	; AdjustedWeaponCount
	add	esp, 12					; 0000000cH
	mov	BYTE PTR tv170[ebp], al
	mov	ecx, DWORD PTR _Weapons$[ebp]
	add	ecx, DWORD PTR _hp$[ebp]
	mov	dl, BYTE PTR tv170[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _last_hp$[ebp]
	add	eax, 1
	sub	eax, DWORD PTR _hp$[ebp]
	mov	ecx, DWORD PTR _Weapons$[ebp]
	mov	dl, BYTE PTR tv170[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 87   : 		to_load = this_load * 2;

	mov	eax, DWORD PTR _this_load$1[ebp]
	shl	eax, 1
	mov	DWORD PTR _to_load$[ebp], eax
$LN1@LoadWeapon:

; 88   : 	}
; 89   : 	return to_load;

	mov	eax, DWORD PTR _to_load$[ebp]
$LN14@LoadWeapon:

; 90   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?LoadWeapon@@YAHHHFHHPAVSquadronClass@@QAFQAEPAUVehicleClassDataType@@@Z ENDP ; LoadWeapon
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\loadout.cpp
_TEXT	SEGMENT
_count$ = -8						; size = 4
_rate$ = -4						; size = 4
_total$ = 8						; size = 4
_max_this_station$ = 12					; size = 1
_wid$ = 16						; size = 2
?AdjustedWeaponCount@@YAEPAHEF@Z PROC			; AdjustedWeaponCount

; 355  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 356  : 	int			count;
; 357  : 	int			rate = GetWeaponFireRate(wid);

	movsx	eax, WORD PTR _wid$[ebp]
	push	eax
	call	?GetWeaponFireRate@@YAHH@Z		; GetWeaponFireRate
	add	esp, 4
	mov	DWORD PTR _rate$[ebp], eax

; 358  : 
; 359  : 	if (rate > max_this_station)

	movzx	ecx, BYTE PTR _max_this_station$[ebp]
	cmp	DWORD PTR _rate$[ebp], ecx
	jle	SHORT $LN3@AdjustedWe

; 360  : 		rate = max_this_station;

	movzx	edx, BYTE PTR _max_this_station$[ebp]
	mov	DWORD PTR _rate$[ebp], edx
$LN3@AdjustedWe:

; 361  : 	if (*total == 1 && max_this_station > 0)

	mov	eax, DWORD PTR _total$[ebp]
	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN2@AdjustedWe
	movzx	ecx, BYTE PTR _max_this_station$[ebp]
	test	ecx, ecx
	jle	SHORT $LN2@AdjustedWe

; 362  : 		{
; 363  : 		count = rate;								// Load one shot's worth

	mov	edx, DWORD PTR _rate$[ebp]
	mov	DWORD PTR _count$[ebp], edx

; 364  : 		*total -= 1;

	mov	eax, DWORD PTR _total$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR _total$[ebp]
	mov	DWORD PTR [edx], ecx

; 365  : 		}
; 366  : //	else if (max_this_station/rate > *total/2)
; 367  : //		{
; 368  : //		count = ((*total)*rate)/2;					// Load 1/2 num shot's worth (we'll load the other half symetrically)
; 369  : //		*total /= 2;
; 370  : //		}
; 371  : 	else 

	jmp	SHORT $LN1@AdjustedWe
$LN2@AdjustedWe:

; 372  : 		{
; 373  : 		count = max_this_station;					// Load the maximum

	movzx	eax, BYTE PTR _max_this_station$[ebp]
	mov	DWORD PTR _count$[ebp], eax

; 374  : 		*total -= count;

	mov	ecx, DWORD PTR _total$[ebp]
	mov	edx, DWORD PTR [ecx]
	sub	edx, DWORD PTR _count$[ebp]
	mov	eax, DWORD PTR _total$[ebp]
	mov	DWORD PTR [eax], edx
$LN1@AdjustedWe:

; 375  : 		}
; 376  : 	return (uchar)count;

	mov	al, BYTE PTR _count$[ebp]

; 377  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?AdjustedWeaponCount@@YAEPAHEF@Z ENDP			; AdjustedWeaponCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
;	COMDAT ?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ PROC ; FalconSessionEntity::GetGame, COMDAT
; _this$ = ecx

; 154  : 	FalconGameEntity* GetGame (void)              { return (FalconGameEntity*)VuSessionEntity::Game(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ ; VuSessionEntity::Game
	mov	esp, ebp
	pop	ebp
	ret	0
?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ENDP ; FalconSessionEntity::GetGame
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\loadout.cpp
_TEXT	SEGMENT
_damageMods$ = -4					; size = 4
_vindex$ = 8						; size = 4
_Weapon$ = 12						; size = 4
_Weapons$ = 16						; size = 4
?LoadvsAir@@YAXHQAFQAE@Z PROC				; LoadvsAir

; 380  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 381  : 	uchar*		damageMods;
; 382  : 
; 383  : 	// This give 100% damage vs most common types of damage.
; 384  : 	// WARNING: if this doesn't get what we want, we can enter 100% for everything
; 385  : 	damageMods = DefaultDamageMods;

	mov	DWORD PTR _damageMods$[ebp], OFFSET ?DefaultDamageMods@@3PAEA ; DefaultDamageMods

; 386  : 
; 387  : 	// Load jamming pod, if possible
; 388  : 	LoadWeapons(NULL, vindex, damageMods, NoMove, 1, WEAP_ECM, 0, Weapon, Weapons); 

	mov	eax, DWORD PTR _Weapons$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Weapon$[ebp]
	push	ecx
	push	0
	push	4
	push	1
	push	0
	mov	edx, DWORD PTR _damageMods$[ebp]
	push	edx
	mov	eax, DWORD PTR _vindex$[ebp]
	push	eax
	push	0
	call	?LoadWeapons@@YAHPAXHPAEW4MoveType@@HHHQAFQAE@Z ; LoadWeapons
	add	esp, 36					; 00000024H

; 389  : 
; 390  : 	// Load AA weapons on remaining slots
; 391  : 	LoadWeapons(NULL, vindex, DefaultDamageMods, Air, 99, 0, 0, Weapon, Weapons); 

	mov	ecx, DWORD PTR _Weapons$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Weapon$[ebp]
	push	edx
	push	0
	push	0
	push	99					; 00000063H
	push	5
	push	OFFSET ?DefaultDamageMods@@3PAEA	; DefaultDamageMods
	mov	eax, DWORD PTR _vindex$[ebp]
	push	eax
	push	0
	call	?LoadWeapons@@YAHPAXHPAEW4MoveType@@HHHQAFQAE@Z ; LoadWeapons
	add	esp, 36					; 00000024H

; 392  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?LoadvsAir@@YAXHQAFQAE@Z ENDP				; LoadvsAir
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\loadout.cpp
_TEXT	SEGMENT
_tl$ = -64						; size = 4
tv258 = -60						; size = 4
_lw$ = -56						; size = 4
_force_on_one$ = -52					; size = 4
_bs$ = -48						; size = 4
_sl$ = -44						; size = 4
_uc$ = -40						; size = 4
_wl$ = -36						; size = 4
_bw$ = -32						; size = 4
_i$ = -28						; size = 4
_chp$ = -24						; size = 4
_lhp$ = -20						; size = 4
_score$ = -16						; size = 4
_wid$ = -12						; size = 4
_vc$ = -8						; size = 4
_hp$ = -4						; size = 4
_squadron$ = 8						; size = 4
_vindex$ = 12						; size = 4
_dam$ = 16						; size = 4
_mt$ = 20						; size = 4
_num$ = 24						; size = 4
_type_flags$ = 28					; size = 4
_guide_flags$ = 32					; size = 4
_Weapon$ = 36						; size = 4
_Weapons$ = 40						; size = 4
?LoadWeapons@@YAHPAXHPAEW4MoveType@@HHHQAFQAE@Z PROC	; LoadWeapons

; 224  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	esi

; 225  : 	int		i,hp,wl,score,bs,bw,wid,lhp,chp,lw=0,sl=0,tl=num,force_on_one=0;

	mov	DWORD PTR _lw$[ebp], 0
	mov	DWORD PTR _sl$[ebp], 0
	mov	eax, DWORD PTR _num$[ebp]
	mov	DWORD PTR _tl$[ebp], eax
	mov	DWORD PTR _force_on_one$[ebp], 0

; 226  : 	VehicleClassDataType	*vc;
; 227  : 	UnitClassDataType		*uc = NULL;

	mov	DWORD PTR _uc$[ebp], 0

; 228  : 
; 229  : 	//int temp_flags = type_flags;
; 230  : 	//int temp_num = 1;
; 231  : 	
; 232  : 	vc = (VehicleClassDataType*) Falcon4ClassTable[vindex].dataPtr;

	mov	ecx, DWORD PTR _vindex$[ebp]
	imul	ecx, 81					; 00000051H
	mov	edx, DWORD PTR ?Falcon4ClassTable@@3PAUFalcon4EntityClassType@@A ; Falcon4ClassTable
	mov	eax, DWORD PTR [edx+ecx+77]
	mov	DWORD PTR _vc$[ebp], eax

; 233  : 	if (!vc)

	cmp	DWORD PTR _vc$[ebp], 0
	jne	SHORT $LN41@LoadWeapon

; 234  : 		return 0;

	xor	eax, eax
	jmp	$LN42@LoadWeapon
$LN41@LoadWeapon:

; 235  : 
; 236  : 	if (squadron)

	cmp	DWORD PTR _squadron$[ebp], 0
	je	SHORT $LN40@LoadWeapon

; 237  : 		uc = ((Squadron)squadron)->GetUnitClassData();

	mov	ecx, DWORD PTR _squadron$[ebp]
	call	?GetUnitClassData@UnitClass@@QAEPAUUnitClassDataType@@XZ ; UnitClass::GetUnitClassData
	mov	DWORD PTR _uc$[ebp], eax
$LN40@LoadWeapon:

; 238  : 
; 239  : 	if (type_flags & WEAP_FORCE_ON_ONE)

	mov	ecx, DWORD PTR _type_flags$[ebp]
	and	ecx, 8192				; 00002000H
	je	SHORT $LN39@LoadWeapon

; 240  : 		{
; 241  : 		// We want to place all our weapons on one (or two if even) hardpoints)
; 242  : 		type_flags &= ~WEAP_FORCE_ON_ONE;

	mov	edx, DWORD PTR _type_flags$[ebp]
	and	edx, -8193				; ffffdfffH
	mov	DWORD PTR _type_flags$[ebp], edx

; 243  : 		force_on_one = 1;

	mov	DWORD PTR _force_on_one$[ebp], 1
$LN39@LoadWeapon:

; 244  : 		}
; 245  : 
; 246  : 	// Find our last and center hardpoint
; 247  : 	lhp = chp = 0;

	mov	DWORD PTR _chp$[ebp], 0
	mov	eax, DWORD PTR _chp$[ebp]
	mov	DWORD PTR _lhp$[ebp], eax

; 248  : 	for (hp=0; hp<HARDPOINT_MAX; hp++) {

	mov	DWORD PTR _hp$[ebp], 0
	jmp	SHORT $LN38@LoadWeapon
$LN37@LoadWeapon:
	mov	ecx, DWORD PTR _hp$[ebp]
	add	ecx, 1
	mov	DWORD PTR _hp$[ebp], ecx
$LN38@LoadWeapon:
	cmp	DWORD PTR _hp$[ebp], 16			; 00000010H
	jge	SHORT $LN36@LoadWeapon

; 249  : 		if (vc->Weapon[hp])

	mov	edx, DWORD PTR _hp$[ebp]
	mov	eax, DWORD PTR _vc$[ebp]
	movsx	ecx, WORD PTR [eax+edx*2+98]
	test	ecx, ecx
	je	SHORT $LN35@LoadWeapon

; 250  : 			lhp = hp;

	mov	edx, DWORD PTR _hp$[ebp]
	mov	DWORD PTR _lhp$[ebp], edx
$LN35@LoadWeapon:

; 251  : 	}

	jmp	SHORT $LN37@LoadWeapon
$LN36@LoadWeapon:

; 252  : 	
; 253  : 	// We have a centerline, and only need one of these
; 254  : 	if (num == 1 && (lhp & 0x01))

	cmp	DWORD PTR _num$[ebp], 1
	jne	SHORT $LN34@LoadWeapon
	mov	eax, DWORD PTR _lhp$[ebp]
	and	eax, 1
	je	SHORT $LN34@LoadWeapon

; 255  : 		chp = (lhp/2) + 1;

	mov	eax, DWORD PTR _lhp$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, 1
	mov	DWORD PTR _chp$[ebp], eax
$LN34@LoadWeapon:

; 256  : 
; 257  : 	// Check if we want a symetric load
; 258  : 	if (!(num & 0x01))

	mov	ecx, DWORD PTR _num$[ebp]
	and	ecx, 1
	jne	SHORT $LN33@LoadWeapon

; 259  : 		sl = 1;

	mov	DWORD PTR _sl$[ebp], 1
$LN33@LoadWeapon:

; 260  : 
; 261  : 	for (hp=chp; hp<=lhp && num>0; hp++) {

	mov	edx, DWORD PTR _chp$[ebp]
	mov	DWORD PTR _hp$[ebp], edx
	jmp	SHORT $LN32@LoadWeapon
$LN31@LoadWeapon:
	mov	eax, DWORD PTR _hp$[ebp]
	add	eax, 1
	mov	DWORD PTR _hp$[ebp], eax
$LN32@LoadWeapon:
	mov	ecx, DWORD PTR _hp$[ebp]
	cmp	ecx, DWORD PTR _lhp$[ebp]
	jg	$LN30@LoadWeapon
	cmp	DWORD PTR _num$[ebp], 0
	jle	$LN30@LoadWeapon

; 262  : 		// RV - Biker - Jammers now do overwrite AA and AG weapons
; 263  : 		//if (!Weapon[hp] && (!sl || !Weapon[lhp+1-hp]))		// Only check for empty hard points
; 264  : 		if (!Weapon[hp] && (!sl || !Weapon[lhp+1-hp]) || ((type_flags & WEAP_ECM || type_flags & WEAP_LASER_POD) && !(WeaponDataTable[Weapon[hp]].Flags & (WEAP_FUEL | WEAP_RECON))))		// Only check for empty hard points

	mov	edx, DWORD PTR _hp$[ebp]
	mov	eax, DWORD PTR _Weapon$[ebp]
	movsx	ecx, WORD PTR [eax+edx*2]
	test	ecx, ecx
	jne	SHORT $LN27@LoadWeapon
	cmp	DWORD PTR _sl$[ebp], 0
	je	SHORT $LN28@LoadWeapon
	mov	edx, DWORD PTR _lhp$[ebp]
	add	edx, 1
	sub	edx, DWORD PTR _hp$[ebp]
	mov	eax, DWORD PTR _Weapon$[ebp]
	movsx	ecx, WORD PTR [eax+edx*2]
	test	ecx, ecx
	je	SHORT $LN28@LoadWeapon
$LN27@LoadWeapon:
	mov	edx, DWORD PTR _type_flags$[ebp]
	and	edx, 4
	jne	SHORT $LN26@LoadWeapon
	mov	eax, DWORD PTR _type_flags$[ebp]
	and	eax, 262144				; 00040000H
	je	$LN29@LoadWeapon
$LN26@LoadWeapon:
	mov	ecx, DWORD PTR _hp$[ebp]
	mov	edx, DWORD PTR _Weapon$[ebp]
	movsx	eax, WORD PTR [edx+ecx*2]
	imul	eax, 60					; 0000003cH
	mov	ecx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	edx, WORD PTR [ecx+eax+10]
	and	edx, 3
	jne	$LN29@LoadWeapon
$LN28@LoadWeapon:

; 265  : 		//if (!Weapon[hp] || (temp_flags & WEAP_LASER_POD))
; 266  : 		{
; 267  : 			if (vc->Weapons[hp] == 255)		// This is a weapon list

	mov	eax, DWORD PTR _vc$[ebp]
	add	eax, DWORD PTR _hp$[ebp]
	movzx	ecx, BYTE PTR [eax+130]
	cmp	ecx, 255				; 000000ffH
	jne	$LN25@LoadWeapon

; 268  : 				{
; 269  : 				wl = vc->Weapon[hp];

	mov	edx, DWORD PTR _hp$[ebp]
	mov	eax, DWORD PTR _vc$[ebp]
	movsx	ecx, WORD PTR [eax+edx*2+98]
	mov	DWORD PTR _wl$[ebp], ecx

; 270  : 				for (i=0, bs=INT_MIN, bw=-1, wid=-1; i<MAX_WEAPONS_IN_LIST && wid; i++)

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _bs$[ebp], -2147483648	; 80000000H
	mov	DWORD PTR _bw$[ebp], -1
	mov	DWORD PTR _wid$[ebp], -1
	jmp	SHORT $LN24@LoadWeapon
$LN23@LoadWeapon:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN24@LoadWeapon:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	$LN22@LoadWeapon
	cmp	DWORD PTR _wid$[ebp], 0
	je	$LN22@LoadWeapon

; 271  : 					{
; 272  : 					wid = GetListEntryWeapon(wl,i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wl$[ebp]
	push	ecx
	call	?GetListEntryWeapon@@YAHHH@Z		; GetListEntryWeapon
	add	esp, 8
	mov	DWORD PTR _wid$[ebp], eax

; 273  : 					score = WeaponLoadScore (wid, lw, dam, mt, type_flags, guide_flags, TRUE);

	push	1
	mov	edx, DWORD PTR _guide_flags$[ebp]
	push	edx
	mov	eax, DWORD PTR _type_flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dam$[ebp]
	push	edx
	mov	eax, DWORD PTR _lw$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wid$[ebp]
	push	ecx
	call	?WeaponLoadScore@@YAHHHPAEW4MoveType@@HHH@Z ; WeaponLoadScore
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _score$[ebp], eax

; 274  : 															
; 275  : 					// Better score for bomb-bays, essentially
; 276  : 					ShiAssert(WeaponDataTable[wid].FireRate);
; 277  : 					if (!(vc->VisibleFlags & (0x01 << hp)) && WeaponDataTable[wid].FireRate)

	mov	edx, DWORD PTR _vc$[ebp]
	movzx	eax, WORD PTR [edx+62]
	mov	edx, 1
	mov	ecx, DWORD PTR _hp$[ebp]
	shl	edx, cl
	and	eax, edx
	jne	SHORT $LN21@LoadWeapon
	mov	eax, DWORD PTR _wid$[ebp]
	imul	eax, 60					; 0000003cH
	mov	ecx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	edx, BYTE PTR [ecx+eax+40]
	test	edx, edx
	je	SHORT $LN21@LoadWeapon

; 278  : 						score = score * vc->Weapons[hp] / WeaponDataTable[wid].FireRate;

	mov	eax, DWORD PTR _vc$[ebp]
	add	eax, DWORD PTR _hp$[ebp]
	movzx	ecx, BYTE PTR [eax+130]
	mov	eax, ecx
	imul	eax, DWORD PTR _score$[ebp]
	mov	edx, DWORD PTR _wid$[ebp]
	imul	edx, 60					; 0000003cH
	mov	ecx, DWORD PTR ?WeaponDataTable@@3PAUWeaponClassDataType@@A ; WeaponDataTable
	movzx	ecx, BYTE PTR [ecx+edx+40]
	cdq
	idiv	ecx
	mov	DWORD PTR _score$[ebp], eax
$LN21@LoadWeapon:

; 279  : 					if (score && uc)

	cmp	DWORD PTR _score$[ebp], 0
	je	$LN20@LoadWeapon
	cmp	DWORD PTR _uc$[ebp], 0
	je	$LN20@LoadWeapon

; 280  : 						{
; 281  : 						if (!((Squadron)squadron)->GetUnitStores(wid))

	mov	edx, DWORD PTR _wid$[ebp]
	push	edx
	mov	eax, DWORD PTR _squadron$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _squadron$[ebp]
	mov	eax, DWORD PTR [edx+788]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN19@LoadWeapon

; 282  : 							{
; 283  : #ifndef INFINITE_AI_AMMO
; 284  : 							// Check for infinite weapons
; 285  : 							if (wid != SquadronStoresDataTable[uc->SpecialIndex].infiniteAA && wid != SquadronStoresDataTable[uc->SpecialIndex].infiniteAG)
; 286  : 								score = 0;
; 287  : #else
; 288  : 							score = -score;			// The worst thing wins..

	mov	edx, DWORD PTR _score$[ebp]
	neg	edx
	mov	DWORD PTR _score$[ebp], edx
	jmp	$LN20@LoadWeapon
$LN19@LoadWeapon:

; 289  : #endif
; 290  : 							}
; 291  : 						else if (((Squadron)squadron)->GetUnitStores(wid) < 100)

	mov	eax, DWORD PTR _wid$[ebp]
	push	eax
	mov	ecx, DWORD PTR _squadron$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _squadron$[ebp]
	mov	eax, DWORD PTR [edx+788]
	call	eax
	movzx	ecx, al
	cmp	ecx, 100				; 00000064H
	jge	$LN20@LoadWeapon

; 292  : 							{
; 293  : 							// Lower score of rare things
; 294  : 							if (wid != SquadronStoresDataTable[uc->SpecialIndex].infiniteAA && wid != SquadronStoresDataTable[uc->SpecialIndex].infiniteAG)

	mov	edx, DWORD PTR _uc$[ebp]
	movsx	eax, WORD PTR [edx+330]
	imul	eax, 603				; 0000025bH
	mov	ecx, DWORD PTR ?SquadronStoresDataTable@@3PAUSquadronStoresDataType@@A ; SquadronStoresDataTable
	movzx	edx, BYTE PTR [ecx+eax+601]
	cmp	DWORD PTR _wid$[ebp], edx
	je	$LN20@LoadWeapon
	mov	eax, DWORD PTR _uc$[ebp]
	movsx	ecx, WORD PTR [eax+330]
	imul	ecx, 603				; 0000025bH
	mov	edx, DWORD PTR ?SquadronStoresDataTable@@3PAUSquadronStoresDataType@@A ; SquadronStoresDataTable
	movzx	eax, BYTE PTR [edx+ecx+600]
	cmp	DWORD PTR _wid$[ebp], eax
	je	SHORT $LN20@LoadWeapon

; 295  : 								score = max(((score * ((Squadron)squadron)->GetUnitStores(wid)) / 100),1);

	mov	ecx, DWORD PTR _wid$[ebp]
	push	ecx
	mov	edx, DWORD PTR _squadron$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _squadron$[ebp]
	mov	edx, DWORD PTR [eax+788]
	call	edx
	movzx	eax, al
	imul	eax, DWORD PTR _score$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	cmp	eax, 1
	jle	SHORT $LN44@LoadWeapon
	mov	edx, DWORD PTR _wid$[ebp]
	push	edx
	mov	eax, DWORD PTR _squadron$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _squadron$[ebp]
	mov	eax, DWORD PTR [edx+788]
	call	eax
	movzx	ecx, al
	mov	eax, ecx
	imul	eax, DWORD PTR _score$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR tv258[ebp], eax
	jmp	SHORT $LN45@LoadWeapon
$LN44@LoadWeapon:
	mov	DWORD PTR tv258[ebp], 1
$LN45@LoadWeapon:
	mov	edx, DWORD PTR tv258[ebp]
	mov	DWORD PTR _score$[ebp], edx
$LN20@LoadWeapon:

; 296  : 							}
; 297  : 						}
; 298  : 					if (score && score > bs)

	cmp	DWORD PTR _score$[ebp], 0
	je	SHORT $LN15@LoadWeapon
	mov	eax, DWORD PTR _score$[ebp]
	cmp	eax, DWORD PTR _bs$[ebp]
	jle	SHORT $LN15@LoadWeapon

; 299  : 						{
; 300  : 						bs = score;

	mov	ecx, DWORD PTR _score$[ebp]
	mov	DWORD PTR _bs$[ebp], ecx

; 301  : 						bw = i;

	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _bw$[ebp], edx
$LN15@LoadWeapon:

; 302  : 						}
; 303  : 					}

	jmp	$LN23@LoadWeapon
$LN22@LoadWeapon:

; 304  : 				
; 305  : 				if (bs > INT_MIN) {

	cmp	DWORD PTR _bs$[ebp], -2147483648	; 80000000H
	jle	$LN14@LoadWeapon

; 306  : 					if (force_on_one)

	cmp	DWORD PTR _force_on_one$[ebp], 0
	je	SHORT $LN13@LoadWeapon

; 307  : 						num = LoadWeapon(hp,lhp,GetListEntryWeapon(wl,bw),num,num/(sl+1),(Squadron)squadron,Weapon,Weapons,vc);

	mov	eax, DWORD PTR _vc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Weapons$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Weapon$[ebp]
	push	edx
	mov	eax, DWORD PTR _squadron$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sl$[ebp]
	add	ecx, 1
	mov	eax, DWORD PTR _num$[ebp]
	cdq
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _num$[ebp]
	push	edx
	mov	eax, DWORD PTR _bw$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wl$[ebp]
	push	ecx
	call	?GetListEntryWeapon@@YAHHH@Z		; GetListEntryWeapon
	add	esp, 8
	push	eax
	mov	edx, DWORD PTR _lhp$[ebp]
	push	edx
	mov	eax, DWORD PTR _hp$[ebp]
	push	eax
	call	?LoadWeapon@@YAHHHFHHPAVSquadronClass@@QAFQAEPAUVehicleClassDataType@@@Z ; LoadWeapon
	add	esp, 36					; 00000024H
	mov	DWORD PTR _num$[ebp], eax

; 308  : 					else

	jmp	SHORT $LN14@LoadWeapon
$LN13@LoadWeapon:

; 309  : 						num = LoadWeapon(hp,lhp,GetListEntryWeapon(wl,bw),num,GetListEntryWeapons(wl,bw),(Squadron)squadron,Weapon,Weapons,vc);

	mov	ecx, DWORD PTR _vc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Weapons$[ebp]
	push	edx
	mov	eax, DWORD PTR _Weapon$[ebp]
	push	eax
	mov	ecx, DWORD PTR _squadron$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bw$[ebp]
	push	edx
	mov	eax, DWORD PTR _wl$[ebp]
	push	eax
	call	?GetListEntryWeapons@@YAHHH@Z		; GetListEntryWeapons
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bw$[ebp]
	push	edx
	mov	eax, DWORD PTR _wl$[ebp]
	push	eax
	call	?GetListEntryWeapon@@YAHHH@Z		; GetListEntryWeapon
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _lhp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hp$[ebp]
	push	edx
	call	?LoadWeapon@@YAHHHFHHPAVSquadronClass@@QAFQAEPAUVehicleClassDataType@@@Z ; LoadWeapon
	add	esp, 36					; 00000024H
	mov	DWORD PTR _num$[ebp], eax
$LN14@LoadWeapon:

; 310  : 				}
; 311  : 			}
; 312  : 			else {

	jmp	$LN29@LoadWeapon
$LN25@LoadWeapon:

; 313  : 				if (hp) {

	cmp	DWORD PTR _hp$[ebp], 0
	je	$LN10@LoadWeapon

; 314  : 					if (WeaponLoadScore (vc->Weapon[hp], 0, dam, mt, type_flags, guide_flags, FALSE)) {

	push	0
	mov	eax, DWORD PTR _guide_flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _type_flags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mt$[ebp]
	push	edx
	mov	eax, DWORD PTR _dam$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _hp$[ebp]
	mov	edx, DWORD PTR _vc$[ebp]
	movsx	eax, WORD PTR [edx+ecx*2+98]
	push	eax
	call	?WeaponLoadScore@@YAHHHPAEW4MoveType@@HHH@Z ; WeaponLoadScore
	add	esp, 28					; 0000001cH
	test	eax, eax
	je	$LN9@LoadWeapon

; 315  : 						if (type_flags & WEAP_LASER_POD){

	mov	ecx, DWORD PTR _type_flags$[ebp]
	and	ecx, 262144				; 00040000H
	je	SHORT $LN8@LoadWeapon

; 316  : 							num = LoadWeapon(hp,hp,GetListEntryWeapon(wl,bw),1, 1,(Squadron)squadron,Weapon,Weapons,vc);

	mov	edx, DWORD PTR _vc$[ebp]
	push	edx
	mov	eax, DWORD PTR _Weapons$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Weapon$[ebp]
	push	ecx
	mov	edx, DWORD PTR _squadron$[ebp]
	push	edx
	push	1
	push	1
	mov	eax, DWORD PTR _bw$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wl$[ebp]
	push	ecx
	call	?GetListEntryWeapon@@YAHHH@Z		; GetListEntryWeapon
	add	esp, 8
	push	eax
	mov	edx, DWORD PTR _hp$[ebp]
	push	edx
	mov	eax, DWORD PTR _hp$[ebp]
	push	eax
	call	?LoadWeapon@@YAHHHFHHPAVSquadronClass@@QAFQAEPAUVehicleClassDataType@@@Z ; LoadWeapon
	add	esp, 36					; 00000024H
	mov	DWORD PTR _num$[ebp], eax

; 317  : 							return 0;

	xor	eax, eax
	jmp	$LN42@LoadWeapon

; 318  : 						}
; 319  : 						else {

	jmp	$LN9@LoadWeapon
$LN8@LoadWeapon:

; 320  : 							if (force_on_one)

	cmp	DWORD PTR _force_on_one$[ebp], 0
	je	SHORT $LN6@LoadWeapon

; 321  : 								num = LoadWeapon(hp,lhp,vc->Weapon[hp],num,num/(sl+1),(Squadron)squadron,Weapon,Weapons,vc);

	mov	ecx, DWORD PTR _vc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Weapons$[ebp]
	push	edx
	mov	eax, DWORD PTR _Weapon$[ebp]
	push	eax
	mov	ecx, DWORD PTR _squadron$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _sl$[ebp]
	add	ecx, 1
	mov	eax, DWORD PTR _num$[ebp]
	cdq
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _num$[ebp]
	push	edx
	mov	eax, DWORD PTR _hp$[ebp]
	mov	ecx, DWORD PTR _vc$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2+98]
	push	edx
	mov	eax, DWORD PTR _lhp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hp$[ebp]
	push	ecx
	call	?LoadWeapon@@YAHHHFHHPAVSquadronClass@@QAFQAEPAUVehicleClassDataType@@@Z ; LoadWeapon
	add	esp, 36					; 00000024H
	mov	DWORD PTR _num$[ebp], eax

; 322  : 							else

	jmp	SHORT $LN9@LoadWeapon
$LN6@LoadWeapon:

; 323  : 								num = LoadWeapon(hp,lhp,vc->Weapon[hp],num,vc->Weapons[hp],(Squadron)squadron,Weapon,Weapons,vc);

	mov	edx, DWORD PTR _vc$[ebp]
	push	edx
	mov	eax, DWORD PTR _Weapons$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Weapon$[ebp]
	push	ecx
	mov	edx, DWORD PTR _squadron$[ebp]
	push	edx
	mov	eax, DWORD PTR _vc$[ebp]
	add	eax, DWORD PTR _hp$[ebp]
	movzx	ecx, BYTE PTR [eax+130]
	push	ecx
	mov	edx, DWORD PTR _num$[ebp]
	push	edx
	mov	eax, DWORD PTR _hp$[ebp]
	mov	ecx, DWORD PTR _vc$[ebp]
	movzx	edx, WORD PTR [ecx+eax*2+98]
	push	edx
	mov	eax, DWORD PTR _lhp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hp$[ebp]
	push	ecx
	call	?LoadWeapon@@YAHHHFHHPAVSquadronClass@@QAFQAEPAUVehicleClassDataType@@@Z ; LoadWeapon
	add	esp, 36					; 00000024H
	mov	DWORD PTR _num$[ebp], eax
$LN9@LoadWeapon:

; 324  : 						}
; 325  : 					}
; 326  : 				}
; 327  : 				else {

	jmp	SHORT $LN29@LoadWeapon
$LN10@LoadWeapon:

; 328  : 					// This is a freebee - it's our gun
; 329  : 					Weapon[hp] = vc->Weapon[hp];

	mov	edx, DWORD PTR _hp$[ebp]
	mov	eax, DWORD PTR _Weapon$[ebp]
	mov	ecx, DWORD PTR _hp$[ebp]
	mov	esi, DWORD PTR _vc$[ebp]
	mov	cx, WORD PTR [esi+ecx*2+98]
	mov	WORD PTR [eax+edx*2], cx

; 330  : 					Weapons[hp] = vc->Weapons[hp];							// Max loadable weapons

	mov	edx, DWORD PTR _Weapons$[ebp]
	add	edx, DWORD PTR _hp$[ebp]
	mov	eax, DWORD PTR _vc$[ebp]
	add	eax, DWORD PTR _hp$[ebp]
	mov	cl, BYTE PTR [eax+130]
	mov	BYTE PTR [edx], cl
$LN29@LoadWeapon:

; 331  : 				}
; 332  : 			}
; 333  : 		}
; 334  : 
; 335  : #ifdef DEBUG
; 336  : 		if (Weapon[hp])
; 337  : 			ShiAssert( Weapons[hp] );
; 338  : #endif
; 339  : 
; 340  : 		if (hp && !lw && Weapon[hp])

	cmp	DWORD PTR _hp$[ebp], 0
	je	SHORT $LN3@LoadWeapon
	cmp	DWORD PTR _lw$[ebp], 0
	jne	SHORT $LN3@LoadWeapon
	mov	edx, DWORD PTR _hp$[ebp]
	mov	eax, DWORD PTR _Weapon$[ebp]
	movsx	ecx, WORD PTR [eax+edx*2]
	test	ecx, ecx
	je	SHORT $LN3@LoadWeapon

; 341  : 			lw = Weapon[hp];

	mov	edx, DWORD PTR _hp$[ebp]
	mov	eax, DWORD PTR _Weapon$[ebp]
	movsx	ecx, WORD PTR [eax+edx*2]
	mov	DWORD PTR _lw$[ebp], ecx
$LN3@LoadWeapon:

; 342  : 
; 343  : 		// RV - Biker - Maybe need to rework this
; 344  : 		if (type_flags & WEAP_LASER_POD && num == 0)

	mov	edx, DWORD PTR _type_flags$[ebp]
	and	edx, 262144				; 00040000H
	je	SHORT $LN2@LoadWeapon
	cmp	DWORD PTR _num$[ebp], 0
	jne	SHORT $LN2@LoadWeapon

; 345  : 			break;

	jmp	SHORT $LN30@LoadWeapon
$LN2@LoadWeapon:

; 346  : 		
; 347  : 		// We checked the center, now do a normal search
; 348  : 		if (chp)

	cmp	DWORD PTR _chp$[ebp], 0
	je	SHORT $LN1@LoadWeapon

; 349  : 			hp = chp = 0;

	mov	DWORD PTR _chp$[ebp], 0
	mov	eax, DWORD PTR _chp$[ebp]
	mov	DWORD PTR _hp$[ebp], eax
$LN1@LoadWeapon:

; 350  : 	}

	jmp	$LN31@LoadWeapon
$LN30@LoadWeapon:

; 351  : 	return tl-num;

	mov	eax, DWORD PTR _tl$[ebp]
	sub	eax, DWORD PTR _num$[ebp]
$LN42@LoadWeapon:

; 352  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?LoadWeapons@@YAHPAXHPAEW4MoveType@@HHHQAFQAE@Z ENDP	; LoadWeapons
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ PROC ; VuBin<VuSessionEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ENDP ; VuBin<VuSessionEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ PROC		; VuBin<VuSessionEntity>::operator bool, COMDAT
; _this$ = ecx

; 40   : 	operator bool() const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		return e != NULL;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@operator
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv66[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv66[ebp]

; 42   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ ENDP		; VuBin<VuSessionEntity>::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
END
