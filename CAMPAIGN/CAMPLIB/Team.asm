; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\CAMPAIGN\CAMPLIB\Team.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?teamManagerDIndex@@3FA				; teamManagerDIndex
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?DogfightTeamNames@@3PAY0BE@DA			; DogfightTeamNames
PUBLIC	?RoEData@@3PAY05EA				; RoEData
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::SIMDIRTYDATA_INTERVAL
PUBLIC	?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB	; FalconEntity::CMPDIRTYDATA_INTERVAL
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?DefaultObjtypePriority@@3PAY0CE@EA		; DefaultObjtypePriority
PUBLIC	?DefaultUnittypePriority@@3PAY0BE@EA		; DefaultUnittypePriority
PUBLIC	?DefaultMissionPriority@@3PAY0CJ@EA		; DefaultMissionPriority
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?TeamInfo@@3PAPAVTeamClass@@A			; TeamInfo
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B ; std::ios_base::failure::_Stream_err
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
_BSS	SEGMENT
?teamManagerDIndex@@3FA DW 01H DUP (?)			; teamManagerDIndex
	ALIGN	4

?DefaultObjtypePriority@@3PAY0CE@EA DB 0b4H DUP (?)	; DefaultObjtypePriority
?DefaultUnittypePriority@@3PAY0BE@EA DB 064H DUP (?)	; DefaultUnittypePriority
?DefaultMissionPriority@@3PAY0CJ@EA DB 0cdH DUP (?)	; DefaultMissionPriority
	ALIGN	4

?TeamInfo@@3PAPAVTeamClass@@A DD 08H DUP (?)		; TeamInfo
_BSS	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B
CONST	SEGMENT
?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B DD 01H ; std::ios_base::failure::_Stream_err
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?CMPDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::CMPDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB
CONST	SEGMENT
?SIMDIRTYDATA_INTERVAL@FalconEntity@@2KB DD 0c8H	; FalconEntity::SIMDIRTYDATA_INTERVAL
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
_DATA	SEGMENT
?DogfightTeamNames@@3PAY0BE@DA DB 'UFO', 00H		; DogfightTeamNames
	ORG $+16
	DB	'Crimson', 00H
	ORG $+12
	DB	'Shark', 00H
	ORG $+14
	DB	'USA', 00H
	ORG $+16
	DB	'Tiger', 00H
	ORG $+14
	DB	'UFO', 00H
	ORG $+16
	DB	'UFO', 00H
	ORG $+16
	DB	'UFO', 00H
	ORG $+16
?RoEData@@3PAY05EA DB 00H				; RoEData
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
_DATA	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0VU_SESSION_ID@@QAE@K@Z			; VU_SESSION_ID::VU_SESSION_ID
PUBLIC	??8VU_SESSION_ID@@QBEHABV0@@Z			; VU_SESSION_ID::operator==
PUBLIC	??0VU_ID@@QAE@XZ				; VU_ID::VU_ID
PUBLIC	??8VU_ID@@QBE_NABV0@@Z				; VU_ID::operator==
PUBLIC	??9VU_ID@@QBE_NABV0@@Z				; VU_ID::operator!=
PUBLIC	_atanf
PUBLIC	?atan@@YAMM@Z					; atan
PUBLIC	?SetAssociation@VuEntity@@QAEXVVU_ID@@@Z	; VuEntity::SetAssociation
PUBLIC	?Id@VuEntity@@QBE?AVVU_ID@@XZ			; VuEntity::Id
PUBLIC	?SetSendCreate@VuEntity@@QAEXW4VU_SEND_TYPE@1@@Z ; VuEntity::SetSendCreate
PUBLIC	?OwnerId@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::OwnerId
PUBLIC	?VuState@VuEntity@@QBE?AW4VU_MEM@@XZ		; VuEntity::VuState
PUBLIC	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ	; VuEntity::EntityType
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0logic_error@std@@QAE@PBD@Z			; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	??_Glogic_error@std@@UAEPAXI@Z			; std::logic_error::`scalar deleting destructor'
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
PUBLIC	??1out_of_range@std@@UAE@XZ			; std::out_of_range::~out_of_range
PUBLIC	??0out_of_range@std@@QAE@ABV01@@Z		; std::out_of_range::out_of_range
PUBLIC	??_Gout_of_range@std@@UAEPAXI@Z			; std::out_of_range::`scalar deleting destructor'
PUBLIC	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ		; VuBin<VuSessionEntity>::operator bool
PUBLIC	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
PUBLIC	?RequestReliableTransmit@VuMessage@@QAEXXZ	; VuMessage::RequestReliableTransmit
PUBLIC	?get@?$VuBin@VVuEntity@@@@QBEPAVVuEntity@@XZ	; VuBin<VuEntity>::get
PUBLIC	?IsSimBase@FalconEntity@@UAE_NXZ		; FalconEntity::IsSimBase
PUBLIC	?IsCampBase@FalconEntity@@UAE_NXZ		; FalconEntity::IsCampBase
PUBLIC	?GetRadarMode@FalconEntity@@UAEHXZ		; FalconEntity::GetRadarMode
PUBLIC	?SetRadarMode@FalconEntity@@UAEXE@Z		; FalconEntity::SetRadarMode
PUBLIC	?ReturnToSearch@FalconEntity@@UAEXXZ		; FalconEntity::ReturnToSearch
PUBLIC	?SetSearchMode@FalconEntity@@UAEXE@Z		; FalconEntity::SetSearchMode
PUBLIC	?CombatClass@FalconEntity@@UAEHXZ		; FalconEntity::CombatClass
PUBLIC	?OnGround@FalconEntity@@UAEHXZ			; FalconEntity::OnGround
PUBLIC	?HasEntity@FalconEntity@@UBEHPAVVuEntity@@@Z	; FalconEntity::HasEntity
PUBLIC	?IsMissile@FalconEntity@@UAEHXZ			; FalconEntity::IsMissile
PUBLIC	?IsLauncher@FalconEntity@@UAEHXZ		; FalconEntity::IsLauncher
PUBLIC	?IsBomb@FalconEntity@@UAEHXZ			; FalconEntity::IsBomb
PUBLIC	?IsGun@FalconEntity@@UAEHXZ			; FalconEntity::IsGun
PUBLIC	?IsMover@FalconEntity@@UAEHXZ			; FalconEntity::IsMover
PUBLIC	?IsVehicle@FalconEntity@@UAEHXZ			; FalconEntity::IsVehicle
PUBLIC	?IsStatic@FalconEntity@@UAEHXZ			; FalconEntity::IsStatic
PUBLIC	?IsHelicopter@FalconEntity@@UAEHXZ		; FalconEntity::IsHelicopter
PUBLIC	?IsEject@FalconEntity@@UAEHXZ			; FalconEntity::IsEject
PUBLIC	?IsAirplane@FalconEntity@@UAEHXZ		; FalconEntity::IsAirplane
PUBLIC	?IsGroundVehicle@FalconEntity@@UAEHXZ		; FalconEntity::IsGroundVehicle
PUBLIC	?IsShip@FalconEntity@@UAEHXZ			; FalconEntity::IsShip
PUBLIC	?IsWeapon@FalconEntity@@UAEHXZ			; FalconEntity::IsWeapon
PUBLIC	?IsExploding@FalconEntity@@UAEHXZ		; FalconEntity::IsExploding
PUBLIC	?IsDead@FalconEntity@@UAEHXZ			; FalconEntity::IsDead
PUBLIC	?IsEmitting@FalconEntity@@UAEHXZ		; FalconEntity::IsEmitting
PUBLIC	?GetMovementType@FalconEntity@@UAE?AW4MoveType@@XZ ; FalconEntity::GetMovementType
PUBLIC	?IsUnit@FalconEntity@@UAEHXZ			; FalconEntity::IsUnit
PUBLIC	?IsObjective@FalconEntity@@UAEHXZ		; FalconEntity::IsObjective
PUBLIC	?IsBattalion@FalconEntity@@UAEHXZ		; FalconEntity::IsBattalion
PUBLIC	?IsBrigade@FalconEntity@@UAEHXZ			; FalconEntity::IsBrigade
PUBLIC	?IsFlight@FalconEntity@@UBEHXZ			; FalconEntity::IsFlight
PUBLIC	?IsSquadron@FalconEntity@@UAEHXZ		; FalconEntity::IsSquadron
PUBLIC	?IsPackage@FalconEntity@@UAEHXZ			; FalconEntity::IsPackage
PUBLIC	?IsTaskForce@FalconEntity@@UAEHXZ		; FalconEntity::IsTaskForce
PUBLIC	?IsSPJamming@FalconEntity@@UAEHXZ		; FalconEntity::IsSPJamming
PUBLIC	?IsAreaJamming@FalconEntity@@UAEHXZ		; FalconEntity::IsAreaJamming
PUBLIC	?HasSPJamming@FalconEntity@@UAEHXZ		; FalconEntity::HasSPJamming
PUBLIC	?HasAreaJamming@FalconEntity@@UAEHXZ		; FalconEntity::HasAreaJamming
PUBLIC	?GetRCSFactor@FalconEntity@@UAEMXZ		; FalconEntity::GetRCSFactor
PUBLIC	?GetIRFactor@FalconEntity@@UAEMXZ		; FalconEntity::GetIRFactor
PUBLIC	?SetAQUIREtimer@FalconEntity@@UAEXK@Z		; FalconEntity::SetAQUIREtimer
PUBLIC	?SetSEARCHtimer@FalconEntity@@UAEXK@Z		; FalconEntity::SetSEARCHtimer
PUBLIC	?SetStepSearchMode@FalconEntity@@UAEXE@Z	; FalconEntity::SetStepSearchMode
PUBLIC	?GetAQUIREtimer@FalconEntity@@UAEKXZ		; FalconEntity::GetAQUIREtimer
PUBLIC	?GetSEARCHtimer@FalconEntity@@UAEKXZ		; FalconEntity::GetSEARCHtimer
PUBLIC	??0InvalidBufferException@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; InvalidBufferException::InvalidBufferException
PUBLIC	??1InvalidBufferException@@UAE@XZ		; InvalidBufferException::~InvalidBufferException
PUBLIC	??0InvalidBufferException@@QAE@ABV0@@Z		; InvalidBufferException::InvalidBufferException
PUBLIC	??_GInvalidBufferException@@UAEPAXI@Z		; InvalidBufferException::`scalar deleting destructor'
PUBLIC	?memcpychk@@YAXPAXPAPAEIPAJ@Z			; memcpychk
PUBLIC	?GetOwner@CampBaseClass@@QAEEXZ			; CampBaseClass::GetOwner
PUBLIC	?GetDomain@CampBaseClass@@QBEEXZ		; CampBaseClass::GetDomain
PUBLIC	?GetType@CampBaseClass@@QBEEXZ			; CampBaseClass::GetType
PUBLIC	?GetSType@CampBaseClass@@QBEEXZ			; CampBaseClass::GetSType
PUBLIC	?GetUserData@ListElementClass@@QAEPAXXZ		; ListElementClass::GetUserData
PUBLIC	?GetNext@ListElementClass@@QAEPAV1@XZ		; ListElementClass::GetNext
PUBLIC	?GetPrev@ListElementClass@@QAEPAV1@XZ		; ListElementClass::GetPrev
PUBLIC	?GetFirstElement@ListClass@@QAEPAVListElementClass@@XZ ; ListClass::GetFirstElement
PUBLIC	?GetLastElement@ListClass@@QAEPAVListElementClass@@XZ ; ListClass::GetLastElement
PUBLIC	??_GListClass@@QAEPAXI@Z			; ListClass::`scalar deleting destructor'
PUBLIC	?CampEnterCriticalSection@@YAXXZ		; CampEnterCriticalSection
PUBLIC	?CampLeaveCriticalSection@@YAXXZ		; CampLeaveCriticalSection
PUBLIC	?Parent@UnitClass@@QBEHXZ			; UnitClass::Parent
PUBLIC	?Cargo@UnitClass@@QBEHXZ			; UnitClass::Cargo
PUBLIC	?GetUnitReinforcementLevel@UnitClass@@QAEHXZ	; UnitClass::GetUnitReinforcementLevel
PUBLIC	?IsNearfront@ObjectiveClass@@QAEHXZ		; ObjectiveClass::IsNearfront
PUBLIC	?GetObjectivePriority@ObjectiveClass@@QAEFXZ	; ObjectiveClass::GetObjectivePriority
PUBLIC	?GetObjectiveStatus@ObjectiveClass@@QAEEXZ	; ObjectiveClass::GetObjectiveStatus
PUBLIC	??0TeamGndActionType@@QAE@XZ			; TeamGndActionType::TeamGndActionType
PUBLIC	??0TeamAirActionType@@QAE@XZ			; TeamAirActionType::TeamAirActionType
PUBLIC	??0TeamDoctrine@@QAE@XZ				; TeamDoctrine::TeamDoctrine
PUBLIC	??0TeamClass@@QAE@HE@Z				; TeamClass::TeamClass
PUBLIC	??0TeamClass@@QAE@PAPAEPAJ@Z			; TeamClass::TeamClass
PUBLIC	??0TeamClass@@QAE@PAU_iobuf@@@Z			; TeamClass::TeamClass
PUBLIC	??1TeamClass@@UAE@XZ				; TeamClass::~TeamClass
PUBLIC	?InitData@TeamClass@@UAEXXZ			; TeamClass::InitData
PUBLIC	?InitLocalData@TeamClass@@AAEXE@Z		; TeamClass::InitLocalData
PUBLIC	?GetVt@TeamClass@@UBEMXZ			; TeamClass::GetVt
PUBLIC	?GetKias@TeamClass@@UBEMXZ			; TeamClass::GetKias
PUBLIC	?Handle@TeamClass@@UAEHPAVVuEvent@@@Z		; TeamClass::Handle
PUBLIC	?Handle@TeamClass@@UAEHPAVVuFullUpdateEvent@@@Z	; TeamClass::Handle
PUBLIC	?Handle@TeamClass@@UAEHPAVVuPositionUpdateEvent@@@Z ; TeamClass::Handle
PUBLIC	?Handle@TeamClass@@UAEHPAVVuEntityCollisionEvent@@@Z ; TeamClass::Handle
PUBLIC	?Handle@TeamClass@@UAEHPAVVuTransferEvent@@@Z	; TeamClass::Handle
PUBLIC	?Handle@TeamClass@@UAEHPAVVuSessionEvent@@@Z	; TeamClass::Handle
PUBLIC	?InsertionCallback@TeamClass@@UAEHXZ		; TeamClass::InsertionCallback
PUBLIC	?RemovalCallback@TeamClass@@UAEHXZ		; TeamClass::RemovalCallback
PUBLIC	?Wake@TeamClass@@UAEHXZ				; TeamClass::Wake
PUBLIC	?Sleep@TeamClass@@UAEHXZ			; TeamClass::Sleep
PUBLIC	?GetInitiative@TeamClass@@QAEFXZ		; TeamClass::GetInitiative
PUBLIC	?GetSupplyAvail@TeamClass@@QAEGXZ		; TeamClass::GetSupplyAvail
PUBLIC	?GetFuelAvail@TeamClass@@QAEGXZ			; TeamClass::GetFuelAvail
PUBLIC	?GetReplacementsAvail@TeamClass@@QAEGXZ		; TeamClass::GetReplacementsAvail
PUBLIC	?GetReinforcement@TeamClass@@QAEFXZ		; TeamClass::GetReinforcement
PUBLIC	?GetObjTypePriority@TeamClass@@QAEEH@Z		; TeamClass::GetObjTypePriority
PUBLIC	?GetUnitTypePriority@TeamClass@@QAEEH@Z		; TeamClass::GetUnitTypePriority
PUBLIC	?GetMissionPriority@TeamClass@@QAEEH@Z		; TeamClass::GetMissionPriority
PUBLIC	?GetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::GetCurrentStats
PUBLIC	?GetGroundAction@TeamClass@@QAEPAUTeamGndActionType@@XZ ; TeamClass::GetGroundAction
PUBLIC	?GetCampID@TeamClass@@UAEFXZ			; TeamClass::GetCampID
PUBLIC	?GetTeam@TeamClass@@UAEEXZ			; TeamClass::GetTeam
PUBLIC	?GetCountry@TeamClass@@UAEEXZ			; TeamClass::GetCountry
PUBLIC	?SetInitiative@TeamClass@@QAEXF@Z		; TeamClass::SetInitiative
PUBLIC	?SetReinforcement@TeamClass@@QAEXF@Z		; TeamClass::SetReinforcement
PUBLIC	?SetAllObjTypePriority@TeamClass@@QAEPAEXZ	; TeamClass::SetAllObjTypePriority
PUBLIC	?SetAllUnitTypePriority@TeamClass@@QAEPAEXZ	; TeamClass::SetAllUnitTypePriority
PUBLIC	?SetAllMissionPriority@TeamClass@@QAEPAEXZ	; TeamClass::SetAllMissionPriority
PUBLIC	?SetObjTypePriority@TeamClass@@QAEXHE@Z		; TeamClass::SetObjTypePriority
PUBLIC	?SetUnitTypePriority@TeamClass@@QAEXHE@Z	; TeamClass::SetUnitTypePriority
PUBLIC	?SetMissionPriority@TeamClass@@QAEXHE@Z		; TeamClass::SetMissionPriority
PUBLIC	?SetSupplyAvail@TeamClass@@QAEXH@Z		; TeamClass::SetSupplyAvail
PUBLIC	?SetFuelAvail@TeamClass@@QAEXH@Z		; TeamClass::SetFuelAvail
PUBLIC	?SetReplacementsAvail@TeamClass@@QAEXH@Z	; TeamClass::SetReplacementsAvail
PUBLIC	?SetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::SetCurrentStats
PUBLIC	?SetGroundAction@TeamClass@@QAEPAUTeamGndActionType@@XZ ; TeamClass::SetGroundAction
PUBLIC	?AddInitiative@TeamClass@@QAEXF@Z		; TeamClass::AddInitiative
PUBLIC	?AddReinforcement@TeamClass@@QAEXF@Z		; TeamClass::AddReinforcement
PUBLIC	?SaveSize@TeamClass@@UAEHXZ			; TeamClass::SaveSize
PUBLIC	?Save@TeamClass@@UAEHPAPAE@Z			; TeamClass::Save
PUBLIC	?Save@TeamClass@@UAEHPAU_iobuf@@@Z		; TeamClass::Save
PUBLIC	?ReadDoctrineFile@TeamClass@@QAEXXZ		; TeamClass::ReadDoctrineFile
PUBLIC	?SetActive@TeamClass@@QAEXH@Z			; TeamClass::SetActive
PUBLIC	?DumpHeader@TeamClass@@QAEXXZ			; TeamClass::DumpHeader
PUBLIC	?Dump@TeamClass@@QAEXXZ				; TeamClass::Dump
PUBLIC	?DoFullUpdate@TeamClass@@QAEXPAVVuTargetEntity@@@Z ; TeamClass::DoFullUpdate
PUBLIC	?SetName@TeamClass@@QAEXPAD@Z			; TeamClass::SetName
PUBLIC	?GetName@TeamClass@@QAEPADXZ			; TeamClass::GetName
PUBLIC	?GetFlag@TeamClass@@QAEHXZ			; TeamClass::GetFlag
PUBLIC	?SetMotto@TeamClass@@QAEXPAD@Z			; TeamClass::SetMotto
PUBLIC	?GetMotto@TeamClass@@QAEPADXZ			; TeamClass::GetMotto
PUBLIC	?GetGroundActionType@TeamClass@@QAEEXZ		; TeamClass::GetGroundActionType
PUBLIC	?SelectGroundAction@TeamClass@@QAEXXZ		; TeamClass::SelectGroundAction
PUBLIC	?SelectAirActions@TeamClass@@QAEXXZ		; TeamClass::SelectAirActions
PUBLIC	?SetGroundAction@TeamClass@@QAEXPAUTeamGndActionType@@@Z ; TeamClass::SetGroundAction
PUBLIC	?IsTeam@TeamClass@@UAEHXZ			; TeamClass::IsTeam
PUBLIC	?MakeTeamDirty@TeamClass@@QAEXW4Dirty_Team@@W4Dirtyness@@@Z ; TeamClass::MakeTeamDirty
PUBLIC	?WriteDirty@TeamClass@@QAEXPAPAE@Z		; TeamClass::WriteDirty
PUBLIC	?ReadDirty@TeamClass@@QAEXPAPAEPAJ@Z		; TeamClass::ReadDirty
PUBLIC	??_GTeamClass@@UAEPAXI@Z			; TeamClass::`scalar deleting destructor'
PUBLIC	?RemoveTeam@@YAXH@Z				; RemoveTeam
PUBLIC	?AddNewTeams@@YAXW4RelType@@@Z			; AddNewTeams
PUBLIC	?RemoveTeams@@YAXXZ				; RemoveTeams
PUBLIC	?LoadTeams@@YAHPAD@Z				; LoadTeams
PUBLIC	?SaveTeams@@YAHPAD@Z				; SaveTeams
PUBLIC	?LoadPriorityTables@@YAXXZ			; LoadPriorityTables
PUBLIC	?GetRoE@@YAHEEH@Z				; GetRoE
PUBLIC	?TransferInitiative@@YAXEEH@Z			; TransferInitiative
PUBLIC	?AirExperienceAdjustment@@YAME@Z		; AirExperienceAdjustment
PUBLIC	?AirDefenseExperienceAdjustment@@YAME@Z		; AirDefenseExperienceAdjustment
PUBLIC	?GroundExperienceAdjustment@@YAME@Z		; GroundExperienceAdjustment
PUBLIC	?NavalExperienceAdjustment@@YAME@Z		; NavalExperienceAdjustment
PUBLIC	?CombatBonus@@YAMEVVU_ID@@@Z			; CombatBonus
PUBLIC	?ApplyPlayerInput@@YAXEVVU_ID@@H@Z		; ApplyPlayerInput
PUBLIC	?GetEnemyTeam@@YAEE@Z				; GetEnemyTeam
PUBLIC	?GetPriority@@YAHPAVMissionRequestClass@@@Z	; GetPriority
PUBLIC	?AddReinforcements@@YAXEH@Z			; AddReinforcements
PUBLIC	?UpdateTeamStatistics@@YAXXZ			; UpdateTeamStatistics
PUBLIC	?NavalSuperiority@@YAHE@Z			; NavalSuperiority
PUBLIC	?AirSuperiority@@YAHE@Z				; AirSuperiority
PUBLIC	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?CampGetNext@@YAPADPAU_iobuf@@@Z		; CampGetNext
PUBLIC	?GetTeamSituation@@YAHE@Z			; GetTeamSituation
PUBLIC	?StartOffensive@@YAXHH@Z			; StartOffensive
PUBLIC	?AddTeam@@YAXHH@Z				; AddTeam
PUBLIC	?ApplyBonus@@YAXEVVU_ID@@H@Z			; ApplyBonus
PUBLIC	?NewInitiativePointSetting@@YAXE@Z		; NewInitiativePointSetting
PUBLIC	?ConvertTeamToStringIndex@@YAHHHHH@Z		; ConvertTeamToStringIndex
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_7out_of_range@std@@6B@			; std::out_of_range::`vftable'
PUBLIC	??_7InvalidBufferException@@6B@			; InvalidBufferException::`vftable'
PUBLIC	??_C@_0CI@MPKJAHJH@Trying?5to?5write?5?$CFlu?5bytes?5to?5?$CFld@ ; `string'
PUBLIC	__TI4?AVInvalidBufferException@@
PUBLIC	__CTA4?AVInvalidBufferException@@
PUBLIC	??_R0?AVInvalidBufferException@@@8		; InvalidBufferException `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVInvalidBufferException@@@8??0InvalidBufferException@@QAE@ABV0@@Z12
PUBLIC	??_R0?AVout_of_range@std@@@8			; std::out_of_range `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_7TeamClass@@6B@				; TeamClass::`vftable'
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	??_C@_0L@FIIMKNHK@doctrine?$CFd?$AA@		; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_03CLFHJCDC@txt?$AA@			; `string'
PUBLIC	??_C@_0EN@PKKGELNA@Team?5CbtPow?5ADPow?5?5AirPow?5GndPow@ ; `string'
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	??_C@_03IBMEEAF@tea?$AA@			; `string'
PUBLIC	??_C@_02GMLFBBN@wb?$AA@				; `string'
PUBLIC	??_C@_03FGMOOMKP@pri?$AA@			; `string'
PUBLIC	??_C@_07NEJDADE@defense?$AA@			; `string'
PUBLIC	??_C@_07GBMLDGPP@offense?$AA@			; `string'
PUBLIC	??_C@_06BONAEKEC@attrit?$AA@			; `string'
PUBLIC	??_C@_03LKCPPDCM@cas?$AA@			; `string'
PUBLIC	??_C@_07DFBNEDOG@intdict?$AA@			; `string'
PUBLIC	??_C@_02BOGAIONP@ab?$AA@			; `string'
PUBLIC	??_C@_03NJFDAMGG@frc?$AA@			; `string'
PUBLIC	??_C@_03FFNGDGKN@tmp?$AA@			; `string'
PUBLIC	??_C@_03GDDNCFJF@his?$AA@			; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	??_C@_08BLEENGAP@Team?4cpp?$AA@			; `string'
PUBLIC	??_C@_0CK@FGAGGLML@?$CFs?5?$CFd?3?5error?5reading?5dirty?0?5inva@ ; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4out_of_range@std@@6B@			; std::out_of_range::`RTTI Complete Object Locator'
PUBLIC	??_R3out_of_range@std@@8			; std::out_of_range::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2out_of_range@std@@8			; std::out_of_range::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@out_of_range@std@@8		; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4InvalidBufferException@@6B@		; InvalidBufferException::`RTTI Complete Object Locator'
PUBLIC	??_R3InvalidBufferException@@8			; InvalidBufferException::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2InvalidBufferException@@8			; InvalidBufferException::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@InvalidBufferException@@8		; InvalidBufferException::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4TeamClass@@6B@				; TeamClass::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVTeamClass@@@8				; TeamClass `RTTI Type Descriptor'
PUBLIC	??_R3TeamClass@@8				; TeamClass::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2TeamClass@@8				; TeamClass::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@TeamClass@@8			; TeamClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@FalconEntity@@8			; FalconEntity::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVFalconEntity@@@8			; FalconEntity `RTTI Type Descriptor'
PUBLIC	??_R3FalconEntity@@8				; FalconEntity::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2FalconEntity@@8				; FalconEntity::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@VuEntity@@8			; VuEntity::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVVuEntity@@@8				; VuEntity `RTTI Type Descriptor'
PUBLIC	??_R3VuEntity@@8				; VuEntity::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2VuEntity@@8				; VuEntity::`RTTI Base Class Array'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@3ff922d0e5604189
PUBLIC	__real@40400000
PUBLIC	__real@4059000000000000
PUBLIC	__real@40800000
PUBLIC	__real@41000000
PUBLIC	__real@41a00000
PUBLIC	__real@42c80000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	_fgets:PROC
EXTRN	_fread:PROC
EXTRN	_fscanf:PROC
EXTRN	_fseek:PROC
EXTRN	_fwrite:PROC
EXTRN	_sprintf:PROC
EXTRN	_atan:PROC
EXTRN	_atof:PROC
EXTRN	_atoi:PROC
EXTRN	_rand:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	_strncpy:PROC
EXTRN	_MonoPrint:PROC
EXTRN	__imp__PostMessageA@16:PROC
EXTRN	?VuReferenceEntity@@YAHPAVVuEntity@@@Z:PROC	; VuReferenceEntity
EXTRN	?VuDeReferenceEntity@@YAHPAVVuEntity@@@Z:PROC	; VuDeReferenceEntity
EXTRN	?SetEntityType@VuEntity@@QAEXG@Z:PROC		; VuEntity::SetEntityType
EXTRN	?IsLocal@VuEntity@@QBEEXZ:PROC			; VuEntity::IsLocal
EXTRN	?CustomCollisionCheck@VuEntity@@UAEEPAV1@M@Z:PROC ; VuEntity::CustomCollisionCheck
EXTRN	?TerrainCollisionCheck@VuEntity@@UAEEXZ:PROC	; VuEntity::TerrainCollisionCheck
EXTRN	?IsTarget@VuEntity@@UAEEXZ:PROC			; VuEntity::IsTarget
EXTRN	?IsSession@VuEntity@@UAEEXZ:PROC		; VuEntity::IsSession
EXTRN	?IsGroup@VuEntity@@UAEEXZ:PROC			; VuEntity::IsGroup
EXTRN	?IsGame@VuEntity@@UAEEXZ:PROC			; VuEntity::IsGame
EXTRN	?IsCamera@VuEntity@@UBEEXZ:PROC			; VuEntity::IsCamera
EXTRN	?Handle@VuEntity@@UAEHPAVVuErrorMessage@@@Z:PROC ; VuEntity::Handle
EXTRN	?Handle@VuEntity@@UAEHPAVVuPushRequest@@@Z:PROC	; VuEntity::Handle
EXTRN	?Handle@VuEntity@@UAEHPAVVuPullRequest@@@Z:PROC	; VuEntity::Handle
EXTRN	?Handle@VuEntity@@UAEHPAVVuEvent@@@Z:PROC	; VuEntity::Handle
EXTRN	?Handle@VuEntity@@UAEHPAVVuFullUpdateEvent@@@Z:PROC ; VuEntity::Handle
EXTRN	?Handle@VuEntity@@UAEHPAVVuPositionUpdateEvent@@@Z:PROC ; VuEntity::Handle
EXTRN	?Handle@VuEntity@@UAEHPAVVuEntityCollisionEvent@@@Z:PROC ; VuEntity::Handle
EXTRN	?Handle@VuEntity@@UAEHPAVVuTransferEvent@@@Z:PROC ; VuEntity::Handle
EXTRN	?Handle@VuEntity@@UAEHPAVVuSessionEvent@@@Z:PROC ; VuEntity::Handle
EXTRN	?InsertionCallback@VuEntity@@MAEHXZ:PROC	; VuEntity::InsertionCallback
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
EXTRN	??_Eout_of_range@std@@UAEPAXI@Z:PROC		; std::out_of_range::`vector deleting destructor'
EXTRN	?Insert@VuDatabase@@QAEHPAVVuEntity@@@Z:PROC	; VuDatabase::Insert
EXTRN	?Remove@VuDatabase@@QAEHPAVVuEntity@@@Z:PROC	; VuDatabase::Remove
EXTRN	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z:PROC ; VuDatabase::Find
EXTRN	??0VuFullUpdateEvent@@QAE@PAVVuEntity@@PAVVuTargetEntity@@E@Z:PROC ; VuFullUpdateEvent::VuFullUpdateEvent
EXTRN	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ:PROC ; VuSessionEntity::Game
EXTRN	?PostVuMessage@VuMessageQueue@@SAHPAVVuMessage@@@Z:PROC ; VuMessageQueue::PostVuMessage
EXTRN	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z:PROC	; VuListIterator::VuListIterator
EXTRN	??1VuListIterator@@UAE@XZ:PROC			; VuListIterator::~VuListIterator
EXTRN	??0FalconEntity@@QAE@GK@Z:PROC			; FalconEntity::FalconEntity
EXTRN	??1FalconEntity@@UAE@XZ:PROC			; FalconEntity::~FalconEntity
EXTRN	?InitData@FalconEntity@@UAEXXZ:PROC		; FalconEntity::InitData
EXTRN	?CleanupData@FalconEntity@@UAEXXZ:PROC		; FalconEntity::CleanupData
EXTRN	?RemovalCallback@FalconEntity@@UAEHXZ:PROC	; FalconEntity::RemovalCallback
EXTRN	?GetDomain@FalconEntity@@UAEEXZ:PROC		; FalconEntity::GetDomain
EXTRN	?GetRadarType@FalconEntity@@UAEHXZ:PROC		; FalconEntity::GetRadarType
EXTRN	?GetDamageModifiers@FalconEntity@@UAEPAEXZ:PROC	; FalconEntity::GetDamageModifiers
EXTRN	?GetLocation@FalconEntity@@QBEXPAF0@Z:PROC	; FalconEntity::GetLocation
EXTRN	?SetOwner@FalconEntity@@QAEXVVU_ID@@@Z:PROC	; FalconEntity::SetOwner
EXTRN	?MakeDirty@FalconEntity@@QAEXW4Dirty_Class@@W4Dirtyness@@@Z:PROC ; FalconEntity::MakeDirty
EXTRN	?Camp_GetCurrentTime@@YAKXZ:PROC		; Camp_GetCurrentTime
EXTRN	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z:PROC	; OpenCampFile
EXTRN	?GetClassID@@YAHEEEEEEEE@Z:PROC			; GetClassID
EXTRN	??_EInvalidBufferException@@UAEPAXI@Z:PROC	; InvalidBufferException::`vector deleting destructor'
EXTRN	?GetIdFromNamespace@@YAKAAVIdNamespace@@@Z:PROC	; GetIdFromNamespace
EXTRN	??0ListClass@@QAE@E@Z:PROC			; ListClass::ListClass
EXTRN	??1ListClass@@QAE@XZ:PROC			; ListClass::~ListClass
EXTRN	?InsertNewElement@ListClass@@QAEXFPAXE@Z:PROC	; ListClass::InsertNewElement
EXTRN	_F4EnterCriticalSection:PROC
EXTRN	_F4LeaveCriticalSection:PROC
EXTRN	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ:PROC ; FalconGameEntity::GetGameType
EXTRN	?CloseCampFile@@YAXPAU_iobuf@@@Z:PROC		; CloseCampFile
EXTRN	??0FalconCampEventMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z:PROC ; FalconCampEventMessage::FalconCampEventMessage
EXTRN	?SendCampUIMessage@@YAXPAVFalconCampEventMessage@@@Z:PROC ; SendCampUIMessage
EXTRN	?GotJoinData@CampaignClass@@QAEXXZ:PROC		; CampaignClass::GotJoinData
EXTRN	?MakeCampMap@CampaignClass@@QAEPAEH@Z:PROC	; CampaignClass::MakeCampMap
EXTRN	?BroadcastUnitMessage@UnitClass@@QAEXVVU_ID@@FFFF@Z:PROC ; UnitClass::BroadcastUnitMessage
EXTRN	?GetTotalVehicles@UnitClass@@QAEHXZ:PROC	; UnitClass::GetTotalVehicles
EXTRN	?GetFirstUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z:PROC ; GetFirstUnit
EXTRN	?GetNextUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z:PROC ; GetNextUnit
EXTRN	?GetObjectivePrimary@ObjectiveClass@@QAEPAV1@XZ:PROC ; ObjectiveClass::GetObjectivePrimary
EXTRN	?GetFirstObjective@@YAPAVObjectiveClass@@PAVVuListIterator@@@Z:PROC ; GetFirstObjective
EXTRN	?GetNextObjective@@YAPAVObjectiveClass@@PAVVuListIterator@@@Z:PROC ; GetNextObjective
EXTRN	??_ETeamClass@@UAEPAXI@Z:PROC			; TeamClass::`vector deleting destructor'
EXTRN	?GetTTRelations@@YAHEE@Z:PROC			; GetTTRelations
EXTRN	?DistSqu@@YAHFFFF@Z:PROC			; DistSqu
EXTRN	?Distance@@YAMFFFF@Z:PROC			; Distance
EXTRN	?DistanceToFront@@YAMFF@Z:PROC			; DistanceToFront
EXTRN	?FindNearestObjective@@YAPAVObjectiveClass@@FFPAMF@Z:PROC ; FindNearestObjective
EXTRN	?FindNearestObjective@@YAPAVObjectiveClass@@PAVVuLinkedList@@FFPAM@Z:PROC ; FindNearestObjective
EXTRN	??0AirTaskingManagerClass@@QAE@GE@Z:PROC	; AirTaskingManagerClass::AirTaskingManagerClass
EXTRN	??0AirTaskingManagerClass@@QAE@PAU_iobuf@@@Z:PROC ; AirTaskingManagerClass::AirTaskingManagerClass
EXTRN	?TargetAllSites@@YAHPAVObjectiveClass@@HHK@Z:PROC ; TargetAllSites
EXTRN	?GetPOData@@YAPAUPrimaryObjectiveData@@PAVObjectiveClass@@@Z:PROC ; GetPOData
EXTRN	??0GroundTaskingManagerClass@@QAE@GE@Z:PROC	; GroundTaskingManagerClass::GroundTaskingManagerClass
EXTRN	??0GroundTaskingManagerClass@@QAE@PAU_iobuf@@@Z:PROC ; GroundTaskingManagerClass::GroundTaskingManagerClass
EXTRN	??0NavalTaskingManagerClass@@QAE@GE@Z:PROC	; NavalTaskingManagerClass::NavalTaskingManagerClass
EXTRN	??0NavalTaskingManagerClass@@QAE@PAU_iobuf@@@Z:PROC ; NavalTaskingManagerClass::NavalTaskingManagerClass
EXTRN	?ReadIndexedString@@YAXHPADH@Z:PROC		; ReadIndexedString
EXTRN	?GetTeam@FalconSessionEntity@@QAEEXZ:PROC	; FalconSessionEntity::GetTeam
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	?SwapCRLF@@YAXPAD@Z:PROC			; SwapCRLF
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	?vuDatabase@@3PAVVuDatabase@@A:DWORD		; vuDatabase
EXTRN	?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A:DWORD ; vuLocalSessionEntity
EXTRN	?FalconNullId@@3VVU_ID@@A:QWORD			; FalconNullId
EXTRN	?MissionData@@3PAUMissionDataType@@A:BYTE	; MissionData
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?VolatileNS@@3VIdNamespace@@A:BYTE		; VolatileNS
EXTRN	?AllUnitList@@3PAVVuLinkedList@@A:DWORD		; AllUnitList
EXTRN	?InactiveList@@3PAVVuLinkedList@@A:DWORD	; InactiveList
EXTRN	?FrontList@@3PAVFalconPrivateList@@A:DWORD	; FrontList
EXTRN	?POList@@3PAVFalconPrivateOrderedList@@A:DWORD	; POList
EXTRN	?campCritical@@3PAUF4CSECTIONHANDLE@@A:DWORD	; campCritical
EXTRN	?TheCampaign@@3VCampaignClass@@A:BYTE		; TheCampaign
EXTRN	?gCampDataVersion@@3HA:DWORD			; gCampDataVersion
EXTRN	?FIRST_COLONEL@@3FA:WORD			; FIRST_COLONEL
EXTRN	?FIRST_COMMANDER@@3FA:WORD			; FIRST_COMMANDER
EXTRN	?FIRST_WINGMAN@@3FA:WORD			; FIRST_WINGMAN
EXTRN	?LAST_WINGMAN@@3FA:WORD				; LAST_WINGMAN
EXTRN	?MIN_FULL_OFFENSIVE_INITIATIVE@@3FA:WORD	; MIN_FULL_OFFENSIVE_INITIATIVE
EXTRN	?MIN_COUNTER_ATTACK_INITIATIVE@@3FA:WORD	; MIN_COUNTER_ATTACK_INITIATIVE
EXTRN	?ACTION_PREP_TIME@@3JA:DWORD			; ACTION_PREP_TIME
EXTRN	?MIN_RECALCULATE_STATISTICS@@3FA:WORD		; MIN_RECALCULATE_STATISTICS
EXTRN	?INITIATIVE_LEAK_PER_HOUR@@3FA:WORD		; INITIATIVE_LEAK_PER_HOUR
EXTRN	?StartOffBonusRepl@@3HA:DWORD			; StartOffBonusRepl
EXTRN	?StartOffBonusSup@@3HA:DWORD			; StartOffBonusSup
EXTRN	?StartOffBonusFuel@@3HA:DWORD			; StartOffBonusFuel
EXTRN	?ActionRate@@3HA:DWORD				; ActionRate
EXTRN	?ActionTimeOut@@3HA:DWORD			; ActionTimeOut
EXTRN	?NewInitiativePoints@@3HA:DWORD			; NewInitiativePoints
EXTRN	?InstantActionSettings@@3UUI_IA@@A:BYTE		; InstantActionSettings
EXTRN	?FalconDisplay@@3VFalconDisplayConfiguration@@A:BYTE ; FalconDisplay
EXTRN	?g_nNoPlayerPlay@@3HA:DWORD			; g_nNoPlayerPlay
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
;	COMDAT ?aline@?1??CampGetNext@@YAPADPAU_iobuf@@@Z@4PADA
_BSS	SEGMENT
?aline@?1??CampGetNext@@YAPADPAU_iobuf@@@Z@4PADA DB 0a0H DUP (?) ; `CampGetNext'::`2'::aline
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@3ff922d0e5604189
CONST	SEGMENT
__real@3ff922d0e5604189 DQ 03ff922d0e5604189r	; 1.571
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
_DATA	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2VuEntity@@8
rdata$r	SEGMENT
??_R2VuEntity@@8 DD FLAT:??_R1A@?0A@EA@VuEntity@@8	; VuEntity::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3VuEntity@@8
rdata$r	SEGMENT
??_R3VuEntity@@8 DD 00H					; VuEntity::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2VuEntity@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVVuEntity@@@8
_DATA	SEGMENT
??_R0?AVVuEntity@@@8 DD FLAT:??_7type_info@@6B@		; VuEntity `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVVuEntity@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@VuEntity@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@VuEntity@@8 DD FLAT:??_R0?AVVuEntity@@@8	; VuEntity::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3VuEntity@@8
rdata$r	ENDS
;	COMDAT ??_R2FalconEntity@@8
rdata$r	SEGMENT
??_R2FalconEntity@@8 DD FLAT:??_R1A@?0A@EA@FalconEntity@@8 ; FalconEntity::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@VuEntity@@8
rdata$r	ENDS
;	COMDAT ??_R3FalconEntity@@8
rdata$r	SEGMENT
??_R3FalconEntity@@8 DD 00H				; FalconEntity::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2FalconEntity@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVFalconEntity@@@8
_DATA	SEGMENT
??_R0?AVFalconEntity@@@8 DD FLAT:??_7type_info@@6B@	; FalconEntity `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVFalconEntity@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@FalconEntity@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@FalconEntity@@8 DD FLAT:??_R0?AVFalconEntity@@@8 ; FalconEntity::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3FalconEntity@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@TeamClass@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@TeamClass@@8 DD FLAT:??_R0?AVTeamClass@@@8 ; TeamClass::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3TeamClass@@8
rdata$r	ENDS
;	COMDAT ??_R2TeamClass@@8
rdata$r	SEGMENT
??_R2TeamClass@@8 DD FLAT:??_R1A@?0A@EA@TeamClass@@8	; TeamClass::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@FalconEntity@@8
	DD	FLAT:??_R1A@?0A@EA@VuEntity@@8
rdata$r	ENDS
;	COMDAT ??_R3TeamClass@@8
rdata$r	SEGMENT
??_R3TeamClass@@8 DD 00H				; TeamClass::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2TeamClass@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVTeamClass@@@8
_DATA	SEGMENT
??_R0?AVTeamClass@@@8 DD FLAT:??_7type_info@@6B@	; TeamClass `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVTeamClass@@', 00H
_DATA	ENDS
;	COMDAT ??_R4TeamClass@@6B@
rdata$r	SEGMENT
??_R4TeamClass@@6B@ DD 00H				; TeamClass::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVTeamClass@@@8
	DD	FLAT:??_R3TeamClass@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@InvalidBufferException@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@InvalidBufferException@@8 DD FLAT:??_R0?AVInvalidBufferException@@@8 ; InvalidBufferException::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3InvalidBufferException@@8
rdata$r	ENDS
;	COMDAT ??_R2InvalidBufferException@@8
rdata$r	SEGMENT
??_R2InvalidBufferException@@8 DD FLAT:??_R1A@?0A@EA@InvalidBufferException@@8 ; InvalidBufferException::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@out_of_range@std@@8
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3InvalidBufferException@@8
rdata$r	SEGMENT
??_R3InvalidBufferException@@8 DD 00H			; InvalidBufferException::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2InvalidBufferException@@8
rdata$r	ENDS
;	COMDAT ??_R4InvalidBufferException@@6B@
rdata$r	SEGMENT
??_R4InvalidBufferException@@6B@ DD 00H			; InvalidBufferException::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVInvalidBufferException@@@8
	DD	FLAT:??_R3InvalidBufferException@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@out_of_range@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@out_of_range@std@@8 DD FLAT:??_R0?AVout_of_range@std@@@8 ; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R2out_of_range@std@@8
rdata$r	SEGMENT
??_R2out_of_range@std@@8 DD FLAT:??_R1A@?0A@EA@out_of_range@std@@8 ; std::out_of_range::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3out_of_range@std@@8
rdata$r	SEGMENT
??_R3out_of_range@std@@8 DD 00H				; std::out_of_range::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R4out_of_range@std@@6B@
rdata$r	SEGMENT
??_R4out_of_range@std@@6B@ DD 00H			; std::out_of_range::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@FGAGGLML@?$CFs?5?$CFd?3?5error?5reading?5dirty?0?5inva@
CONST	SEGMENT
??_C@_0CK@FGAGGLML@?$CFs?5?$CFd?3?5error?5reading?5dirty?0?5inva@ DB '%s '
	DB	'%d: error reading dirty, invalid cteam', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08BLEENGAP@Team?4cpp?$AA@
CONST	SEGMENT
??_C@_08BLEENGAP@Team?4cpp?$AA@ DB 'Team.cpp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03GDDNCFJF@his?$AA@
CONST	SEGMENT
??_C@_03GDDNCFJF@his?$AA@ DB 'his', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FFNGDGKN@tmp?$AA@
CONST	SEGMENT
??_C@_03FFNGDGKN@tmp?$AA@ DB 'tmp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NJFDAMGG@frc?$AA@
CONST	SEGMENT
??_C@_03NJFDAMGG@frc?$AA@ DB 'frc', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BOGAIONP@ab?$AA@
CONST	SEGMENT
??_C@_02BOGAIONP@ab?$AA@ DB 'ab', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07DFBNEDOG@intdict?$AA@
CONST	SEGMENT
??_C@_07DFBNEDOG@intdict?$AA@ DB 'intdict', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03LKCPPDCM@cas?$AA@
CONST	SEGMENT
??_C@_03LKCPPDCM@cas?$AA@ DB 'cas', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06BONAEKEC@attrit?$AA@
CONST	SEGMENT
??_C@_06BONAEKEC@attrit?$AA@ DB 'attrit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07GBMLDGPP@offense?$AA@
CONST	SEGMENT
??_C@_07GBMLDGPP@offense?$AA@ DB 'offense', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07NEJDADE@defense?$AA@
CONST	SEGMENT
??_C@_07NEJDADE@defense?$AA@ DB 'defense', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03FGMOOMKP@pri?$AA@
CONST	SEGMENT
??_C@_03FGMOOMKP@pri?$AA@ DB 'pri', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb?$AA@
CONST	SEGMENT
??_C@_02GMLFBBN@wb?$AA@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03IBMEEAF@tea?$AA@
CONST	SEGMENT
??_C@_03IBMEEAF@tea?$AA@ DB 'tea', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@PKKGELNA@Team?5CbtPow?5ADPow?5?5AirPow?5GndPow@
CONST	SEGMENT
??_C@_0EN@PKKGELNA@Team?5CbtPow?5ADPow?5?5AirPow?5GndPow@ DB 'Team CbtPow'
	DB	' ADPow  AirPow GndPow NvlPow Sup  Fuel Sats  Tran Mrle Exp  P'
	DB	'rod', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03CLFHJCDC@txt?$AA@
CONST	SEGMENT
??_C@_03CLFHJCDC@txt?$AA@ DB 'txt', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FIIMKNHK@doctrine?$CFd?$AA@
CONST	SEGMENT
??_C@_0L@FIIMKNHK@doctrine?$CFd?$AA@ DB 'doctrine%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7TeamClass@@6B@
CONST	SEGMENT
??_7TeamClass@@6B@ DD FLAT:??_R4TeamClass@@6B@		; TeamClass::`vftable'
	DD	FLAT:?CustomCollisionCheck@VuEntity@@UAEEPAV1@M@Z
	DD	FLAT:?TerrainCollisionCheck@VuEntity@@UAEEXZ
	DD	FLAT:?IsTarget@VuEntity@@UAEEXZ
	DD	FLAT:?IsSession@VuEntity@@UAEEXZ
	DD	FLAT:?IsGroup@VuEntity@@UAEEXZ
	DD	FLAT:?IsGame@VuEntity@@UAEEXZ
	DD	FLAT:?IsCamera@VuEntity@@UBEEXZ
	DD	FLAT:?SaveSize@TeamClass@@UAEHXZ
	DD	FLAT:?Save@TeamClass@@UAEHPAU_iobuf@@@Z
	DD	FLAT:?Save@TeamClass@@UAEHPAPAE@Z
	DD	FLAT:?Handle@TeamClass@@UAEHPAVVuSessionEvent@@@Z
	DD	FLAT:?Handle@TeamClass@@UAEHPAVVuTransferEvent@@@Z
	DD	FLAT:?Handle@TeamClass@@UAEHPAVVuEntityCollisionEvent@@@Z
	DD	FLAT:?Handle@TeamClass@@UAEHPAVVuPositionUpdateEvent@@@Z
	DD	FLAT:?Handle@TeamClass@@UAEHPAVVuFullUpdateEvent@@@Z
	DD	FLAT:?Handle@TeamClass@@UAEHPAVVuEvent@@@Z
	DD	FLAT:?Handle@VuEntity@@UAEHPAVVuPullRequest@@@Z
	DD	FLAT:?Handle@VuEntity@@UAEHPAVVuPushRequest@@@Z
	DD	FLAT:?Handle@VuEntity@@UAEHPAVVuErrorMessage@@@Z
	DD	FLAT:??_ETeamClass@@UAEPAXI@Z
	DD	FLAT:?InsertionCallback@TeamClass@@UAEHXZ
	DD	FLAT:?RemovalCallback@TeamClass@@UAEHXZ
	DD	FLAT:?InitData@TeamClass@@UAEXXZ
	DD	FLAT:?CleanupData@FalconEntity@@UAEXXZ
	DD	FLAT:?IsSimBase@FalconEntity@@UAE_NXZ
	DD	FLAT:?IsCampBase@FalconEntity@@UAE_NXZ
	DD	FLAT:?Wake@TeamClass@@UAEHXZ
	DD	FLAT:?Sleep@TeamClass@@UAEHXZ
	DD	FLAT:?GetCampID@TeamClass@@UAEFXZ
	DD	FLAT:?GetTeam@TeamClass@@UAEEXZ
	DD	FLAT:?GetCountry@TeamClass@@UAEEXZ
	DD	FLAT:?GetDomain@FalconEntity@@UAEEXZ
	DD	FLAT:?GetRadarMode@FalconEntity@@UAEHXZ
	DD	FLAT:?SetRadarMode@FalconEntity@@UAEXE@Z
	DD	FLAT:?ReturnToSearch@FalconEntity@@UAEXXZ
	DD	FLAT:?SetSearchMode@FalconEntity@@UAEXE@Z
	DD	FLAT:?CombatClass@FalconEntity@@UAEHXZ
	DD	FLAT:?OnGround@FalconEntity@@UAEHXZ
	DD	FLAT:?HasEntity@FalconEntity@@UBEHPAVVuEntity@@@Z
	DD	FLAT:?IsMissile@FalconEntity@@UAEHXZ
	DD	FLAT:?IsLauncher@FalconEntity@@UAEHXZ
	DD	FLAT:?IsBomb@FalconEntity@@UAEHXZ
	DD	FLAT:?IsGun@FalconEntity@@UAEHXZ
	DD	FLAT:?IsMover@FalconEntity@@UAEHXZ
	DD	FLAT:?IsVehicle@FalconEntity@@UAEHXZ
	DD	FLAT:?IsStatic@FalconEntity@@UAEHXZ
	DD	FLAT:?IsHelicopter@FalconEntity@@UAEHXZ
	DD	FLAT:?IsEject@FalconEntity@@UAEHXZ
	DD	FLAT:?IsAirplane@FalconEntity@@UAEHXZ
	DD	FLAT:?IsGroundVehicle@FalconEntity@@UAEHXZ
	DD	FLAT:?IsShip@FalconEntity@@UAEHXZ
	DD	FLAT:?IsWeapon@FalconEntity@@UAEHXZ
	DD	FLAT:?IsExploding@FalconEntity@@UAEHXZ
	DD	FLAT:?IsDead@FalconEntity@@UAEHXZ
	DD	FLAT:?IsEmitting@FalconEntity@@UAEHXZ
	DD	FLAT:?GetVt@TeamClass@@UBEMXZ
	DD	FLAT:?GetKias@TeamClass@@UBEMXZ
	DD	FLAT:?GetMovementType@FalconEntity@@UAE?AW4MoveType@@XZ
	DD	FLAT:?IsUnit@FalconEntity@@UAEHXZ
	DD	FLAT:?IsObjective@FalconEntity@@UAEHXZ
	DD	FLAT:?IsBattalion@FalconEntity@@UAEHXZ
	DD	FLAT:?IsBrigade@FalconEntity@@UAEHXZ
	DD	FLAT:?IsFlight@FalconEntity@@UBEHXZ
	DD	FLAT:?IsSquadron@FalconEntity@@UAEHXZ
	DD	FLAT:?IsPackage@FalconEntity@@UAEHXZ
	DD	FLAT:?IsTeam@TeamClass@@UAEHXZ
	DD	FLAT:?IsTaskForce@FalconEntity@@UAEHXZ
	DD	FLAT:?IsSPJamming@FalconEntity@@UAEHXZ
	DD	FLAT:?IsAreaJamming@FalconEntity@@UAEHXZ
	DD	FLAT:?HasSPJamming@FalconEntity@@UAEHXZ
	DD	FLAT:?HasAreaJamming@FalconEntity@@UAEHXZ
	DD	FLAT:?GetRCSFactor@FalconEntity@@UAEMXZ
	DD	FLAT:?GetIRFactor@FalconEntity@@UAEMXZ
	DD	FLAT:?GetRadarType@FalconEntity@@UAEHXZ
	DD	FLAT:?GetDamageModifiers@FalconEntity@@UAEPAEXZ
	DD	FLAT:?SetAQUIREtimer@FalconEntity@@UAEXK@Z
	DD	FLAT:?SetSEARCHtimer@FalconEntity@@UAEXK@Z
	DD	FLAT:?SetStepSearchMode@FalconEntity@@UAEXE@Z
	DD	FLAT:?GetAQUIREtimer@FalconEntity@@UAEKXZ
	DD	FLAT:?GetSEARCHtimer@FalconEntity@@UAEKXZ
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0out_of_range@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT
??_R0?AVout_of_range@std@@@8 DD FLAT:??_7type_info@@6B@	; std::out_of_range `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVout_of_range@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVInvalidBufferException@@@8??0InvalidBufferException@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVInvalidBufferException@@@8??0InvalidBufferException@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVInvalidBufferException@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0InvalidBufferException@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVInvalidBufferException@@@8
_DATA	SEGMENT
??_R0?AVInvalidBufferException@@@8 DD FLAT:??_7type_info@@6B@ ; InvalidBufferException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVInvalidBufferException@@', 00H
_DATA	ENDS
;	COMDAT __CTA4?AVInvalidBufferException@@
xdata$x	SEGMENT
__CTA4?AVInvalidBufferException@@ DD 04H
	DD	FLAT:__CT??_R0?AVInvalidBufferException@@@8??0InvalidBufferException@@QAE@ABV0@@Z12
	DD	FLAT:__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI4?AVInvalidBufferException@@
xdata$x	SEGMENT
__TI4?AVInvalidBufferException@@ DD 00H
	DD	FLAT:??1InvalidBufferException@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA4?AVInvalidBufferException@@
xdata$x	ENDS
;	COMDAT ??_C@_0CI@MPKJAHJH@Trying?5to?5write?5?$CFlu?5bytes?5to?5?$CFld@
CONST	SEGMENT
??_C@_0CI@MPKJAHJH@Trying?5to?5write?5?$CFlu?5bytes?5to?5?$CFld@ DB 'Tryi'
	DB	'ng to write %lu bytes to %ld buffer', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7InvalidBufferException@@6B@
CONST	SEGMENT
??_7InvalidBufferException@@6B@ DD FLAT:??_R4InvalidBufferException@@6B@ ; InvalidBufferException::`vftable'
	DD	FLAT:??_EInvalidBufferException@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT
??_7out_of_range@std@@6B@ DD FLAT:??_R4out_of_range@std@@6B@ ; std::out_of_range::`vftable'
	DD	FLAT:??_Eout_of_range@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?ReadDirty@TeamClass@@QAEXPAPAEPAJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ReadDirty@TeamClass@@QAEXPAPAEPAJ@Z$0
__unwindtable$?SelectGroundAction@TeamClass@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SelectGroundAction@TeamClass@@QAEXXZ$0
__unwindtable$??0TeamClass@@QAE@PAU_iobuf@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0TeamClass@@QAE@PAU_iobuf@@@Z$0
__unwindtable$??0TeamClass@@QAE@PAPAEPAJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0TeamClass@@QAE@PAPAEPAJ@Z$0
__unwindtable$??0TeamClass@@QAE@HE@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0TeamClass@@QAE@HE@Z$0
__unwindtable$?AddReinforcements@@YAXEH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddReinforcements@@YAXEH@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?AddReinforcements@@YAXEH@Z$1
__unwindtable$?UpdateTeamStatistics@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdateTeamStatistics@@YAXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdateTeamStatistics@@YAXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdateTeamStatistics@@YAXXZ$2
__unwindtable$?SelectAirActions@TeamClass@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SelectAirActions@TeamClass@@QAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SelectAirActions@TeamClass@@QAEXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SelectAirActions@TeamClass@@QAEXXZ$2
__unwindtable$?AddTeam@@YAXHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddTeam@@YAXHH@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddTeam@@YAXHH@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddTeam@@YAXHH@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddTeam@@YAXHH@Z$3
__unwindtable$?LoadTeams@@YAHPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadTeams@@YAHPAD@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadTeams@@YAHPAD@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadTeams@@YAHPAD@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadTeams@@YAHPAD@Z$3
__unwindtable$?DoFullUpdate@TeamClass@@QAEXPAVVuTargetEntity@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoFullUpdate@TeamClass@@QAEXPAVVuTargetEntity@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DoFullUpdate@TeamClass@@QAEXPAVVuTargetEntity@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DoFullUpdate@TeamClass@@QAEXPAVVuTargetEntity@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DoFullUpdate@TeamClass@@QAEXPAVVuTargetEntity@@@Z$3
__ehfuncinfo$?AddTeam@@YAXHH@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?AddTeam@@YAXHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?UpdateTeamStatistics@@YAXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?UpdateTeamStatistics@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?AddReinforcements@@YAXEH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AddReinforcements@@YAXEH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?LoadTeams@@YAHPAD@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?LoadTeams@@YAHPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?ReadDirty@TeamClass@@QAEXPAPAEPAJ@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ReadDirty@TeamClass@@QAEXPAPAEPAJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SelectAirActions@TeamClass@@QAEXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?SelectAirActions@TeamClass@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SelectGroundAction@TeamClass@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SelectGroundAction@TeamClass@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?DoFullUpdate@TeamClass@@QAEXPAVVuTargetEntity@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?DoFullUpdate@TeamClass@@QAEXPAVVuTargetEntity@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0TeamClass@@QAE@PAU_iobuf@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0TeamClass@@QAE@PAU_iobuf@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0TeamClass@@QAE@PAPAEPAJ@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0TeamClass@@QAE@PAPAEPAJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0TeamClass@@QAE@HE@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0TeamClass@@QAE@HE@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?memcpychk@@YAXPAXPAPAEIPAJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?memcpychk@@YAXPAXPAPAEIPAJ@Z$0
__ehfuncinfo$?memcpychk@@YAXPAXPAPAEIPAJ@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?memcpychk@@YAXPAXPAPAEIPAJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@D@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<char>::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@_W@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<wchar_t>::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<wchar_t>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<wchar_t>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 758  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 910  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_stridx$ = -4						; size = 4
_team$ = 8						; size = 4
_gender$ = 12						; size = 4
_usage$ = 16						; size = 4
_plural$ = 20						; size = 4
?ConvertTeamToStringIndex@@YAHHHHH@Z PROC		; ConvertTeamToStringIndex

; 2908 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2909 : 	int		stridx = 3820 + 20;

	mov	DWORD PTR _stridx$[ebp], 3840		; 00000f00H

; 2910 : 	if (TeamInfo[team])

	mov	eax, DWORD PTR _team$[ebp]
	cmp	DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4], 0
	je	SHORT $LN1@ConvertTea

; 2911 : 		stridx = 3820 + 20*TeamInfo[team]->GetFlag() + 6*usage + 3*plural + gender;

	mov	ecx, DWORD PTR _team$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?GetFlag@TeamClass@@QAEHXZ		; TeamClass::GetFlag
	imul	eax, 20					; 00000014H
	mov	edx, DWORD PTR _usage$[ebp]
	imul	edx, 6
	lea	eax, DWORD PTR [eax+edx+3820]
	mov	ecx, DWORD PTR _plural$[ebp]
	imul	ecx, 3
	add	eax, DWORD PTR _gender$[ebp]
	add	ecx, eax
	mov	DWORD PTR _stridx$[ebp], ecx
$LN1@ConvertTea:

; 2912 : 	return stridx;

	mov	eax, DWORD PTR _stridx$[ebp]

; 2913 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ConvertTeamToStringIndex@@YAHHHHH@Z ENDP		; ConvertTeamToStringIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
tv315 = -92						; size = 8
tv310 = -84						; size = 8
_initiative_old$ = -76					; size = 4
_oa_start$ = -72					; size = 4
_longRunInitiative$ = -68				; size = 4
_longRunInitiative2$ = -64				; size = 4
_longRunInitiative3$ = -60				; size = 4
_longRunInitiative1$ = -56				; size = 4
tv321 = -52						; size = 4
_oa$ = -48						; size = 4
_os_start$ = -44					; size = 4
_os$ = -40						; size = 4
_ta_start$ = -36					; size = 4
_oloss$ = -32						; size = 4
_tloss$ = -28						; size = 4
_ta$ = -24						; size = 4
_ts_start$ = -20					; size = 4
_ts$ = -16						; size = 4
_initiative$ = -12					; size = 4
_i$ = -8						; size = 4
_et$ = -1						; size = 1
_who$ = 8						; size = 1
?NewInitiativePointSetting@@YAXE@Z PROC			; NewInitiativePointSetting

; 1841 : void NewInitiativePointSetting(Team who) {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH

; 1842 : 
; 1843 : 	int		i,os,ts,initiative, initiative_old;
; 1844 : 	int		oa, ta, os_start, oa_start, ts_start, ta_start;
; 1845 : 	int		longRunInitiative, longRunInitiative1, longRunInitiative2, longRunInitiative3;
; 1846 : 	float	oloss, tloss;
; 1847 : 	Team	et = NUM_TEAMS + 1;

	mov	BYTE PTR _et$[ebp], 9

; 1848 : 
; 1849 : 	os = TeamInfo[who]->GetCurrentStats()->groundVehs;		// Calculating the strenght of the player's team relativ to the others

	movzx	eax, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	call	?GetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::GetCurrentStats
	movzx	ecx, WORD PTR [eax+4]
	mov	DWORD PTR _os$[ebp], ecx

; 1850 : 	oa = TeamInfo[who]->GetCurrentStats()->aircraft;

	movzx	edx, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?GetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::GetCurrentStats
	movzx	eax, WORD PTR [eax+2]
	mov	DWORD PTR _oa$[ebp], eax

; 1851 : 	os_start = TeamInfo[who]->startStats.groundVehs;

	movzx	ecx, BYTE PTR _who$[ebp]
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	movzx	eax, WORD PTR [edx+620]
	mov	DWORD PTR _os_start$[ebp], eax

; 1852 : 	oa_start = TeamInfo[who]->startStats.aircraft;

	movzx	ecx, BYTE PTR _who$[ebp]
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	movzx	eax, WORD PTR [edx+618]
	mov	DWORD PTR _oa_start$[ebp], eax

; 1853 : 
; 1854 : 	for (i=0,ts=0,ta=0,ts_start=0,ta_start=0; i<NUM_TEAMS; i++)

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _ts$[ebp], 0
	mov	DWORD PTR _ta$[ebp], 0
	mov	DWORD PTR _ts_start$[ebp], 0
	mov	DWORD PTR _ta_start$[ebp], 0
	jmp	SHORT $LN14@NewInitiat
$LN13@NewInitiat:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN14@NewInitiat:
	cmp	DWORD PTR _i$[ebp], 8
	jge	$LN12@NewInitiat

; 1855 : 	{
; 1856 : 		if (GetTTRelations(i,who) == War)

	movzx	edx, BYTE PTR _who$[ebp]
	push	edx
	movzx	eax, BYTE PTR _i$[ebp]
	push	eax
	call	?GetTTRelations@@YAHEE@Z		; GetTTRelations
	add	esp, 8
	cmp	eax, 5
	jne	SHORT $LN11@NewInitiat

; 1857 : 		{
; 1858 : 			ts += TeamInfo[i]->GetCurrentStats()->groundVehs;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?GetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::GetCurrentStats
	movzx	edx, WORD PTR [eax+4]
	add	edx, DWORD PTR _ts$[ebp]
	mov	DWORD PTR _ts$[ebp], edx

; 1859 : 			ta += TeamInfo[i]->GetCurrentStats()->aircraft;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	call	?GetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::GetCurrentStats
	movzx	ecx, WORD PTR [eax+2]
	add	ecx, DWORD PTR _ta$[ebp]
	mov	DWORD PTR _ta$[ebp], ecx

; 1860 : 			ts_start += TeamInfo[i]->startStats.groundVehs;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	movzx	ecx, WORD PTR [eax+620]
	add	ecx, DWORD PTR _ts_start$[ebp]
	mov	DWORD PTR _ts_start$[ebp], ecx

; 1861 : 			ta_start += TeamInfo[i]->startStats.aircraft;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	movzx	ecx, WORD PTR [eax+618]
	add	ecx, DWORD PTR _ta_start$[ebp]
	mov	DWORD PTR _ta_start$[ebp], ecx

; 1862 : 			et = i;

	mov	dl, BYTE PTR _i$[ebp]
	mov	BYTE PTR _et$[ebp], dl
$LN11@NewInitiat:

; 1863 : 		}
; 1864 : 	}

	jmp	$LN13@NewInitiat
$LN12@NewInitiat:

; 1865 : 
; 1866 : 	if (et >= NUM_TEAMS)

	movzx	eax, BYTE PTR _et$[ebp]
	cmp	eax, 8
	jl	SHORT $LN10@NewInitiat

; 1867 : 		return;

	jmp	$LN15@NewInitiat
$LN10@NewInitiat:

; 1868 : 
; 1869 : 	oloss = (os_start*1.0f - os*1.0f);

	cvtsi2ss xmm0, DWORD PTR _os_start$[ebp]
	mulss	xmm0, DWORD PTR __real@3f800000
	cvtsi2ss xmm1, DWORD PTR _os$[ebp]
	mulss	xmm1, DWORD PTR __real@3f800000
	subss	xmm0, xmm1
	movss	DWORD PTR _oloss$[ebp], xmm0

; 1870 : 	if (oloss==0)

	movss	xmm0, DWORD PTR _oloss$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN9@NewInitiat

; 1871 : 		oloss = 1;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _oloss$[ebp], xmm0
$LN9@NewInitiat:

; 1872 : 	tloss = (ts_start*1.0f - ts*1.0f);

	cvtsi2ss xmm0, DWORD PTR _ts_start$[ebp]
	mulss	xmm0, DWORD PTR __real@3f800000
	cvtsi2ss xmm1, DWORD PTR _ts$[ebp]
	mulss	xmm1, DWORD PTR __real@3f800000
	subss	xmm0, xmm1
	movss	DWORD PTR _tloss$[ebp], xmm0

; 1873 : 	if ( tloss==0)

	movss	xmm0, DWORD PTR _tloss$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN8@NewInitiat

; 1874 : 		tloss = 1;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _tloss$[ebp], xmm0
$LN8@NewInitiat:

; 1875 : 
; 1876 : 	longRunInitiative1 = (int) ( atan( (os*1.0)/ts  ) * 100 / (3.142/2) + 1 );	// We need a function, which maps [0, +inf] into [0, 100].

	cvtsi2sd xmm0, DWORD PTR _os$[ebp]
	mulsd	xmm0, QWORD PTR __real@3ff0000000000000
	cvtsi2sd xmm1, DWORD PTR _ts$[ebp]
	divsd	xmm0, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_atan
	add	esp, 8
	fstp	QWORD PTR tv310[ebp]
	movsd	xmm0, QWORD PTR tv310[ebp]
	mulsd	xmm0, QWORD PTR __real@4059000000000000
	divsd	xmm0, QWORD PTR __real@3ff922d0e5604189
	addsd	xmm0, QWORD PTR __real@3ff0000000000000
	cvttsd2si ecx, xmm0
	mov	DWORD PTR _longRunInitiative1$[ebp], ecx

; 1877 : 	longRunInitiative2 = (int) ( atan( (oa*1.0)/ta  ) * 100 / (3.142/2) + 1 );	// The ArcusTangens-function is used for this purpose. We have to divide by Pi/2.

	cvtsi2sd xmm0, DWORD PTR _oa$[ebp]
	mulsd	xmm0, QWORD PTR __real@3ff0000000000000
	cvtsi2sd xmm1, DWORD PTR _ta$[ebp]
	divsd	xmm0, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_atan
	add	esp, 8
	fstp	QWORD PTR tv315[ebp]
	movsd	xmm0, QWORD PTR tv315[ebp]
	mulsd	xmm0, QWORD PTR __real@4059000000000000
	divsd	xmm0, QWORD PTR __real@3ff922d0e5604189
	addsd	xmm0, QWORD PTR __real@3ff0000000000000
	cvttsd2si edx, xmm0
	mov	DWORD PTR _longRunInitiative2$[ebp], edx

; 1878 : 	longRunInitiative3 = (int) ( atan( tloss/oloss  ) * 100 / (3.142/2) + 1 );	// e.g., if the relative strenght is 1, longRunInitiative = 50. 

	movss	xmm0, DWORD PTR _tloss$[ebp]
	divss	xmm0, DWORD PTR _oloss$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?atan@@YAMM@Z				; atan
	add	esp, 4
	fstp	DWORD PTR tv321[ebp]
	movss	xmm0, DWORD PTR tv321[ebp]
	mulss	xmm0, DWORD PTR __real@42c80000
	cvtss2sd xmm0, xmm0
	divsd	xmm0, QWORD PTR __real@3ff922d0e5604189
	addsd	xmm0, QWORD PTR __real@3ff0000000000000
	cvttsd2si eax, xmm0
	mov	DWORD PTR _longRunInitiative3$[ebp], eax

; 1879 : 	longRunInitiative = (5*longRunInitiative1 + 4*longRunInitiative2 + 1*longRunInitiative3)/10;

	mov	ecx, DWORD PTR _longRunInitiative1$[ebp]
	imul	ecx, 5
	add	ecx, DWORD PTR _longRunInitiative3$[ebp]
	mov	edx, DWORD PTR _longRunInitiative2$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	mov	DWORD PTR _longRunInitiative$[ebp], eax

; 1880 : 
; 1881 : 
; 1882 : 	initiative = TeamInfo[who]->GetInitiative();

	movzx	edx, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?GetInitiative@TeamClass@@QAEFXZ	; TeamClass::GetInitiative
	cwde
	mov	DWORD PTR _initiative$[ebp], eax

; 1883 : 	initiative_old = initiative;

	mov	ecx, DWORD PTR _initiative$[ebp]
	mov	DWORD PTR _initiative_old$[ebp], ecx

; 1884 : 	initiative = (int) (0.5F * initiative  +  0.5F * longRunInitiative);  // Adaptive mechanism to long run equilibrium. 

	cvtsi2ss xmm0, DWORD PTR _initiative$[ebp]
	mulss	xmm0, DWORD PTR __real@3f000000
	cvtsi2ss xmm1, DWORD PTR _longRunInitiative$[ebp]
	mulss	xmm1, DWORD PTR __real@3f000000
	addss	xmm0, xmm1
	cvttss2si edx, xmm0
	mov	DWORD PTR _initiative$[ebp], edx

; 1885 : 
; 1886 : 	TeamInfo[who]->SetInitiative( initiative );

	movzx	eax, WORD PTR _initiative$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?SetInitiative@TeamClass@@QAEXF@Z	; TeamClass::SetInitiative

; 1887 : 	TeamInfo[et]->SetInitiative( (100 - initiative) );		// enemy team gets 100 minus our initiative points 

	mov	edx, 100				; 00000064H
	sub	edx, DWORD PTR _initiative$[ebp]
	push	edx
	movzx	eax, BYTE PTR _et$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	call	?SetInitiative@TeamClass@@QAEXF@Z	; TeamClass::SetInitiative

; 1888 : 
; 1889 : 	//debug
; 1890 : 	//FILE *deb;
; 1891 : 	//deb = fopen("c:\\temp\\deb2.txt", "a");
; 1892 : 	//fprintf(deb, "Team %2d  Init = %3d  Init_old %d  LRInit = %3d  osts = %f  adta = %f  TIME = %d\n", who, TeamInfo[who]->GetInitiative(), initiative_old, longRunInitiative, (os*1.0)/ts, (oa*1.0)/ta, TheCampaign.CurrentTime/(3600*1000));   
; 1893 : 	//fprintf(deb, "Aircraft_start =  %d %d TheirLoss = %5.1f GroungVehicle_start = %d %d %5.1f\n", oa_start, oa, tloss, os_start, os, oloss);
; 1894 : 	//fprintf(deb, "Team %d  Rating = %3.2f    |    Team %d  Rating = %3.2f\n\n", who, TeamInfo[who]->playerRating, et, TeamInfo[et]->playerRating);
; 1895 : 	//fclose(deb);
; 1896 : 	// end debug
; 1897 : 
; 1898 : 
; 1899 : 	for (i=0; i<NUM_TEAMS; i++)		// old code for the other teams (replaces same code in UpdateTeamStatistics-procedure)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@NewInitiat
$LN6@NewInitiat:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN7@NewInitiat:
	cmp	DWORD PTR _i$[ebp], 8
	jge	$LN5@NewInitiat

; 1900 : 	{
; 1901 : 		if ( i != who  &&  i != et  &&  TeamInfo[i]->flags & TEAM_ACTIVE)   

	movzx	edx, BYTE PTR _who$[ebp]
	cmp	DWORD PTR _i$[ebp], edx
	je	$LN1@NewInitiat
	movzx	eax, BYTE PTR _et$[ebp]
	cmp	DWORD PTR _i$[ebp], eax
	je	$LN1@NewInitiat
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	movsx	eax, WORD PTR [edx+350]
	and	eax, 1
	je	$LN1@NewInitiat

; 1902 : 		{
; 1903 : 			if (TeamInfo[i]->GetInitiative() < 40)

	mov	ecx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?GetInitiative@TeamClass@@QAEFXZ	; TeamClass::GetInitiative
	movsx	edx, ax
	cmp	edx, 40					; 00000028H
	jge	SHORT $LN3@NewInitiat

; 1904 : 				TeamInfo[i]->AddInitiative ((INITIATIVE_LEAK_PER_HOUR * MIN_RECALCULATE_STATISTICS) / 60);

	movsx	eax, WORD PTR ?INITIATIVE_LEAK_PER_HOUR@@3FA ; INITIATIVE_LEAK_PER_HOUR
	movsx	ecx, WORD PTR ?MIN_RECALCULATE_STATISTICS@@3FA ; MIN_RECALCULATE_STATISTICS
	imul	eax, ecx
	cdq
	mov	ecx, 60					; 0000003cH
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?AddInitiative@TeamClass@@QAEXF@Z	; TeamClass::AddInitiative
	jmp	SHORT $LN1@NewInitiat
$LN3@NewInitiat:

; 1905 : 			else if (TeamInfo[i]->GetInitiative() <= 100)  // 100 instead of 60

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	call	?GetInitiative@TeamClass@@QAEFXZ	; TeamClass::GetInitiative
	movsx	ecx, ax
	cmp	ecx, 100				; 00000064H
	jg	SHORT $LN1@NewInitiat

; 1906 : 				TeamInfo[i]->AddInitiative (-(INITIATIVE_LEAK_PER_HOUR * MIN_RECALCULATE_STATISTICS) / 60);

	movsx	eax, WORD PTR ?INITIATIVE_LEAK_PER_HOUR@@3FA ; INITIATIVE_LEAK_PER_HOUR
	movsx	edx, WORD PTR ?MIN_RECALCULATE_STATISTICS@@3FA ; MIN_RECALCULATE_STATISTICS
	imul	eax, edx
	neg	eax
	cdq
	mov	ecx, 60					; 0000003cH
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?AddInitiative@TeamClass@@QAEXF@Z	; TeamClass::AddInitiative
$LN1@NewInitiat:

; 1907 : 		}
; 1908 : 	}

	jmp	$LN6@NewInitiat
$LN5@NewInitiat:
$LN15@NewInitiat:

; 1909 : 
; 1910 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?NewInitiativePointSetting@@YAXE@Z ENDP			; NewInitiativePointSetting
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_applied$ = -8						; size = 4
_i$ = -4						; size = 4
_who$ = 8						; size = 1
_poid$ = 12						; size = 8
_rating$ = 20						; size = 4
?ApplyBonus@@YAXEVVU_ID@@H@Z PROC			; ApplyBonus

; 1725 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1726 : 	int		i,applied=FALSE;

	mov	DWORD PTR _applied$[ebp], 0

; 1727 : 
; 1728 : 	// Apply a local combat bonus
; 1729 : 	for (i=0; i<MAX_BONUSES; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN11@ApplyBonus
$LN10@ApplyBonus:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN11@ApplyBonus:
	cmp	DWORD PTR _i$[ebp], 20			; 00000014H
	jge	$LN9@ApplyBonus

; 1730 : 	{
; 1731 : 		if (TeamInfo[who]->bonusObjs[i] == poid)

	lea	ecx, DWORD PTR _poid$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _who$[ebp]
	mov	eax, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	mov	ecx, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*8+632]
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN8@ApplyBonus

; 1732 : 		{
; 1733 : 			TeamInfo[who]->bonusTime[i] += rating * 4 * CampaignMinutes;

	movzx	eax, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	mov	edx, DWORD PTR _rating$[ebp]
	shl	edx, 2
	imul	edx, 60000				; 0000ea60H
	mov	eax, DWORD PTR _i$[ebp]
	add	edx, DWORD PTR [ecx+eax*4+792]
	movzx	ecx, BYTE PTR _who$[ebp]
	mov	eax, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+ecx*4+792], edx

; 1734 : 			applied = TRUE;

	mov	DWORD PTR _applied$[ebp], 1
$LN8@ApplyBonus:

; 1735 : 		}
; 1736 : 		if (TeamInfo[who]->bonusTime[i] < TheCampaign.CurrentTime)

	movzx	edx, BYTE PTR _who$[ebp]
	mov	eax, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4+792]
	cmp	edx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	jae	SHORT $LN7@ApplyBonus

; 1737 : 			TeamInfo[who]->bonusObjs[i] = FalconNullId;

	movzx	eax, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [ecx+edx*8+632], eax
	mov	eax, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [ecx+edx*8+636], eax
$LN7@ApplyBonus:

; 1738 : 	}

	jmp	$LN10@ApplyBonus
$LN9@ApplyBonus:

; 1739 : 	if (rating < 0 || applied)

	cmp	DWORD PTR _rating$[ebp], 0
	jl	SHORT $LN5@ApplyBonus
	cmp	DWORD PTR _applied$[ebp], 0
	je	SHORT $LN6@ApplyBonus
$LN5@ApplyBonus:

; 1740 : 		return;

	jmp	$LN12@ApplyBonus
$LN6@ApplyBonus:

; 1741 : 	for (i=0; i<MAX_BONUSES && !applied; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@ApplyBonus
$LN3@ApplyBonus:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@ApplyBonus:
	cmp	DWORD PTR _i$[ebp], 20			; 00000014H
	jge	$LN12@ApplyBonus
	cmp	DWORD PTR _applied$[ebp], 0
	jne	SHORT $LN12@ApplyBonus

; 1742 : 	{
; 1743 : 		if (TeamInfo[who]->bonusObjs[i] == FalconNullId)

	push	OFFSET ?FalconNullId@@3VVU_ID@@A	; FalconNullId
	movzx	edx, BYTE PTR _who$[ebp]
	mov	eax, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	mov	ecx, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*8+632]
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@ApplyBonus

; 1744 : 		{
; 1745 : 			TeamInfo[who]->bonusObjs[i] = poid;

	movzx	eax, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _poid$[ebp]
	mov	DWORD PTR [ecx+edx*8+632], eax
	mov	eax, DWORD PTR _poid$[ebp+4]
	mov	DWORD PTR [ecx+edx*8+636], eax

; 1746 : 			TeamInfo[who]->bonusTime[i] = TheCampaign.CurrentTime + (rating * 4 * CampaignMinutes);

	mov	ecx, DWORD PTR _rating$[ebp]
	shl	ecx, 2
	imul	ecx, 60000				; 0000ea60H
	add	ecx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	movzx	edx, BYTE PTR _who$[ebp]
	mov	eax, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+edx*4+792], ecx

; 1747 : 			applied = TRUE;

	mov	DWORD PTR _applied$[ebp], 1
$LN1@ApplyBonus:

; 1748 : 		}
; 1749 : 	}

	jmp	$LN3@ApplyBonus
$LN12@ApplyBonus:

; 1750 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ApplyBonus@@YAXEVVU_ID@@H@Z ENDP			; ApplyBonus
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
$T2 = -84						; size = 4
$T3 = -80						; size = 4
$T4 = -76						; size = 4
$T5 = -72						; size = 4
_ntm$ = -68						; size = 4
tv219 = -64						; size = 4
$T6 = -60						; size = 4
_gtm$ = -56						; size = 4
tv189 = -52						; size = 4
$T7 = -48						; size = 4
_atm$ = -44						; size = 4
tv159 = -40						; size = 4
$T8 = -36						; size = 4
tv87 = -32						; size = 4
$T9 = -28						; size = 4
_temp$ = -24						; size = 4
_tid$ = -20						; size = 4
_j$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_teamNum$ = 8						; size = 4
_defaultStance$ = 12					; size = 4
?AddTeam@@YAXHH@Z PROC					; AddTeam

; 1418 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddTeam@@YAXHH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1419 : 	TeamClass					*temp;
; 1420 : 	AirTaskingManagerClass		*atm;
; 1421 : 	GroundTaskingManagerClass	*gtm;
; 1422 : 	NavalTaskingManagerClass	*ntm;
; 1423 : 	int							tid,j;
; 1424 : 
; 1425 : 	if (TeamInfo[teamNum]){

	mov	eax, DWORD PTR _teamNum$[ebp]
	cmp	DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4], 0
	je	SHORT $LN8@AddTeam

; 1426 : 		RemoveTeam(teamNum);

	mov	ecx, DWORD PTR _teamNum$[ebp]
	push	ecx
	call	?RemoveTeam@@YAXH@Z			; RemoveTeam
	add	esp, 4
$LN8@AddTeam:

; 1427 : 	}
; 1428 : 
; 1429 : 	tid = GetClassID(DOMAIN_ABSTRACT,CLASS_MANAGER,TYPE_TEAM,0,0,0,0,0) + VU_LAST_ENTITY_TYPE;

	push	0
	push	0
	push	0
	push	0
	push	0
	push	1
	push	3
	push	1
	call	?GetClassID@@YAHEEEEEEEE@Z		; GetClassID
	add	esp, 32					; 00000020H
	add	eax, 100				; 00000064H
	mov	DWORD PTR _tid$[ebp], eax

; 1430 : 	temp = new TeamClass(tid, teamNum);

	push	904					; 00000388H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T9[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T9[ebp], 0
	je	SHORT $LN11@AddTeam
	movzx	edx, BYTE PTR _teamNum$[ebp]
	push	edx
	mov	eax, DWORD PTR _tid$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T9[ebp]
	call	??0TeamClass@@QAE@HE@Z			; TeamClass::TeamClass
	mov	DWORD PTR tv87[ebp], eax
	jmp	SHORT $LN12@AddTeam
$LN11@AddTeam:
	mov	DWORD PTR tv87[ebp], 0
$LN12@AddTeam:
	mov	ecx, DWORD PTR tv87[ebp]
	mov	DWORD PTR $T5[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T5[ebp]
	mov	DWORD PTR _temp$[ebp], edx

; 1431 : 	for (j=0; j<NUM_TEAMS; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@AddTeam
$LN6@AddTeam:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$LN7@AddTeam:
	cmp	DWORD PTR _j$[ebp], 8
	jge	SHORT $LN5@AddTeam

; 1432 : 	{
; 1433 : 		if (teamNum != j && teamNum && j)

	mov	ecx, DWORD PTR _teamNum$[ebp]
	cmp	ecx, DWORD PTR _j$[ebp]
	je	SHORT $LN4@AddTeam
	cmp	DWORD PTR _teamNum$[ebp], 0
	je	SHORT $LN4@AddTeam
	cmp	DWORD PTR _j$[ebp], 0
	je	SHORT $LN4@AddTeam

; 1434 : 			temp->stance[j] = defaultStance;

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _temp$[ebp]
	mov	cx, WORD PTR _defaultStance$[ebp]
	mov	WORD PTR [eax+edx*2+580], cx
	jmp	SHORT $LN3@AddTeam
$LN4@AddTeam:

; 1435 : 		else if (teamNum != j)

	mov	edx, DWORD PTR _teamNum$[ebp]
	cmp	edx, DWORD PTR _j$[ebp]
	je	SHORT $LN2@AddTeam

; 1436 : 			temp->stance[j] = Neutral;

	mov	eax, 3
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _temp$[ebp]
	mov	WORD PTR [edx+ecx*2+580], ax

; 1437 : 		else

	jmp	SHORT $LN3@AddTeam
$LN2@AddTeam:

; 1438 : 			temp->stance[j] = Allied;

	mov	eax, 1
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _temp$[ebp]
	mov	WORD PTR [edx+ecx*2+580], ax
$LN3@AddTeam:

; 1439 : 	}

	jmp	SHORT $LN6@AddTeam
$LN5@AddTeam:

; 1440 : 	vuDatabase->/*Silent*/Insert(temp);

	mov	eax, DWORD PTR _temp$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Insert@VuDatabase@@QAEHPAVVuEntity@@@Z	; VuDatabase::Insert

; 1441 : 	tid = GetClassID(DOMAIN_AIR,CLASS_MANAGER,TYPE_ATM,0,0,0,0,0) + VU_LAST_ENTITY_TYPE;

	push	0
	push	0
	push	0
	push	0
	push	0
	push	1
	push	3
	push	2
	call	?GetClassID@@YAHEEEEEEEE@Z		; GetClassID
	add	esp, 32					; 00000020H
	add	eax, 100				; 00000064H
	mov	DWORD PTR _tid$[ebp], eax

; 1442 : 	atm = new AirTaskingManagerClass (tid, teamNum);

	push	208					; 000000d0H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T8[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T8[ebp], 0
	je	SHORT $LN13@AddTeam
	movzx	ecx, BYTE PTR _teamNum$[ebp]
	push	ecx
	movzx	edx, WORD PTR _tid$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T8[ebp]
	call	??0AirTaskingManagerClass@@QAE@GE@Z	; AirTaskingManagerClass::AirTaskingManagerClass
	mov	DWORD PTR tv159[ebp], eax
	jmp	SHORT $LN14@AddTeam
$LN13@AddTeam:
	mov	DWORD PTR tv159[ebp], 0
$LN14@AddTeam:
	mov	eax, DWORD PTR tv159[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T4[ebp]
	mov	DWORD PTR _atm$[ebp], ecx

; 1443 : 	vuDatabase->/*Silent*/Insert(atm);

	mov	edx, DWORD PTR _atm$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Insert@VuDatabase@@QAEHPAVVuEntity@@@Z	; VuDatabase::Insert

; 1444 : 	VuReferenceEntity(atm);

	mov	eax, DWORD PTR _atm$[ebp]
	push	eax
	call	?VuReferenceEntity@@YAHPAVVuEntity@@@Z	; VuReferenceEntity
	add	esp, 4

; 1445 : 	tid = GetClassID(DOMAIN_LAND,CLASS_MANAGER,TYPE_GTM,0,0,0,0,0) + VU_LAST_ENTITY_TYPE;

	push	0
	push	0
	push	0
	push	0
	push	0
	push	1
	push	3
	push	3
	call	?GetClassID@@YAHEEEEEEEE@Z		; GetClassID
	add	esp, 32					; 00000020H
	add	eax, 100				; 00000064H
	mov	DWORD PTR _tid$[ebp], eax

; 1446 : 	gtm = new GroundTaskingManagerClass (tid, teamNum);

	push	252					; 000000fcH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T7[ebp], 0
	je	SHORT $LN15@AddTeam
	movzx	ecx, BYTE PTR _teamNum$[ebp]
	push	ecx
	movzx	edx, WORD PTR _tid$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T7[ebp]
	call	??0GroundTaskingManagerClass@@QAE@GE@Z	; GroundTaskingManagerClass::GroundTaskingManagerClass
	mov	DWORD PTR tv189[ebp], eax
	jmp	SHORT $LN16@AddTeam
$LN15@AddTeam:
	mov	DWORD PTR tv189[ebp], 0
$LN16@AddTeam:
	mov	eax, DWORD PTR tv189[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR _gtm$[ebp], ecx

; 1447 : 	vuDatabase->/*Silent*/Insert(gtm);

	mov	edx, DWORD PTR _gtm$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Insert@VuDatabase@@QAEHPAVVuEntity@@@Z	; VuDatabase::Insert

; 1448 : 	VuReferenceEntity(gtm);

	mov	eax, DWORD PTR _gtm$[ebp]
	push	eax
	call	?VuReferenceEntity@@YAHPAVVuEntity@@@Z	; VuReferenceEntity
	add	esp, 4

; 1449 : 	tid = GetClassID(DOMAIN_SEA,CLASS_MANAGER,TYPE_NTM,0,0,0,0,0) + VU_LAST_ENTITY_TYPE;

	push	0
	push	0
	push	0
	push	0
	push	0
	push	1
	push	3
	push	4
	call	?GetClassID@@YAHEEEEEEEE@Z		; GetClassID
	add	esp, 32					; 00000020H
	add	eax, 100				; 00000064H
	mov	DWORD PTR _tid$[ebp], eax

; 1450 : 	ntm = new NavalTaskingManagerClass (tid, teamNum);

	push	164					; 000000a4H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	cmp	DWORD PTR $T6[ebp], 0
	je	SHORT $LN17@AddTeam
	movzx	ecx, BYTE PTR _teamNum$[ebp]
	push	ecx
	movzx	edx, WORD PTR _tid$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T6[ebp]
	call	??0NavalTaskingManagerClass@@QAE@GE@Z	; NavalTaskingManagerClass::NavalTaskingManagerClass
	mov	DWORD PTR tv219[ebp], eax
	jmp	SHORT $LN18@AddTeam
$LN17@AddTeam:
	mov	DWORD PTR tv219[ebp], 0
$LN18@AddTeam:
	mov	eax, DWORD PTR tv219[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _ntm$[ebp], ecx

; 1451 : 	vuDatabase->/*Silent*/Insert(ntm);

	mov	edx, DWORD PTR _ntm$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Insert@VuDatabase@@QAEHPAVVuEntity@@@Z	; VuDatabase::Insert

; 1452 : 	VuReferenceEntity(ntm);

	mov	eax, DWORD PTR _ntm$[ebp]
	push	eax
	call	?VuReferenceEntity@@YAHPAVVuEntity@@@Z	; VuReferenceEntity
	add	esp, 4

; 1453 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?AddTeam@@YAXHH@Z$0:
	mov	eax, DWORD PTR $T9[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?AddTeam@@YAXHH@Z$1:
	mov	eax, DWORD PTR $T8[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?AddTeam@@YAXHH@Z$2:
	mov	eax, DWORD PTR $T7[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?AddTeam@@YAXHH@Z$3:
	mov	eax, DWORD PTR $T6[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?AddTeam@@YAXHH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddTeam@@YAXHH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddTeam@@YAXHH@Z ENDP					; AddTeam
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_team$ = 8						; size = 4
_bonus$ = 12						; size = 4
?StartOffensive@@YAXHH@Z PROC				; StartOffensive

; 2923 : {

	push	ebp
	mov	ebp, esp

; 2924 : 	// A.S. 2001-12-09. This makes the offensive bonuses configurable 
; 2925 : #ifdef DEBUG
; 2926 : 	if (TeamInfo[team]->GetSupplyAvail() < StartOffBonusSup)
; 2927 : 		gSupplyFromOffensive[team] += StartOffBonusSup - TeamInfo[team]->GetSupplyAvail(); 
; 2928 : 	if (TeamInfo[team]->GetFuelAvail() < StartOffBonusFuel)
; 2929 : 		gFuelFromOffensive[team] += StartOffBonusFuel - TeamInfo[team]->GetFuelAvail();  
; 2930 : 	if (TeamInfo[team]->GetReplacementsAvail() < StartOffBonusRepl)
; 2931 : 		gReplacmentsFromOffensive[team] += StartOffBonusRepl - TeamInfo[team]->GetReplacementsAvail(); 
; 2932 : #endif
; 2933 : 	if (TeamInfo[team]->GetSupplyAvail() < StartOffBonusSup)     

	mov	eax, DWORD PTR _team$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	call	?GetSupplyAvail@TeamClass@@QAEGXZ	; TeamClass::GetSupplyAvail
	movzx	ecx, ax
	cmp	ecx, DWORD PTR ?StartOffBonusSup@@3HA	; StartOffBonusSup
	jge	SHORT $LN3@StartOffen

; 2934 : 		TeamInfo[team]->SetSupplyAvail(StartOffBonusSup);         //from 5000 to StartOffBonusSup

	mov	edx, DWORD PTR ?StartOffBonusSup@@3HA	; StartOffBonusSup
	push	edx
	mov	eax, DWORD PTR _team$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	call	?SetSupplyAvail@TeamClass@@QAEXH@Z	; TeamClass::SetSupplyAvail
$LN3@StartOffen:

; 2935 : 	if (TeamInfo[team]->GetFuelAvail() < StartOffBonusFuel)

	mov	ecx, DWORD PTR _team$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?GetFuelAvail@TeamClass@@QAEGXZ		; TeamClass::GetFuelAvail
	movzx	edx, ax
	cmp	edx, DWORD PTR ?StartOffBonusFuel@@3HA	; StartOffBonusFuel
	jge	SHORT $LN2@StartOffen

; 2936 : 		TeamInfo[team]->SetFuelAvail(StartOffBonusFuel);          //from 5000 to StartOffBonusFuel

	mov	eax, DWORD PTR ?StartOffBonusFuel@@3HA	; StartOffBonusFuel
	push	eax
	mov	ecx, DWORD PTR _team$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?SetFuelAvail@TeamClass@@QAEXH@Z	; TeamClass::SetFuelAvail
$LN2@StartOffen:

; 2937 : 	if (TeamInfo[team]->GetReplacementsAvail() < StartOffBonusRepl)  

	mov	edx, DWORD PTR _team$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?GetReplacementsAvail@TeamClass@@QAEGXZ	; TeamClass::GetReplacementsAvail
	movzx	eax, ax
	cmp	eax, DWORD PTR ?StartOffBonusRepl@@3HA	; StartOffBonusRepl
	jge	SHORT $LN4@StartOffen

; 2938 : 		TeamInfo[team]->SetReplacementsAvail(StartOffBonusRepl);   //from 1000 to StartOffBonusRep

	mov	ecx, DWORD PTR ?StartOffBonusRepl@@3HA	; StartOffBonusRepl
	push	ecx
	mov	edx, DWORD PTR _team$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?SetReplacementsAvail@TeamClass@@QAEXH@Z ; TeamClass::SetReplacementsAvail
$LN4@StartOffen:

; 2939 : 	// end added section
; 2940 : 
; 2941 : 	/* +++ old code +++
; 2942 : #ifdef DEBUG
; 2943 : if (TeamInfo[team]->GetSupplyAvail() < 5000)
; 2944 : gSupplyFromOffensive[team] += 5000 - TeamInfo[team]->GetSupplyAvail();
; 2945 : if (TeamInfo[team]->GetFuelAvail() < 5000)
; 2946 : gFuelFromOffensive[team] += 5000 - TeamInfo[team]->GetFuelAvail();
; 2947 : if (TeamInfo[team]->GetReplacementsAvail() < 1000)
; 2948 : gReplacmentsFromOffensive[team] += 1000 - TeamInfo[team]->GetReplacementsAvail();
; 2949 : #endif
; 2950 : if (TeamInfo[team]->GetSupplyAvail() < 5000)
; 2951 : TeamInfo[team]->SetSupplyAvail(5000);
; 2952 : if (TeamInfo[team]->GetFuelAvail() < 5000)
; 2953 : TeamInfo[team]->SetFuelAvail(5000);
; 2954 : if (TeamInfo[team]->GetReplacementsAvail() < 1000)
; 2955 : TeamInfo[team]->SetReplacementsAvail(1000);
; 2956 : 	 */
; 2957 : }

	pop	ebp
	ret	0
?StartOffensive@@YAXHH@Z ENDP				; StartOffensive
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_t$ = 8							; size = 1
?GetTeamSituation@@YAHE@Z PROC				; GetTeamSituation

; 2456 : {

	push	ebp
	mov	ebp, esp

; 2457 : 	/*	int				i;
; 2458 : 		float			etotal=0.0F,mytotal=0.0F;
; 2459 : 
; 2460 : 		for (i=0; i<NUM_TEAMS; i++)
; 2461 : 		{
; 2462 : 		if ((GetTTRelations(t,i) == War) && (TeamInfo[i]))
; 2463 : 		{
; 2464 : 		etotal +=	TeamInfo[i]->GetCurrentStats()->airDefenseVehs +
; 2465 : 		TeamInfo[i]->GetCurrentStats()->aircraft * 2.0F +
; 2466 : 		TeamInfo[i]->GetCurrentStats()->groundVehs +
; 2467 : 		TeamInfo[i]->GetCurrentStats()->ships * 5.0F +
; 2468 : 		TeamInfo[i]->GetCurrentStats()->supplyLevel * 100.0F;
; 2469 : 		TeamInfo[i]->GetCurrentStats()->fuelLevel * 100.0F;
; 2470 : 		}
; 2471 : 		if ((GetTTRelations(t,i) == Allied || t == i) && (TeamInfo[i]))
; 2472 : 		{
; 2473 : 		mytotal +=	TeamInfo[i]->GetCurrentStats()->airDefenseVehs +
; 2474 : 		TeamInfo[i]->GetCurrentStats()->aircraft * 2.0F +
; 2475 : 		TeamInfo[i]->GetCurrentStats()->groundVehs +
; 2476 : 		TeamInfo[i]->GetCurrentStats()->ships * 5.0F +
; 2477 : 		TeamInfo[i]->GetCurrentStats()->supplyLevel * 100.0F;
; 2478 : 		TeamInfo[i]->GetCurrentStats()->fuelLevel * 100.0F;
; 2479 : 		}
; 2480 : 		}
; 2481 : 		if (mytotal * 1.6F < etotal)
; 2482 : 		TheCampaign.Situation = 0;
; 2483 : 		else if (mytotal * 1.2F < etotal)
; 2484 : 		TheCampaign.Situation = 1;
; 2485 : 		else if (mytotal < etotal * 1.2F)
; 2486 : 		TheCampaign.Situation = 2;
; 2487 : 		else if (mytotal < etotal * 1.6F)
; 2488 : 		TheCampaign.Situation = 3;
; 2489 : 		else
; 2490 : 		TheCampaign.Situation = 4;
; 2491 : 	 */
; 2492 : 	return TheCampaign.Situation;

	movzx	eax, BYTE PTR ?TheCampaign@@3VCampaignClass@@A+94

; 2493 : }

	pop	ebp
	ret	0
?GetTeamSituation@@YAHE@Z ENDP				; GetTeamSituation
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_is_comment$ = -4					; size = 4
_fptr$ = 8						; size = 4
?CampGetNext@@YAPADPAU_iobuf@@@Z PROC			; CampGetNext

; 2508 : {

	push	ebp
	mov	ebp, esp
	push	ecx
$LN7@CampGetNex:

; 2509 : 	static char aline[160];
; 2510 : 	int is_comment;
; 2511 : 
; 2512 : 	// Can we read
; 2513 : 	F4Assert (fptr);
; 2514 : 	do
; 2515 : 	{
; 2516 : 		fscanf (fptr, "%s", aline);

	push	OFFSET ?aline@?1??CampGetNext@@YAPADPAU_iobuf@@@Z@4PADA
	push	OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
	mov	eax, DWORD PTR _fptr$[ebp]
	push	eax
	call	_fscanf
	add	esp, 12					; 0000000cH

; 2517 : 		SwapCRLF (aline);

	push	OFFSET ?aline@?1??CampGetNext@@YAPADPAU_iobuf@@@Z@4PADA
	call	?SwapCRLF@@YAXPAD@Z			; SwapCRLF
	add	esp, 4

; 2518 : 		if (aline[0] == ';' || aline[0] == '#')

	mov	ecx, 1
	imul	ecx, 0
	movsx	edx, BYTE PTR ?aline@?1??CampGetNext@@YAPADPAU_iobuf@@@Z@4PADA[ecx]
	cmp	edx, 59					; 0000003bH
	je	SHORT $LN3@CampGetNex
	mov	eax, 1
	imul	eax, 0
	movsx	ecx, BYTE PTR ?aline@?1??CampGetNext@@YAPADPAU_iobuf@@@Z@4PADA[eax]
	cmp	ecx, 35					; 00000023H
	jne	SHORT $LN4@CampGetNex
$LN3@CampGetNex:

; 2519 : 		{
; 2520 : 			if (fgets (aline, 160, fptr) == NULL)

	mov	edx, DWORD PTR _fptr$[ebp]
	push	edx
	push	160					; 000000a0H
	push	OFFSET ?aline@?1??CampGetNext@@YAPADPAU_iobuf@@@Z@4PADA
	call	_fgets
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@CampGetNex

; 2521 : 				break;

	jmp	SHORT $LN5@CampGetNex
$LN2@CampGetNex:

; 2522 : 			is_comment = TRUE;

	mov	DWORD PTR _is_comment$[ebp], 1

; 2523 : 		}
; 2524 : 		else

	jmp	SHORT $LN6@CampGetNex
$LN4@CampGetNex:

; 2525 : 			is_comment = FALSE;

	mov	DWORD PTR _is_comment$[ebp], 0
$LN6@CampGetNex:

; 2526 : 	}
; 2527 : 	while (is_comment);

	cmp	DWORD PTR _is_comment$[ebp], 0
	jne	SHORT $LN7@CampGetNex
$LN5@CampGetNex:

; 2528 : 
; 2529 : 	return (aline);

	mov	eax, OFFSET ?aline@?1??CampGetNext@@YAPADPAU_iobuf@@@Z@4PADA

; 2530 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CampGetNext@@YAPADPAU_iobuf@@@Z ENDP			; CampGetNext
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 641  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@default_er

; 643  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 644  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 645  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	edx, DWORD PTR __Errval$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 646  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 634  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 635  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 636  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 637  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 629  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 630  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 631  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 624  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 625  : 		{	// default constructor
; 626  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 611  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 612  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 613  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 614  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 615  : 			return (_Generic_error_category::message(_Errcode));

	mov	ecx, DWORD PTR __Errcode$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 616  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 606  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 607  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 601  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 602  : 		{	// default constructor
; 603  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 590  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 591  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 593  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 585  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 580  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 581  : 		{	// default constructor
; 582  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 376  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 379  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 354  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 356  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 349  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 350  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 351  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 316  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax

; 317  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 256  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 257  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 258  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 251  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 184  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 415  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 408  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 410  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 401  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 403  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 167  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 162  : 	error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 163  : 		{	// default constructor
; 164  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 679  : 	{	// get system_category

	push	ebp
	mov	ebp, esp

; 680  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 681  : 	}

	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 669  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp

; 670  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 671  : 	}

	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 75   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcsess.h
;	COMDAT ?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ PROC ; FalconSessionEntity::GetGame, COMDAT
; _this$ = ecx

; 154  : 	FalconGameEntity* GetGame (void)              { return (FalconGameEntity*)VuSessionEntity::Game(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Game@VuSessionEntity@@QAEPAVVuGameEntity@@XZ ; VuSessionEntity::Game
	mov	esp, ebp
	pop	ebp
	ret	0
?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ENDP ; FalconSessionEntity::GetGame
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_who$ = 8						; size = 1
?AirSuperiority@@YAHE@Z PROC				; AirSuperiority

; 2502 : {

	push	ebp
	mov	ebp, esp

; 2503 : 	return 0;

	xor	eax, eax

; 2504 : }

	pop	ebp
	ret	0
?AirSuperiority@@YAHE@Z ENDP				; AirSuperiority
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_who$ = 8						; size = 1
?NavalSuperiority@@YAHE@Z PROC				; NavalSuperiority

; 2497 : {

	push	ebp
	mov	ebp, esp

; 2498 : 	return 0;

	xor	eax, eax

; 2499 : }

	pop	ebp
	ret	0
?NavalSuperiority@@YAHE@Z ENDP				; NavalSuperiority
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_uit$2 = -252						; size = 12
_uit$3 = -240						; size = 12
_uit$4 = -228						; size = 12
_o$5 = -216						; size = 4
tv342 = -212						; size = 4
tv309 = -208						; size = 4
_thf$ = -204						; size = 4
tv288 = -200						; size = 4
_rating$ = -196						; size = 4
_ths$ = -192						; size = 4
tv186 = -188						; size = 4
tv206 = -184						; size = 4
tv370 = -180						; size = 4
_hist$ = -176						; size = 5
_d$ = -168						; size = 2
_timestamp$ = -164					; size = 4
_count$ = -160						; size = 2
_fp$ = -156						; size = 4
_u$ = -152						; size = 4
_i$ = -148						; size = 4
_fhave$ = -144						; size = 32
_fwant$ = -112						; size = 32
_swant$ = -80						; size = 32
_shave$ = -48						; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?UpdateTeamStatistics@@YAXXZ PROC			; UpdateTeamStatistics

; 2225 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?UpdateTeamStatistics@@YAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 240				; 000000f0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 2226 : 	Unit			u;
; 2227 : 	int				i,ths,thf;
; 2228 : 	int				shave[NUM_TEAMS],swant[NUM_TEAMS],fhave[NUM_TEAMS],fwant[NUM_TEAMS];
; 2229 : 
; 2230 : 	// Clear vehicle counts
; 2231 : 	for (i=0; i<NUM_TEAMS; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN62@UpdateTeam
$LN61@UpdateTeam:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN62@UpdateTeam:
	cmp	DWORD PTR _i$[ebp], 8
	jge	$LN60@UpdateTeam

; 2232 : 	{
; 2233 : 		if (!TeamInfo[i])

	mov	ecx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4], 0
	jne	SHORT $LN59@UpdateTeam

; 2234 : 			return;

	jmp	$LN63@UpdateTeam
$LN59@UpdateTeam:

; 2235 : 		TeamInfo[i]->SetCurrentStats()->airDefenseVehs = 0;

	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?SetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::SetCurrentStats
	xor	ecx, ecx
	mov	WORD PTR [eax], cx

; 2236 : 		TeamInfo[i]->SetCurrentStats()->aircraft = 0;

	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?SetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::SetCurrentStats
	xor	ecx, ecx
	mov	WORD PTR [eax+2], cx

; 2237 : 		TeamInfo[i]->SetCurrentStats()->groundVehs = 0;

	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?SetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::SetCurrentStats
	xor	ecx, ecx
	mov	WORD PTR [eax+4], cx

; 2238 : 		TeamInfo[i]->SetCurrentStats()->ships = 0;

	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?SetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::SetCurrentStats
	xor	ecx, ecx
	mov	WORD PTR [eax+6], cx

; 2239 : 		TeamInfo[i]->SetCurrentStats()->supply = 0;

	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?SetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::SetCurrentStats
	xor	ecx, ecx
	mov	WORD PTR [eax+8], cx

; 2240 : 		TeamInfo[i]->SetCurrentStats()->fuel = 0;

	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?SetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::SetCurrentStats
	xor	ecx, ecx
	mov	WORD PTR [eax+10], cx

; 2241 : 		shave[i] = swant[i] = fhave[i] = fwant[i] = 0;

	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _fwant$[ebp+edx*4], 0
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _fhave$[ebp+eax*4], 0
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _swant$[ebp+ecx*4], 0
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _shave$[ebp+edx*4], 0

; 2242 : 	}

	jmp	$LN61@UpdateTeam
$LN60@UpdateTeam:

; 2243 : 
; 2244 : 	// Add units to count
; 2245 : 	{
; 2246 : 		VuListIterator	uit(AllUnitList);

	mov	eax, DWORD PTR ?AllUnitList@@3PAVVuLinkedList@@A ; AllUnitList
	push	eax
	lea	ecx, DWORD PTR _uit$4[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2247 : 		u = GetFirstUnit(&uit);

	lea	ecx, DWORD PTR _uit$4[ebp]
	push	ecx
	call	?GetFirstUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z ; GetFirstUnit
	add	esp, 4
	mov	DWORD PTR _u$[ebp], eax
$LN58@UpdateTeam:

; 2248 : 		while (u)

	cmp	DWORD PTR _u$[ebp], 0
	je	$LN57@UpdateTeam

; 2249 : 		{
; 2250 : 			// ALFREDs FIX - ignore brigades as they are counted already.
; 2251 : 			if (u->IsBrigade()) {

	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+244]
	call	edx
	test	eax, eax
	je	SHORT $LN56@UpdateTeam

; 2252 : 				u = GetNextUnit(&uit);

	lea	eax, DWORD PTR _uit$4[ebp]
	push	eax
	call	?GetNextUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z ; GetNextUnit
	add	esp, 4
	mov	DWORD PTR _u$[ebp], eax

; 2253 : 				continue;

	jmp	SHORT $LN58@UpdateTeam
$LN56@UpdateTeam:

; 2254 : 			}
; 2255 : 
; 2256 : 			if (u->GetDomain() == DOMAIN_LAND)

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetDomain@CampBaseClass@@QBEEXZ	; CampBaseClass::GetDomain
	movzx	ecx, al
	cmp	ecx, 3
	jne	$LN55@UpdateTeam

; 2257 : 			{
; 2258 : 				if (u->GetUnitNormalRole() == GRO_AIRDEFENSE)

	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+668]
	call	edx
	cmp	eax, 5
	jne	SHORT $LN54@UpdateTeam

; 2259 : 					TeamInfo[u->GetTeam()]->SetCurrentStats()->airDefenseVehs += u->GetTotalVehicles();

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?SetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::SetCurrentStats
	mov	DWORD PTR tv186[ebp], eax
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	mov	edx, DWORD PTR tv186[ebp]
	movzx	ecx, WORD PTR [edx]
	add	ecx, eax
	mov	edx, DWORD PTR tv186[ebp]
	mov	WORD PTR [edx], cx

; 2260 : 				else

	jmp	SHORT $LN53@UpdateTeam
$LN54@UpdateTeam:

; 2261 : 					TeamInfo[u->GetTeam()]->SetCurrentStats()->groundVehs += u->GetTotalVehicles();

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?SetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::SetCurrentStats
	add	eax, 4
	mov	DWORD PTR tv206[ebp], eax
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	mov	edx, DWORD PTR tv206[ebp]
	movzx	ecx, WORD PTR [edx]
	add	ecx, eax
	mov	edx, DWORD PTR tv206[ebp]
	mov	WORD PTR [edx], cx
$LN53@UpdateTeam:
	jmp	$LN52@UpdateTeam
$LN55@UpdateTeam:

; 2262 : 			}
; 2263 : 			else if (u->GetDomain() == DOMAIN_AIR)

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetDomain@CampBaseClass@@QBEEXZ	; CampBaseClass::GetDomain
	movzx	eax, al
	cmp	eax, 2
	jne	$LN51@UpdateTeam

; 2264 : 			{
; 2265 : 				// RV - Biker - Only count attack AC for statistic
; 2266 : 				if (u->GetType() == TYPE_SQUADRON &&
; 2267 : 			   		(u->GetSType() == STYPE_UNIT_ATTACK ||
; 2268 : 					u->GetSType() == STYPE_UNIT_ATTACK_HELO ||
; 2269 : 					u->GetSType() == STYPE_UNIT_BOMBER ||
; 2270 : 					u->GetSType() == STYPE_UNIT_FIGHTER ||
; 2271 : 					u->GetSType() == STYPE_UNIT_FIGHTER_BOMBER)) {

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetType
	movzx	ecx, al
	cmp	ecx, 3
	jne	$LN50@UpdateTeam
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetSType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetSType
	movzx	edx, al
	cmp	edx, 3
	je	SHORT $LN49@UpdateTeam
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetSType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetSType
	movzx	eax, al
	cmp	eax, 4
	je	SHORT $LN49@UpdateTeam
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetSType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetSType
	movzx	ecx, al
	cmp	ecx, 6
	je	SHORT $LN49@UpdateTeam
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetSType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetSType
	movzx	edx, al
	cmp	edx, 8
	je	SHORT $LN49@UpdateTeam
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetSType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetSType
	movzx	eax, al
	cmp	eax, 9
	jne	$LN50@UpdateTeam
$LN49@UpdateTeam:

; 2272 : 					if (u->GetUnitAirbase() == NULL || u->GetSType() == STYPE_UNIT_ATTACK_HELO || !u->GetUnitAirbase()->IsObjective())

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+704]
	call	eax
	test	eax, eax
	je	SHORT $LN47@UpdateTeam
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetSType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetSType
	movzx	ecx, al
	cmp	ecx, 4
	je	SHORT $LN47@UpdateTeam
	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+704]
	call	edx
	mov	DWORD PTR tv288[ebp], eax
	mov	eax, DWORD PTR tv288[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv288[ebp]
	mov	eax, DWORD PTR [edx+236]
	call	eax
	test	eax, eax
	jne	SHORT $LN48@UpdateTeam
$LN47@UpdateTeam:

; 2273 : 						TeamInfo[u->GetTeam()]->SetCurrentStats()->aircraft += u->GetTotalVehicles();

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?SetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::SetCurrentStats
	add	eax, 2
	mov	DWORD PTR tv309[ebp], eax
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	mov	edx, DWORD PTR tv309[ebp]
	movzx	ecx, WORD PTR [edx]
	add	ecx, eax
	mov	edx, DWORD PTR tv309[ebp]
	mov	WORD PTR [edx], cx

; 2274 : 					else {

	jmp	$LN50@UpdateTeam
$LN48@UpdateTeam:

; 2275 : 						Objective o = (Objective)u->GetUnitAirbase();

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+704]
	call	eax
	mov	DWORD PTR _o$5[ebp], eax

; 2276 : 						TeamInfo[u->GetTeam()]->SetCurrentStats()->aircraft += int(u->GetTotalVehicles()*o->GetObjectiveStatus()/100);

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?SetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::SetCurrentStats
	add	eax, 2
	mov	DWORD PTR tv342[ebp], eax
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	mov	esi, eax
	mov	ecx, DWORD PTR _o$5[ebp]
	call	?GetObjectiveStatus@ObjectiveClass@@QAEEXZ ; ObjectiveClass::GetObjectiveStatus
	movzx	edx, al
	imul	esi, edx
	mov	eax, esi
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	edx, DWORD PTR tv342[ebp]
	movzx	ecx, WORD PTR [edx]
	add	ecx, eax
	mov	edx, DWORD PTR tv342[ebp]
	mov	WORD PTR [edx], cx
$LN50@UpdateTeam:

; 2277 : 					}
; 2278 : 				}
; 2279 : 			}

	jmp	SHORT $LN52@UpdateTeam
$LN51@UpdateTeam:

; 2280 : 			else if (u->GetDomain() == DOMAIN_SEA)

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetDomain@CampBaseClass@@QBEEXZ	; CampBaseClass::GetDomain
	movzx	eax, al
	cmp	eax, 4
	jne	SHORT $LN52@UpdateTeam

; 2281 : 			{
; 2282 : 				TeamInfo[u->GetTeam()]->SetCurrentStats()->ships += u->GetTotalVehicles();

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?SetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::SetCurrentStats
	add	eax, 6
	mov	DWORD PTR tv370[ebp], eax
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	mov	edx, DWORD PTR tv370[ebp]
	movzx	ecx, WORD PTR [edx]
	add	ecx, eax
	mov	edx, DWORD PTR tv370[ebp]
	mov	WORD PTR [edx], cx
$LN52@UpdateTeam:

; 2283 : 			}
; 2284 : 			if (u->GetDomain() == DOMAIN_LAND || u->IsSquadron())

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetDomain@CampBaseClass@@QBEEXZ	; CampBaseClass::GetDomain
	movzx	eax, al
	cmp	eax, 3
	je	SHORT $LN42@UpdateTeam
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+252]
	call	eax
	test	eax, eax
	je	$LN43@UpdateTeam
$LN42@UpdateTeam:

; 2285 : 			{
; 2286 : 				i = u->GetTeam();

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	DWORD PTR _i$[ebp], ecx

; 2287 : 				ths = u->GetUnitSupplyNeed(TRUE);

	push	1
	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+536]
	call	edx
	mov	DWORD PTR _ths$[ebp], eax

; 2288 : 				thf = u->GetUnitFuelNeed(TRUE);

	push	1
	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+540]
	call	eax
	mov	DWORD PTR _thf$[ebp], eax

; 2289 : 				shave[i] += ths;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _shave$[ebp+ecx*4]
	add	edx, DWORD PTR _ths$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _shave$[ebp+eax*4], edx

; 2290 : 				fhave[i] += thf;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _fhave$[ebp+ecx*4]
	add	edx, DWORD PTR _thf$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _fhave$[ebp+eax*4], edx

; 2291 : 				swant[i] += ths + u->GetUnitSupplyNeed(FALSE);

	push	0
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+536]
	call	eax
	add	eax, DWORD PTR _ths$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	add	eax, DWORD PTR _swant$[ebp+ecx*4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _swant$[ebp+edx*4], eax

; 2292 : 				fwant[i] += thf + u->GetUnitFuelNeed(FALSE);

	push	0
	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+540]
	call	eax
	add	eax, DWORD PTR _thf$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	add	eax, DWORD PTR _fwant$[ebp+ecx*4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _fwant$[ebp+edx*4], eax
$LN43@UpdateTeam:

; 2293 : 			}
; 2294 : 			u = GetNextUnit(&uit);

	lea	eax, DWORD PTR _uit$4[ebp]
	push	eax
	call	?GetNextUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z ; GetNextUnit
	add	esp, 4
	mov	DWORD PTR _u$[ebp], eax

; 2295 : 		}

	jmp	$LN58@UpdateTeam
$LN57@UpdateTeam:

; 2296 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _uit$4[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator

; 2297 : 
; 2298 : 	// If we havn't gotten a start score yet, set it.
; 2299 : 	for (i=0; i<NUM_TEAMS; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN41@UpdateTeam
$LN40@UpdateTeam:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN41@UpdateTeam:
	cmp	DWORD PTR _i$[ebp], 8
	jge	$LN39@UpdateTeam

; 2300 : 	{
; 2301 : 		if (TeamInfo[i]->flags & TEAM_ACTIVE)

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	movsx	ecx, WORD PTR [eax+350]
	and	ecx, 1
	je	$LN38@UpdateTeam

; 2302 : 		{
; 2303 : 			// Do supply and fuel
; 2304 : 			TeamInfo[i]->SetCurrentStats()->supply = TeamInfo[i]->GetSupplyAvail ();

	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?GetSupplyAvail@TeamClass@@QAEGXZ	; TeamClass::GetSupplyAvail
	mov	si, ax
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	call	?SetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::SetCurrentStats
	mov	WORD PTR [eax+8], si

; 2305 : 			TeamInfo[i]->SetCurrentStats()->fuel = TeamInfo[i]->GetFuelAvail ();

	mov	ecx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?GetFuelAvail@TeamClass@@QAEGXZ		; TeamClass::GetFuelAvail
	mov	si, ax
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?SetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::SetCurrentStats
	mov	WORD PTR [eax+10], si

; 2306 : 
; 2307 : 			if (TeamInfo[i]->startStats.airDefenseVehs < TeamInfo[i]->GetCurrentStats()->airDefenseVehs)

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	movzx	esi, WORD PTR [ecx+616]
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?GetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::GetCurrentStats
	movzx	eax, WORD PTR [eax]
	cmp	esi, eax
	jge	SHORT $LN37@UpdateTeam

; 2308 : 				TeamInfo[i]->startStats.airDefenseVehs = TeamInfo[i]->GetCurrentStats()->airDefenseVehs;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?GetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::GetCurrentStats
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	mov	dx, WORD PTR [eax]
	mov	WORD PTR [ecx+616], dx
$LN37@UpdateTeam:

; 2309 : 			if (TeamInfo[i]->startStats.aircraft < TeamInfo[i]->GetCurrentStats()->aircraft)

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	movzx	esi, WORD PTR [ecx+618]
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?GetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::GetCurrentStats
	movzx	eax, WORD PTR [eax+2]
	cmp	esi, eax
	jge	SHORT $LN36@UpdateTeam

; 2310 : 				TeamInfo[i]->startStats.aircraft = TeamInfo[i]->GetCurrentStats()->aircraft;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?GetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::GetCurrentStats
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	mov	dx, WORD PTR [eax+2]
	mov	WORD PTR [ecx+618], dx
$LN36@UpdateTeam:

; 2311 : 			if (TeamInfo[i]->startStats.groundVehs < TeamInfo[i]->GetCurrentStats()->groundVehs)

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	movzx	esi, WORD PTR [ecx+620]
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?GetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::GetCurrentStats
	movzx	eax, WORD PTR [eax+4]
	cmp	esi, eax
	jge	SHORT $LN35@UpdateTeam

; 2312 : 				TeamInfo[i]->startStats.groundVehs = TeamInfo[i]->GetCurrentStats()->groundVehs;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?GetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::GetCurrentStats
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	mov	dx, WORD PTR [eax+4]
	mov	WORD PTR [ecx+620], dx
$LN35@UpdateTeam:

; 2313 : 			if (TeamInfo[i]->startStats.ships < TeamInfo[i]->GetCurrentStats()->ships)

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	movzx	esi, WORD PTR [ecx+622]
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?GetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::GetCurrentStats
	movzx	eax, WORD PTR [eax+6]
	cmp	esi, eax
	jge	SHORT $LN34@UpdateTeam

; 2314 : 				TeamInfo[i]->startStats.ships = TeamInfo[i]->GetCurrentStats()->ships;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?GetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::GetCurrentStats
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	mov	dx, WORD PTR [eax+6]
	mov	WORD PTR [ecx+622], dx
$LN34@UpdateTeam:

; 2315 : 			if (TeamInfo[i]->startStats.supply < TeamInfo[i]->GetCurrentStats()->supply)

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	movzx	esi, WORD PTR [ecx+624]
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?GetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::GetCurrentStats
	movzx	eax, WORD PTR [eax+8]
	cmp	esi, eax
	jge	SHORT $LN33@UpdateTeam

; 2316 : 				TeamInfo[i]->startStats.supply = TeamInfo[i]->GetCurrentStats()->supply;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?GetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::GetCurrentStats
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	mov	dx, WORD PTR [eax+8]
	mov	WORD PTR [ecx+624], dx
$LN33@UpdateTeam:

; 2317 : 			if (TeamInfo[i]->startStats.fuel < TeamInfo[i]->GetCurrentStats()->fuel)

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	movzx	esi, WORD PTR [ecx+626]
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?GetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::GetCurrentStats
	movzx	eax, WORD PTR [eax+10]
	cmp	esi, eax
	jge	SHORT $LN32@UpdateTeam

; 2318 : 				TeamInfo[i]->startStats.fuel = TeamInfo[i]->GetCurrentStats()->fuel;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?GetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::GetCurrentStats
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	mov	dx, WORD PTR [eax+10]
	mov	WORD PTR [ecx+626], dx
$LN32@UpdateTeam:

; 2319 : 			if (TeamInfo[i]->startStats.airbases < TeamInfo[i]->GetCurrentStats()->airbases)

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	movzx	esi, WORD PTR [ecx+628]
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?GetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::GetCurrentStats
	movzx	eax, WORD PTR [eax+12]
	cmp	esi, eax
	jge	SHORT $LN31@UpdateTeam

; 2320 : 				TeamInfo[i]->startStats.airbases = TeamInfo[i]->GetCurrentStats()->airbases;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?GetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::GetCurrentStats
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	mov	dx, WORD PTR [eax+12]
	mov	WORD PTR [ecx+628], dx
$LN31@UpdateTeam:

; 2321 : 			// A.S. 2001-12-09 
; 2322 : 			if (!NewInitiativePoints) // The new procedure NewInitiativePointSetting does the job.

	cmp	DWORD PTR ?NewInitiativePoints@@3HA, 0	; NewInitiativePoints
	jne	$LN30@UpdateTeam

; 2323 : 			{
; 2324 : 				// same as old code 
; 2325 : 				if (TeamInfo[i]->GetInitiative() < 40)

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	call	?GetInitiative@TeamClass@@QAEFXZ	; TeamClass::GetInitiative
	movsx	ecx, ax
	cmp	ecx, 40					; 00000028H
	jge	SHORT $LN29@UpdateTeam

; 2326 : 					TeamInfo[i]->AddInitiative ((INITIATIVE_LEAK_PER_HOUR * MIN_RECALCULATE_STATISTICS) / 60);

	movsx	eax, WORD PTR ?INITIATIVE_LEAK_PER_HOUR@@3FA ; INITIATIVE_LEAK_PER_HOUR
	movsx	edx, WORD PTR ?MIN_RECALCULATE_STATISTICS@@3FA ; MIN_RECALCULATE_STATISTICS
	imul	eax, edx
	cdq
	mov	ecx, 60					; 0000003cH
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?AddInitiative@TeamClass@@QAEXF@Z	; TeamClass::AddInitiative
	jmp	SHORT $LN30@UpdateTeam
$LN29@UpdateTeam:

; 2327 : 				else if (TeamInfo[i]->GetInitiative() < 60)

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	call	?GetInitiative@TeamClass@@QAEFXZ	; TeamClass::GetInitiative
	movsx	ecx, ax
	cmp	ecx, 60					; 0000003cH
	jge	SHORT $LN30@UpdateTeam

; 2328 : 					TeamInfo[i]->AddInitiative (-(INITIATIVE_LEAK_PER_HOUR * MIN_RECALCULATE_STATISTICS) / 60);

	movsx	eax, WORD PTR ?INITIATIVE_LEAK_PER_HOUR@@3FA ; INITIATIVE_LEAK_PER_HOUR
	movsx	edx, WORD PTR ?MIN_RECALCULATE_STATISTICS@@3FA ; MIN_RECALCULATE_STATISTICS
	imul	eax, edx
	neg	eax
	cdq
	mov	ecx, 60					; 0000003cH
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?AddInitiative@TeamClass@@QAEXF@Z	; TeamClass::AddInitiative
$LN30@UpdateTeam:

; 2329 : 			}  
; 2330 : 			// end section	
; 2331 : 
; 2332 : 			/* A.S.
; 2333 : 			// +++ old code +++ begin
; 2334 : 			// Adjust initiative
; 2335 : 			if (TeamInfo[i]->GetInitiative() < 40)
; 2336 : 			TeamInfo[i]->AddInitiative ((INITIATIVE_LEAK_PER_HOUR * MIN_RECALCULATE_STATISTICS) / 60);
; 2337 : 			else if (TeamInfo[i]->GetInitiative() < 60)
; 2338 : 			TeamInfo[i]->AddInitiative (-(INITIATIVE_LEAK_PER_HOUR * MIN_RECALCULATE_STATISTICS) / 60);
; 2339 : 			// +++ old code +++ end
; 2340 : 			 */
; 2341 : 
; 2342 : 			// Calculate current supply percentages
; 2343 : 			if (swant[i])

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _swant$[ebp+eax*4], 0
	je	SHORT $LN26@UpdateTeam

; 2344 : 				TeamInfo[i]->SetCurrentStats()->supplyLevel = shave[i]*100/swant[i];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _shave$[ebp+ecx*4]
	imul	eax, 100				; 00000064H
	mov	ecx, DWORD PTR _i$[ebp]
	cdq
	idiv	DWORD PTR _swant$[ebp+ecx*4]
	mov	ebx, eax
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?SetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::SetCurrentStats
	mov	BYTE PTR [eax+14], bl
	jmp	SHORT $LN25@UpdateTeam
$LN26@UpdateTeam:

; 2345 : 			else if (shave[i])

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _shave$[ebp+eax*4], 0
	je	SHORT $LN24@UpdateTeam

; 2346 : 				TeamInfo[i]->SetCurrentStats()->supplyLevel = 100;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?SetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::SetCurrentStats
	mov	BYTE PTR [eax+14], 100			; 00000064H

; 2347 : 			else

	jmp	SHORT $LN25@UpdateTeam
$LN24@UpdateTeam:

; 2348 : 				TeamInfo[i]->SetCurrentStats()->supplyLevel = 0;

	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?SetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::SetCurrentStats
	mov	BYTE PTR [eax+14], 0
$LN25@UpdateTeam:

; 2349 : 			if (fwant[i])

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _fwant$[ebp+eax*4], 0
	je	SHORT $LN22@UpdateTeam

; 2350 : 				TeamInfo[i]->SetCurrentStats()->fuelLevel = fhave[i]*100/fwant[i];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _fhave$[ebp+ecx*4]
	imul	eax, 100				; 00000064H
	mov	ecx, DWORD PTR _i$[ebp]
	cdq
	idiv	DWORD PTR _fwant$[ebp+ecx*4]
	mov	ebx, eax
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?SetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::SetCurrentStats
	mov	BYTE PTR [eax+15], bl
	jmp	SHORT $LN21@UpdateTeam
$LN22@UpdateTeam:

; 2351 : 			else if (fhave[i])

	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR _fhave$[ebp+eax*4], 0
	je	SHORT $LN20@UpdateTeam

; 2352 : 				TeamInfo[i]->SetCurrentStats()->fuelLevel = 100;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?SetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::SetCurrentStats
	mov	BYTE PTR [eax+15], 100			; 00000064H

; 2353 : 			else

	jmp	SHORT $LN21@UpdateTeam
$LN20@UpdateTeam:

; 2354 : 				TeamInfo[i]->SetCurrentStats()->fuelLevel = 0;

	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?SetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::SetCurrentStats
	mov	BYTE PTR [eax+15], 0
$LN21@UpdateTeam:

; 2355 : 		}
; 2356 : 		else

	jmp	SHORT $LN18@UpdateTeam
$LN38@UpdateTeam:

; 2357 : 		{
; 2358 : 			// Mark as non-existant
; 2359 : 			TeamInfo[i]->SetCurrentStats()->supplyLevel = 255;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	call	?SetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::SetCurrentStats
	mov	BYTE PTR [eax+14], 255			; 000000ffH
$LN18@UpdateTeam:

; 2360 : 		}
; 2361 : 	}

	jmp	$LN40@UpdateTeam
$LN39@UpdateTeam:

; 2362 : 
; 2363 : 	if (FalconLocalSession->GetTeam() < NUM_TEAMS)

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetTeam@FalconSessionEntity@@QAEEXZ	; FalconSessionEntity::GetTeam
	movzx	ecx, al
	cmp	ecx, 8
	jge	SHORT $LN17@UpdateTeam

; 2364 : 		GetTeamSituation (FalconLocalSession->GetTeam());

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetTeam@FalconSessionEntity@@QAEEXZ	; FalconSessionEntity::GetTeam
	movzx	edx, al
	push	edx
	call	?GetTeamSituation@@YAHE@Z		; GetTeamSituation
	add	esp, 4
$LN17@UpdateTeam:

; 2365 : 
; 2366 : 	// A.S. 2001-12-09. Call of the new initiative points procedure
; 2367 : 	if (NewInitiativePoints)   

	cmp	DWORD PTR ?NewInitiativePoints@@3HA, 0	; NewInitiativePoints
	je	SHORT $LN16@UpdateTeam

; 2368 : 		NewInitiativePointSetting(FalconLocalSession->GetTeam());  

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetTeam@FalconSessionEntity@@QAEEXZ	; FalconSessionEntity::GetTeam
	movzx	eax, al
	push	eax
	call	?NewInitiativePointSetting@@YAXE@Z	; NewInitiativePointSetting
	add	esp, 4
$LN16@UpdateTeam:

; 2369 : 	// end added section
; 2370 : 
; 2371 : 	// Write data to file
; 2372 : 	CampaignTime	timestamp;
; 2373 : 	FILE			*fp;
; 2374 : 	short			d,count;
; 2375 : 	UnitHistoryType	hist;
; 2376 : 
; 2377 : 	// SPLIT SAVE FILE into 2 FILES SO I DON'T HAVE TO READ & DISCARD A BUNCH OF DATA
; 2378 : 	// Teaminfo => .frc
; 2379 : 	// History  => .his
; 2380 : 	// PJW
; 2381 : 
; 2382 : 	CampEnterCriticalSection();

	call	?CampEnterCriticalSection@@YAXXZ	; CampEnterCriticalSection

; 2383 : 	TheCampaign.TimeStamp++;

	mov	cx, WORD PTR ?TheCampaign@@3VCampaignClass@@A+70
	add	cx, 1
	mov	WORD PTR ?TheCampaign@@3VCampaignClass@@A+70, cx

; 2384 : 	if (TheCampaign.TimeStamp > 24)

	movsx	edx, WORD PTR ?TheCampaign@@3VCampaignClass@@A+70
	cmp	edx, 24					; 00000018H
	jle	SHORT $LN15@UpdateTeam

; 2385 : 		TheCampaign.TimeStamp = 0;

	xor	eax, eax
	mov	WORD PTR ?TheCampaign@@3VCampaignClass@@A+70, ax
$LN15@UpdateTeam:

; 2386 : 	fp = OpenCampFile("tmp","frc","ab");

	push	OFFSET ??_C@_02BOGAIONP@ab?$AA@
	push	OFFSET ??_C@_03NJFDAMGG@frc?$AA@
	push	OFFSET ??_C@_03FFNGDGKN@tmp?$AA@
	call	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z	; OpenCampFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax

; 2387 : 	if (fp)

	cmp	DWORD PTR _fp$[ebp], 0
	je	$LN14@UpdateTeam

; 2388 : 	{
; 2389 : 		fseek(fp,0,SEEK_END);

	push	2
	push	0
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	_fseek
	add	esp, 12					; 0000000cH

; 2390 : 		timestamp = Camp_GetCurrentTime();

	call	?Camp_GetCurrentTime@@YAKXZ		; Camp_GetCurrentTime
	mov	DWORD PTR _timestamp$[ebp], eax

; 2391 : 		fwrite(&timestamp,sizeof(CampaignTime),1,fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	push	1
	push	4
	lea	eax, DWORD PTR _timestamp$[ebp]
	push	eax
	call	_fwrite
	add	esp, 16					; 00000010H

; 2392 : 		d = NUM_TEAMS;

	mov	ecx, 8
	mov	WORD PTR _d$[ebp], cx

; 2393 : 		fwrite(&d,sizeof(short),1,fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	push	1
	push	2
	lea	eax, DWORD PTR _d$[ebp]
	push	eax
	call	_fwrite
	add	esp, 16					; 00000010H

; 2394 : 		for (i=0; i<NUM_TEAMS; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@UpdateTeam
$LN12@UpdateTeam:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN13@UpdateTeam:
	cmp	DWORD PTR _i$[ebp], 8
	jge	SHORT $LN11@UpdateTeam

; 2395 : 			fwrite(TeamInfo[i]->SetCurrentStats(),sizeof(TeamStatusType),1,fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	push	1
	push	16					; 00000010H
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	call	?SetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::SetCurrentStats
	push	eax
	call	_fwrite
	add	esp, 16					; 00000010H
	jmp	SHORT $LN12@UpdateTeam
$LN11@UpdateTeam:

; 2396 : 		CloseCampFile(fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	?CloseCampFile@@YAXPAU_iobuf@@@Z	; CloseCampFile
	add	esp, 4
$LN14@UpdateTeam:

; 2397 : 	}
; 2398 : 
; 2399 : 	fp = OpenCampFile("tmp","his","ab");

	push	OFFSET ??_C@_02BOGAIONP@ab?$AA@
	push	OFFSET ??_C@_03GDDNCFJF@his?$AA@
	push	OFFSET ??_C@_03FFNGDGKN@tmp?$AA@
	call	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z	; OpenCampFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax

; 2400 : 	if (fp)

	cmp	DWORD PTR _fp$[ebp], 0
	je	$LN10@UpdateTeam

; 2401 : 	{
; 2402 : 		fseek(fp,0,SEEK_END);

	push	2
	push	0
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	_fseek
	add	esp, 12					; 0000000cH

; 2403 : 		timestamp = Camp_GetCurrentTime();

	call	?Camp_GetCurrentTime@@YAKXZ		; Camp_GetCurrentTime
	mov	DWORD PTR _timestamp$[ebp], eax

; 2404 : 		fwrite(&timestamp,sizeof(CampaignTime),1,fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	4
	lea	ecx, DWORD PTR _timestamp$[ebp]
	push	ecx
	call	_fwrite
	add	esp, 16					; 00000010H

; 2405 : 		// Count brigades and write to file
; 2406 : 		count = 0;

	xor	edx, edx
	mov	WORD PTR _count$[ebp], dx

; 2407 : 		{
; 2408 : 			VuListIterator	uit(AllUnitList);

	mov	eax, DWORD PTR ?AllUnitList@@3PAVVuLinkedList@@A ; AllUnitList
	push	eax
	lea	ecx, DWORD PTR _uit$3[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 2409 : 			u = GetFirstUnit(&uit);

	lea	ecx, DWORD PTR _uit$3[ebp]
	push	ecx
	call	?GetFirstUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z ; GetFirstUnit
	add	esp, 4
	mov	DWORD PTR _u$[ebp], eax
$LN9@UpdateTeam:

; 2410 : 			while (u)

	cmp	DWORD PTR _u$[ebp], 0
	je	SHORT $LN8@UpdateTeam

; 2411 : 			{
; 2412 : 				if (u->IsBattalion())

	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+240]
	call	edx
	test	eax, eax
	je	SHORT $LN7@UpdateTeam

; 2413 : 					count++;

	mov	ax, WORD PTR _count$[ebp]
	add	ax, 1
	mov	WORD PTR _count$[ebp], ax
$LN7@UpdateTeam:

; 2414 : 				u = GetNextUnit(&uit);

	lea	ecx, DWORD PTR _uit$3[ebp]
	push	ecx
	call	?GetNextUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z ; GetNextUnit
	add	esp, 4
	mov	DWORD PTR _u$[ebp], eax

; 2415 : 			}

	jmp	SHORT $LN9@UpdateTeam
$LN8@UpdateTeam:

; 2416 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _uit$3[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator

; 2417 : 
; 2418 : 		fwrite(&count,sizeof(short),1,fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	push	1
	push	2
	lea	eax, DWORD PTR _count$[ebp]
	push	eax
	call	_fwrite
	add	esp, 16					; 00000010H

; 2419 : 		{
; 2420 : 			VuListIterator	uit(AllUnitList);

	mov	ecx, DWORD PTR ?AllUnitList@@3PAVVuLinkedList@@A ; AllUnitList
	push	ecx
	lea	ecx, DWORD PTR _uit$2[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 2421 : 			u = GetFirstUnit(&uit);

	lea	edx, DWORD PTR _uit$2[ebp]
	push	edx
	call	?GetFirstUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z ; GetFirstUnit
	add	esp, 4
	mov	DWORD PTR _u$[ebp], eax
$LN6@UpdateTeam:

; 2422 : 			while (u)

	cmp	DWORD PTR _u$[ebp], 0
	je	$LN5@UpdateTeam

; 2423 : 			{
; 2424 : 				if (u->IsBattalion())

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+240]
	call	eax
	test	eax, eax
	je	SHORT $LN4@UpdateTeam

; 2425 : 				{
; 2426 : 					u->GetLocation(&hist.x,&hist.y);

	lea	ecx, DWORD PTR _hist$[ebp+3]
	push	ecx
	lea	edx, DWORD PTR _hist$[ebp+1]
	push	edx
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 2427 : 					hist.team = u->GetTeam();

	mov	eax, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	mov	BYTE PTR _hist$[ebp], al

; 2428 : 					fwrite(&hist,sizeof(UnitHistoryType),1,fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	push	5
	lea	edx, DWORD PTR _hist$[ebp]
	push	edx
	call	_fwrite
	add	esp, 16					; 00000010H
$LN4@UpdateTeam:

; 2429 : 				}
; 2430 : 				u = GetNextUnit(&uit);

	lea	eax, DWORD PTR _uit$2[ebp]
	push	eax
	call	?GetNextUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z ; GetNextUnit
	add	esp, 4
	mov	DWORD PTR _u$[ebp], eax

; 2431 : 			}

	jmp	$LN6@UpdateTeam
$LN5@UpdateTeam:

; 2432 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _uit$2[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator

; 2433 : 		CloseCampFile(fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	?CloseCampFile@@YAXPAU_iobuf@@@Z	; CloseCampFile
	add	esp, 4
$LN10@UpdateTeam:

; 2434 : 	}
; 2435 : 	CampLeaveCriticalSection();

	call	?CampLeaveCriticalSection@@YAXXZ	; CampLeaveCriticalSection

; 2436 : 
; 2437 : 	// Apply player input if player hasn't flown any missions in the last hour
; 2438 : 	/*	if (TeamInfo[FalconLocalSession->GetTeam()]->lastPlayerMission - TheCampaign.CurrentTime > g_nNoPlayerPlay*CampaignHours)
; 2439 : 		ApplyPlayerInput(FalconLocalSession->GetTeam(),FalconNullId,-10);*/
; 2440 : 
; 2441 : 	// Fix by Alfred, ApplyPlayerInput is called every hour!
; 2442 : 	int rating;
; 2443 : 	if  (TheCampaign.CurrentTime < CampaignHours*10)

	cmp	DWORD PTR ?TheCampaign@@3VCampaignClass@@A, 36000000 ; 02255100H
	jae	SHORT $LN3@UpdateTeam

; 2444 : 		rating = 0;

	mov	DWORD PTR _rating$[ebp], 0

; 2445 : 	else        // don't apply input at campaign start

	jmp	SHORT $LN2@UpdateTeam
$LN3@UpdateTeam:

; 2446 : 		rating = -10;

	mov	DWORD PTR _rating$[ebp], -10		; fffffff6H
$LN2@UpdateTeam:

; 2447 : 
; 2448 : 	if (TheCampaign.CurrentTime - TeamInfo[FalconLocalSession->GetTeam()]->lastPlayerMission > 
; 2449 : 					(unsigned int)g_nNoPlayerPlay*CampaignHours){

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetTeam@FalconSessionEntity@@QAEEXZ	; FalconSessionEntity::GetTeam
	movzx	edx, al
	mov	eax, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	mov	ecx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	sub	ecx, DWORD PTR [eax+608]
	mov	edx, DWORD PTR ?g_nNoPlayerPlay@@3HA	; g_nNoPlayerPlay
	imul	edx, 3600000				; 0036ee80H
	cmp	ecx, edx
	jbe	SHORT $LN63@UpdateTeam

; 2450 : 		ApplyPlayerInput(FalconLocalSession->GetTeam(),FalconNullId,rating);

	mov	eax, DWORD PTR _rating$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	push	ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	push	edx
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetTeam@FalconSessionEntity@@QAEEXZ	; FalconSessionEntity::GetTeam
	movzx	eax, al
	push	eax
	call	?ApplyPlayerInput@@YAXEVVU_ID@@H@Z	; ApplyPlayerInput
	add	esp, 16					; 00000010H
$LN63@UpdateTeam:

; 2451 : 	}
; 2452 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?UpdateTeamStatistics@@YAXXZ$0:
	lea	ecx, DWORD PTR _uit$4[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__unwindfunclet$?UpdateTeamStatistics@@YAXXZ$1:
	lea	ecx, DWORD PTR _uit$3[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__unwindfunclet$?UpdateTeamStatistics@@YAXXZ$2:
	lea	ecx, DWORD PTR _uit$2[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__ehhandler$?UpdateTeamStatistics@@YAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-252]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?UpdateTeamStatistics@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?UpdateTeamStatistics@@YAXXZ ENDP			; UpdateTeamStatistics
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_myit$ = -92						; size = 12
$T2 = -80						; size = 8
$T3 = -72						; size = 8
$T4 = -64						; size = 8
$T5 = -56						; size = 4
tv268 = -52						; size = 4
$T6 = -48						; size = 4
tv257 = -44						; size = 4
_added$ = -40						; size = 4
_o$ = -36						; size = 4
_newEvent$7 = -32					; size = 4
_e$ = -28						; size = 4
_u$ = -24						; size = 4
_x$ = -20						; size = 2
_y$ = -16						; size = 2
__$EHRec$ = -12						; size = 12
_who$ = 8						; size = 1
_inc$ = 12						; size = 4
?AddReinforcements@@YAXEH@Z PROC			; AddReinforcements

; 2164 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddReinforcements@@YAXEH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 80					; 00000050H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 2165 : 	Unit				u,e;
; 2166 : 	Objective			o;
; 2167 : 	GridIndex			x,y;
; 2168 : 	int					added;
; 2169 : 
; 2170 : 	if ((inc <= 0) || (TeamInfo[who] == NULL) || (!(TeamInfo[who]->flags & TEAM_ACTIVE)))

	cmp	DWORD PTR _inc$[ebp], 0
	jle	SHORT $LN14@AddReinfor
	movzx	eax, BYTE PTR _who$[ebp]
	cmp	DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4], 0
	je	SHORT $LN14@AddReinfor
	movzx	ecx, BYTE PTR _who$[ebp]
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	movsx	eax, WORD PTR [edx+350]
	and	eax, 1
	jne	SHORT $LN15@AddReinfor
$LN14@AddReinfor:

; 2171 : 		return;

	jmp	$LN16@AddReinfor
$LN15@AddReinfor:

; 2172 : 	TeamInfo[who]->AddReinforcement (inc);

	movzx	ecx, WORD PTR _inc$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?AddReinforcement@TeamClass@@QAEXF@Z	; TeamClass::AddReinforcement

; 2173 : 	// Traverse reinforcement list, adding new units
; 2174 : 	VuListIterator		myit(InactiveList);

	mov	eax, DWORD PTR ?InactiveList@@3PAVVuLinkedList@@A ; InactiveList
	push	eax
	lea	ecx, DWORD PTR _myit$[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2175 : 	u = GetFirstUnit(&myit);

	lea	ecx, DWORD PTR _myit$[ebp]
	push	ecx
	call	?GetFirstUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z ; GetFirstUnit
	add	esp, 4
	mov	DWORD PTR _u$[ebp], eax
$LN13@AddReinfor:

; 2176 : 	while (u)

	cmp	DWORD PTR _u$[ebp], 0
	je	$LN12@AddReinfor

; 2177 : 	{
; 2178 : 		// Activate any waiting reinforcements (note: cargoed units are inactive too, so keep an eye out)
; 2179 : 		if (u->GetTeam() == who && !u->Cargo() && u->GetUnitReinforcementLevel() <= TeamInfo[who]->GetReinforcement() && u->Parent())

	mov	edx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	movzx	ecx, BYTE PTR _who$[ebp]
	cmp	eax, ecx
	jne	$LN11@AddReinfor
	mov	ecx, DWORD PTR _u$[ebp]
	call	?Cargo@UnitClass@@QBEHXZ		; UnitClass::Cargo
	test	eax, eax
	jne	$LN11@AddReinfor
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetUnitReinforcementLevel@UnitClass@@QAEHXZ ; UnitClass::GetUnitReinforcementLevel
	mov	esi, eax
	movzx	edx, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?GetReinforcement@TeamClass@@QAEFXZ	; TeamClass::GetReinforcement
	cwde
	cmp	esi, eax
	jg	$LN11@AddReinfor
	mov	ecx, DWORD PTR _u$[ebp]
	call	?Parent@UnitClass@@QBEHXZ		; UnitClass::Parent
	test	eax, eax
	je	$LN11@AddReinfor

; 2180 : 		{
; 2181 : 			added = 0;

	mov	DWORD PTR _added$[ebp], 0

; 2182 : 			if (u->IsBrigade()){

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+244]
	call	eax
	test	eax, eax
	je	SHORT $LN10@AddReinfor

; 2183 : 				e = u->GetFirstUnitElement();

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+956]
	call	eax
	mov	DWORD PTR _e$[ebp], eax

; 2184 : 			}
; 2185 : 			else {

	jmp	SHORT $LN8@AddReinfor
$LN10@AddReinfor:

; 2186 : 				e = u;

	mov	ecx, DWORD PTR _u$[ebp]
	mov	DWORD PTR _e$[ebp], ecx
$LN8@AddReinfor:

; 2187 : 			}
; 2188 : 			while (e){

	cmp	DWORD PTR _e$[ebp], 0
	je	$LN7@AddReinfor

; 2189 : 				e->GetLocation(&x,&y);

	lea	edx, DWORD PTR _y$[ebp]
	push	edx
	lea	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 2190 : 				// RV - Biker - 100km is too big perimeter (carrier near coast)
; 2191 : 				o = FindNearestObjective(x, y, NULL, 25);

	push	25					; 00000019H
	push	0
	movzx	ecx, WORD PTR _y$[ebp]
	push	ecx
	movzx	edx, WORD PTR _x$[ebp]
	push	edx
	call	?FindNearestObjective@@YAPAVObjectiveClass@@FFPAMF@Z ; FindNearestObjective
	add	esp, 16					; 00000010H
	mov	DWORD PTR _o$[ebp], eax

; 2192 : 				if (!o || o->GetTeam() == who)

	cmp	DWORD PTR _o$[ebp], 0
	je	SHORT $LN5@AddReinfor
	mov	eax, DWORD PTR _o$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _o$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	movzx	edx, BYTE PTR _who$[ebp]
	cmp	ecx, edx
	jne	SHORT $LN6@AddReinfor
$LN5@AddReinfor:

; 2193 : 				{
; 2194 : 					// Activate this unit && force list reinsertion
; 2195 : 					e->BroadcastUnitMessage(e->Id(), FalconUnitMessage::unitActivate, 0, 0, 0);

	push	0
	push	0
	push	0
	push	7
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, DWORD PTR _e$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _e$[ebp]
	call	?BroadcastUnitMessage@UnitClass@@QAEXVVU_ID@@FFFF@Z ; UnitClass::BroadcastUnitMessage

; 2196 : #ifdef DEBUG
; 2197 : 					gReinforcementsAdded[who]++;
; 2198 : #endif
; 2199 : 					added++;

	mov	eax, DWORD PTR _added$[ebp]
	add	eax, 1
	mov	DWORD PTR _added$[ebp], eax
$LN6@AddReinfor:

; 2200 : 				}
; 2201 : 				if (u->IsBrigade())

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+244]
	call	eax
	test	eax, eax
	je	SHORT $LN4@AddReinfor

; 2202 : 					e = u->GetNextUnitElement();

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+960]
	call	eax
	mov	DWORD PTR _e$[ebp], eax

; 2203 : 				else

	jmp	SHORT $LN3@AddReinfor
$LN4@AddReinfor:

; 2204 : 					e = NULL;

	mov	DWORD PTR _e$[ebp], 0
$LN3@AddReinfor:

; 2205 : 			}

	jmp	$LN8@AddReinfor
$LN7@AddReinfor:

; 2206 : 			if (added)

	cmp	DWORD PTR _added$[ebp], 0
	je	$LN11@AddReinfor

; 2207 : 			{
; 2208 : 				if (u->IsBrigade())

	mov	ecx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _u$[ebp]
	mov	eax, DWORD PTR [edx+244]
	call	eax
	test	eax, eax
	je	SHORT $LN1@AddReinfor

; 2209 : 					u->BroadcastUnitMessage(u->Id(), FalconUnitMessage::unitActivate, 0, 0, 0);

	push	0
	push	0
	push	0
	push	7
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _u$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	call	?BroadcastUnitMessage@UnitClass@@QAEXVVU_ID@@FFFF@Z ; UnitClass::BroadcastUnitMessage
$LN1@AddReinfor:

; 2210 : 				// Do a news event?
; 2211 : 				FalconCampEventMessage	*newEvent = new FalconCampEventMessage(u->Id(),FalconLocalGame);

	push	100					; 00000064H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T6[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T6[ebp], 0
	je	SHORT $LN20@AddReinfor
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN18@AddReinfor
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv257[ebp], eax
	jmp	SHORT $LN19@AddReinfor
$LN18@AddReinfor:
	mov	DWORD PTR tv257[ebp], 0
$LN19@AddReinfor:
	push	1
	mov	edx, DWORD PTR tv257[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR $T6[ebp]
	call	??0FalconCampEventMessage@@QAE@VVU_ID@@PAVVuTargetEntity@@E@Z ; FalconCampEventMessage::FalconCampEventMessage
	mov	DWORD PTR tv268[ebp], eax
	jmp	SHORT $LN21@AddReinfor
$LN20@AddReinfor:
	mov	DWORD PTR tv268[ebp], 0
$LN21@AddReinfor:
	mov	eax, DWORD PTR tv268[ebp]
	mov	DWORD PTR $T5[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR $T5[ebp]
	mov	DWORD PTR _newEvent$7[ebp], ecx

; 2212 : 				newEvent->dataBlock.team = who;

	mov	edx, DWORD PTR _newEvent$7[ebp]
	mov	al, BYTE PTR _who$[ebp]
	mov	BYTE PTR [edx+53], al

; 2213 : 				newEvent->dataBlock.eventType = FalconCampEventMessage::unitReinforcement;

	mov	ecx, DWORD PTR _newEvent$7[ebp]
	mov	DWORD PTR [ecx+48], 7

; 2214 : 				u->GetLocation(&newEvent->dataBlock.data.xLoc,&newEvent->dataBlock.data.yLoc);

	mov	edx, DWORD PTR _newEvent$7[ebp]
	add	edx, 60					; 0000003cH
	push	edx
	mov	eax, DWORD PTR _newEvent$7[ebp]
	add	eax, 58					; 0000003aH
	push	eax
	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 2215 : 				newEvent->dataBlock.data.formatId = 1850;

	mov	ecx, 1850				; 0000073aH
	mov	edx, DWORD PTR _newEvent$7[ebp]
	mov	WORD PTR [edx+56], cx

; 2216 : 				newEvent->dataBlock.data.owners[0] = u->GetOwner();

	mov	ecx, DWORD PTR _u$[ebp]
	call	?GetOwner@CampBaseClass@@QAEEXZ		; CampBaseClass::GetOwner
	movzx	ax, al
	mov	ecx, 2
	imul	ecx, 0
	mov	edx, DWORD PTR _newEvent$7[ebp]
	mov	WORD PTR [edx+ecx+80], ax

; 2217 : 				SendCampUIMessage(newEvent);

	mov	eax, DWORD PTR _newEvent$7[ebp]
	push	eax
	call	?SendCampUIMessage@@YAXPAVFalconCampEventMessage@@@Z ; SendCampUIMessage
	add	esp, 4
$LN11@AddReinfor:

; 2218 : 			}
; 2219 : 		}
; 2220 : 		u = GetNextUnit(&myit);

	lea	ecx, DWORD PTR _myit$[ebp]
	push	ecx
	call	?GetNextUnit@@YAPAVUnitClass@@PAVVuListIterator@@@Z ; GetNextUnit
	add	esp, 4
	mov	DWORD PTR _u$[ebp], eax

; 2221 : 	}

	jmp	$LN13@AddReinfor
$LN12@AddReinfor:

; 2222 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _myit$[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
$LN16@AddReinfor:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?AddReinforcements@@YAXEH@Z$0:
	lea	ecx, DWORD PTR _myit$[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__unwindfunclet$?AddReinforcements@@YAXEH@Z$1:
	mov	eax, DWORD PTR $T6[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?AddReinforcements@@YAXEH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddReinforcements@@YAXEH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddReinforcements@@YAXEH@Z ENDP			; AddReinforcements
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
$T1 = -60						; size = 8
_random_priority$ = -52					; size = 4
_bonus$ = -48						; size = 4
tv726 = -44						; size = 4
_ratio$2 = -40						; size = 4
_pak_priority$ = -36					; size = 4
_pd$ = -32						; size = 4
_distance_priority$ = -28				; size = 4
_d$ = -24						; size = 4
_mission_priority$ = -20				; size = 4
_priority$ = -16					; size = 4
_po$ = -12						; size = 4
_target_priority$ = -8					; size = 4
_e$ = -4						; size = 4
_mis$ = 8						; size = 4
?GetPriority@@YAHPAVMissionRequestClass@@@Z PROC	; GetPriority

; 1999 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	push	esi

; 2000 : 	int			priority,d,bonus;
; 2001 : 	int			target_priority=0, mission_priority, random_priority, pak_priority=0, distance_priority=0;

	mov	DWORD PTR _target_priority$[ebp], 0
	mov	DWORD PTR _pak_priority$[ebp], 0
	mov	DWORD PTR _distance_priority$[ebp], 0

; 2002 : 	Objective	po = NULL;

	mov	DWORD PTR _po$[ebp], 0

; 2003 : 	POData		pd;
; 2004 : 	CampEntity	e;
; 2005 : 
; 2006 : 	bonus = mis->priority;

	mov	eax, DWORD PTR _mis$[ebp]
	movsx	ecx, WORD PTR [eax+56]
	mov	DWORD PTR _bonus$[ebp], ecx

; 2007 : 	mis->priority = 0;

	xor	edx, edx
	mov	eax, DWORD PTR _mis$[ebp]
	mov	WORD PTR [eax+56], dx

; 2008 : 	e = (CampEntity) vuDatabase->Find(mis->targetID);

	mov	ecx, DWORD PTR _mis$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR [ecx+8]
	push	eax
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _e$[ebp], eax

; 2009 : 	if (e && e->IsPackage())

	cmp	DWORD PTR _e$[ebp], 0
	je	SHORT $LN38@GetPriorit
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+256]
	call	eax
	test	eax, eax
	je	SHORT $LN38@GetPriorit

; 2010 : 		e = ((Package)e)->GetFirstUnitElement();

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+996]
	call	eax
	mov	DWORD PTR _e$[ebp], eax
$LN38@GetPriorit:

; 2011 : 
; 2012 : 	// KCK: Make sure we ignore any requests if the player has specified 0 priority
; 2013 : 	if (!TeamInfo[mis->who]->GetMissionPriority (mis->mission))

	mov	ecx, DWORD PTR _mis$[ebp]
	movzx	edx, BYTE PTR [ecx+60]
	push	edx
	mov	eax, DWORD PTR _mis$[ebp]
	movzx	ecx, BYTE PTR [eax+32]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?GetMissionPriority@TeamClass@@QAEEH@Z	; TeamClass::GetMissionPriority
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN37@GetPriorit

; 2014 : 		return -1;

	or	eax, -1
	jmp	$LN39@GetPriorit
$LN37@GetPriorit:

; 2015 : 
; 2016 : 	// Mission priority (0 - 100)
; 2017 : 	if (mis->flags & REQF_PART_OF_ACTION)

	mov	eax, DWORD PTR _mis$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	and	ecx, 1024				; 00000400H
	je	SHORT $LN36@GetPriorit

; 2018 : 		mission_priority = DefaultMissionPriority[mis->action_type-1][mis->mission];

	mov	edx, DWORD PTR _mis$[ebp]
	movzx	eax, BYTE PTR [edx+59]
	sub	eax, 1
	imul	eax, 41					; 00000029H
	mov	ecx, DWORD PTR _mis$[ebp]
	movzx	edx, BYTE PTR [ecx+60]
	movzx	eax, BYTE PTR ?DefaultMissionPriority@@3PAY0CJ@EA[eax+edx]
	mov	DWORD PTR _mission_priority$[ebp], eax

; 2019 : 	else

	jmp	SHORT $LN35@GetPriorit
$LN36@GetPriorit:

; 2020 : 		mission_priority = TeamInfo[mis->who]->GetMissionPriority (mis->mission);

	mov	ecx, DWORD PTR _mis$[ebp]
	movzx	edx, BYTE PTR [ecx+60]
	push	edx
	mov	eax, DWORD PTR _mis$[ebp]
	movzx	ecx, BYTE PTR [eax+32]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?GetMissionPriority@TeamClass@@QAEEH@Z	; TeamClass::GetMissionPriority
	movzx	edx, al
	mov	DWORD PTR _mission_priority$[ebp], edx
$LN35@GetPriorit:

; 2021 : 
; 2022 : 	// Target Priority (0 - 100)
; 2023 : 	if (!e)

	cmp	DWORD PTR _e$[ebp], 0
	jne	SHORT $LN34@GetPriorit

; 2024 : 	{
; 2025 : 		// Take the mission priority if no target
; 2026 : 		target_priority = mission_priority;

	mov	eax, DWORD PTR _mission_priority$[ebp]
	mov	DWORD PTR _target_priority$[ebp], eax

; 2027 : 		po = FindNearestObjective (POList, mis->tx, mis->ty, NULL);

	push	0
	mov	ecx, DWORD PTR _mis$[ebp]
	movzx	edx, WORD PTR [ecx+42]
	push	edx
	mov	eax, DWORD PTR _mis$[ebp]
	movzx	ecx, WORD PTR [eax+40]
	push	ecx
	mov	edx, DWORD PTR ?POList@@3PAVFalconPrivateOrderedList@@A ; POList
	push	edx
	call	?FindNearestObjective@@YAPAVObjectiveClass@@PAVVuLinkedList@@FFPAM@Z ; FindNearestObjective
	add	esp, 16					; 00000010H
	mov	DWORD PTR _po$[ebp], eax
	jmp	$LN17@GetPriorit
$LN34@GetPriorit:

; 2028 : 	}
; 2029 : 	else if (e->IsObjective())

	mov	eax, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+236]
	call	eax
	test	eax, eax
	je	$LN32@GetPriorit

; 2030 : 	{
; 2031 : 		// KCK: Make sure we ignore any requests if the player has specified 0 priority
; 2032 : 		if (!TeamInfo[mis->who]->GetObjTypePriority(e->GetType()))

	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetType
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _mis$[ebp]
	movzx	eax, BYTE PTR [edx+32]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	call	?GetObjTypePriority@TeamClass@@QAEEH@Z	; TeamClass::GetObjTypePriority
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN31@GetPriorit

; 2033 : 			return -1;

	or	eax, -1
	jmp	$LN39@GetPriorit
$LN31@GetPriorit:

; 2034 : 		// o Objective Target Type component (0-50)
; 2035 : 		if (mis->flags & REQF_PART_OF_ACTION)

	mov	edx, DWORD PTR _mis$[ebp]
	mov	eax, DWORD PTR [edx+44]
	and	eax, 1024				; 00000400H
	je	SHORT $LN30@GetPriorit

; 2036 : 			target_priority = DefaultObjtypePriority[mis->action_type-1][e->GetType()]/2;

	mov	ecx, DWORD PTR _mis$[ebp]
	movzx	esi, BYTE PTR [ecx+59]
	sub	esi, 1
	imul	esi, 36					; 00000024H
	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetType
	movzx	edx, al
	movzx	eax, BYTE PTR ?DefaultObjtypePriority@@3PAY0CE@EA[esi+edx]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _target_priority$[ebp], eax

; 2037 : 		else

	jmp	SHORT $LN29@GetPriorit
$LN30@GetPriorit:

; 2038 : 			target_priority = TeamInfo[mis->who]->GetObjTypePriority(e->GetType())/2;

	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetType
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _mis$[ebp]
	movzx	edx, BYTE PTR [ecx+32]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?GetObjTypePriority@TeamClass@@QAEEH@Z	; TeamClass::GetObjTypePriority
	movzx	eax, al
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _target_priority$[ebp], eax
$LN29@GetPriorit:

; 2039 : 		// o Objective Priority component (0-50)
; 2040 : 		target_priority += (target_priority * ((Objective)e)->GetObjectivePriority()) / 100;

	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetObjectivePriority@ObjectiveClass@@QAEFXZ ; ObjectiveClass::GetObjectivePriority
	cwde
	imul	eax, DWORD PTR _target_priority$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	add	eax, DWORD PTR _target_priority$[ebp]
	mov	DWORD PTR _target_priority$[ebp], eax

; 2041 : 		po = ((Objective)e)->GetObjectivePrimary();

	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetObjectivePrimary@ObjectiveClass@@QAEPAV1@XZ ; ObjectiveClass::GetObjectivePrimary
	mov	DWORD PTR _po$[ebp], eax

; 2042 : 		if (!po)

	cmp	DWORD PTR _po$[ebp], 0
	jne	SHORT $LN28@GetPriorit

; 2043 : 			po = FindNearestObjective (POList, mis->tx, mis->ty, NULL);

	push	0
	mov	edx, DWORD PTR _mis$[ebp]
	movzx	eax, WORD PTR [edx+42]
	push	eax
	mov	ecx, DWORD PTR _mis$[ebp]
	movzx	edx, WORD PTR [ecx+40]
	push	edx
	mov	eax, DWORD PTR ?POList@@3PAVFalconPrivateOrderedList@@A ; POList
	push	eax
	call	?FindNearestObjective@@YAPAVObjectiveClass@@PAVVuLinkedList@@FFPAM@Z ; FindNearestObjective
	add	esp, 16					; 00000010H
	mov	DWORD PTR _po$[ebp], eax
$LN28@GetPriorit:

; 2044 : 	}

	jmp	$LN17@GetPriorit
$LN32@GetPriorit:

; 2045 : 	else if (e->IsUnit() && e->GetDomain() == DOMAIN_LAND)

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+232]
	call	eax
	test	eax, eax
	je	$LN26@GetPriorit
	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetDomain@CampBaseClass@@QBEEXZ	; CampBaseClass::GetDomain
	movzx	ecx, al
	cmp	ecx, 3
	jne	$LN26@GetPriorit

; 2046 : 	{
; 2047 : 		// KCK: Make sure we ignore any requests if the player has specified 0 priority
; 2048 : 		if (!TeamInfo[mis->who]->GetUnitTypePriority(e->GetSType()))

	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetSType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetSType
	movzx	edx, al
	push	edx
	mov	eax, DWORD PTR _mis$[ebp]
	movzx	ecx, BYTE PTR [eax+32]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?GetUnitTypePriority@TeamClass@@QAEEH@Z	; TeamClass::GetUnitTypePriority
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN25@GetPriorit

; 2049 : 			return -1;

	or	eax, -1
	jmp	$LN39@GetPriorit
$LN25@GetPriorit:

; 2050 : 		// o Unit Target Type component (0-50)
; 2051 : 		if (mis->flags & REQF_PART_OF_ACTION)

	mov	eax, DWORD PTR _mis$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	and	ecx, 1024				; 00000400H
	je	SHORT $LN24@GetPriorit

; 2052 : 			target_priority = DefaultUnittypePriority[mis->action_type-1][e->GetSType()]/2;

	mov	edx, DWORD PTR _mis$[ebp]
	movzx	esi, BYTE PTR [edx+59]
	sub	esi, 1
	imul	esi, 20					; 00000014H
	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetSType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetSType
	movzx	eax, al
	movzx	eax, BYTE PTR ?DefaultUnittypePriority@@3PAY0BE@EA[esi+eax]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _target_priority$[ebp], eax

; 2053 : 		else

	jmp	SHORT $LN23@GetPriorit
$LN24@GetPriorit:

; 2054 : 			target_priority = TeamInfo[mis->who]->GetUnitTypePriority(e->GetSType())/2;

	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetSType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetSType
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _mis$[ebp]
	movzx	eax, BYTE PTR [edx+32]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	call	?GetUnitTypePriority@TeamClass@@QAEEH@Z	; TeamClass::GetUnitTypePriority
	movzx	eax, al
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _target_priority$[ebp], eax
$LN23@GetPriorit:

; 2055 : 		// o Unit size/range component (0-50)
; 2056 : 		if (e->GetSType() == STYPE_UNIT_AIR_DEFENSE)

	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetSType@CampBaseClass@@QBEEXZ		; CampBaseClass::GetSType
	movzx	ecx, al
	cmp	ecx, 1
	jne	SHORT $LN22@GetPriorit

; 2057 : 			target_priority = (target_priority + e->GetAproxWeaponRange(Air)*2)/2;

	push	5
	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax+412]
	call	edx
	mov	ecx, DWORD PTR _target_priority$[ebp]
	lea	eax, DWORD PTR [ecx+eax*2]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _target_priority$[ebp], eax

; 2058 : 		else

	jmp	SHORT $LN21@GetPriorit
$LN22@GetPriorit:

; 2059 : 			target_priority = (target_priority * ((Unit)e)->GetTotalVehicles()) / 50;

	mov	ecx, DWORD PTR _e$[ebp]
	call	?GetTotalVehicles@UnitClass@@QAEHXZ	; UnitClass::GetTotalVehicles
	imul	eax, DWORD PTR _target_priority$[ebp]
	cdq
	mov	ecx, 50					; 00000032H
	idiv	ecx
	mov	DWORD PTR _target_priority$[ebp], eax
$LN21@GetPriorit:

; 2060 : 		po = FindNearestObjective (POList, mis->tx, mis->ty, NULL);

	push	0
	mov	edx, DWORD PTR _mis$[ebp]
	movzx	eax, WORD PTR [edx+42]
	push	eax
	mov	ecx, DWORD PTR _mis$[ebp]
	movzx	edx, WORD PTR [ecx+40]
	push	edx
	mov	eax, DWORD PTR ?POList@@3PAVFalconPrivateOrderedList@@A ; POList
	push	eax
	call	?FindNearestObjective@@YAPAVObjectiveClass@@PAVVuLinkedList@@FFPAM@Z ; FindNearestObjective
	add	esp, 16					; 00000010H
	mov	DWORD PTR _po$[ebp], eax
	jmp	$LN17@GetPriorit
$LN26@GetPriorit:

; 2061 : 	}
; 2062 : 	else if (e->IsTaskForce())

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [edx+264]
	call	eax
	test	eax, eax
	je	SHORT $LN19@GetPriorit

; 2063 : 	{
; 2064 : 		// o TaskForce component (0-100)
; 2065 : 		target_priority = TeamInfo[mis->who]->GetUnitTypePriority(MAX_UNITTYPE-1);

	push	19					; 00000013H
	mov	ecx, DWORD PTR _mis$[ebp]
	movzx	edx, BYTE PTR [ecx+32]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?GetUnitTypePriority@TeamClass@@QAEEH@Z	; TeamClass::GetUnitTypePriority
	movzx	eax, al
	mov	DWORD PTR _target_priority$[ebp], eax

; 2066 : 		// KCK: Make sure we ignore any requests if the player has specified 0 priority
; 2067 : 		if (!target_priority)

	cmp	DWORD PTR _target_priority$[ebp], 0
	jne	SHORT $LN18@GetPriorit

; 2068 : 			return -1;

	or	eax, -1
	jmp	$LN39@GetPriorit
$LN18@GetPriorit:

; 2069 : 		po = FindNearestObjective (POList, mis->tx, mis->ty, NULL);

	push	0
	mov	ecx, DWORD PTR _mis$[ebp]
	movzx	edx, WORD PTR [ecx+42]
	push	edx
	mov	eax, DWORD PTR _mis$[ebp]
	movzx	ecx, WORD PTR [eax+40]
	push	ecx
	mov	edx, DWORD PTR ?POList@@3PAVFalconPrivateOrderedList@@A ; POList
	push	edx
	call	?FindNearestObjective@@YAPAVObjectiveClass@@PAVVuLinkedList@@FFPAM@Z ; FindNearestObjective
	add	esp, 16					; 00000010H
	mov	DWORD PTR _po$[ebp], eax

; 2070 : 	}
; 2071 : 	else

	jmp	SHORT $LN17@GetPriorit
$LN19@GetPriorit:

; 2072 : 	{
; 2073 : 		// Default
; 2074 : 		target_priority = mission_priority;

	mov	eax, DWORD PTR _mission_priority$[ebp]
	mov	DWORD PTR _target_priority$[ebp], eax

; 2075 : 		po = FindNearestObjective (POList, mis->tx, mis->ty, NULL);

	push	0
	mov	ecx, DWORD PTR _mis$[ebp]
	movzx	edx, WORD PTR [ecx+42]
	push	edx
	mov	eax, DWORD PTR _mis$[ebp]
	movzx	ecx, WORD PTR [eax+40]
	push	ecx
	mov	edx, DWORD PTR ?POList@@3PAVFalconPrivateOrderedList@@A ; POList
	push	edx
	call	?FindNearestObjective@@YAPAVObjectiveClass@@PAVVuLinkedList@@FFPAM@Z ; FindNearestObjective
	add	esp, 16					; 00000010H
	mov	DWORD PTR _po$[ebp], eax
$LN17@GetPriorit:

; 2076 : 	}
; 2077 : 	if (!po)

	cmp	DWORD PTR _po$[ebp], 0
	jne	SHORT $LN16@GetPriorit

; 2078 : 		return -1;

	or	eax, -1
	jmp	$LN39@GetPriorit
$LN16@GetPriorit:

; 2079 : 	// Pak priority (0 - 100)
; 2080 : 	pd = GetPOData(po);

	mov	eax, DWORD PTR _po$[ebp]
	push	eax
	call	?GetPOData@@YAPAUPrimaryObjectiveData@@PAVObjectiveClass@@@Z ; GetPOData
	add	esp, 4
	mov	DWORD PTR _pd$[ebp], eax

; 2081 : 	if (!pd)

	cmp	DWORD PTR _pd$[ebp], 0
	jne	SHORT $LN15@GetPriorit

; 2082 : 		return -1;

	or	eax, -1
	jmp	$LN39@GetPriorit
$LN15@GetPriorit:

; 2083 : 	if (pd->player_priority[mis->who] >= 0)

	mov	ecx, DWORD PTR _mis$[ebp]
	movzx	edx, BYTE PTR [ecx+32]
	mov	eax, DWORD PTR _pd$[ebp]
	movsx	ecx, WORD PTR [eax+edx*2+56]
	test	ecx, ecx
	jl	SHORT $LN14@GetPriorit

; 2084 : 	{
; 2085 : 		pak_priority = pd->player_priority[mis->who];

	mov	edx, DWORD PTR _mis$[ebp]
	movzx	eax, BYTE PTR [edx+32]
	mov	ecx, DWORD PTR _pd$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+56]
	mov	DWORD PTR _pak_priority$[ebp], edx

; 2086 : 		// KCK: Make sure we ignore any requests if the player has specified 0 priority
; 2087 : 		if (!pak_priority)

	cmp	DWORD PTR _pak_priority$[ebp], 0
	jne	SHORT $LN13@GetPriorit

; 2088 : 			return -1;

	or	eax, -1
	jmp	$LN39@GetPriorit
$LN13@GetPriorit:

; 2089 : 	}
; 2090 : 	else

	jmp	SHORT $LN12@GetPriorit
$LN14@GetPriorit:

; 2091 : 		pak_priority = pd->air_priority[mis->who];

	mov	eax, DWORD PTR _mis$[ebp]
	movzx	ecx, BYTE PTR [eax+32]
	mov	edx, DWORD PTR _pd$[ebp]
	movsx	eax, WORD PTR [edx+ecx*2+40]
	mov	DWORD PTR _pak_priority$[ebp], eax
$LN12@GetPriorit:

; 2092 : 	mis->pakID = po->Id();

	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _po$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _mis$[ebp]
	mov	DWORD PTR [ecx+24], edx
	mov	DWORD PTR [ecx+28], eax

; 2093 : 	// Distance priority (0 - 200)
; 2094 : 	if (MissionData[mis->mission].flags & AMIS_NO_DIST_BONUS)

	mov	edx, DWORD PTR _mis$[ebp]
	movzx	eax, BYTE PTR [edx+60]
	shl	eax, 5
	mov	ecx, DWORD PTR ?MissionData@@3PAUMissionDataType@@A[eax+28]
	and	ecx, 134217728				; 08000000H
	je	SHORT $LN11@GetPriorit

; 2095 : 		distance_priority = mission_priority * 2;

	mov	edx, DWORD PTR _mission_priority$[ebp]
	shl	edx, 1
	mov	DWORD PTR _distance_priority$[ebp], edx

; 2096 : 	else

	jmp	$LN5@GetPriorit
$LN11@GetPriorit:

; 2097 : 	{
; 2098 : 		d = FloatToInt32(DistanceToFront(mis->tx,mis->ty));

	mov	eax, DWORD PTR _mis$[ebp]
	movzx	ecx, WORD PTR [eax+42]
	push	ecx
	mov	edx, DWORD PTR _mis$[ebp]
	movzx	eax, WORD PTR [edx+40]
	push	eax
	call	?DistanceToFront@@YAMFF@Z		; DistanceToFront
	add	esp, 4
	fstp	DWORD PTR [esp]
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _d$[ebp], eax

; 2099 : 		if (d < 50)

	cmp	DWORD PTR _d$[ebp], 50			; 00000032H
	jge	SHORT $LN9@GetPriorit

; 2100 : 			distance_priority = 100 + (50-d)*2;		// 100 - 200

	mov	ecx, 50					; 00000032H
	sub	ecx, DWORD PTR _d$[ebp]
	lea	edx, DWORD PTR [ecx+ecx+100]
	mov	DWORD PTR _distance_priority$[ebp], edx
	jmp	SHORT $LN6@GetPriorit
$LN9@GetPriorit:

; 2101 : 		else if (d < 250)

	cmp	DWORD PTR _d$[ebp], 250			; 000000faH
	jge	SHORT $LN7@GetPriorit

; 2102 : 			distance_priority = 100 - (d-50)/2;		// 0 - 100

	mov	eax, DWORD PTR _d$[ebp]
	sub	eax, 50					; 00000032H
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, 100				; 00000064H
	sub	ecx, eax
	mov	DWORD PTR _distance_priority$[ebp], ecx

; 2103 : 		else

	jmp	SHORT $LN6@GetPriorit
$LN7@GetPriorit:

; 2104 : 			distance_priority = 0;					// 0

	mov	DWORD PTR _distance_priority$[ebp], 0
$LN6@GetPriorit:

; 2105 : 		if (d > 100 && !mis->action_type && mis->mission == AMIS_SWEEP)

	cmp	DWORD PTR _d$[ebp], 100			; 00000064H
	jle	SHORT $LN5@GetPriorit
	mov	edx, DWORD PTR _mis$[ebp]
	movzx	eax, BYTE PTR [edx+59]
	test	eax, eax
	jne	SHORT $LN5@GetPriorit
	mov	ecx, DWORD PTR _mis$[ebp]
	movzx	edx, BYTE PTR [ecx+60]
	cmp	edx, 7
	jne	SHORT $LN5@GetPriorit

; 2106 : 		{
; 2107 : 			priority = -1;

	mov	DWORD PTR _priority$[ebp], -1

; 2108 : 			return -1;

	or	eax, -1
	jmp	$LN39@GetPriorit
$LN5@GetPriorit:

; 2109 : 		}
; 2110 : 	}
; 2111 : 	// Random priority (0 - 50)
; 2112 : 	random_priority = rand()%50;

	call	_rand
	cdq
	mov	ecx, 50					; 00000032H
	idiv	ecx
	mov	DWORD PTR _random_priority$[ebp], edx

; 2113 : 	// KCK HACK:
; 2114 : 	// Special case adjustments (it'd be nice to do this to the priorities themselves)
; 2115 : 	if ((mis->mission == AMIS_CAS || mis->mission == AMIS_ONCALLCAS || mis->mission == AMIS_PRPLANCAS || mis->mission == AMIS_BAI) && mis->vs)

	mov	edx, DWORD PTR _mis$[ebp]
	movzx	eax, BYTE PTR [edx+60]
	cmp	eax, 22					; 00000016H
	je	SHORT $LN3@GetPriorit
	mov	ecx, DWORD PTR _mis$[ebp]
	movzx	edx, BYTE PTR [ecx+60]
	cmp	edx, 20					; 00000014H
	je	SHORT $LN3@GetPriorit
	mov	eax, DWORD PTR _mis$[ebp]
	movzx	ecx, BYTE PTR [eax+60]
	cmp	ecx, 21					; 00000015H
	je	SHORT $LN3@GetPriorit
	mov	edx, DWORD PTR _mis$[ebp]
	movzx	eax, BYTE PTR [edx+60]
	cmp	eax, 25					; 00000019H
	jne	$LN4@GetPriorit
$LN3@GetPriorit:
	mov	ecx, DWORD PTR _mis$[ebp]
	movzx	edx, BYTE PTR [ecx+33]
	test	edx, edx
	je	$LN4@GetPriorit

; 2116 : 	{
; 2117 : 		// Bonus/penalty based on ground force ratios.
; 2118 : 		float	ratio = (float)sqrt((float)TeamInfo[mis->who]->GetCurrentStats()->groundVehs/(float)TeamInfo[mis->vs]->GetCurrentStats()->groundVehs);

	mov	eax, DWORD PTR _mis$[ebp]
	movzx	ecx, BYTE PTR [eax+32]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?GetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::GetCurrentStats
	movzx	edx, WORD PTR [eax+4]
	cvtsi2ss xmm0, edx
	mov	eax, DWORD PTR _mis$[ebp]
	movzx	ecx, BYTE PTR [eax+33]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	movss	DWORD PTR tv726[ebp], xmm0
	call	?GetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::GetCurrentStats
	movzx	edx, WORD PTR [eax+4]
	cvtsi2ss xmm0, edx
	movss	xmm1, DWORD PTR tv726[ebp]
	divss	xmm1, xmm0
	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	fstp	DWORD PTR _ratio$2[ebp]

; 2119 : 		target_priority = FloatToInt32(ratio * target_priority);

	cvtsi2ss xmm0, DWORD PTR _target_priority$[ebp]
	mulss	xmm0, DWORD PTR _ratio$2[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _target_priority$[ebp], eax

; 2120 : 		mission_priority = FloatToInt32(ratio * mission_priority);

	cvtsi2ss xmm0, DWORD PTR _mission_priority$[ebp]
	mulss	xmm0, DWORD PTR _ratio$2[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _mission_priority$[ebp], eax
$LN4@GetPriorit:

; 2121 : 	}
; 2122 : 	// Total priority (0 - 550) + bonus
; 2123 : 	priority = bonus + target_priority + mission_priority + pak_priority + distance_priority + random_priority;

	mov	eax, DWORD PTR _bonus$[ebp]
	add	eax, DWORD PTR _target_priority$[ebp]
	add	eax, DWORD PTR _mission_priority$[ebp]
	add	eax, DWORD PTR _pak_priority$[ebp]
	add	eax, DWORD PTR _distance_priority$[ebp]
	add	eax, DWORD PTR _random_priority$[ebp]
	mov	DWORD PTR _priority$[ebp], eax

; 2124 : 
; 2125 : 	// Scaled roughly to 0-255
; 2126 : 	priority = (priority * 300) / 500;

	mov	eax, DWORD PTR _priority$[ebp]
	imul	eax, 300				; 0000012cH
	cdq
	mov	ecx, 500				; 000001f4H
	idiv	ecx
	mov	DWORD PTR _priority$[ebp], eax

; 2127 : 	if (priority > 255)

	cmp	DWORD PTR _priority$[ebp], 255		; 000000ffH
	jle	SHORT $LN2@GetPriorit

; 2128 : 		priority = 255;

	mov	DWORD PTR _priority$[ebp], 255		; 000000ffH
$LN2@GetPriorit:

; 2129 : 	if (priority < 0)

	cmp	DWORD PTR _priority$[ebp], 0
	jge	SHORT $LN1@GetPriorit

; 2130 : 		priority = 0;

	mov	DWORD PTR _priority$[ebp], 0
$LN1@GetPriorit:

; 2131 : 	mis->priority = priority;

	mov	edx, DWORD PTR _mis$[ebp]
	mov	ax, WORD PTR _priority$[ebp]
	mov	WORD PTR [edx+56], ax

; 2132 : 
; 2133 : #ifdef DEBUG
; 2134 : 	// Keep statistics on priorities
; 2135 : 	strcpy(Priorities[mis->mission].name,MissStr[mis->mission]);
; 2136 : 	Priorities[mis->mission].number_queried++;
; 2137 : 	Priorities[mis->mission].total_score += priority;
; 2138 : 	Priorities[mis->mission].total_distance += distance_priority;
; 2139 : 	Priorities[mis->mission].total_target += target_priority;
; 2140 : 	Priorities[mis->mission].total_mission += mission_priority;
; 2141 : 	Priorities[mis->mission].total_random += random_priority;
; 2142 : 	Priorities[mis->mission].total_pak += pak_priority;
; 2143 : 	Priorities[mis->mission].total_bonus += bonus;;
; 2144 : 	Priorities[mis->mission].average_score = Priorities[mis->mission].total_score / Priorities[mis->mission].number_queried;
; 2145 : 	Priorities[mis->mission].average_distance = Priorities[mis->mission].total_distance / Priorities[mis->mission].number_queried;
; 2146 : 	Priorities[mis->mission].average_target = Priorities[mis->mission].total_target / Priorities[mis->mission].number_queried;
; 2147 : 	Priorities[mis->mission].average_mission = Priorities[mis->mission].total_mission / Priorities[mis->mission].number_queried;
; 2148 : 	Priorities[mis->mission].average_random = Priorities[mis->mission].total_random / Priorities[mis->mission].number_queried;
; 2149 : 	Priorities[mis->mission].average_pak = Priorities[mis->mission].total_pak / Priorities[mis->mission].number_queried;
; 2150 : 	Priorities[mis->mission].average_bonus = Priorities[mis->mission].total_bonus / Priorities[mis->mission].number_queried;
; 2151 : 	RemoveFromSortedList (&Priorities[mis->mission]);
; 2152 : 	InsertIntoSortedList (&Priorities[mis->mission]);
; 2153 : 
; 2154 : 	if (pak_priority > MaxPakPriority)
; 2155 : 		MaxPakPriority = pak_priority;
; 2156 : 	if (pak_priority < MinPakPriority)
; 2157 : 		MinPakPriority = pak_priority;
; 2158 : 
; 2159 : #endif
; 2160 : 	return priority;

	mov	eax, DWORD PTR _priority$[ebp]
$LN39@GetPriorit:

; 2161 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPriority@@YAHPAVMissionRequestClass@@@Z ENDP	; GetPriority
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_best$ = -2						; size = 1
_enemy$ = -1						; size = 1
_who$ = 8						; size = 1
?GetEnemyTeam@@YAEE@Z PROC				; GetEnemyTeam

; 1981 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1982 : 	Team	enemy,best = 0;

	mov	BYTE PTR _best$[ebp], 0

; 1983 : 
; 1984 : 	ShiAssert (who < NUM_TEAMS);
; 1985 : 
; 1986 : 	for (enemy=1; enemy<NUM_TEAMS; enemy++){

	mov	BYTE PTR _enemy$[ebp], 1
	jmp	SHORT $LN5@GetEnemyTe
$LN4@GetEnemyTe:
	mov	al, BYTE PTR _enemy$[ebp]
	add	al, 1
	mov	BYTE PTR _enemy$[ebp], al
$LN5@GetEnemyTe:
	movzx	ecx, BYTE PTR _enemy$[ebp]
	cmp	ecx, 8
	jge	SHORT $LN3@GetEnemyTe

; 1987 : 		if (GetTTRelations(who,enemy) == War){

	movzx	edx, BYTE PTR _enemy$[ebp]
	push	edx
	movzx	eax, BYTE PTR _who$[ebp]
	push	eax
	call	?GetTTRelations@@YAHEE@Z		; GetTTRelations
	add	esp, 8
	cmp	eax, 5
	jne	SHORT $LN2@GetEnemyTe

; 1988 : 			return enemy;

	mov	al, BYTE PTR _enemy$[ebp]
	jmp	SHORT $LN6@GetEnemyTe
$LN2@GetEnemyTe:

; 1989 : 		}
; 1990 : 		if (GetTTRelations(who,enemy) == Hostile){

	movzx	ecx, BYTE PTR _enemy$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _who$[ebp]
	push	edx
	call	?GetTTRelations@@YAHEE@Z		; GetTTRelations
	add	esp, 8
	cmp	eax, 4
	jne	SHORT $LN1@GetEnemyTe

; 1991 : 			best = enemy;

	mov	al, BYTE PTR _enemy$[ebp]
	mov	BYTE PTR _best$[ebp], al
$LN1@GetEnemyTe:

; 1992 : 		}
; 1993 : 	}

	jmp	SHORT $LN4@GetEnemyTe
$LN3@GetEnemyTe:

; 1994 : 	return best;

	mov	al, BYTE PTR _best$[ebp]
$LN6@GetEnemyTe:

; 1995 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetEnemyTeam@@YAEE@Z ENDP				; GetEnemyTeam
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_initiative$ = -32					; size = 4
_ts$ = -28						; size = 4
_os$ = -24						; size = 4
_initDelta$ = -20					; size = 4
_maxInitiative$ = -16					; size = 4
_i$ = -12						; size = 4
_pts$ = -8						; size = 4
_et$ = -1						; size = 1
_who$ = 8						; size = 1
_poid$ = 12						; size = 8
_rating$ = 20						; size = 4
?ApplyPlayerInput@@YAXEVVU_ID@@H@Z PROC			; ApplyPlayerInput

; 1754 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 1755 : 	ShiAssert(TeamInfo);
; 1756 : 	if (!TeamInfo)

	mov	eax, OFFSET ?TeamInfo@@3PAPAVTeamClass@@A ; TeamInfo
	test	eax, eax
	jne	SHORT $LN23@ApplyPlaye

; 1757 : 		return;

	jmp	$LN24@ApplyPlaye
$LN23@ApplyPlaye:

; 1758 : 
; 1759 : 	int		i,os,ts,initiative,maxInitiative,initDelta,pts;
; 1760 : 	Team	et = NUM_TEAMS + 1;

	mov	BYTE PTR _et$[ebp], 9

; 1761 : 
; 1762 : 	if (poid == FalconNullId)

	push	OFFSET ?FalconNullId@@3VVU_ID@@A	; FalconNullId
	lea	ecx, DWORD PTR _poid$[ebp]
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN22@ApplyPlaye

; 1763 : 		poid = TeamInfo[who]->GetGroundAction()->actionObjective;

	movzx	edx, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?GetGroundAction@TeamClass@@QAEPAUTeamGndActionType@@XZ ; TeamClass::GetGroundAction
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _poid$[ebp], ecx
	mov	DWORD PTR _poid$[ebp+4], edx
$LN22@ApplyPlaye:

; 1764 : 
; 1765 : 	// Rolling average, weighted towards most recent
; 1766 : 	TeamInfo[who]->playerRating = (TeamInfo[who]->playerRating * 4.0F + rating * 4.0F) / 8.0F;

	movzx	eax, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	movss	xmm0, DWORD PTR [ecx+604]
	mulss	xmm0, DWORD PTR __real@40800000
	cvtsi2ss xmm1, DWORD PTR _rating$[ebp]
	mulss	xmm1, DWORD PTR __real@40800000
	addss	xmm0, xmm1
	divss	xmm0, DWORD PTR __real@41000000
	movzx	edx, BYTE PTR _who$[ebp]
	mov	eax, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	movss	DWORD PTR [eax+604], xmm0

; 1767 : 	TeamInfo[who]->lastPlayerMission = TheCampaign.CurrentTime;

	movzx	ecx, BYTE PTR _who$[ebp]
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	mov	DWORD PTR [edx+608], eax

; 1768 : 
; 1769 : 	// Shift initiative in our favor, if force ratios allow it.
; 1770 : 	os = 0;

	mov	DWORD PTR _os$[ebp], 0

; 1771 : 	if (TeamInfo[who]->GetCurrentStats())

	movzx	ecx, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?GetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::GetCurrentStats
	test	eax, eax
	je	SHORT $LN21@ApplyPlaye

; 1772 : 		os = TeamInfo[who]->GetCurrentStats()->groundVehs;

	movzx	edx, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?GetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::GetCurrentStats
	movzx	eax, WORD PTR [eax+4]
	mov	DWORD PTR _os$[ebp], eax
$LN21@ApplyPlaye:

; 1773 : 
; 1774 : 	for (i=0,ts=0; i<NUM_TEAMS; i++)

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _ts$[ebp], 0
	jmp	SHORT $LN20@ApplyPlaye
$LN19@ApplyPlaye:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN20@ApplyPlaye:
	cmp	DWORD PTR _i$[ebp], 8
	jge	SHORT $LN18@ApplyPlaye

; 1775 : 	{
; 1776 : 		if (GetTTRelations(i,who) == War)

	movzx	edx, BYTE PTR _who$[ebp]
	push	edx
	movzx	eax, BYTE PTR _i$[ebp]
	push	eax
	call	?GetTTRelations@@YAHEE@Z		; GetTTRelations
	add	esp, 8
	cmp	eax, 5
	jne	SHORT $LN17@ApplyPlaye

; 1777 : 		{
; 1778 : 			ts += TeamInfo[i]->GetCurrentStats()->groundVehs;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?GetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::GetCurrentStats
	movzx	edx, WORD PTR [eax+4]
	add	edx, DWORD PTR _ts$[ebp]
	mov	DWORD PTR _ts$[ebp], edx

; 1779 : 			et = i;

	mov	al, BYTE PTR _i$[ebp]
	mov	BYTE PTR _et$[ebp], al
$LN17@ApplyPlaye:

; 1780 : 		}
; 1781 : 	}

	jmp	SHORT $LN19@ApplyPlaye
$LN18@ApplyPlaye:

; 1782 : 	if (et >= NUM_TEAMS)

	movzx	ecx, BYTE PTR _et$[ebp]
	cmp	ecx, 8
	jl	SHORT $LN16@ApplyPlaye

; 1783 : 		return;

	jmp	$LN24@ApplyPlaye
$LN16@ApplyPlaye:

; 1784 : 	if (os > ts)

	mov	edx, DWORD PTR _os$[ebp]
	cmp	edx, DWORD PTR _ts$[ebp]
	jle	SHORT $LN15@ApplyPlaye

; 1785 : 		maxInitiative = 100;

	mov	DWORD PTR _maxInitiative$[ebp], 100	; 00000064H
	jmp	SHORT $LN12@ApplyPlaye
$LN15@ApplyPlaye:

; 1786 : 	else if (!os)

	cmp	DWORD PTR _os$[ebp], 0
	jne	SHORT $LN13@ApplyPlaye

; 1787 : 		maxInitiative = 0;

	mov	DWORD PTR _maxInitiative$[ebp], 0

; 1788 : 	else

	jmp	SHORT $LN12@ApplyPlaye
$LN13@ApplyPlaye:

; 1789 : 		maxInitiative = (os*100)/ts;

	mov	eax, DWORD PTR _os$[ebp]
	imul	eax, 100				; 00000064H
	cdq
	idiv	DWORD PTR _ts$[ebp]
	mov	DWORD PTR _maxInitiative$[ebp], eax
$LN12@ApplyPlaye:

; 1790 : 
; 1791 : 	// A.S. 2001-12-09 begin, 
; 1792 : 	if (NewInitiativePoints)		// The above constraint, maxInitiative = (os*100)/ts, is no longer needed.

	cmp	DWORD PTR ?NewInitiativePoints@@3HA, 0	; NewInitiativePoints
	je	SHORT $LN11@ApplyPlaye

; 1793 : 		maxInitiative = 100;		// The new procedure NewInitiativePointSetting does the job.

	mov	DWORD PTR _maxInitiative$[ebp], 100	; 00000064H
$LN11@ApplyPlaye:

; 1794 : 	// end added section
; 1795 : 
; 1796 : 	initiative = TeamInfo[who]->GetInitiative();

	movzx	eax, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	call	?GetInitiative@TeamClass@@QAEFXZ	; TeamClass::GetInitiative
	movsx	ecx, ax
	mov	DWORD PTR _initiative$[ebp], ecx

; 1797 : 	initDelta = rating/4;

	mov	eax, DWORD PTR _rating$[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR _initDelta$[ebp], eax

; 1798 : 	if (initiative + initDelta > maxInitiative)

	mov	edx, DWORD PTR _initiative$[ebp]
	add	edx, DWORD PTR _initDelta$[ebp]
	cmp	edx, DWORD PTR _maxInitiative$[ebp]
	jle	SHORT $LN10@ApplyPlaye

; 1799 : 		initDelta = maxInitiative - initiative;

	mov	eax, DWORD PTR _maxInitiative$[ebp]
	sub	eax, DWORD PTR _initiative$[ebp]
	mov	DWORD PTR _initDelta$[ebp], eax
$LN10@ApplyPlaye:

; 1800 : 	if (initiative + initDelta < 0)

	mov	ecx, DWORD PTR _initiative$[ebp]
	add	ecx, DWORD PTR _initDelta$[ebp]
	jns	SHORT $LN9@ApplyPlaye

; 1801 : 		initDelta = 0 - initiative;

	xor	edx, edx
	sub	edx, DWORD PTR _initiative$[ebp]
	mov	DWORD PTR _initDelta$[ebp], edx
$LN9@ApplyPlaye:

; 1802 : 	TransferInitiative(et,who,initDelta);

	mov	eax, DWORD PTR _initDelta$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _who$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _et$[ebp]
	push	edx
	call	?TransferInitiative@@YAXEEH@Z		; TransferInitiative
	add	esp, 12					; 0000000cH

; 1803 : 
; 1804 : 	// Shift reinforcement schedule
; 1805 : 	if (rating > 15)

	cmp	DWORD PTR _rating$[ebp], 15		; 0000000fH
	jle	SHORT $LN8@ApplyPlaye

; 1806 : 		TeamInfo[who]->AddReinforcement(1);

	push	1
	movzx	eax, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	call	?AddReinforcement@TeamClass@@QAEXF@Z	; TeamClass::AddReinforcement
$LN8@ApplyPlaye:

; 1807 : 	if (rating > 5)

	cmp	DWORD PTR _rating$[ebp], 5
	jle	SHORT $LN7@ApplyPlaye

; 1808 : 		TeamInfo[et]->AddReinforcement(-1);

	push	-1
	movzx	ecx, BYTE PTR _et$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?AddReinforcement@TeamClass@@QAEXF@Z	; TeamClass::AddReinforcement
$LN7@ApplyPlaye:

; 1809 : 	if (rating < -5)

	cmp	DWORD PTR _rating$[ebp], -5		; fffffffbH
	jge	SHORT $LN6@ApplyPlaye

; 1810 : 		TeamInfo[who]->AddReinforcement(-1);

	push	-1
	movzx	edx, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?AddReinforcement@TeamClass@@QAEXF@Z	; TeamClass::AddReinforcement
$LN6@ApplyPlaye:

; 1811 : 	if (rating < -15)

	cmp	DWORD PTR _rating$[ebp], -15		; fffffff1H
	jge	SHORT $LN5@ApplyPlaye

; 1812 : 		TeamInfo[et]->AddReinforcement(1);

	push	1
	movzx	eax, BYTE PTR _et$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	call	?AddReinforcement@TeamClass@@QAEXF@Z	; TeamClass::AddReinforcement
$LN5@ApplyPlaye:

; 1813 : 
; 1814 : 	// A.S. debug
; 1815 : 	//FILE *deb;
; 1816 : 	//deb = fopen("c:\\temp\\deb3.txt", "a");
; 1817 : 	//fprintf(deb, "Team %2d  Init = %3d  Rating = %3.2f  TIME = %d\n\n", who, TeamInfo[who]->GetInitiative(), TeamInfo[who]->playerRating, TheCampaign.CurrentTime/(3600*1000));   
; 1818 : 	//fclose(deb);
; 1819 : 	// debug end
; 1820 : 
; 1821 : 	// Apply a local combat bonus
; 1822 : 	if (rating > 2 || rating < -2)

	cmp	DWORD PTR _rating$[ebp], 2
	jg	SHORT $LN3@ApplyPlaye
	cmp	DWORD PTR _rating$[ebp], -2		; fffffffeH
	jge	SHORT $LN4@ApplyPlaye
$LN3@ApplyPlaye:

; 1823 : 	{
; 1824 : 		ApplyBonus(who,poid,rating);

	mov	ecx, DWORD PTR _rating$[ebp]
	push	ecx
	mov	edx, DWORD PTR _poid$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _poid$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _who$[ebp]
	push	ecx
	call	?ApplyBonus@@YAXEVVU_ID@@H@Z		; ApplyBonus
	add	esp, 16					; 00000010H

; 1825 : 		ApplyBonus(et,poid,-1*rating);

	mov	edx, DWORD PTR _rating$[ebp]
	imul	edx, -1
	push	edx
	mov	eax, DWORD PTR _poid$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _poid$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _et$[ebp]
	push	edx
	call	?ApplyBonus@@YAXEVVU_ID@@H@Z		; ApplyBonus
	add	esp, 16					; 00000010H
$LN4@ApplyPlaye:

; 1826 : 	}
; 1827 : 
; 1828 : 	// Modify our or our enemy's action points
; 1829 : 	pts = TeamInfo[who]->GetGroundAction()->actionPoints + (rating/2);

	movzx	eax, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	call	?GetGroundAction@TeamClass@@QAEPAUTeamGndActionType@@XZ ; TeamClass::GetGroundAction
	movzx	ecx, BYTE PTR [eax+18]
	mov	eax, DWORD PTR _rating$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	ecx, eax
	mov	DWORD PTR _pts$[ebp], ecx

; 1830 : 	if (pts > 0 && pts < 100)

	cmp	DWORD PTR _pts$[ebp], 0
	jle	SHORT $LN2@ApplyPlaye
	cmp	DWORD PTR _pts$[ebp], 100		; 00000064H
	jge	SHORT $LN2@ApplyPlaye

; 1831 : 		TeamInfo[who]->GetGroundAction()->actionPoints = pts;

	movzx	edx, BYTE PTR _who$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?GetGroundAction@TeamClass@@QAEPAUTeamGndActionType@@XZ ; TeamClass::GetGroundAction
	mov	cl, BYTE PTR _pts$[ebp]
	mov	BYTE PTR [eax+18], cl
$LN2@ApplyPlaye:

; 1832 : 	pts = TeamInfo[et]->GetGroundAction()->actionPoints - (rating/2);

	movzx	edx, BYTE PTR _et$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?GetGroundAction@TeamClass@@QAEPAUTeamGndActionType@@XZ ; TeamClass::GetGroundAction
	movzx	ecx, BYTE PTR [eax+18]
	mov	eax, DWORD PTR _rating$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	ecx, eax
	mov	DWORD PTR _pts$[ebp], ecx

; 1833 : 	if (pts > 0 && pts < 100)

	cmp	DWORD PTR _pts$[ebp], 0
	jle	SHORT $LN1@ApplyPlaye
	cmp	DWORD PTR _pts$[ebp], 100		; 00000064H
	jge	SHORT $LN1@ApplyPlaye

; 1834 : 		TeamInfo[et]->GetGroundAction()->actionPoints = pts;

	movzx	edx, BYTE PTR _et$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?GetGroundAction@TeamClass@@QAEPAUTeamGndActionType@@XZ ; TeamClass::GetGroundAction
	mov	cl, BYTE PTR _pts$[ebp]
	mov	BYTE PTR [eax+18], cl
$LN1@ApplyPlaye:
$LN24@ApplyPlaye:

; 1835 : 
; 1836 : 	//	MonoPrint("Applying player input: Rating: %d, Location: %d, i:%d,r:%3.3f\n",rating,poid.num_,TeamInfo[who]->GetInitiative(),TeamInfo[who]->playerRating);
; 1837 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ApplyPlayerInput@@YAXEVVU_ID@@H@Z ENDP			; ApplyPlayerInput
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_mult$ = -16						; size = 4
_currtime$ = -12					; size = 4
_bonus$ = -8						; size = 4
_i$ = -4						; size = 4
_t$ = 8							; size = 1
_poid$ = 12						; size = 8
?CombatBonus@@YAMEVVU_ID@@@Z PROC			; CombatBonus

; 1698 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1699 : 	int				i;
; 1700 : 	CampaignTime	currtime = Camp_GetCurrentTime();

	call	?Camp_GetCurrentTime@@YAKXZ		; Camp_GetCurrentTime
	mov	DWORD PTR _currtime$[ebp], eax

; 1701 : 	float			bonus = 1.0F,mult;

	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _bonus$[ebp], xmm0

; 1702 : 
; 1703 : 	// Area bonuses
; 1704 : 	if (poid != FalconNullId)

	push	OFFSET ?FalconNullId@@3VVU_ID@@A	; FalconNullId
	lea	ecx, DWORD PTR _poid$[ebp]
	call	??9VU_ID@@QBE_NABV0@@Z			; VU_ID::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@CombatBonu

; 1705 : 	{
; 1706 : 		for (i=0; i<MAX_BONUSES; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN5@CombatBonu
$LN4@CombatBonu:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN5@CombatBonu:
	cmp	DWORD PTR _i$[ebp], 20			; 00000014H
	jge	SHORT $LN3@CombatBonu

; 1707 : 		{
; 1708 : 			if (TeamInfo[t]->bonusObjs[i] == poid)

	lea	edx, DWORD PTR _poid$[ebp]
	push	edx
	movzx	eax, BYTE PTR _t$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	mov	edx, DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR [ecx+edx*8+632]
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@CombatBonu

; 1709 : 			{
; 1710 : 				if (TeamInfo[t]->bonusTime[i] > currtime)

	movzx	ecx, BYTE PTR _t$[ebp]
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4+792]
	cmp	ecx, DWORD PTR _currtime$[ebp]
	jbe	SHORT $LN1@CombatBonu

; 1711 : 				{
; 1712 : 					//					MonoPrint("Applying x3 specific bonus at %x.\n",poid.num_);
; 1713 : 					bonus *= 3.0F;			// Tripple combat effects for positive time

	movss	xmm0, DWORD PTR _bonus$[ebp]
	mulss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR _bonus$[ebp], xmm0
$LN1@CombatBonu:

; 1714 : 				}
; 1715 : 			}
; 1716 : 		}

	jmp	SHORT $LN4@CombatBonu
$LN3@CombatBonu:

; 1717 : 	}
; 1718 : 	mult = ((TeamInfo[t]->playerRating+20)/20);

	movzx	edx, BYTE PTR _t$[ebp]
	mov	eax, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	movss	xmm0, DWORD PTR [eax+604]
	addss	xmm0, DWORD PTR __real@41a00000
	divss	xmm0, DWORD PTR __real@41a00000
	movss	DWORD PTR _mult$[ebp], xmm0

; 1719 : 	//	MonoPrint("Applying team %d %3.3f multiplier at %x.\n",t,mult,poid.num_);
; 1720 : 	bonus = bonus * mult;

	movss	xmm0, DWORD PTR _bonus$[ebp]
	mulss	xmm0, DWORD PTR _mult$[ebp]
	movss	DWORD PTR _bonus$[ebp], xmm0

; 1721 : 	return bonus;

	fld	DWORD PTR _bonus$[ebp]

; 1722 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CombatBonus@@YAMEVVU_ID@@@Z ENDP			; CombatBonus
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
tv74 = -4						; size = 4
_t$ = 8							; size = 1
?NavalExperienceAdjustment@@YAME@Z PROC			; NavalExperienceAdjustment

; 1693 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1694 : 	return (float)(TeamInfo[t]->navalExperience/100.0F);

	movzx	eax, BYTE PTR _t$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	movzx	edx, BYTE PTR [ecx+615]
	cvtsi2ss xmm0, edx
	divss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR tv74[ebp], xmm0
	fld	DWORD PTR tv74[ebp]

; 1695 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?NavalExperienceAdjustment@@YAME@Z ENDP			; NavalExperienceAdjustment
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
tv74 = -4						; size = 4
_t$ = 8							; size = 1
?GroundExperienceAdjustment@@YAME@Z PROC		; GroundExperienceAdjustment

; 1688 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1689 : 	return (float)(TeamInfo[t]->groundExperience/100.0F);

	movzx	eax, BYTE PTR _t$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	movzx	edx, BYTE PTR [ecx+614]
	cvtsi2ss xmm0, edx
	divss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR tv74[ebp], xmm0
	fld	DWORD PTR tv74[ebp]

; 1690 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GroundExperienceAdjustment@@YAME@Z ENDP		; GroundExperienceAdjustment
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
tv74 = -4						; size = 4
_t$ = 8							; size = 1
?AirDefenseExperienceAdjustment@@YAME@Z PROC		; AirDefenseExperienceAdjustment

; 1683 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1684 : 	return (float)(TeamInfo[t]->airDefenseExperience/100.0F);

	movzx	eax, BYTE PTR _t$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	movzx	edx, BYTE PTR [ecx+613]
	cvtsi2ss xmm0, edx
	divss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR tv74[ebp], xmm0
	fld	DWORD PTR tv74[ebp]

; 1685 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AirDefenseExperienceAdjustment@@YAME@Z ENDP		; AirDefenseExperienceAdjustment
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
tv74 = -4						; size = 4
_t$ = 8							; size = 1
?AirExperienceAdjustment@@YAME@Z PROC			; AirExperienceAdjustment

; 1678 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1679 : 	return (float)(TeamInfo[t]->airExperience/100.0F);

	movzx	eax, BYTE PTR _t$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	movzx	edx, BYTE PTR [ecx+612]
	cvtsi2ss xmm0, edx
	divss	xmm0, DWORD PTR __real@42c80000
	movss	DWORD PTR tv74[ebp], xmm0
	fld	DWORD PTR tv74[ebp]

; 1680 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AirExperienceAdjustment@@YAME@Z ENDP			; AirExperienceAdjustment
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_from$ = 8						; size = 1
_to$ = 12						; size = 1
_i$ = 16						; size = 4
?TransferInitiative@@YAXEEH@Z PROC			; TransferInitiative

; 1628 : {

	push	ebp
	mov	ebp, esp

; 1629 : 	if ((TeamInfo[to]) && (TeamInfo[from]))

	movzx	eax, BYTE PTR _to$[ebp]
	cmp	DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4], 0
	je	SHORT $LN2@TransferIn
	movzx	ecx, BYTE PTR _from$[ebp]
	cmp	DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4], 0
	je	SHORT $LN2@TransferIn

; 1630 : 	{
; 1631 : 		//		MonoPrint ("Transfering %d initiative from %d to %d.\n",i,from,to);
; 1632 : 		TeamInfo[to]->AddInitiative (i);

	movzx	edx, WORD PTR _i$[ebp]
	push	edx
	movzx	eax, BYTE PTR _to$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	call	?AddInitiative@TeamClass@@QAEXF@Z	; TeamClass::AddInitiative

; 1633 : 		TeamInfo[from]->AddInitiative (-i);

	mov	ecx, DWORD PTR _i$[ebp]
	neg	ecx
	push	ecx
	movzx	edx, BYTE PTR _from$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	call	?AddInitiative@TeamClass@@QAEXF@Z	; TeamClass::AddInitiative
$LN2@TransferIn:

; 1634 : 	}
; 1635 : }

	pop	ebp
	ret	0
?TransferInitiative@@YAXEEH@Z ENDP			; TransferInitiative
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_a$ = 8							; size = 1
_b$ = 12						; size = 1
_type$ = 16						; size = 4
?GetRoE@@YAHEEH@Z PROC					; GetRoE

; 1614 : {

	push	ebp
	mov	ebp, esp

; 1615 :     //Pu239
; 1616 : 	//ShiAssert (TeamInfo[a]);
; 1617 : 	if (TeamInfo[a])

	movzx	eax, BYTE PTR _a$[ebp]
	cmp	DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4], 0
	je	SHORT $LN2@GetRoE

; 1618 : 	{
; 1619 : 		return RoEData[type][TeamInfo[a]->stance[b]];

	mov	ecx, DWORD PTR _type$[ebp]
	imul	ecx, 6
	movzx	edx, BYTE PTR _a$[ebp]
	mov	eax, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	movzx	edx, BYTE PTR _b$[ebp]
	movsx	eax, WORD PTR [eax+edx*2+580]
	movzx	eax, BYTE PTR ?RoEData@@3PAY05EA[ecx+eax]
	jmp	SHORT $LN3@GetRoE

; 1620 : 	}
; 1621 : 	else

	jmp	SHORT $LN3@GetRoE
$LN2@GetRoE:

; 1622 : 	{
; 1623 : 		return ROE_ALLOWED;

	mov	eax, 1
$LN3@GetRoE:

; 1624 : 	}
; 1625 : }

	pop	ebp
	ret	0
?GetRoE@@YAHEEH@Z ENDP					; GetRoE
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
tv76 = -16						; size = 4
_t$ = -12						; size = 4
_n$ = -8						; size = 4
_fp$ = -4						; size = 4
?LoadPriorityTables@@YAXXZ PROC				; LoadPriorityTables

; 1560 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1561 : 	FILE		*fp;
; 1562 : 	int			n,t;
; 1563 : 
; 1564 : 	memset(DefaultObjtypePriority,0,TAT_CAS*MAX_TGTTYPE);

	push	180					; 000000b4H
	push	0
	push	OFFSET ?DefaultObjtypePriority@@3PAY0CE@EA ; DefaultObjtypePriority
	call	_memset
	add	esp, 12					; 0000000cH

; 1565 : 	memset(DefaultUnittypePriority,0,TAT_CAS*MAX_UNITTYPE);

	push	100					; 00000064H
	push	0
	push	OFFSET ?DefaultUnittypePriority@@3PAY0BE@EA ; DefaultUnittypePriority
	call	_memset
	add	esp, 12					; 0000000cH

; 1566 : 	memset(DefaultMissionPriority,0,TAT_CAS*AMIS_OTHER);

	push	205					; 000000cdH
	push	0
	push	OFFSET ?DefaultMissionPriority@@3PAY0CJ@EA ; DefaultMissionPriority
	call	_memset
	add	esp, 12					; 0000000cH

; 1567 : 
; 1568 : 	for (t=0; t<TAT_CAS; t++)

	mov	DWORD PTR _t$[ebp], 0
	jmp	SHORT $LN16@LoadPriori
$LN15@LoadPriori:
	mov	eax, DWORD PTR _t$[ebp]
	add	eax, 1
	mov	DWORD PTR _t$[ebp], eax
$LN16@LoadPriori:
	cmp	DWORD PTR _t$[ebp], 5
	jge	$LN17@LoadPriori

; 1569 : 	{
; 1570 : 		switch (t+1)

	mov	ecx, DWORD PTR _t$[ebp]
	add	ecx, 1
	mov	DWORD PTR tv76[ebp], ecx
	mov	edx, DWORD PTR tv76[ebp]
	sub	edx, 1
	mov	DWORD PTR tv76[ebp], edx
	cmp	DWORD PTR tv76[ebp], 4
	ja	SHORT $LN7@LoadPriori
	mov	eax, DWORD PTR tv76[ebp]
	jmp	DWORD PTR $LN19@LoadPriori[eax*4]
$LN11@LoadPriori:

; 1571 : 		{
; 1572 : 				case TAT_DEFENSIVE:
; 1573 : 						fp = OpenCampFile("defense","pri","r");

	push	OFFSET ??_C@_01KDCPPGHE@r?$AA@
	push	OFFSET ??_C@_03FGMOOMKP@pri?$AA@
	push	OFFSET ??_C@_07NEJDADE@defense?$AA@
	call	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z	; OpenCampFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax

; 1574 : 						break;

	jmp	SHORT $LN12@LoadPriori
$LN10@LoadPriori:

; 1575 : 				case TAT_OFFENSIVE:
; 1576 : 						fp = OpenCampFile("offense","pri","r");

	push	OFFSET ??_C@_01KDCPPGHE@r?$AA@
	push	OFFSET ??_C@_03FGMOOMKP@pri?$AA@
	push	OFFSET ??_C@_07GBMLDGPP@offense?$AA@
	call	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z	; OpenCampFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax

; 1577 : 						break;

	jmp	SHORT $LN12@LoadPriori
$LN9@LoadPriori:

; 1578 : 				case TAT_ATTRITION:
; 1579 : 						fp = OpenCampFile("attrit","pri","r");

	push	OFFSET ??_C@_01KDCPPGHE@r?$AA@
	push	OFFSET ??_C@_03FGMOOMKP@pri?$AA@
	push	OFFSET ??_C@_06BONAEKEC@attrit?$AA@
	call	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z	; OpenCampFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax

; 1580 : 						break;

	jmp	SHORT $LN12@LoadPriori
$LN8@LoadPriori:

; 1581 : 				case TAT_CAS:
; 1582 : 						fp = OpenCampFile("cas","pri","r");

	push	OFFSET ??_C@_01KDCPPGHE@r?$AA@
	push	OFFSET ??_C@_03FGMOOMKP@pri?$AA@
	push	OFFSET ??_C@_03LKCPPDCM@cas?$AA@
	call	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z	; OpenCampFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax

; 1583 : 						break;

	jmp	SHORT $LN12@LoadPriori
$LN7@LoadPriori:

; 1584 : 				default:
; 1585 : 						fp = OpenCampFile("intdict","pri","r");

	push	OFFSET ??_C@_01KDCPPGHE@r?$AA@
	push	OFFSET ??_C@_03FGMOOMKP@pri?$AA@
	push	OFFSET ??_C@_07DFBNEDOG@intdict?$AA@
	call	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z	; OpenCampFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax
$LN12@LoadPriori:

; 1586 : 						break;
; 1587 : 		}
; 1588 : 
; 1589 : 		ShiAssert(fp);
; 1590 : 		n = atoi(CampGetNext(fp));		// # of objective target priorities

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	?CampGetNext@@YAPADPAU_iobuf@@@Z	; CampGetNext
	add	esp, 4
	push	eax
	call	_atoi
	add	esp, 4
	mov	DWORD PTR _n$[ebp], eax
$LN6@LoadPriori:

; 1591 : 		while (n >= 0)

	cmp	DWORD PTR _n$[ebp], 0
	jl	SHORT $LN5@LoadPriori

; 1592 : 		{
; 1593 : 			DefaultObjtypePriority[t][n] = atoi(CampGetNext(fp));

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	?CampGetNext@@YAPADPAU_iobuf@@@Z	; CampGetNext
	add	esp, 4
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _t$[ebp]
	imul	ecx, 36					; 00000024H
	mov	edx, DWORD PTR _n$[ebp]
	mov	BYTE PTR ?DefaultObjtypePriority@@3PAY0CE@EA[ecx+edx], al

; 1594 : 			n = atoi(CampGetNext(fp));

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	?CampGetNext@@YAPADPAU_iobuf@@@Z	; CampGetNext
	add	esp, 4
	push	eax
	call	_atoi
	add	esp, 4
	mov	DWORD PTR _n$[ebp], eax

; 1595 : 		}

	jmp	SHORT $LN6@LoadPriori
$LN5@LoadPriori:

; 1596 : 		n = atoi(CampGetNext(fp));		// # of unit target priorities

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	?CampGetNext@@YAPADPAU_iobuf@@@Z	; CampGetNext
	add	esp, 4
	push	eax
	call	_atoi
	add	esp, 4
	mov	DWORD PTR _n$[ebp], eax
$LN4@LoadPriori:

; 1597 : 		while (n >= 0)

	cmp	DWORD PTR _n$[ebp], 0
	jl	SHORT $LN3@LoadPriori

; 1598 : 		{
; 1599 : 			DefaultUnittypePriority[t][n] = atoi(CampGetNext(fp));

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	?CampGetNext@@YAPADPAU_iobuf@@@Z	; CampGetNext
	add	esp, 4
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _t$[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _n$[ebp]
	mov	BYTE PTR ?DefaultUnittypePriority@@3PAY0BE@EA[ecx+edx], al

; 1600 : 			n = atoi(CampGetNext(fp));

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	?CampGetNext@@YAPADPAU_iobuf@@@Z	; CampGetNext
	add	esp, 4
	push	eax
	call	_atoi
	add	esp, 4
	mov	DWORD PTR _n$[ebp], eax

; 1601 : 		}

	jmp	SHORT $LN4@LoadPriori
$LN3@LoadPriori:

; 1602 : 		n = atoi(CampGetNext(fp));		// # of mission priorities

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	?CampGetNext@@YAPADPAU_iobuf@@@Z	; CampGetNext
	add	esp, 4
	push	eax
	call	_atoi
	add	esp, 4
	mov	DWORD PTR _n$[ebp], eax
$LN2@LoadPriori:

; 1603 : 		while (n >= 0)

	cmp	DWORD PTR _n$[ebp], 0
	jl	SHORT $LN1@LoadPriori

; 1604 : 		{
; 1605 : 			DefaultMissionPriority[t][n] = atoi(CampGetNext(fp));

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	?CampGetNext@@YAPADPAU_iobuf@@@Z	; CampGetNext
	add	esp, 4
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _t$[ebp]
	imul	ecx, 41					; 00000029H
	mov	edx, DWORD PTR _n$[ebp]
	mov	BYTE PTR ?DefaultMissionPriority@@3PAY0CJ@EA[ecx+edx], al

; 1606 : 			n = atoi(CampGetNext(fp));

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	?CampGetNext@@YAPADPAU_iobuf@@@Z	; CampGetNext
	add	esp, 4
	push	eax
	call	_atoi
	add	esp, 4
	mov	DWORD PTR _n$[ebp], eax

; 1607 : 		}

	jmp	SHORT $LN2@LoadPriori
$LN1@LoadPriori:

; 1608 : 		CloseCampFile(fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	?CloseCampFile@@YAXPAU_iobuf@@@Z	; CloseCampFile
	add	esp, 4

; 1609 : 	}

	jmp	$LN15@LoadPriori
$LN17@LoadPriori:

; 1610 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN19@LoadPriori:
	DD	$LN11@LoadPriori
	DD	$LN10@LoadPriori
	DD	$LN7@LoadPriori
	DD	$LN9@LoadPriori
	DD	$LN8@LoadPriori
?LoadPriorityTables@@YAXXZ ENDP				; LoadPriorityTables
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_fp$ = -12						; size = 4
_i$ = -8						; size = 4
_teams$ = -4						; size = 2
_scenario$ = 8						; size = 4
?SaveTeams@@YAHPAD@Z PROC				; SaveTeams

; 1532 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1533 : 	FILE		*fp;
; 1534 : 	int			i;
; 1535 : 	short		teams = 0;

	xor	eax, eax
	mov	WORD PTR _teams$[ebp], ax

; 1536 : 
; 1537 : 	if ((fp = OpenCampFile (scenario, "tea", "wb")) == NULL){

	push	OFFSET ??_C@_02GMLFBBN@wb?$AA@
	push	OFFSET ??_C@_03IBMEEAF@tea?$AA@
	mov	ecx, DWORD PTR _scenario$[ebp]
	push	ecx
	call	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z	; OpenCampFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax
	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN7@SaveTeams

; 1538 : 		return 0;

	xor	eax, eax
	jmp	$LN8@SaveTeams
$LN7@SaveTeams:

; 1539 : 	}
; 1540 : 	i = 0;

	mov	DWORD PTR _i$[ebp], 0
$LN6@SaveTeams:

; 1541 : 	while (i < NUM_TEAMS){

	cmp	DWORD PTR _i$[ebp], 8
	jge	SHORT $LN5@SaveTeams

; 1542 : 		if (TeamInfo[i] && TeamInfo[i]->VuState() == VU_MEM_ACTIVE){

	mov	edx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4], 0
	je	SHORT $LN4@SaveTeams
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	call	?VuState@VuEntity@@QBE?AW4VU_MEM@@XZ	; VuEntity::VuState
	cmp	eax, 3
	jne	SHORT $LN4@SaveTeams

; 1543 : 			teams++;

	mov	cx, WORD PTR _teams$[ebp]
	add	cx, 1
	mov	WORD PTR _teams$[ebp], cx
$LN4@SaveTeams:

; 1544 : 		}
; 1545 : 		i++;

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx

; 1546 : 	}

	jmp	SHORT $LN6@SaveTeams
$LN5@SaveTeams:

; 1547 : 	fwrite(&teams, sizeof(short), 1, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	2
	lea	ecx, DWORD PTR _teams$[ebp]
	push	ecx
	call	_fwrite
	add	esp, 16					; 00000010H

; 1548 : 	i = 0;

	mov	DWORD PTR _i$[ebp], 0
$LN3@SaveTeams:

; 1549 : 	while (i < NUM_TEAMS){

	cmp	DWORD PTR _i$[ebp], 8
	jge	SHORT $LN2@SaveTeams

; 1550 : 		if (TeamInfo[i] && TeamInfo[i]->VuState() == VU_MEM_ACTIVE){

	mov	edx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4], 0
	je	SHORT $LN1@SaveTeams
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	call	?VuState@VuEntity@@QBE?AW4VU_MEM@@XZ	; VuEntity::VuState
	cmp	eax, 3
	jne	SHORT $LN1@SaveTeams

; 1551 : 			TeamInfo[i]->Save(fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	eax, DWORD PTR [edx+32]
	call	eax
$LN1@SaveTeams:

; 1552 : 		}
; 1553 : 		i++;

	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx

; 1554 : 	}

	jmp	SHORT $LN3@SaveTeams
$LN2@SaveTeams:

; 1555 : 	CloseCampFile(fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	?CloseCampFile@@YAXPAU_iobuf@@@Z	; CloseCampFile
	add	esp, 4

; 1556 : 	return 1;

	mov	eax, 1
$LN8@SaveTeams:

; 1557 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SaveTeams@@YAHPAD@Z ENDP				; SaveTeams
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
$T2 = -88						; size = 4
$T3 = -84						; size = 4
$T4 = -80						; size = 4
_temp$ = -76						; size = 4
$T5 = -72						; size = 4
_ntm$ = -68						; size = 4
tv185 = -64						; size = 4
$T6 = -60						; size = 4
_gtm$ = -56						; size = 4
tv166 = -52						; size = 4
$T7 = -48						; size = 4
_atm$ = -44						; size = 4
tv147 = -40						; size = 4
$T8 = -36						; size = 4
tv133 = -32						; size = 4
$T9 = -28						; size = 4
_i$ = -24						; size = 4
_fp$ = -20						; size = 4
_teams$ = -16						; size = 2
__$EHRec$ = -12						; size = 12
_scenario$ = 8						; size = 4
?LoadTeams@@YAHPAD@Z PROC				; LoadTeams

; 1485 : int LoadTeams (char* scenario){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LoadTeams@@YAHPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1486 : 	int			i;
; 1487 : 	short		teams;
; 1488 : 	FILE		*fp;
; 1489 : 	TeamClass	*temp;
; 1490 : 	AirTaskingManagerClass		*atm;
; 1491 : 	GroundTaskingManagerClass	*gtm;
; 1492 : 	NavalTaskingManagerClass	*ntm;
; 1493 : 
; 1494 : 	RemoveTeams();

	call	?RemoveTeams@@YAXXZ			; RemoveTeams

; 1495 : 
; 1496 : 	// Set up the DIndex for our team manager class
; 1497 : 	teamManagerDIndex = GetClassID(DOMAIN_ABSTRACT,CLASS_MANAGER,TYPE_TEAM,0,0,0,0,0);

	push	0
	push	0
	push	0
	push	0
	push	0
	push	1
	push	3
	push	1
	call	?GetClassID@@YAHEEEEEEEE@Z		; GetClassID
	add	esp, 32					; 00000020H
	mov	WORD PTR ?teamManagerDIndex@@3FA, ax	; teamManagerDIndex

; 1498 : 	if (!teamManagerDIndex)

	movsx	eax, WORD PTR ?teamManagerDIndex@@3FA	; teamManagerDIndex
	test	eax, eax
	jne	SHORT $LN6@LoadTeams

; 1499 : 		return 0;

	xor	eax, eax
	jmp	$LN7@LoadTeams
$LN6@LoadTeams:

; 1500 : 	teamManagerDIndex += VU_LAST_ENTITY_TYPE;

	movsx	ecx, WORD PTR ?teamManagerDIndex@@3FA	; teamManagerDIndex
	add	ecx, 100				; 00000064H
	mov	WORD PTR ?teamManagerDIndex@@3FA, cx	; teamManagerDIndex

; 1501 : 
; 1502 : 	if ((fp = OpenCampFile (scenario, "tea", "rb")) == NULL)

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	push	OFFSET ??_C@_03IBMEEAF@tea?$AA@
	mov	edx, DWORD PTR _scenario$[ebp]
	push	edx
	call	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z	; OpenCampFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax
	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN5@LoadTeams

; 1503 : 		return 0;

	xor	eax, eax
	jmp	$LN7@LoadTeams
$LN5@LoadTeams:

; 1504 : 	fread(&teams, sizeof(short), 1, fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	push	2
	lea	ecx, DWORD PTR _teams$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 1505 : 	if (teams > NUM_TEAMS)

	movsx	edx, WORD PTR _teams$[ebp]
	cmp	edx, 8
	jle	SHORT $LN4@LoadTeams

; 1506 : 		teams = NUM_TEAMS;

	mov	eax, 8
	mov	WORD PTR _teams$[ebp], ax
$LN4@LoadTeams:

; 1507 : 	for (i=0; i<teams; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@LoadTeams
$LN2@LoadTeams:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@LoadTeams:
	movsx	edx, WORD PTR _teams$[ebp]
	cmp	DWORD PTR _i$[ebp], edx
	jge	$LN1@LoadTeams

; 1508 : 	{
; 1509 : 		temp = new TeamClass(fp);

	push	904					; 00000388H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T9[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T9[ebp], 0
	je	SHORT $LN9@LoadTeams
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T9[ebp]
	call	??0TeamClass@@QAE@PAU_iobuf@@@Z		; TeamClass::TeamClass
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN10@LoadTeams
$LN9@LoadTeams:
	mov	DWORD PTR tv133[ebp], 0
$LN10@LoadTeams:
	mov	ecx, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T5[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T5[ebp]
	mov	DWORD PTR _temp$[ebp], edx

; 1510 : 		vuDatabase->/*Silent*/Insert(temp);

	mov	eax, DWORD PTR _temp$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Insert@VuDatabase@@QAEHPAVVuEntity@@@Z	; VuDatabase::Insert

; 1511 : 		atm = new AirTaskingManagerClass (fp);

	push	208					; 000000d0H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T8[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T8[ebp], 0
	je	SHORT $LN11@LoadTeams
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T8[ebp]
	call	??0AirTaskingManagerClass@@QAE@PAU_iobuf@@@Z ; AirTaskingManagerClass::AirTaskingManagerClass
	mov	DWORD PTR tv147[ebp], eax
	jmp	SHORT $LN12@LoadTeams
$LN11@LoadTeams:
	mov	DWORD PTR tv147[ebp], 0
$LN12@LoadTeams:
	mov	edx, DWORD PTR tv147[ebp]
	mov	DWORD PTR $T4[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR _atm$[ebp], eax

; 1512 : 		vuDatabase->/*Silent*/Insert(atm);

	mov	ecx, DWORD PTR _atm$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Insert@VuDatabase@@QAEHPAVVuEntity@@@Z	; VuDatabase::Insert

; 1513 : 		VuReferenceEntity(atm);

	mov	edx, DWORD PTR _atm$[ebp]
	push	edx
	call	?VuReferenceEntity@@YAHPAVVuEntity@@@Z	; VuReferenceEntity
	add	esp, 4

; 1514 : 		gtm = new GroundTaskingManagerClass (fp);

	push	252					; 000000fcH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T7[ebp], 0
	je	SHORT $LN13@LoadTeams
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T7[ebp]
	call	??0GroundTaskingManagerClass@@QAE@PAU_iobuf@@@Z ; GroundTaskingManagerClass::GroundTaskingManagerClass
	mov	DWORD PTR tv166[ebp], eax
	jmp	SHORT $LN14@LoadTeams
$LN13@LoadTeams:
	mov	DWORD PTR tv166[ebp], 0
$LN14@LoadTeams:
	mov	ecx, DWORD PTR tv166[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR _gtm$[ebp], edx

; 1515 : 		vuDatabase->/*Silent*/Insert(gtm);

	mov	eax, DWORD PTR _gtm$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Insert@VuDatabase@@QAEHPAVVuEntity@@@Z	; VuDatabase::Insert

; 1516 : 		VuReferenceEntity(gtm);

	mov	ecx, DWORD PTR _gtm$[ebp]
	push	ecx
	call	?VuReferenceEntity@@YAHPAVVuEntity@@@Z	; VuReferenceEntity
	add	esp, 4

; 1517 : 		ntm = new NavalTaskingManagerClass (fp);

	push	164					; 000000a4H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	cmp	DWORD PTR $T6[ebp], 0
	je	SHORT $LN15@LoadTeams
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T6[ebp]
	call	??0NavalTaskingManagerClass@@QAE@PAU_iobuf@@@Z ; NavalTaskingManagerClass::NavalTaskingManagerClass
	mov	DWORD PTR tv185[ebp], eax
	jmp	SHORT $LN16@LoadTeams
$LN15@LoadTeams:
	mov	DWORD PTR tv185[ebp], 0
$LN16@LoadTeams:
	mov	eax, DWORD PTR tv185[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _ntm$[ebp], ecx

; 1518 : 		vuDatabase->/*Silent*/Insert(ntm);

	mov	edx, DWORD PTR _ntm$[ebp]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Insert@VuDatabase@@QAEHPAVVuEntity@@@Z	; VuDatabase::Insert

; 1519 : 		VuReferenceEntity(ntm);

	mov	eax, DWORD PTR _ntm$[ebp]
	push	eax
	call	?VuReferenceEntity@@YAHPAVVuEntity@@@Z	; VuReferenceEntity
	add	esp, 4

; 1520 : 	}

	jmp	$LN2@LoadTeams
$LN1@LoadTeams:

; 1521 : 	// Removed to make Tactical Engagement's concept of teams work.
; 1522 : 	// Should make no difference to Campaign. - RH
; 1523 : 
; 1524 : 	// for (; i<NUM_TEAMS; i++)
; 1525 : 	//	AddTeam(i);
; 1526 : 
; 1527 : 	CloseCampFile(fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	?CloseCampFile@@YAXPAU_iobuf@@@Z	; CloseCampFile
	add	esp, 4

; 1528 : 	return 1;

	mov	eax, 1
$LN7@LoadTeams:

; 1529 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?LoadTeams@@YAHPAD@Z$0:
	mov	eax, DWORD PTR $T9[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?LoadTeams@@YAHPAD@Z$1:
	mov	eax, DWORD PTR $T8[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?LoadTeams@@YAHPAD@Z$2:
	mov	eax, DWORD PTR $T7[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?LoadTeams@@YAHPAD@Z$3:
	mov	eax, DWORD PTR $T6[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?LoadTeams@@YAHPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LoadTeams@@YAHPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LoadTeams@@YAHPAD@Z ENDP				; LoadTeams
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_i$ = -4						; size = 4
?RemoveTeams@@YAXXZ PROC				; RemoveTeams

; 1477 : void RemoveTeams(){

	push	ebp
	mov	ebp, esp
	push	ecx

; 1478 : 	int i;
; 1479 : 	for (i=0; i<NUM_TEAMS; i++){

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@RemoveTeam
$LN2@RemoveTeam:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@RemoveTeam:
	cmp	DWORD PTR _i$[ebp], 8
	jge	SHORT $LN4@RemoveTeam

; 1480 : 		RemoveTeam(i);

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	call	?RemoveTeam@@YAXH@Z			; RemoveTeam
	add	esp, 4

; 1481 : 	}

	jmp	SHORT $LN2@RemoveTeam
$LN4@RemoveTeam:

; 1482 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveTeams@@YAXXZ ENDP				; RemoveTeams
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_i$ = -4						; size = 4
_defaultStance$ = 8					; size = 4
?AddNewTeams@@YAXW4RelType@@@Z PROC			; AddNewTeams

; 1456 : void AddNewTeams(RelType defaultStance){

	push	ebp
	mov	ebp, esp
	push	ecx

; 1457 : 	int i;
; 1458 : 	RemoveTeams();

	call	?RemoveTeams@@YAXXZ			; RemoveTeams

; 1459 : 	for (i=0; i<NUM_TEAMS; i++){

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@AddNewTeam
$LN2@AddNewTeam:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@AddNewTeam:
	cmp	DWORD PTR _i$[ebp], 8
	jge	SHORT $LN4@AddNewTeam

; 1460 : 		AddTeam(i,defaultStance);

	mov	ecx, DWORD PTR _defaultStance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	call	?AddTeam@@YAXHH@Z			; AddTeam
	add	esp, 8

; 1461 : 	}

	jmp	SHORT $LN2@AddNewTeam
$LN4@AddNewTeam:

; 1462 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AddNewTeams@@YAXW4RelType@@@Z ENDP			; AddNewTeams
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_teamNum$ = 8						; size = 4
?RemoveTeam@@YAXH@Z PROC				; RemoveTeam

; 1464 : void RemoveTeam(int teamNum){

	push	ebp
	mov	ebp, esp

; 1465 : 	if (TeamInfo[teamNum]){

	mov	eax, DWORD PTR _teamNum$[ebp]
	cmp	DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4], 0
	je	$LN2@RemoveTeam

; 1466 : 		vuDatabase->Remove(TeamInfo[teamNum]->atm);

	mov	ecx, DWORD PTR _teamNum$[ebp]
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	eax, DWORD PTR [edx+876]
	push	eax
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Remove@VuDatabase@@QAEHPAVVuEntity@@@Z	; VuDatabase::Remove

; 1467 : 		VuDeReferenceEntity(TeamInfo[teamNum]->atm);

	mov	ecx, DWORD PTR _teamNum$[ebp]
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	eax, DWORD PTR [edx+876]
	push	eax
	call	?VuDeReferenceEntity@@YAHPAVVuEntity@@@Z ; VuDeReferenceEntity
	add	esp, 4

; 1468 : 		vuDatabase->Remove(TeamInfo[teamNum]->gtm);

	mov	ecx, DWORD PTR _teamNum$[ebp]
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	eax, DWORD PTR [edx+880]
	push	eax
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Remove@VuDatabase@@QAEHPAVVuEntity@@@Z	; VuDatabase::Remove

; 1469 : 		VuDeReferenceEntity(TeamInfo[teamNum]->gtm);

	mov	ecx, DWORD PTR _teamNum$[ebp]
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	eax, DWORD PTR [edx+880]
	push	eax
	call	?VuDeReferenceEntity@@YAHPAVVuEntity@@@Z ; VuDeReferenceEntity
	add	esp, 4

; 1470 : 		vuDatabase->Remove(TeamInfo[teamNum]->ntm);

	mov	ecx, DWORD PTR _teamNum$[ebp]
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	eax, DWORD PTR [edx+884]
	push	eax
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Remove@VuDatabase@@QAEHPAVVuEntity@@@Z	; VuDatabase::Remove

; 1471 : 		VuDeReferenceEntity(TeamInfo[teamNum]->ntm);

	mov	ecx, DWORD PTR _teamNum$[ebp]
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	eax, DWORD PTR [edx+884]
	push	eax
	call	?VuDeReferenceEntity@@YAHPAVVuEntity@@@Z ; VuDeReferenceEntity
	add	esp, 4

; 1472 : 		vuDatabase->Remove(TeamInfo[teamNum]);

	mov	ecx, DWORD PTR _teamNum$[ebp]
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Remove@VuDatabase@@QAEHPAVVuEntity@@@Z	; VuDatabase::Remove
$LN2@RemoveTeam:

; 1473 : 	}
; 1474 : }

	pop	ebp
	ret	0
?RemoveTeam@@YAXH@Z ENDP				; RemoveTeam
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GTeamClass@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GTeamClass@@UAEPAXI@Z PROC				; TeamClass::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1TeamClass@@UAE@XZ			; TeamClass::~TeamClass
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GTeamClass@@UAEPAXI@Z ENDP				; TeamClass::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
$T2 = -260						; size = 12
_this$ = -248						; size = 4
_bits$ = -244						; size = 2
$T3 = -240						; size = 24
_err$4 = -216						; size = 200
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_stream$ = 8						; size = 4
_rem$ = 12						; size = 4
?ReadDirty@TeamClass@@QAEXPAPAEPAJ@Z PROC		; TeamClass::ReadDirty
; _this$ = ecx

; 2843 : void TeamClass::ReadDirty (unsigned char **stream, long *rem){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ReadDirty@TeamClass@@QAEXPAPAEPAJ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 248				; 000000f8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2844 : 
; 2845 : 	ushort bits;
; 2846 : 
; 2847 : 	// Encode it up
; 2848 : 	memcpychk(&bits, stream, sizeof(ushort), rem);

	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	push	2
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	lea	edx, DWORD PTR _bits$[ebp]
	push	edx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 2849 : 
; 2850 : 	if (bits & DIRTY_MISSION_PRIORITY) {

	movzx	eax, WORD PTR _bits$[ebp]
	and	eax, 128				; 00000080H
	je	SHORT $LN13@ReadDirty

; 2851 : 		memcpychk(mission_priority, stream, sizeof (mission_priority), rem);

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	41					; 00000029H
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 226				; 000000e2H
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H
$LN13@ReadDirty:

; 2852 : 	}
; 2853 : 
; 2854 : 	if (bits & DIRTY_UNITTYPE_PRIORITY)	{

	movzx	ecx, WORD PTR _bits$[ebp]
	and	ecx, 64					; 00000040H
	je	SHORT $LN12@ReadDirty

; 2855 : 		memcpychk(unittype_priority, stream, sizeof (unittype_priority), rem);

	mov	edx, DWORD PTR _rem$[ebp]
	push	edx
	push	20					; 00000014H
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 206				; 000000ceH
	push	ecx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H
$LN12@ReadDirty:

; 2856 : 	}
; 2857 : 
; 2858 : 	if (bits & DIRTY_OBJTYPE_PRIORITY){

	movzx	edx, WORD PTR _bits$[ebp]
	and	edx, 32					; 00000020H
	je	SHORT $LN11@ReadDirty

; 2859 : 		memcpychk(objtype_priority, stream, sizeof (objtype_priority), rem);

	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	push	36					; 00000024H
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 170				; 000000aaH
	push	edx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H
$LN11@ReadDirty:

; 2860 : 	}
; 2861 : 
; 2862 : 	if (bits & DIRTY_SUPPLY_FUEL_AVAIL)	{

	movzx	eax, WORD PTR _bits$[ebp]
	and	eax, 4
	je	SHORT $LN10@ReadDirty

; 2863 : 		memcpychk(&supplyAvail, stream, sizeof(ushort), rem);

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 146				; 00000092H
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 2864 : 		memcpychk(&fuelAvail, stream, sizeof(ushort), rem);

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 148				; 00000094H
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 2865 : 		memcpychk(&replacementsAvail, stream, sizeof(ushort), rem);

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 150				; 00000096H
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H
$LN10@ReadDirty:

; 2866 : 	}
; 2867 : 
; 2868 : 	if (bits & DIRTY_TEAM_INITIATIVE) {

	movzx	ecx, WORD PTR _bits$[ebp]
	and	ecx, 1
	je	SHORT $LN9@ReadDirty

; 2869 : 		memcpychk(&initiative, stream, sizeof(short), rem);

	mov	edx, DWORD PTR _rem$[ebp]
	push	edx
	push	2
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 144				; 00000090H
	push	ecx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H
$LN9@ReadDirty:

; 2870 : 	}
; 2871 : 
; 2872 : 	if (bits & DIRTY_TEAM_REINFORCEMENT) {

	movzx	edx, WORD PTR _bits$[ebp]
	and	edx, 2
	je	SHORT $LN8@ReadDirty

; 2873 : 		memcpychk(&reinforcement, stream, sizeof(short), rem);

	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	push	2
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 168				; 000000a8H
	push	edx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H
$LN8@ReadDirty:

; 2874 : 	}
; 2875 : 
; 2876 : 	if (bits & DIRTY_CURRENT_STATS) {

	movzx	eax, WORD PTR _bits$[ebp]
	and	eax, 8
	je	SHORT $LN7@ReadDirty

; 2877 : 		memcpychk(&currentStats, stream, sizeof (currentStats), rem);

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	16					; 00000010H
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 152				; 00000098H
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H
$LN7@ReadDirty:

; 2878 : 	}
; 2879 : 
; 2880 : 	if (bits & DIRTY_GROUND_ACTION) {

	movzx	ecx, WORD PTR _bits$[ebp]
	and	ecx, 16					; 00000010H
	je	SHORT $LN6@ReadDirty

; 2881 : 		memcpychk(&groundAction, stream, sizeof (groundAction), rem);

	mov	edx, DWORD PTR _rem$[ebp]
	push	edx
	push	19					; 00000013H
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 267				; 0000010bH
	push	ecx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H
$LN6@ReadDirty:

; 2882 : 	}
; 2883 : 
; 2884 : 	if (bits & DIRTY_OFFAIR_ACTION) {

	movzx	edx, WORD PTR _bits$[ebp]
	and	edx, 256				; 00000100H
	je	SHORT $LN5@ReadDirty

; 2885 : 		memcpychk(&offensiveAirAction, stream, sizeof (offensiveAirAction), rem);

	mov	eax, DWORD PTR _rem$[ebp]
	push	eax
	push	28					; 0000001cH
	mov	ecx, DWORD PTR _stream$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 316				; 0000013cH
	push	edx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H
$LN5@ReadDirty:

; 2886 : 	}
; 2887 : 
; 2888 : 	if (bits & DIRTY_DEFAIR_ACTION) {

	movzx	eax, WORD PTR _bits$[ebp]
	and	eax, 512				; 00000200H
	je	SHORT $LN4@ReadDirty

; 2889 : 		memcpychk(&defensiveAirAction, stream, sizeof (defensiveAirAction), rem);

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	28					; 0000001cH
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 288				; 00000120H
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H
$LN4@ReadDirty:

; 2890 : 	}
; 2891 : 
; 2892 : 	if (bits & DIRTY_TEAM_RELATIONS) {

	movzx	ecx, WORD PTR _bits$[ebp]
	and	ecx, 1024				; 00000400H
	je	$LN15@ReadDirty

; 2893 : 		memcpychk(&cteam, stream, sizeof (uchar), rem);

	mov	edx, DWORD PTR _rem$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 349				; 0000015dH
	push	ecx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 2894 : 		if (!((cteam > 0) && (cteam < NUM_TEAMS))){

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+349]
	test	eax, eax
	jle	SHORT $LN1@ReadDirty
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+349]
	cmp	edx, 8
	jl	SHORT $LN2@ReadDirty
$LN1@ReadDirty:

; 2895 : 			char err[200];
; 2896 : 			sprintf(err, "%s %d: error reading dirty, invalid cteam", __FILE__, __LINE__);

	push	2896					; 00000b50H
	push	OFFSET ??_C@_08BLEENGAP@Team?4cpp?$AA@
	push	OFFSET ??_C@_0CK@FGAGGLML@?$CFs?5?$CFd?3?5error?5reading?5dirty?0?5inva@
	lea	eax, DWORD PTR _err$4[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 2897 : 			throw InvalidBufferException(err);

	lea	ecx, DWORD PTR _err$4[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0InvalidBufferException@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; InvalidBufferException::InvalidBufferException
	push	OFFSET __TI4?AVInvalidBufferException@@
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN2@ReadDirty:

; 2898 : 		}
; 2899 : 		memcpychk(member, stream, sizeof (uchar) * NUM_COUNS, rem);

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	8
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 572				; 0000023cH
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 2900 : 		memcpychk(stance, stream, sizeof (short) * NUM_TEAMS, rem);

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	16					; 00000010H
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 580				; 00000244H
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 2901 : 		TheCampaign.MakeCampMap(MAP_OWNERSHIP);

	push	1
	mov	ecx, OFFSET ?TheCampaign@@3VCampaignClass@@A ; TheCampaign
	call	?MakeCampMap@CampaignClass@@QAEPAEH@Z	; CampaignClass::MakeCampMap

; 2902 : 		PostMessage(FalconDisplay.appWin,FM_REFRESH_CAMPMAP,0,0);

	push	0
	push	0
	push	1067					; 0000042bH
	mov	ecx, DWORD PTR ?FalconDisplay@@3VFalconDisplayConfiguration@@A+108
	push	ecx
	call	DWORD PTR __imp__PostMessageA@16
$LN15@ReadDirty:

; 2903 : 	}
; 2904 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ReadDirty@TeamClass@@QAEXPAPAEPAJ@Z$0:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?ReadDirty@TeamClass@@QAEXPAPAEPAJ@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-252]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ReadDirty@TeamClass@@QAEXPAPAEPAJ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ReadDirty@TeamClass@@QAEXPAPAEPAJ@Z ENDP		; TeamClass::ReadDirty
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_ptr$ = -4						; size = 4
_stream$ = 8						; size = 4
?WriteDirty@TeamClass@@QAEXPAPAE@Z PROC			; TeamClass::WriteDirty
; _this$ = ecx

; 2766 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2767 : 	unsigned char *ptr;
; 2768 : 
; 2769 : 	ptr = *stream;

	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _ptr$[ebp], ecx

; 2770 : 	// Encode it up
; 2771 : 	*(ushort*)ptr = (ushort) dirty_team;

	mov	edx, DWORD PTR _ptr$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+344]
	mov	WORD PTR [edx], cx

; 2772 : 	ptr += sizeof (ushort);

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, 2
	mov	DWORD PTR _ptr$[ebp], edx

; 2773 : 	if (dirty_team & DIRTY_MISSION_PRIORITY){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+344]
	and	ecx, 128				; 00000080H
	je	SHORT $LN11@WriteDirty

; 2774 : 		memcpy (ptr, mission_priority, sizeof (mission_priority));

	push	41					; 00000029H
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 226				; 000000e2H
	push	edx
	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2775 : 		ptr += sizeof (mission_priority);

	mov	ecx, DWORD PTR _ptr$[ebp]
	add	ecx, 41					; 00000029H
	mov	DWORD PTR _ptr$[ebp], ecx
$LN11@WriteDirty:

; 2776 : 	}
; 2777 : 
; 2778 : 	if (dirty_team & DIRTY_UNITTYPE_PRIORITY){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+344]
	and	eax, 64					; 00000040H
	je	SHORT $LN10@WriteDirty

; 2779 : 		memcpy (ptr, unittype_priority, sizeof (unittype_priority));

	push	20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 206				; 000000ceH
	push	ecx
	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2780 : 		ptr += sizeof (unittype_priority);

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR _ptr$[ebp], eax
$LN10@WriteDirty:

; 2781 : 	}
; 2782 : 
; 2783 : 	if (dirty_team & DIRTY_OBJTYPE_PRIORITY){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+344]
	and	edx, 32					; 00000020H
	je	SHORT $LN9@WriteDirty

; 2784 : 		memcpy (ptr, objtype_priority, sizeof (objtype_priority));

	push	36					; 00000024H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 170				; 000000aaH
	push	eax
	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2785 : 		ptr += sizeof (objtype_priority);

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, 36					; 00000024H
	mov	DWORD PTR _ptr$[ebp], edx
$LN9@WriteDirty:

; 2786 : 	}
; 2787 : 
; 2788 : 	if (dirty_team & DIRTY_SUPPLY_FUEL_AVAIL){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+344]
	and	ecx, 4
	je	SHORT $LN8@WriteDirty

; 2789 : 		*(ushort*)ptr = supplyAvail;

	mov	edx, DWORD PTR _ptr$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+146]
	mov	WORD PTR [edx], cx

; 2790 : 		ptr += sizeof (ushort);

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, 2
	mov	DWORD PTR _ptr$[ebp], edx

; 2791 : 
; 2792 : 		*(ushort*)ptr = fuelAvail;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+148]
	mov	WORD PTR [eax], dx

; 2793 : 		ptr += sizeof (ushort);

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 2
	mov	DWORD PTR _ptr$[ebp], eax

; 2794 : 
; 2795 : 		*(ushort*)ptr = replacementsAvail;

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+150]
	mov	WORD PTR [ecx], ax

; 2796 : 		ptr += sizeof (ushort);

	mov	ecx, DWORD PTR _ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _ptr$[ebp], ecx
$LN8@WriteDirty:

; 2797 : 	}
; 2798 : 
; 2799 : 	if (dirty_team & DIRTY_TEAM_INITIATIVE){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+344]
	and	eax, 1
	je	SHORT $LN7@WriteDirty

; 2800 : 		*(short*)ptr = initiative;

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+144]
	mov	WORD PTR [ecx], ax

; 2801 : 		ptr += sizeof (short);

	mov	ecx, DWORD PTR _ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _ptr$[ebp], ecx
$LN7@WriteDirty:

; 2802 : 	}
; 2803 : 
; 2804 : 	if (dirty_team & DIRTY_TEAM_REINFORCEMENT){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+344]
	and	eax, 2
	je	SHORT $LN6@WriteDirty

; 2805 : 		*(short*)ptr = reinforcement;

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+168]
	mov	WORD PTR [ecx], ax

; 2806 : 		ptr += sizeof (short);

	mov	ecx, DWORD PTR _ptr$[ebp]
	add	ecx, 2
	mov	DWORD PTR _ptr$[ebp], ecx
$LN6@WriteDirty:

; 2807 : 	}
; 2808 : 
; 2809 : 	if (dirty_team & DIRTY_CURRENT_STATS){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+344]
	and	eax, 8
	je	SHORT $LN5@WriteDirty

; 2810 : 		memcpy (ptr, &currentStats, sizeof (currentStats));

	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 152				; 00000098H
	push	ecx
	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2811 : 		ptr += sizeof (currentStats);

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _ptr$[ebp], eax
$LN5@WriteDirty:

; 2812 : 	}
; 2813 : 
; 2814 : 	if (dirty_team & DIRTY_GROUND_ACTION){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+344]
	and	edx, 16					; 00000010H
	je	SHORT $LN4@WriteDirty

; 2815 : 		memcpy (ptr, &groundAction, sizeof (groundAction));

	push	19					; 00000013H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 267				; 0000010bH
	push	eax
	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2816 : 		ptr += sizeof (groundAction);

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, 19					; 00000013H
	mov	DWORD PTR _ptr$[ebp], edx
$LN4@WriteDirty:

; 2817 : 	}
; 2818 : 
; 2819 : 	if (dirty_team & DIRTY_OFFAIR_ACTION){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+344]
	and	ecx, 256				; 00000100H
	je	SHORT $LN3@WriteDirty

; 2820 : 		memcpy (ptr, &offensiveAirAction, sizeof (offensiveAirAction));

	push	28					; 0000001cH
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 316				; 0000013cH
	push	edx
	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2821 : 		ptr += sizeof (offensiveAirAction);

	mov	ecx, DWORD PTR _ptr$[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR _ptr$[ebp], ecx
$LN3@WriteDirty:

; 2822 : 	}
; 2823 : 
; 2824 : 	if (dirty_team & DIRTY_DEFAIR_ACTION){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+344]
	and	eax, 512				; 00000200H
	je	SHORT $LN2@WriteDirty

; 2825 : 		memcpy (ptr, &defensiveAirAction, sizeof (defensiveAirAction));

	push	28					; 0000001cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 288				; 00000120H
	push	ecx
	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2826 : 		ptr += sizeof (defensiveAirAction);

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR _ptr$[ebp], eax
$LN2@WriteDirty:

; 2827 : 	}
; 2828 : 
; 2829 : 	if (dirty_team & DIRTY_TEAM_RELATIONS) {

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+344]
	and	edx, 1024				; 00000400H
	je	SHORT $LN1@WriteDirty

; 2830 : 		ShiAssert ((cteam & 0xff) != 0xfc);
; 2831 : 		memcpy (ptr, &cteam, sizeof (uchar));

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 349				; 0000015dH
	push	eax
	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2832 : 		ptr += sizeof (uchar);

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR _ptr$[ebp], edx

; 2833 : 		memcpy (ptr, member, sizeof (uchar) * NUM_COUNS);

	push	8
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 572				; 0000023cH
	push	eax
	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2834 : 		ptr += sizeof (uchar) * NUM_COUNS;

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, 8
	mov	DWORD PTR _ptr$[ebp], edx

; 2835 : 		memcpy (ptr, stance, sizeof (short) * NUM_TEAMS);

	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 580				; 00000244H
	push	eax
	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2836 : 		ptr += sizeof (short) * NUM_TEAMS;

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _ptr$[ebp], edx
$LN1@WriteDirty:

; 2837 : 	}
; 2838 : 
; 2839 : 	dirty_team = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+344], 0

; 2840 : 	*stream = ptr;

	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [ecx], edx

; 2841 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?WriteDirty@TeamClass@@QAEXPAPAE@Z ENDP			; TeamClass::WriteDirty
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bits$ = 8						; size = 4
_score$ = 12						; size = 4
?MakeTeamDirty@TeamClass@@QAEXW4Dirty_Team@@W4Dirtyness@@@Z PROC ; TeamClass::MakeTeamDirty
; _this$ = ecx

; 2757 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2758 : 	if ((!IsLocal()) || (VuState() != VU_MEM_ACTIVE)){

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@MakeTeamDi
	mov	ecx, DWORD PTR _this$[ebp]
	call	?VuState@VuEntity@@QBE?AW4VU_MEM@@XZ	; VuEntity::VuState
	cmp	eax, 3
	je	SHORT $LN2@MakeTeamDi
$LN1@MakeTeamDi:

; 2759 : 		return;

	jmp	SHORT $LN3@MakeTeamDi
$LN2@MakeTeamDi:

; 2760 : 	}
; 2761 : 	dirty_team |= bits;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+344]
	or	edx, DWORD PTR _bits$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+344], edx

; 2762 : 	MakeDirty (DIRTY_TEAM, score);

	mov	ecx, DWORD PTR _score$[ebp]
	push	ecx
	push	512					; 00000200H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeDirty@FalconEntity@@QAEXW4Dirty_Class@@W4Dirtyness@@@Z ; FalconEntity::MakeDirty
$LN3@MakeTeamDi:

; 2763 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?MakeTeamDirty@TeamClass@@QAEXW4Dirty_Team@@W4Dirtyness@@@Z ENDP ; TeamClass::MakeTeamDirty
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\team.h
;	COMDAT ?IsTeam@TeamClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsTeam@TeamClass@@UAEHXZ PROC				; TeamClass::IsTeam, COMDAT
; _this$ = ecx

; 340  : 	virtual int IsTeam (void)					{ return TRUE; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?IsTeam@TeamClass@@UAEHXZ ENDP				; TeamClass::IsTeam
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_action$ = 8						; size = 4
?SetGroundAction@TeamClass@@QAEXPAUTeamGndActionType@@@Z PROC ; TeamClass::SetGroundAction
; _this$ = ecx

; 1402 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1403 : 	groundAction.actionTime = action->actionTime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _action$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+267], edx

; 1404 : 	groundAction.actionObjective = action->actionObjective;

	mov	eax, DWORD PTR _action$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+275], ecx
	mov	DWORD PTR [eax+279], edx

; 1405 : 	groundAction.actionType = action->actionType;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _action$[ebp]
	mov	al, BYTE PTR [edx+16]
	mov	BYTE PTR [ecx+283], al

; 1406 : 	groundAction.actionTimeout = action->actionTimeout;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _action$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+271], eax

; 1407 : 	groundAction.actionTempo = action->actionTempo;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _action$[ebp]
	mov	al, BYTE PTR [edx+17]
	mov	BYTE PTR [ecx+284], al

; 1408 : 	groundAction.actionPoints = action->actionPoints;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _action$[ebp]
	mov	al, BYTE PTR [edx+18]
	mov	BYTE PTR [ecx+285], al

; 1409 : 	//MakeTeamDirty (DIRTY_GROUND_ACTION, DDP[16].priority);
; 1410 : 	MakeTeamDirty (DIRTY_GROUND_ACTION, SEND_EVENTUALLY);

	push	1
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeTeamDirty@TeamClass@@QAEXW4Dirty_Team@@W4Dirtyness@@@Z ; TeamClass::MakeTeamDirty

; 1411 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetGroundAction@TeamClass@@QAEXPAUTeamGndActionType@@@Z ENDP ; TeamClass::SetGroundAction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
$T2 = -216						; size = 8
$T3 = -208						; size = 8
$T4 = -200						; size = 8
$T5 = -192						; size = 8
$T6 = -184						; size = 8
_poit$7 = -176						; size = 12
_poit$8 = -164						; size = 12
_oa$ = -152						; size = 4
$T9 = -148						; size = 4
tv457 = -144						; size = 4
_fo$10 = -140						; size = 4
$T11 = -136						; size = 4
_yd$12 = -132						; size = 4
_xd$13 = -128						; size = 4
$T14 = -124						; size = 4
_best$15 = -120						; size = 4
_paks$ = -116						; size = 4
$T16 = -112						; size = 4
_found$17 = -108					; size = 4
_airRatio$ = -104					; size = 4
tv291 = -100						; size = 4
_mis$ = -96						; size = 4
_dist$18 = -92						; size = 4
_y$19 = -88						; size = 2
_pd$ = -84						; size = 4
_x$20 = -80						; size = 2
_ta$ = -76						; size = 4
_missions_requested$ = -72				; size = 4
_objectiveList$21 = -68					; size = 4
_step$22 = -64						; size = 4
_action$ = -60						; size = 4
_current_time$ = -56					; size = 4
_score$23 = -52						; size = 4
_fx$24 = -48						; size = 2
_fy$25 = -44						; size = 2
_ty$26 = -40						; size = 2
_tx$27 = -36						; size = 2
_lp$ = -32						; size = 4
_o$28 = -28						; size = 4
_bo$ = -24						; size = 4
_t$ = -17						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?SelectAirActions@TeamClass@@QAEXXZ PROC		; TeamClass::SelectAirActions
; _this$ = ecx

; 1217 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SelectAirActions@TeamClass@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1218 : 	// Find the highest priority primary objective
; 1219 : 	Objective		bo=NULL;

	mov	DWORD PTR _bo$[ebp], 0

; 1220 : 	POData			pd;
; 1221 : 	int				oa,ta=1,airRatio,action,missions_requested,paks=0;

	mov	DWORD PTR _ta$[ebp], 1
	mov	DWORD PTR _paks$[ebp], 0

; 1222 : 	Team			t;
; 1223 : 	ListNode		lp;
; 1224 : 	MissionRequest	mis;
; 1225 : 	CampaignTime	current_time;
; 1226 : 
; 1227 : 	if (!(flags & TEAM_ACTIVE) || !IsLocal())

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+350]
	and	ecx, 1
	je	SHORT $LN36@SelectAirA
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN37@SelectAirA
$LN36@SelectAirA:

; 1228 : 		return;

	jmp	$LN38@SelectAirA
$LN37@SelectAirA:

; 1229 : 
; 1230 : 	if (TheCampaign.CurrentTime > defensiveAirAction.actionStopTime)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	cmp	ecx, DWORD PTR [eax+292]
	jbe	SHORT $LN35@SelectAirA

; 1231 : 	{
; 1232 : 		// Clear old defensive action
; 1233 : 		defensiveAirAction.actionType = AACTION_NOTHING;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+312], 0
$LN35@SelectAirA:

; 1234 : 	}
; 1235 : 
; 1236 : 
; 1237 : 	if (TheCampaign.CurrentTime < offensiveAirAction.actionStopTime)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	cmp	ecx, DWORD PTR [eax+320]
	jae	SHORT $LN34@SelectAirA

; 1238 : 		return;

	jmp	$LN38@SelectAirA
$LN34@SelectAirA:

; 1239 : 
; 1240 : 	// Plan a new offensive action
; 1241 : 
; 1242 : 	// Determine percentage of non-action offensive missions to fill during next action cycle, based on tempo
; 1243 : 	missions_requested = 0;

	mov	DWORD PTR _missions_requested$[ebp], 0

; 1244 : 	lp = atm->requestList->GetLastElement();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+876]
	mov	ecx, DWORD PTR [eax+180]
	call	?GetLastElement@ListClass@@QAEPAVListElementClass@@XZ ; ListClass::GetLastElement
	mov	DWORD PTR _lp$[ebp], eax
$LN33@SelectAirA:

; 1245 : 	while (lp)

	cmp	DWORD PTR _lp$[ebp], 0
	je	SHORT $LN32@SelectAirA

; 1246 : 	{
; 1247 : 		mis = (MissionRequest) lp->GetUserData();

	mov	ecx, DWORD PTR _lp$[ebp]
	call	?GetUserData@ListElementClass@@QAEPAXXZ	; ListElementClass::GetUserData
	mov	DWORD PTR _mis$[ebp], eax

; 1248 : 		if (!mis->action_type && !(MissionData[mis->mission].flags & AMIS_FLYALWAYS))

	mov	ecx, DWORD PTR _mis$[ebp]
	movzx	edx, BYTE PTR [ecx+59]
	test	edx, edx
	jne	SHORT $LN31@SelectAirA
	mov	eax, DWORD PTR _mis$[ebp]
	movzx	ecx, BYTE PTR [eax+60]
	shl	ecx, 5
	mov	edx, DWORD PTR ?MissionData@@3PAUMissionDataType@@A[ecx+28]
	and	edx, 536870912				; 20000000H
	jne	SHORT $LN31@SelectAirA

; 1249 : 			missions_requested++;

	mov	eax, DWORD PTR _missions_requested$[ebp]
	add	eax, 1
	mov	DWORD PTR _missions_requested$[ebp], eax
$LN31@SelectAirA:

; 1250 : 		lp = lp->GetPrev();

	mov	ecx, DWORD PTR _lp$[ebp]
	call	?GetPrev@ListElementClass@@QAEPAV1@XZ	; ListElementClass::GetPrev
	mov	DWORD PTR _lp$[ebp], eax

; 1251 : 	}

	jmp	SHORT $LN33@SelectAirA
$LN32@SelectAirA:

; 1252 : 	atm->missionsToFill = (missions_requested * groundAction.actionTempo) / 100;

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+284]
	mov	eax, edx
	imul	eax, DWORD PTR _missions_requested$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+876]
	mov	DWORD PTR [ecx+160], eax

; 1253 : 	atm->missionsFilled = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+876]
	mov	DWORD PTR [eax+164], 0

; 1254 : 
; 1255 : 	// Get ratio of air forces
; 1256 : 	oa = currentStats.aircraft;

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+154]
	mov	DWORD PTR _oa$[ebp], edx

; 1257 : 	for (t = 0; t<NUM_TEAMS; t++)

	mov	BYTE PTR _t$[ebp], 0
	jmp	SHORT $LN30@SelectAirA
$LN29@SelectAirA:
	mov	al, BYTE PTR _t$[ebp]
	add	al, 1
	mov	BYTE PTR _t$[ebp], al
$LN30@SelectAirA:
	movzx	ecx, BYTE PTR _t$[ebp]
	cmp	ecx, 8
	jge	SHORT $LN28@SelectAirA

; 1258 : 	{
; 1259 : 		if (GetRoE(who,t,ROE_AIR_FIRE) == ROE_ALLOWED)

	push	5
	movzx	edx, BYTE PTR _t$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+348]
	push	ecx
	call	?GetRoE@@YAHEEH@Z			; GetRoE
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	jne	SHORT $LN27@SelectAirA

; 1260 : 			ta += TeamInfo[t]->currentStats.aircraft;

	movzx	edx, BYTE PTR _t$[ebp]
	mov	eax, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	movzx	ecx, WORD PTR [eax+154]
	add	ecx, DWORD PTR _ta$[ebp]
	mov	DWORD PTR _ta$[ebp], ecx
$LN27@SelectAirA:

; 1261 : 	}

	jmp	SHORT $LN29@SelectAirA
$LN28@SelectAirA:

; 1262 : 	airRatio = (oa*100)/ta;

	mov	eax, DWORD PTR _oa$[ebp]
	imul	eax, 100				; 00000064H
	cdq
	idiv	DWORD PTR _ta$[ebp]
	mov	DWORD PTR _airRatio$[ebp], eax

; 1263 : 
; 1264 : 	// Select Air Action Type
; 1265 : 	// TJL 01/03/04 Eliminate the ratio for INTERDICT.  It was too high and never got there
; 1266 : 	// OCA is now the offensive mode.  All target types are now available based on OCA mode.
; 1267 : 	// See ATM.CPP
; 1268 : 	//if (airRatio > 200)
; 1269 : 	//
; 1270 : 	//action = AACTION_INTERDICT;	// If we can afford it, do interdiction action
; 1271 : 	//	else if (airRatio > 60)
; 1272 : 	if (airRatio > 60)

	cmp	DWORD PTR _airRatio$[ebp], 60		; 0000003cH
	jle	SHORT $LN26@SelectAirA

; 1273 : 		action = AACTION_OCA;	// Otherwise try for air superiority with OCA action

	mov	DWORD PTR _action$[ebp], 2

; 1274 : 	else

	jmp	SHORT $LN25@SelectAirA
$LN26@SelectAirA:

; 1275 : 		action = AACTION_DCA;	// Otherwise, defense only (this will not create an action)

	mov	DWORD PTR _action$[ebp], 1
$LN25@SelectAirA:

; 1276 : 
; 1277 : 
; 1278 : 
; 1279 : 	// Couple of special cases
; 1280 : 	if ((groundAction.actionType == GACTION_OFFENSIVE) && (action == AACTION_DCA) && (airRatio > 40)){

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+283]
	cmp	eax, 4
	jne	SHORT $LN24@SelectAirA
	cmp	DWORD PTR _action$[ebp], 1
	jne	SHORT $LN24@SelectAirA
	cmp	DWORD PTR _airRatio$[ebp], 40		; 00000028H
	jle	SHORT $LN24@SelectAirA

; 1281 : 		action = AACTION_OCA;

	mov	DWORD PTR _action$[ebp], 2
$LN24@SelectAirA:

; 1282 : 	}
; 1283 : 
; 1284 : 	if (action == AACTION_DCA){

	cmp	DWORD PTR _action$[ebp], 1
	jne	SHORT $LN23@SelectAirA

; 1285 : 		return;

	jmp	$LN38@SelectAirA
$LN23@SelectAirA:

; 1286 : 	}
; 1287 : 
; 1288 : 	// Now select a target PAK
; 1289 : 	//TJL 01/03/04 Remove INTERDICT
; 1290 : 	//if (action == AACTION_OCA || action == AACTION_INTERDICT)
; 1291 : 	if (action == AACTION_OCA)

	cmp	DWORD PTR _action$[ebp], 2
	jne	$LN22@SelectAirA

; 1292 : 	{
; 1293 : 		Objective		o,fo;
; 1294 : 		int				best=-200,score,found,step,dist;

	mov	DWORD PTR _best$15[ebp], -200		; ffffff38H

; 1295 : 		float			xd,yd;
; 1296 : 		GridIndex		tx,ty,fx,fy,x,y;
; 1297 : 		List			objectiveList;
; 1298 : 
; 1299 : 		{
; 1300 : 			VuListIterator	poit(POList);

	mov	ecx, DWORD PTR ?POList@@3PAVFalconPrivateOrderedList@@A ; POList
	push	ecx
	lea	ecx, DWORD PTR _poit$7[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1301 : 			o = GetFirstObjective(&poit);

	lea	edx, DWORD PTR _poit$7[ebp]
	push	edx
	call	?GetFirstObjective@@YAPAVObjectiveClass@@PAVVuListIterator@@@Z ; GetFirstObjective
	add	esp, 4
	mov	DWORD PTR _o$28[ebp], eax
$LN21@SelectAirA:

; 1302 : 			while (o)

	cmp	DWORD PTR _o$28[ebp], 0
	je	$LN20@SelectAirA

; 1303 : 			{
; 1304 : 				if (GetRoE(who,o->GetTeam(),ROE_AIR_ATTACK) == ROE_ALLOWED)

	push	8
	mov	eax, DWORD PTR _o$28[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _o$28[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+348]
	push	eax
	call	?GetRoE@@YAHEEH@Z			; GetRoE
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	jne	$LN14@SelectAirA

; 1305 : 				{
; 1306 : 					pd = GetPOData(o);

	mov	ecx, DWORD PTR _o$28[ebp]
	push	ecx
	call	?GetPOData@@YAPAUPrimaryObjectiveData@@PAVObjectiveClass@@@Z ; GetPOData
	add	esp, 4
	mov	DWORD PTR _pd$[ebp], eax

; 1307 : 					if (pd->player_priority[who] >= 0)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+348]
	mov	ecx, DWORD PTR _pd$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+56]
	test	edx, edx
	jl	SHORT $LN18@SelectAirA

; 1308 : 						score = pd->player_priority[who];

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+348]
	mov	edx, DWORD PTR _pd$[ebp]
	movsx	eax, WORD PTR [edx+ecx*2+56]
	mov	DWORD PTR _score$23[ebp], eax

; 1309 : 					else

	jmp	SHORT $LN17@SelectAirA
$LN18@SelectAirA:

; 1310 : 						score = pd->air_priority[who];

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+348]
	mov	eax, DWORD PTR _pd$[ebp]
	movsx	ecx, WORD PTR [eax+edx*2+40]
	mov	DWORD PTR _score$23[ebp], ecx
$LN17@SelectAirA:

; 1311 : 					if (o->Id() == groundAction.actionObjective)

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 275				; 00000113H
	push	edx
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	mov	ecx, DWORD PTR _o$28[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, eax
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN16@SelectAirA

; 1312 : 						score += 50;

	mov	edx, DWORD PTR _score$23[ebp]
	add	edx, 50					; 00000032H
	mov	DWORD PTR _score$23[ebp], edx
$LN16@SelectAirA:

; 1313 : 					if (o->Id() == offensiveAirAction.lastActionObjective)

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 332				; 0000014cH
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, DWORD PTR _o$28[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, eax
	call	??8VU_ID@@QBE_NABV0@@Z			; VU_ID::operator==
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN15@SelectAirA

; 1314 : 						score -= 200;

	mov	eax, DWORD PTR _score$23[ebp]
	sub	eax, 200				; 000000c8H
	mov	DWORD PTR _score$23[ebp], eax
$LN15@SelectAirA:

; 1315 : 					if (score > best)

	mov	ecx, DWORD PTR _score$23[ebp]
	cmp	ecx, DWORD PTR _best$15[ebp]
	jle	SHORT $LN14@SelectAirA

; 1316 : 					{
; 1317 : 						bo = o;

	mov	edx, DWORD PTR _o$28[ebp]
	mov	DWORD PTR _bo$[ebp], edx

; 1318 : 						best = score;

	mov	eax, DWORD PTR _score$23[ebp]
	mov	DWORD PTR _best$15[ebp], eax
$LN14@SelectAirA:

; 1319 : 					}
; 1320 : 				}
; 1321 : 				o = GetNextObjective(&poit);

	lea	ecx, DWORD PTR _poit$7[ebp]
	push	ecx
	call	?GetNextObjective@@YAPAVObjectiveClass@@PAVVuListIterator@@@Z ; GetNextObjective
	add	esp, 4
	mov	DWORD PTR _o$28[ebp], eax

; 1322 : 			}

	jmp	$LN21@SelectAirA
$LN20@SelectAirA:

; 1323 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _poit$7[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator

; 1324 : 
; 1325 : 		if (!bo)

	cmp	DWORD PTR _bo$[ebp], 0
	jne	SHORT $LN13@SelectAirA

; 1326 : 			return;

	jmp	$LN38@SelectAirA
$LN13@SelectAirA:

; 1327 : 
; 1328 : 		// Set up our action
; 1329 : 		offensiveAirAction.actionStartTime = current_time = TheCampaign.CurrentTime + CampaignHours;

	mov	edx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	add	edx, 3600000				; 0036ee80H
	mov	DWORD PTR _current_time$[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _current_time$[ebp]
	mov	DWORD PTR [eax+316], ecx

; 1330 : 		offensiveAirAction.actionType = action;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR _action$[ebp]
	mov	BYTE PTR [edx+340], al

; 1331 : 		offensiveAirAction.actionObjective = bo->Id();

	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _bo$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+324], edx
	mov	DWORD PTR [ecx+328], eax

; 1332 : 		offensiveAirAction.lastActionObjective = bo->Id();

	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _bo$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+332], ecx
	mov	DWORD PTR [eax+336], edx

; 1333 : 		objectiveList = new ListClass(LADT_SORTED_LIST);

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T16[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T16[ebp], 0
	je	SHORT $LN40@SelectAirA
	push	1
	mov	ecx, DWORD PTR $T16[ebp]
	call	??0ListClass@@QAE@E@Z			; ListClass::ListClass
	mov	DWORD PTR tv291[ebp], eax
	jmp	SHORT $LN41@SelectAirA
$LN40@SelectAirA:
	mov	DWORD PTR tv291[ebp], 0
$LN41@SelectAirA:
	mov	ecx, DWORD PTR tv291[ebp]
	mov	DWORD PTR $T9[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T9[ebp]
	mov	DWORD PTR _objectiveList$21[ebp], edx

; 1334 : 
; 1335 : 		// Calculate our clear path & build list of all additional target PAKs
; 1336 : 		// This is a very rough way to find all PAKs along the path to our target PAK
; 1337 : 		bo->GetLocation(&tx,&ty);

	lea	eax, DWORD PTR _ty$26[ebp]
	push	eax
	lea	ecx, DWORD PTR _tx$27[ebp]
	push	ecx
	mov	ecx, DWORD PTR _bo$[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 1338 : 		fo = FindNearestObjective(FrontList, tx, ty, NULL);

	push	0
	movzx	edx, WORD PTR _ty$26[ebp]
	push	edx
	movzx	eax, WORD PTR _tx$27[ebp]
	push	eax
	mov	ecx, DWORD PTR ?FrontList@@3PAVFalconPrivateList@@A ; FrontList
	push	ecx
	call	?FindNearestObjective@@YAPAVObjectiveClass@@PAVVuLinkedList@@FFPAM@Z ; FindNearestObjective
	add	esp, 16					; 00000010H
	mov	DWORD PTR _fo$10[ebp], eax

; 1339 : 		ShiAssert(fo);
; 1340 : 		fo->GetLocation(&fx, &fy);

	lea	edx, DWORD PTR _fy$25[ebp]
	push	edx
	lea	eax, DWORD PTR _fx$24[ebp]
	push	eax
	mov	ecx, DWORD PTR _fo$10[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 1341 : 		dist = FloatToInt32(Distance(fx,fy,tx,ty));

	movzx	ecx, WORD PTR _ty$26[ebp]
	push	ecx
	movzx	edx, WORD PTR _tx$27[ebp]
	push	edx
	movzx	eax, WORD PTR _fy$25[ebp]
	push	eax
	movzx	ecx, WORD PTR _fx$24[ebp]
	push	ecx
	call	?Distance@@YAMFFFF@Z			; Distance
	add	esp, 12					; 0000000cH
	fstp	DWORD PTR [esp]
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	DWORD PTR _dist$18[ebp], eax

; 1342 : 		xd = (float)(tx-fx)/dist;

	movsx	edx, WORD PTR _tx$27[ebp]
	movsx	eax, WORD PTR _fx$24[ebp]
	sub	edx, eax
	cvtsi2ss xmm0, edx
	cvtsi2ss xmm1, DWORD PTR _dist$18[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _xd$13[ebp], xmm0

; 1343 : 		yd = (float)(ty-fy)/dist;

	movsx	ecx, WORD PTR _ty$26[ebp]
	movsx	edx, WORD PTR _fy$25[ebp]
	sub	ecx, edx
	cvtsi2ss xmm0, ecx
	cvtsi2ss xmm1, DWORD PTR _dist$18[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _yd$12[ebp], xmm0

; 1344 : 		for (step=20; step<=dist; step+=30){

	mov	DWORD PTR _step$22[ebp], 20		; 00000014H
	jmp	SHORT $LN12@SelectAirA
$LN11@SelectAirA:
	mov	eax, DWORD PTR _step$22[ebp]
	add	eax, 30					; 0000001eH
	mov	DWORD PTR _step$22[ebp], eax
$LN12@SelectAirA:
	mov	ecx, DWORD PTR _step$22[ebp]
	cmp	ecx, DWORD PTR _dist$18[ebp]
	jg	$LN10@SelectAirA

; 1345 : 			x = fx + FloatToInt32(xd*step + 0.5F);

	movsx	esi, WORD PTR _fx$24[ebp]
	cvtsi2ss xmm0, DWORD PTR _step$22[ebp]
	mulss	xmm0, DWORD PTR _xd$13[ebp]
	addss	xmm0, DWORD PTR __real@3f000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	add	esi, eax
	mov	WORD PTR _x$20[ebp], si

; 1346 : 			y = fy + FloatToInt32(yd*step + 0.5F);

	movsx	esi, WORD PTR _fy$25[ebp]
	cvtsi2ss xmm0, DWORD PTR _step$22[ebp]
	mulss	xmm0, DWORD PTR _yd$12[ebp]
	addss	xmm0, DWORD PTR __real@3f000000
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	add	esi, eax
	mov	WORD PTR _y$19[ebp], si

; 1347 : 			VuListIterator	poit(POList);

	mov	edx, DWORD PTR ?POList@@3PAVFalconPrivateOrderedList@@A ; POList
	push	edx
	lea	ecx, DWORD PTR _poit$8[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 1348 : 			o = GetFirstObjective(&poit);

	lea	eax, DWORD PTR _poit$8[ebp]
	push	eax
	call	?GetFirstObjective@@YAPAVObjectiveClass@@PAVVuListIterator@@@Z ; GetFirstObjective
	add	esp, 4
	mov	DWORD PTR _o$28[ebp], eax
$LN9@SelectAirA:

; 1349 : 			while (o)

	cmp	DWORD PTR _o$28[ebp], 0
	je	$LN8@SelectAirA

; 1350 : 			{
; 1351 : 				o->GetLocation(&tx,&ty);

	lea	ecx, DWORD PTR _ty$26[ebp]
	push	ecx
	lea	edx, DWORD PTR _tx$27[ebp]
	push	edx
	mov	ecx, DWORD PTR _o$28[ebp]
	call	?GetLocation@FalconEntity@@QBEXPAF0@Z	; FalconEntity::GetLocation

; 1352 : 				if (o != bo && DistSqu(x,y,tx,ty) < SIDE_CHECK_DISTANCE*SIDE_CHECK_DISTANCE)

	mov	eax, DWORD PTR _o$28[ebp]
	cmp	eax, DWORD PTR _bo$[ebp]
	je	$LN3@SelectAirA
	movzx	ecx, WORD PTR _ty$26[ebp]
	push	ecx
	movzx	edx, WORD PTR _tx$27[ebp]
	push	edx
	movzx	eax, WORD PTR _y$19[ebp]
	push	eax
	movzx	ecx, WORD PTR _x$20[ebp]
	push	ecx
	call	?DistSqu@@YAHFFFF@Z			; DistSqu
	add	esp, 16					; 00000010H
	cmp	eax, 3600				; 00000e10H
	jge	SHORT $LN3@SelectAirA

; 1353 : 				{
; 1354 : 					found = 0;

	mov	DWORD PTR _found$17[ebp], 0

; 1355 : 					lp = objectiveList->GetFirstElement();

	mov	ecx, DWORD PTR _objectiveList$21[ebp]
	call	?GetFirstElement@ListClass@@QAEPAVListElementClass@@XZ ; ListClass::GetFirstElement
	mov	DWORD PTR _lp$[ebp], eax
$LN6@SelectAirA:

; 1356 : 					while (lp)

	cmp	DWORD PTR _lp$[ebp], 0
	je	SHORT $LN5@SelectAirA

; 1357 : 					{
; 1358 : 						if (lp->GetUserData() == o)

	mov	ecx, DWORD PTR _lp$[ebp]
	call	?GetUserData@ListElementClass@@QAEPAXXZ	; ListElementClass::GetUserData
	cmp	eax, DWORD PTR _o$28[ebp]
	jne	SHORT $LN4@SelectAirA

; 1359 : 							found = 1;

	mov	DWORD PTR _found$17[ebp], 1
$LN4@SelectAirA:

; 1360 : 						lp = lp->GetNext();

	mov	ecx, DWORD PTR _lp$[ebp]
	call	?GetNext@ListElementClass@@QAEPAV1@XZ	; ListElementClass::GetNext
	mov	DWORD PTR _lp$[ebp], eax

; 1361 : 					}

	jmp	SHORT $LN6@SelectAirA
$LN5@SelectAirA:

; 1362 : 					if (!found)

	cmp	DWORD PTR _found$17[ebp], 0
	jne	SHORT $LN3@SelectAirA

; 1363 : 					{
; 1364 : 						objectiveList->InsertNewElement(FloatToInt32(DistanceToFront(fx,fy)),o);

	push	0
	mov	edx, DWORD PTR _o$28[ebp]
	push	edx
	movzx	eax, WORD PTR _fy$25[ebp]
	push	eax
	movzx	ecx, WORD PTR _fx$24[ebp]
	push	ecx
	call	?DistanceToFront@@YAMFF@Z		; DistanceToFront
	add	esp, 4
	fstp	DWORD PTR [esp]
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _objectiveList$21[ebp]
	call	?InsertNewElement@ListClass@@QAEXFPAXE@Z ; ListClass::InsertNewElement

; 1365 : 						paks++;

	mov	edx, DWORD PTR _paks$[ebp]
	add	edx, 1
	mov	DWORD PTR _paks$[ebp], edx
$LN3@SelectAirA:

; 1366 : 					}
; 1367 : 				}
; 1368 : 				o = GetNextObjective(&poit);

	lea	eax, DWORD PTR _poit$8[ebp]
	push	eax
	call	?GetNextObjective@@YAPAVObjectiveClass@@PAVVuListIterator@@@Z ; GetNextObjective
	add	esp, 4
	mov	DWORD PTR _o$28[ebp], eax

; 1369 : 			}

	jmp	$LN9@SelectAirA
$LN8@SelectAirA:

; 1370 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _poit$8[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
	jmp	$LN11@SelectAirA
$LN10@SelectAirA:

; 1371 : 
; 1372 : 		// Target all PAKs
; 1373 : 		lp = objectiveList->GetFirstElement();

	mov	ecx, DWORD PTR _objectiveList$21[ebp]
	call	?GetFirstElement@ListClass@@QAEPAVListElementClass@@XZ ; ListClass::GetFirstElement
	mov	DWORD PTR _lp$[ebp], eax
$LN2@SelectAirA:

; 1374 : 		while (lp)

	cmp	DWORD PTR _lp$[ebp], 0
	je	SHORT $LN1@SelectAirA

; 1375 : 		{
; 1376 : 			o = (Objective) lp->GetUserData();

	mov	ecx, DWORD PTR _lp$[ebp]
	call	?GetUserData@ListElementClass@@QAEPAXXZ	; ListElementClass::GetUserData
	mov	DWORD PTR _o$28[ebp], eax

; 1377 : 			TargetAllSites (o, AACTION_OCA, who, current_time);

	mov	ecx, DWORD PTR _current_time$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+348]
	push	eax
	push	2
	mov	ecx, DWORD PTR _o$28[ebp]
	push	ecx
	call	?TargetAllSites@@YAHPAVObjectiveClass@@HHK@Z ; TargetAllSites
	add	esp, 16					; 00000010H

; 1378 : 			current_time += 20 * CampaignMinutes;

	mov	edx, DWORD PTR _current_time$[ebp]
	add	edx, 1200000				; 00124f80H
	mov	DWORD PTR _current_time$[ebp], edx

; 1379 : 			lp = lp->GetNext();

	mov	ecx, DWORD PTR _lp$[ebp]
	call	?GetNext@ListElementClass@@QAEPAV1@XZ	; ListElementClass::GetNext
	mov	DWORD PTR _lp$[ebp], eax

; 1380 : 		}

	jmp	SHORT $LN2@SelectAirA
$LN1@SelectAirA:

; 1381 : 
; 1382 : 		offensiveAirAction.actionStopTime = current_time + 30*CampaignMinutes;

	mov	eax, DWORD PTR _current_time$[ebp]
	add	eax, 1800000				; 001b7740H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+320], eax

; 1383 : 		TargetAllSites (bo, action, who, current_time);

	mov	edx, DWORD PTR _current_time$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+348]
	push	ecx
	mov	edx, DWORD PTR _action$[ebp]
	push	edx
	mov	eax, DWORD PTR _bo$[ebp]
	push	eax
	call	?TargetAllSites@@YAHPAVObjectiveClass@@HHK@Z ; TargetAllSites
	add	esp, 16					; 00000010H

; 1384 : 		delete objectiveList;

	mov	ecx, DWORD PTR _objectiveList$21[ebp]
	mov	DWORD PTR $T11[ebp], ecx
	mov	edx, DWORD PTR $T11[ebp]
	mov	DWORD PTR $T14[ebp], edx
	cmp	DWORD PTR $T14[ebp], 0
	je	SHORT $LN42@SelectAirA
	push	1
	mov	ecx, DWORD PTR $T14[ebp]
	call	??_GListClass@@QAEPAXI@Z
	mov	DWORD PTR tv457[ebp], eax
	jmp	SHORT $LN43@SelectAirA
$LN42@SelectAirA:
	mov	DWORD PTR tv457[ebp], 0
$LN43@SelectAirA:

; 1385 : 
; 1386 : 		//MakeTeamDirty (DIRTY_OFFAIR_ACTION, DDP[14].priority);
; 1387 : 		MakeTeamDirty (DIRTY_OFFAIR_ACTION, SEND_EVENTUALLY);

	push	1
	push	256					; 00000100H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeTeamDirty@TeamClass@@QAEXW4Dirty_Team@@W4Dirtyness@@@Z ; TeamClass::MakeTeamDirty

; 1388 : 
; 1389 : 		// Warp enemy defensive action to this location.
; 1390 : 
; 1391 : 		TeamInfo[bo->GetTeam()]->defensiveAirAction.actionType = AACTION_DCA;

	mov	eax, DWORD PTR _bo$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _bo$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	BYTE PTR [edx+312], 1

; 1392 : 		TeamInfo[bo->GetTeam()]->defensiveAirAction.actionObjective = bo->Id();

	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	mov	ecx, DWORD PTR _bo$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	esi, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _bo$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _bo$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	DWORD PTR [edx+296], esi
	mov	DWORD PTR [edx+300], edi

; 1393 : 		TeamInfo[bo->GetTeam()]->defensiveAirAction.actionStartTime = current_time;

	mov	eax, DWORD PTR _bo$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _bo$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	eax, DWORD PTR _current_time$[ebp]
	mov	DWORD PTR [edx+288], eax

; 1394 : 		TeamInfo[bo->GetTeam()]->defensiveAirAction.actionStopTime = offensiveAirAction.actionStopTime;

	mov	ecx, DWORD PTR _bo$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _bo$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+320]
	mov	DWORD PTR [edx+292], ecx

; 1395 : 
; 1396 : 		//TeamInfo[bo->GetTeam()]->MakeTeamDirty (DIRTY_DEFAIR_ACTION, DDP[15].priority);
; 1397 : 		TeamInfo[bo->GetTeam()]->MakeTeamDirty (DIRTY_DEFAIR_ACTION, SEND_EVENTUALLY);

	push	1
	push	512					; 00000200H
	mov	edx, DWORD PTR _bo$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _bo$[ebp]
	mov	edx, DWORD PTR [eax+116]
	call	edx
	movzx	eax, al
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	call	?MakeTeamDirty@TeamClass@@QAEXW4Dirty_Team@@W4Dirtyness@@@Z ; TeamClass::MakeTeamDirty
$LN22@SelectAirA:
$LN38@SelectAirA:

; 1398 : 	}
; 1399 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SelectAirActions@TeamClass@@QAEXXZ$0:
	lea	ecx, DWORD PTR _poit$7[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__unwindfunclet$?SelectAirActions@TeamClass@@QAEXXZ$1:
	mov	eax, DWORD PTR $T16[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?SelectAirActions@TeamClass@@QAEXXZ$2:
	lea	ecx, DWORD PTR _poit$8[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__ehhandler$?SelectAirActions@TeamClass@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-216]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SelectAirActions@TeamClass@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?SelectAirActions@TeamClass@@QAEXXZ ENDP		; TeamClass::SelectAirActions
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
$T2 = -92						; size = 8
$T3 = -84						; size = 8
_poit$4 = -76						; size = 12
_pd$ = -64						; size = 4
_best$ = -60						; size = 4
_o$ = -56						; size = 4
_bo$ = -52						; size = 4
_sup$ = -48						; size = 4
_this$ = -44						; size = 4
_t$ = -37						; size = 1
_enemyAction$ = -36					; size = 19
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?SelectGroundAction@TeamClass@@QAEXXZ PROC		; TeamClass::SelectGroundAction
; _this$ = ecx

; 1075 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SelectGroundAction@TeamClass@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1076 : 	// Find the highest priority primary objective
; 1077 : 	Objective		o,bo=NULL;

	mov	DWORD PTR _bo$[ebp], 0

; 1078 : 	POData			pd;
; 1079 : 	int				best=0,sup;

	mov	DWORD PTR _best$[ebp], 0

; 1080 : 	Team			t;
; 1081 : 	TeamGndActionType	enemyAction;

	lea	ecx, DWORD PTR _enemyAction$[ebp]
	call	??0TeamGndActionType@@QAE@XZ

; 1082 : 
; 1083 : 	if (!(flags & TEAM_ACTIVE) || !IsLocal())

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+350]
	and	ecx, 1
	je	SHORT $LN31@SelectGrou
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN32@SelectGrou
$LN31@SelectGrou:

; 1084 : 		return;

	jmp	$LN33@SelectGrou
$LN32@SelectGrou:

; 1085 : 
; 1086 : 	// A.S. begin, 2001-12-09
; 1087 : 
; 1088 : 	if (NewInitiativePoints) {	// New trigers for new initiative point system  

	cmp	DWORD PTR ?NewInitiativePoints@@3HA, 0	; NewInitiativePoints
	je	SHORT $LN30@SelectGrou

; 1089 : 		MIN_COUNTER_ATTACK_INITIATIVE = 50;

	mov	eax, 50					; 00000032H
	mov	WORD PTR ?MIN_COUNTER_ATTACK_INITIATIVE@@3FA, ax ; MIN_COUNTER_ATTACK_INITIATIVE

; 1090 : 		MIN_FULL_OFFENSIVE_INITIATIVE = 55;

	mov	ecx, 55					; 00000037H
	mov	WORD PTR ?MIN_FULL_OFFENSIVE_INITIATIVE@@3FA, cx ; MIN_FULL_OFFENSIVE_INITIATIVE
$LN30@SelectGrou:

; 1091 : 	}
; 1092 : 
; 1093 : 	// end added section
; 1094 : 	// Check for action timeout
; 1095 : 	if (TheCampaign.CurrentTime > groundAction.actionTimeout)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	cmp	eax, DWORD PTR [edx+271]
	jbe	SHORT $LN29@SelectGrou

; 1096 : 	{
; 1097 : 		// Go to consolidation action
; 1098 : 		groundAction.actionType = GACTION_CONSOLIDATE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+283], 2
$LN29@SelectGrou:

; 1099 : 	}
; 1100 : 	// If we're not currently in an action, see if we can start one
; 1101 : 	if (groundAction.actionType == GACTION_CONSOLIDATE && 
; 1102 : 					POList && 
; 1103 : 					initiative >= MIN_COUNTER_ATTACK_INITIATIVE &&
; 1104 : 					TheCampaign.CurrentTime >= groundAction.actionTimeout + ACTION_RATE)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+283]
	cmp	eax, 2
	jne	$LN28@SelectGrou
	cmp	DWORD PTR ?POList@@3PAVFalconPrivateOrderedList@@A, 0 ; POList
	je	$LN28@SelectGrou
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+144]
	movsx	eax, WORD PTR ?MIN_COUNTER_ATTACK_INITIATIVE@@3FA ; MIN_COUNTER_ATTACK_INITIATIVE
	cmp	edx, eax
	jl	$LN28@SelectGrou
	mov	ecx, DWORD PTR ?ActionRate@@3HA		; ActionRate
	imul	ecx, 3600000				; 0036ee80H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+271]
	cmp	DWORD PTR ?TheCampaign@@3VCampaignClass@@A, ecx
	jb	$LN28@SelectGrou

; 1105 : 	{
; 1106 : 		// Select our objective
; 1107 : 		{
; 1108 : 			VuListIterator	poit(POList);

	mov	eax, DWORD PTR ?POList@@3PAVFalconPrivateOrderedList@@A ; POList
	push	eax
	lea	ecx, DWORD PTR _poit$4[ebp]
	call	??0VuListIterator@@QAE@PAVVuLinkedList@@@Z ; VuListIterator::VuListIterator
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1109 : 			o = GetFirstObjective(&poit);

	lea	ecx, DWORD PTR _poit$4[ebp]
	push	ecx
	call	?GetFirstObjective@@YAPAVObjectiveClass@@PAVVuListIterator@@@Z ; GetFirstObjective
	add	esp, 4
	mov	DWORD PTR _o$[ebp], eax
$LN27@SelectGrou:

; 1110 : 			while (o)

	cmp	DWORD PTR _o$[ebp], 0
	je	$LN26@SelectGrou

; 1111 : 			{
; 1112 : 				pd = GetPOData(o);

	mov	edx, DWORD PTR _o$[ebp]
	push	edx
	call	?GetPOData@@YAPAUPrimaryObjectiveData@@PAVObjectiveClass@@@Z ; GetPOData
	add	esp, 4
	mov	DWORD PTR _pd$[ebp], eax

; 1113 : 				// KCK: I Hope Nearfront() is sufficient to allow the team to consolidate around this objective
; 1114 : 				// before going on to the next. Maybe I should use distance to front
; 1115 : 				if (pd->ground_priority[who] > best && (o->IsNearfront() || GetRoE(who,o->GetTeam(),ROE_GROUND_CAPTURE) == ROE_ALLOWED))

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+348]
	mov	edx, DWORD PTR _pd$[ebp]
	movsx	eax, WORD PTR [edx+ecx*2+8]
	cmp	eax, DWORD PTR _best$[ebp]
	jle	SHORT $LN25@SelectGrou
	mov	ecx, DWORD PTR _o$[ebp]
	call	?IsNearfront@ObjectiveClass@@QAEHXZ	; ObjectiveClass::IsNearfront
	test	eax, eax
	jne	SHORT $LN24@SelectGrou
	push	3
	mov	ecx, DWORD PTR _o$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _o$[ebp]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+348]
	push	eax
	call	?GetRoE@@YAHEEH@Z			; GetRoE
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	jne	SHORT $LN25@SelectGrou
$LN24@SelectGrou:

; 1116 : 				{
; 1117 : 					bo = o;

	mov	ecx, DWORD PTR _o$[ebp]
	mov	DWORD PTR _bo$[ebp], ecx

; 1118 : 					best = pd->ground_priority[who];

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+348]
	mov	ecx, DWORD PTR _pd$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+8]
	mov	DWORD PTR _best$[ebp], edx
$LN25@SelectGrou:

; 1119 : 				}
; 1120 : 				o = GetNextObjective(&poit);

	lea	eax, DWORD PTR _poit$4[ebp]
	push	eax
	call	?GetNextObjective@@YAPAVObjectiveClass@@PAVVuListIterator@@@Z ; GetNextObjective
	add	esp, 4
	mov	DWORD PTR _o$[ebp], eax

; 1121 : 			}

	jmp	$LN27@SelectGrou
$LN26@SelectGrou:

; 1122 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _poit$4[ebp]
	call	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator

; 1123 : 		if (bo)

	cmp	DWORD PTR _bo$[ebp], 0
	je	$LN28@SelectGrou

; 1124 : 		{
; 1125 : 			// Offensive Action! Yahoo!
; 1126 : 			if (initiative >= MIN_FULL_OFFENSIVE_INITIATIVE)

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+144]
	movsx	eax, WORD PTR ?MIN_FULL_OFFENSIVE_INITIATIVE@@3FA ; MIN_FULL_OFFENSIVE_INITIATIVE
	cmp	edx, eax
	jl	SHORT $LN22@SelectGrou

; 1127 : 				groundAction.actionType = GACTION_OFFENSIVE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+283], 4

; 1128 : 			else

	jmp	SHORT $LN21@SelectGrou
$LN22@SelectGrou:

; 1129 : 				groundAction.actionType = GACTION_MINOROFFENSIVE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+283], 3
$LN21@SelectGrou:

; 1130 : 			groundAction.actionTime = TheCampaign.CurrentTime + ACTION_PREP_TIME;

	mov	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	add	eax, DWORD PTR ?ACTION_PREP_TIME@@3JA	; ACTION_PREP_TIME
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+267], eax

; 1131 : 			groundAction.actionTime = (int)(groundAction.actionTime/CampaignHours) * CampaignHours;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+267]
	xor	edx, edx
	mov	ecx, 3600000				; 0036ee80H
	div	ecx
	imul	eax, 3600000				; 0036ee80H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+267], eax

; 1132 : 			groundAction.actionTimeout = TheCampaign.CurrentTime + ACTION_TIMEOUT;

	mov	eax, DWORD PTR ?ActionTimeOut@@3HA	; ActionTimeOut
	imul	eax, 3600000				; 0036ee80H
	add	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+271], eax

; 1133 : 			groundAction.actionObjective = bo->Id();

	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _bo$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+275], ecx
	mov	DWORD PTR [eax+279], edx

; 1134 : 			groundAction.actionTempo = best/2;

	mov	eax, DWORD PTR _best$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+284], al

; 1135 : 			groundAction.actionPoints = (uchar) initiative;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+144]
	mov	BYTE PTR [edx+285], cl

; 1136 : 			sup = ((currentStats.groundVehs+currentStats.aircraft)*initiative)/1000;

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, WORD PTR [edx+156]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+154]
	add	eax, edx
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+144]
	imul	eax, edx
	cdq
	mov	ecx, 1000				; 000003e8H
	idiv	ecx
	mov	DWORD PTR _sup$[ebp], eax

; 1137 : 			if (supplyAvail < sup)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, WORD PTR [edx+146]
	cmp	eax, DWORD PTR _sup$[ebp]
	jge	SHORT $LN20@SelectGrou

; 1138 : 				supplyAvail = sup;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR _sup$[ebp]
	mov	WORD PTR [ecx+146], dx
$LN20@SelectGrou:

; 1139 : 			if (fuelAvail < sup)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+148]
	cmp	ecx, DWORD PTR _sup$[ebp]
	jge	SHORT $LN19@SelectGrou

; 1140 : 				fuelAvail = sup;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR _sup$[ebp]
	mov	WORD PTR [edx+148], ax
$LN19@SelectGrou:

; 1141 : 			// This is where we really cheat. We're going to add (initiative %) to both supply and strength.
; 1142 : 			StartOffensive(who, initiative);

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+144]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+348]
	push	ecx
	call	?StartOffensive@@YAXHH@Z		; StartOffensive
	add	esp, 8

; 1143 : 			//MakeTeamDirty (DIRTY_GROUND_ACTION, DDP[12].priority);
; 1144 : 			MakeTeamDirty (DIRTY_GROUND_ACTION, SEND_EVENTUALLY);

	push	1
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeTeamDirty@TeamClass@@QAEXW4Dirty_Team@@W4Dirtyness@@@Z ; TeamClass::MakeTeamDirty

; 1145 : 
; 1146 : 			// Now force a defensive action on our enemies
; 1147 : 			enemyAction.actionTime = groundAction.actionTime;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+267]
	mov	DWORD PTR _enemyAction$[ebp], eax

; 1148 : 			enemyAction.actionObjective = bo->Id();

	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	ecx, DWORD PTR _bo$[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _enemyAction$[ebp+8], edx
	mov	DWORD PTR _enemyAction$[ebp+12], eax

; 1149 : 			enemyAction.actionTempo = groundAction.actionTempo;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+284]
	mov	BYTE PTR _enemyAction$[ebp+17], dl

; 1150 : 			enemyAction.actionType = GACTION_DEFENSIVE;

	mov	BYTE PTR _enemyAction$[ebp+16], 1

; 1151 : 			enemyAction.actionTimeout = TheCampaign.CurrentTime + ACTION_TIMEOUT;

	mov	eax, DWORD PTR ?ActionTimeOut@@3HA	; ActionTimeOut
	imul	eax, 3600000				; 0036ee80H
	add	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	mov	DWORD PTR _enemyAction$[ebp+4], eax

; 1152 : 			enemyAction.actionPoints = 0;

	mov	BYTE PTR _enemyAction$[ebp+18], 0

; 1153 : 			for (t=0; t<NUM_TEAMS; t++)

	mov	BYTE PTR _t$[ebp], 0
	jmp	SHORT $LN18@SelectGrou
$LN17@SelectGrou:
	mov	cl, BYTE PTR _t$[ebp]
	add	cl, 1
	mov	BYTE PTR _t$[ebp], cl
$LN18@SelectGrou:
	movzx	edx, BYTE PTR _t$[ebp]
	cmp	edx, 8
	jge	$LN16@SelectGrou

; 1154 : 			{
; 1155 : 				if (GetRoE(who,t,ROE_GROUND_CAPTURE) == ROE_ALLOWED)

	push	3
	movzx	eax, BYTE PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+348]
	push	edx
	call	?GetRoE@@YAHEEH@Z			; GetRoE
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	jne	$LN15@SelectGrou

; 1156 : 				{
; 1157 : 					sup = ((TeamInfo[t]->GetCurrentStats()->groundVehs+TeamInfo[t]->GetCurrentStats()->aircraft)*TeamInfo[t]->GetInitiative())/1000;

	movzx	eax, BYTE PTR _t$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	call	?GetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::GetCurrentStats
	movzx	esi, WORD PTR [eax+4]
	movzx	ecx, BYTE PTR _t$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?GetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ; TeamClass::GetCurrentStats
	movzx	edx, WORD PTR [eax+2]
	add	esi, edx
	movzx	eax, BYTE PTR _t$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	call	?GetInitiative@TeamClass@@QAEFXZ	; TeamClass::GetInitiative
	movsx	ecx, ax
	imul	esi, ecx
	mov	eax, esi
	cdq
	mov	ecx, 1000				; 000003e8H
	idiv	ecx
	mov	DWORD PTR _sup$[ebp], eax

; 1158 : 					if (TeamInfo[t]->supplyAvail > sup)

	movzx	edx, BYTE PTR _t$[ebp]
	mov	eax, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	movzx	ecx, WORD PTR [eax+146]
	cmp	ecx, DWORD PTR _sup$[ebp]
	jle	SHORT $LN14@SelectGrou

; 1159 : 						TeamInfo[t]->supplyAvail = sup;

	movzx	edx, BYTE PTR _t$[ebp]
	mov	eax, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	mov	cx, WORD PTR _sup$[ebp]
	mov	WORD PTR [eax+146], cx
$LN14@SelectGrou:

; 1160 : 					if (TeamInfo[t]->fuelAvail > sup)

	movzx	edx, BYTE PTR _t$[ebp]
	mov	eax, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	movzx	ecx, WORD PTR [eax+148]
	cmp	ecx, DWORD PTR _sup$[ebp]
	jle	SHORT $LN13@SelectGrou

; 1161 : 						TeamInfo[t]->fuelAvail = sup;

	movzx	edx, BYTE PTR _t$[ebp]
	mov	eax, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[edx*4]
	mov	cx, WORD PTR _sup$[ebp]
	mov	WORD PTR [eax+148], cx
$LN13@SelectGrou:

; 1162 : 					TeamInfo[t]->SetGroundAction(&enemyAction);

	lea	edx, DWORD PTR _enemyAction$[ebp]
	push	edx
	movzx	eax, BYTE PTR _t$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	call	?SetGroundAction@TeamClass@@QAEXPAUTeamGndActionType@@@Z ; TeamClass::SetGroundAction
$LN15@SelectGrou:

; 1163 : 				}
; 1164 : 			}

	jmp	$LN17@SelectGrou
$LN16@SelectGrou:

; 1165 : 			return;

	jmp	$LN33@SelectGrou
$LN28@SelectGrou:

; 1166 : 		}
; 1167 : 	}
; 1168 : 
; 1169 : 	// If we're currently performing an action, check if it's still valid
; 1170 : 	if (groundAction.actionType != GACTION_CONSOLIDATE)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+283]
	cmp	edx, 2
	je	$LN12@SelectGrou

; 1171 : 	{
; 1172 : 		// Validate our current action
; 1173 : 		bo = (Objective) vuDatabase->Find(groundAction.actionObjective);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+279]
	push	ecx
	mov	edx, DWORD PTR [eax+275]
	push	edx
	mov	ecx, DWORD PTR ?vuDatabase@@3PAVVuDatabase@@A ; vuDatabase
	call	?Find@VuDatabase@@QBEPAVVuEntity@@VVU_ID@@@Z ; VuDatabase::Find
	mov	DWORD PTR _bo$[ebp], eax

; 1174 : 
; 1175 : 		// A.S. begin, 2001-12-09  if initiative < 40 then consolidate
; 1176 : 		if (NewInitiativePoints) {

	cmp	DWORD PTR ?NewInitiativePoints@@3HA, 0	; NewInitiativePoints
	je	SHORT $LN11@SelectGrou

; 1177 : 			if (groundAction.actionPoints && bo && initiative >= 40) 

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+285]
	test	ecx, ecx
	je	SHORT $LN10@SelectGrou
	cmp	DWORD PTR _bo$[ebp], 0
	je	SHORT $LN10@SelectGrou
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+144]
	cmp	eax, 40					; 00000028H
	jl	SHORT $LN10@SelectGrou

; 1178 : 				return;									// We've still got umph, or havn't started yet, and havn't captured our objective

	jmp	$LN33@SelectGrou
$LN10@SelectGrou:

; 1179 : 		}
; 1180 : 		else {		// *** old code ***

	jmp	SHORT $LN9@SelectGrou
$LN11@SelectGrou:

; 1181 : 			if (groundAction.actionPoints && bo) //  && GetRoE(who,bo->GetTeam(),ROE_GROUND_CAPTURE) == ROE_ALLOWED)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+285]
	test	edx, edx
	je	SHORT $LN9@SelectGrou
	cmp	DWORD PTR _bo$[ebp], 0
	je	SHORT $LN9@SelectGrou

; 1182 : 				return;									// We've still got umph, or havn't started yet, and havn't captured our objective

	jmp	$LN33@SelectGrou
$LN9@SelectGrou:

; 1183 : 		}
; 1184 : 		// end added section. This replaces(!) the section marked with +++ old code +++
; 1185 : 
; 1186 : 
; 1187 : 
; 1188 : 		if (groundAction.actionType == GACTION_DEFENSIVE)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+283]
	cmp	ecx, 1
	jne	SHORT $LN7@SelectGrou

; 1189 : 		{
; 1190 : 			// Validate enemy actions
; 1191 : 			for (t=0; t<NUM_TEAMS; t++)

	mov	BYTE PTR _t$[ebp], 0
	jmp	SHORT $LN6@SelectGrou
$LN5@SelectGrou:
	mov	dl, BYTE PTR _t$[ebp]
	add	dl, 1
	mov	BYTE PTR _t$[ebp], dl
$LN6@SelectGrou:
	movzx	eax, BYTE PTR _t$[ebp]
	cmp	eax, 8
	jge	SHORT $LN4@SelectGrou

; 1192 : 			{
; 1193 : 				if (GetRoE(t,who,ROE_GROUND_CAPTURE) == ROE_ALLOWED && (TeamInfo[t]->GetGroundActionType() == GACTION_OFFENSIVE || TeamInfo[t]->GetGroundActionType() == GACTION_MINOROFFENSIVE))

	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+348]
	push	edx
	movzx	eax, BYTE PTR _t$[ebp]
	push	eax
	call	?GetRoE@@YAHEEH@Z			; GetRoE
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	jne	SHORT $LN3@SelectGrou
	movzx	ecx, BYTE PTR _t$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	call	?GetGroundActionType@TeamClass@@QAEEXZ	; TeamClass::GetGroundActionType
	movzx	edx, al
	cmp	edx, 4
	je	SHORT $LN2@SelectGrou
	movzx	eax, BYTE PTR _t$[ebp]
	mov	ecx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4]
	call	?GetGroundActionType@TeamClass@@QAEEXZ	; TeamClass::GetGroundActionType
	movzx	ecx, al
	cmp	ecx, 3
	jne	SHORT $LN3@SelectGrou
$LN2@SelectGrou:

; 1194 : 					return;

	jmp	SHORT $LN33@SelectGrou
$LN3@SelectGrou:

; 1195 : 			}

	jmp	SHORT $LN5@SelectGrou
$LN4@SelectGrou:

; 1196 : 		}
; 1197 : 		else

	jmp	SHORT $LN12@SelectGrou
$LN7@SelectGrou:

; 1198 : 		{
; 1199 : 			// We've captured/completed our goal. Reset timeout
; 1200 : 			groundAction.actionTimeout = TheCampaign.CurrentTime;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	mov	DWORD PTR [edx+271], eax
$LN12@SelectGrou:

; 1201 : 		}
; 1202 : 	}
; 1203 : 
; 1204 : 	// Otherwise, nothing is going on currently (we're not attacking or being attacked.
; 1205 : 	// Go to a consolidation action until we decide to go on the offensive, or are forced onto the 
; 1206 : 	// defensive by an enemy offensive.
; 1207 : 	groundAction.actionType = GACTION_CONSOLIDATE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+283], 2

; 1208 : 	groundAction.actionTime = TheCampaign.CurrentTime;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	mov	DWORD PTR [edx+267], eax

; 1209 : 	groundAction.actionObjective = FalconNullId;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR [ecx+275], edx
	mov	eax, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR [ecx+279], eax

; 1210 : 	groundAction.actionTempo = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+284], 0

; 1211 : 	groundAction.actionPoints = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+285], 0

; 1212 : 	//MakeTeamDirty (DIRTY_GROUND_ACTION, DDP[13].priority);
; 1213 : 	MakeTeamDirty (DIRTY_GROUND_ACTION, SEND_EVENTUALLY);

	push	1
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeTeamDirty@TeamClass@@QAEXW4Dirty_Team@@W4Dirtyness@@@Z ; TeamClass::MakeTeamDirty
$LN33@SelectGrou:

; 1214 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SelectGroundAction@TeamClass@@QAEXXZ$0:
	lea	ecx, DWORD PTR _poit$4[ebp]
	jmp	??1VuListIterator@@UAE@XZ		; VuListIterator::~VuListIterator
__ehhandler$?SelectGroundAction@TeamClass@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SelectGroundAction@TeamClass@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?SelectGroundAction@TeamClass@@QAEXXZ ENDP		; TeamClass::SelectGroundAction
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\team.h
;	COMDAT ?GetGroundActionType@TeamClass@@QAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGroundActionType@TeamClass@@QAEEXZ PROC		; TeamClass::GetGroundActionType, COMDAT
; _this$ = ecx

; 335  : 	uchar GetGroundActionType (void)			{ return groundAction.actionType; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+283]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetGroundActionType@TeamClass@@QAEEXZ ENDP		; TeamClass::GetGroundActionType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMotto@TeamClass@@QAEPADXZ PROC			; TeamClass::GetMotto
; _this$ = ecx

; 1070 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1071 : 	return teamMotto;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 372				; 00000174H

; 1072 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMotto@TeamClass@@QAEPADXZ ENDP			; TeamClass::GetMotto
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newmotto$ = 8						; size = 4
?SetMotto@TeamClass@@QAEXPAD@Z PROC			; TeamClass::SetMotto
; _this$ = ecx

; 1065 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1066 : 	strncpy (teamMotto, newmotto, MAX_MOTTO_SIZE);

	push	200					; 000000c8H
	mov	eax, DWORD PTR _newmotto$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 372				; 00000174H
	push	ecx
	call	_strncpy
	add	esp, 12					; 0000000cH

; 1067 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetMotto@TeamClass@@QAEXPAD@Z ENDP			; TeamClass::SetMotto
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\team.h
;	COMDAT ?GetFlag@TeamClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFlag@TeamClass@@QAEHXZ PROC				; TeamClass::GetFlag, COMDAT
; _this$ = ecx

; 327  : 	int GetFlag (void)							{ return (int) teamFlag; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax+888]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFlag@TeamClass@@QAEHXZ ENDP				; TeamClass::GetFlag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetName@TeamClass@@QAEPADXZ PROC			; TeamClass::GetName
; _this$ = ecx

; 1060 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1061 : 	return name;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 352				; 00000160H

; 1062 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetName@TeamClass@@QAEPADXZ ENDP			; TeamClass::GetName
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newname$ = 8						; size = 4
?SetName@TeamClass@@QAEXPAD@Z PROC			; TeamClass::SetName
; _this$ = ecx

; 1055 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1056 : 	strncpy (name, newname, MAX_TEAM_NAME_SIZE);

	push	20					; 00000014H
	mov	eax, DWORD PTR _newname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 352				; 00000160H
	push	ecx
	call	_strncpy
	add	esp, 12					; 0000000cH

; 1057 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetName@TeamClass@@QAEXPAD@Z ENDP			; TeamClass::SetName
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
$T2 = -84						; size = 4
$T3 = -80						; size = 4
$T4 = -76						; size = 4
$T5 = -72						; size = 4
_event$6 = -68						; size = 4
tv224 = -64						; size = 4
$T7 = -60						; size = 4
_event$8 = -56						; size = 4
tv193 = -52						; size = 4
$T9 = -48						; size = 4
_event$10 = -44						; size = 4
tv162 = -40						; size = 4
$T11 = -36						; size = 4
_event$ = -32						; size = 4
tv131 = -28						; size = 4
$T12 = -24						; size = 4
tv80 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_target$ = 8						; size = 4
?DoFullUpdate@TeamClass@@QAEXPAVVuTargetEntity@@@Z PROC	; TeamClass::DoFullUpdate
; _this$ = ecx

; 931  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DoFullUpdate@TeamClass@@QAEXPAVVuTargetEntity@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 932  : 	if (!target)

	cmp	DWORD PTR _target$[ebp], 0
	jne	SHORT $LN4@DoFullUpda

; 933  : 		target = FalconLocalGame;

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@DoFullUpda
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv80[ebp], eax
	jmp	SHORT $LN8@DoFullUpda
$LN7@DoFullUpda:
	mov	DWORD PTR tv80[ebp], 0
$LN8@DoFullUpda:
	mov	ecx, DWORD PTR tv80[ebp]
	mov	DWORD PTR _target$[ebp], ecx
$LN4@DoFullUpda:

; 934  : 	VuEvent *event = new VuFullUpdateEvent(this, target);

	push	68					; 00000044H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T12[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T12[ebp], 0
	je	SHORT $LN9@DoFullUpda
	push	0
	mov	edx, DWORD PTR _target$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T12[ebp]
	call	??0VuFullUpdateEvent@@QAE@PAVVuEntity@@PAVVuTargetEntity@@E@Z ; VuFullUpdateEvent::VuFullUpdateEvent
	mov	DWORD PTR tv131[ebp], eax
	jmp	SHORT $LN10@DoFullUpda
$LN9@DoFullUpda:
	mov	DWORD PTR tv131[ebp], 0
$LN10@DoFullUpda:
	mov	ecx, DWORD PTR tv131[ebp]
	mov	DWORD PTR $T5[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T5[ebp]
	mov	DWORD PTR _event$[ebp], edx

; 935  : 	event->RequestReliableTransmit();

	mov	ecx, DWORD PTR _event$[ebp]
	call	?RequestReliableTransmit@VuMessage@@QAEXXZ ; VuMessage::RequestReliableTransmit

; 936  : 	VuMessageQueue::PostVuMessage(event);

	mov	eax, DWORD PTR _event$[ebp]
	push	eax
	call	?PostVuMessage@VuMessageQueue@@SAHPAVVuMessage@@@Z ; VuMessageQueue::PostVuMessage
	add	esp, 4

; 937  : 	if (atm)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+876], 0
	je	SHORT $LN3@DoFullUpda

; 938  : 	{
; 939  : 		VuEvent *event = new VuFullUpdateEvent(atm, target);

	push	68					; 00000044H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T11[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T11[ebp], 0
	je	SHORT $LN11@DoFullUpda
	push	0
	mov	edx, DWORD PTR _target$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+876]
	push	ecx
	mov	ecx, DWORD PTR $T11[ebp]
	call	??0VuFullUpdateEvent@@QAE@PAVVuEntity@@PAVVuTargetEntity@@E@Z ; VuFullUpdateEvent::VuFullUpdateEvent
	mov	DWORD PTR tv162[ebp], eax
	jmp	SHORT $LN12@DoFullUpda
$LN11@DoFullUpda:
	mov	DWORD PTR tv162[ebp], 0
$LN12@DoFullUpda:
	mov	edx, DWORD PTR tv162[ebp]
	mov	DWORD PTR $T4[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR _event$10[ebp], eax

; 940  : 		event->RequestReliableTransmit();

	mov	ecx, DWORD PTR _event$10[ebp]
	call	?RequestReliableTransmit@VuMessage@@QAEXXZ ; VuMessage::RequestReliableTransmit

; 941  : 		VuMessageQueue::PostVuMessage(event);

	mov	ecx, DWORD PTR _event$10[ebp]
	push	ecx
	call	?PostVuMessage@VuMessageQueue@@SAHPAVVuMessage@@@Z ; VuMessageQueue::PostVuMessage
	add	esp, 4
$LN3@DoFullUpda:

; 942  : 	}
; 943  : 	if (gtm)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+880], 0
	je	SHORT $LN2@DoFullUpda

; 944  : 	{
; 945  : 		VuEvent *event = new VuFullUpdateEvent(gtm, target);

	push	68					; 00000044H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T9[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T9[ebp], 0
	je	SHORT $LN13@DoFullUpda
	push	0
	mov	eax, DWORD PTR _target$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+880]
	push	edx
	mov	ecx, DWORD PTR $T9[ebp]
	call	??0VuFullUpdateEvent@@QAE@PAVVuEntity@@PAVVuTargetEntity@@E@Z ; VuFullUpdateEvent::VuFullUpdateEvent
	mov	DWORD PTR tv193[ebp], eax
	jmp	SHORT $LN14@DoFullUpda
$LN13@DoFullUpda:
	mov	DWORD PTR tv193[ebp], 0
$LN14@DoFullUpda:
	mov	eax, DWORD PTR tv193[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR _event$8[ebp], ecx

; 946  : 		event->RequestReliableTransmit();

	mov	ecx, DWORD PTR _event$8[ebp]
	call	?RequestReliableTransmit@VuMessage@@QAEXXZ ; VuMessage::RequestReliableTransmit

; 947  : 		VuMessageQueue::PostVuMessage(event);

	mov	edx, DWORD PTR _event$8[ebp]
	push	edx
	call	?PostVuMessage@VuMessageQueue@@SAHPAVVuMessage@@@Z ; VuMessageQueue::PostVuMessage
	add	esp, 4
$LN2@DoFullUpda:

; 948  : 	}
; 949  : 	if (ntm)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+884], 0
	je	SHORT $LN5@DoFullUpda

; 950  : 	{
; 951  : 		VuEvent *event = new VuFullUpdateEvent(ntm, target);

	push	68					; 00000044H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	cmp	DWORD PTR $T7[ebp], 0
	je	SHORT $LN15@DoFullUpda
	push	0
	mov	ecx, DWORD PTR _target$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+884]
	push	eax
	mov	ecx, DWORD PTR $T7[ebp]
	call	??0VuFullUpdateEvent@@QAE@PAVVuEntity@@PAVVuTargetEntity@@E@Z ; VuFullUpdateEvent::VuFullUpdateEvent
	mov	DWORD PTR tv224[ebp], eax
	jmp	SHORT $LN16@DoFullUpda
$LN15@DoFullUpda:
	mov	DWORD PTR tv224[ebp], 0
$LN16@DoFullUpda:
	mov	ecx, DWORD PTR tv224[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _event$6[ebp], edx

; 952  : 		event->RequestReliableTransmit();

	mov	ecx, DWORD PTR _event$6[ebp]
	call	?RequestReliableTransmit@VuMessage@@QAEXXZ ; VuMessage::RequestReliableTransmit

; 953  : 		VuMessageQueue::PostVuMessage(event);

	mov	eax, DWORD PTR _event$6[ebp]
	push	eax
	call	?PostVuMessage@VuMessageQueue@@SAHPAVVuMessage@@@Z ; VuMessageQueue::PostVuMessage
	add	esp, 4
$LN5@DoFullUpda:

; 954  : 	}
; 955  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?DoFullUpdate@TeamClass@@QAEXPAVVuTargetEntity@@@Z$0:
	mov	eax, DWORD PTR $T12[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?DoFullUpdate@TeamClass@@QAEXPAVVuTargetEntity@@@Z$1:
	mov	eax, DWORD PTR $T11[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?DoFullUpdate@TeamClass@@QAEXPAVVuTargetEntity@@@Z$2:
	mov	eax, DWORD PTR $T9[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?DoFullUpdate@TeamClass@@QAEXPAVVuTargetEntity@@@Z$3:
	mov	eax, DWORD PTR $T7[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?DoFullUpdate@TeamClass@@QAEXPAVVuTargetEntity@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DoFullUpdate@TeamClass@@QAEXPAVVuTargetEntity@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoFullUpdate@TeamClass@@QAEXPAVVuTargetEntity@@@Z ENDP	; TeamClass::DoFullUpdate
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Dump@TeamClass@@QAEXXZ PROC				; TeamClass::Dump
; _this$ = ecx

; 925  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 926  : 	//	MonoPrint("%d    %5.5d  %4.4d   %4.4d   %4.4d   %4.4d",who,combatPower,airDefense,airPower,groundPower,navalPower);
; 927  : 	//	MonoPrint("   %3.3d  %3.3d  %3.3d  %3.3d  %3.3d  %3.3d  %3.3d\n",supply,fuel,satelites,transportNet,morale,experience,production);
; 928  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Dump@TeamClass@@QAEXXZ ENDP				; TeamClass::Dump
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DumpHeader@TeamClass@@QAEXXZ PROC			; TeamClass::DumpHeader
; _this$ = ecx

; 920  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 921  : 	MonoPrint("Team CbtPow ADPow  AirPow GndPow NvlPow Sup  Fuel Sats  Tran Mrle Exp  Prod\n");

	push	OFFSET ??_C@_0EN@PKKGELNA@Team?5CbtPow?5ADPow?5?5AirPow?5GndPow@
	call	_MonoPrint
	add	esp, 4

; 922  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DumpHeader@TeamClass@@QAEXXZ ENDP			; TeamClass::DumpHeader
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_act$ = 8						; size = 4
?SetActive@TeamClass@@QAEXH@Z PROC			; TeamClass::SetActive
; _this$ = ecx

; 913  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 	flags |= TEAM_ACTIVE;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+350]
	or	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+350], cx

; 915  : 	if (!act)

	cmp	DWORD PTR _act$[ebp], 0
	jne	SHORT $LN2@SetActive

; 916  : 		flags ^= TEAM_ACTIVE;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+350]
	xor	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+350], cx
$LN2@SetActive:

; 917  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetActive@TeamClass@@QAEXH@Z ENDP			; TeamClass::SetActive
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_this$ = -52						; size = 4
_fp$ = -48						; size = 4
_tmpStr$ = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
?ReadDoctrineFile@TeamClass@@QAEXXZ PROC		; TeamClass::ReadDoctrineFile
; _this$ = ecx

; 854  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 855  : 	FILE		*fp;
; 856  : 	char		tmpStr[40];
; 857  : 
; 858  : 	sprintf (tmpStr, "doctrine%d", who);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+348]
	push	ecx
	push	OFFSET ??_C@_0L@FIIMKNHK@doctrine?$CFd?$AA@
	lea	edx, DWORD PTR _tmpStr$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 859  : 	fp = OpenCampFile(tmpStr,"txt","r");

	push	OFFSET ??_C@_01KDCPPGHE@r?$AA@
	push	OFFSET ??_C@_03CLFHJCDC@txt?$AA@
	lea	eax, DWORD PTR _tmpStr$[ebp]
	push	eax
	call	?OpenCampFile@@YAPAU_iobuf@@PAD00@Z	; OpenCampFile
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fp$[ebp], eax

; 860  : 	doctrine.simFlags = atoi(CampGetNext (fp));

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	?CampGetNext@@YAPADPAU_iobuf@@@Z	; CampGetNext
	add	esp, 4
	push	eax
	call	_atoi
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+892], eax

; 861  : 	doctrine.radarShootShootPct = (float)atof (CampGetNext (fp));

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	?CampGetNext@@YAPADPAU_iobuf@@@Z	; CampGetNext
	add	esp, 4
	push	eax
	call	_atof
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+896]

; 862  : 	doctrine.heatShootShootPct  = (float)atof (CampGetNext (fp));

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	?CampGetNext@@YAPADPAU_iobuf@@@Z	; CampGetNext
	add	esp, 4
	push	eax
	call	_atof
	add	esp, 4
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+900]

; 863  : 	CloseCampFile(fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	?CloseCampFile@@YAXPAU_iobuf@@@Z	; CloseCampFile
	add	esp, 4

; 864  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadDoctrineFile@TeamClass@@QAEXXZ ENDP		; TeamClass::ReadDoctrineFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_retval$ = -4						; size = 4
_file$ = 8						; size = 4
?Save@TeamClass@@UAEHPAU_iobuf@@@Z PROC			; TeamClass::Save
; _this$ = ecx

; 793  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 794  : 	int retval = 0;

	mov	DWORD PTR _retval$[ebp], 0

; 795  : 
; 796  : 	if (file) 

	cmp	DWORD PTR _file$[ebp], 0
	je	$LN1@Save

; 797  : 	{
; 798  : 		// Write vu stuff here
; 799  : 		retval += fwrite(&share_.id_, sizeof(VU_ID), 1, file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	1
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	call	_fwrite
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax

; 800  : 		retval += fwrite(&share_.entityType_, sizeof(ushort), 1, file);

	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	push	1
	push	2
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	call	_fwrite
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax

; 801  : 
; 802  : 		retval += fwrite(&who, sizeof(Team), 1, file);						

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	push	1
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 348				; 0000015cH
	push	edx
	call	_fwrite
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax

; 803  : 		retval += fwrite(&cteam, sizeof(Team), 1, file);						

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	1
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 349				; 0000015dH
	push	ecx
	call	_fwrite
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax

; 804  : 		retval += fwrite(&flags, sizeof(short), 1, file);					

	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	push	1
	push	2
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 350				; 0000015eH
	push	eax
	call	_fwrite
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax

; 805  : 		retval += fwrite(member, sizeof(uchar), NUM_COUNS, file);

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	push	8
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 572				; 0000023cH
	push	edx
	call	_fwrite
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax

; 806  : 		retval += fwrite(stance, sizeof(short), NUM_TEAMS, file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	8
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 580				; 00000244H
	push	ecx
	call	_fwrite
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax

; 807  : 		retval += fwrite(&firstColonel, sizeof(short), 1, file);			

	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	push	1
	push	2
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 596				; 00000254H
	push	eax
	call	_fwrite
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax

; 808  : 		retval += fwrite(&firstCommander, sizeof(short), 1, file);			

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	push	1
	push	2
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 598				; 00000256H
	push	edx
	call	_fwrite
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax

; 809  : 		retval += fwrite(&firstWingman, sizeof(short), 1, file);			

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	1
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 600				; 00000258H
	push	ecx
	call	_fwrite
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax

; 810  : 		retval += fwrite(&lastWingman, sizeof(short), 1, file);			

	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	push	1
	push	2
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 602				; 0000025aH
	push	eax
	call	_fwrite
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax

; 811  : 		retval += fwrite(&airExperience, sizeof(uchar), 1, file);		

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	push	1
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 612				; 00000264H
	push	edx
	call	_fwrite
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax

; 812  : 		retval += fwrite(&airDefenseExperience, sizeof(uchar), 1, file);		

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	1
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 613				; 00000265H
	push	ecx
	call	_fwrite
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax

; 813  : 		retval += fwrite(&groundExperience, sizeof(uchar), 1, file);		

	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	push	1
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 614				; 00000266H
	push	eax
	call	_fwrite
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax

; 814  : 		retval += fwrite(&navalExperience, sizeof(uchar), 1, file);		

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	push	1
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 615				; 00000267H
	push	edx
	call	_fwrite
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax

; 815  : 		retval += fwrite(&initiative, sizeof(short), 1, file);		

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	1
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 144				; 00000090H
	push	ecx
	call	_fwrite
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax

; 816  : 		retval += fwrite(&supplyAvail, sizeof(ushort), 1, file);				

	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	push	1
	push	2
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 146				; 00000092H
	push	eax
	call	_fwrite
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax

; 817  : 		retval += fwrite(&fuelAvail, sizeof(ushort), 1, file);				

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	push	1
	push	2
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 148				; 00000094H
	push	edx
	call	_fwrite
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax

; 818  : 		retval += fwrite(&replacementsAvail, sizeof(ushort), 1, file);	

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	1
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 150				; 00000096H
	push	ecx
	call	_fwrite
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax

; 819  : 		retval += fwrite(&playerRating, sizeof(float), 1, file);	

	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	push	1
	push	4
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 604				; 0000025cH
	push	eax
	call	_fwrite
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax

; 820  : 		retval += fwrite(&lastPlayerMission, sizeof(CampaignTime), 1, file);	

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	push	1
	push	4
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 608				; 00000260H
	push	edx
	call	_fwrite
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax

; 821  : 		retval += fwrite(&currentStats, sizeof(TeamStatusType), 1, file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	1
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 152				; 00000098H
	push	ecx
	call	_fwrite
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax

; 822  : 		retval += fwrite(&startStats, sizeof(TeamStatusType), 1, file);

	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	push	1
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 616				; 00000268H
	push	eax
	call	_fwrite
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax

; 823  : 		retval += fwrite(&reinforcement, sizeof(short), 1, file);			

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	push	1
	push	2
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 168				; 000000a8H
	push	edx
	call	_fwrite
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax

; 824  : #ifdef CAMPTOOL
; 825  : 		if (gRenameIds)
; 826  : 		{
; 827  : 			for (int i=0; i<MAX_BONUSES; i++)
; 828  : 				bonusObjs[i].num_ = RenameTable[bonusObjs[i].num_];
; 829  : 		}
; 830  : #endif
; 831  : 		retval += fwrite(bonusObjs, sizeof(VU_ID), MAX_BONUSES, file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	20					; 00000014H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 632				; 00000278H
	push	ecx
	call	_fwrite
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax

; 832  : 		retval += fwrite(bonusTime, sizeof(CampaignTime), MAX_BONUSES, file);

	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	push	20					; 00000014H
	push	4
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 792				; 00000318H
	push	eax
	call	_fwrite
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax

; 833  : 		retval += fwrite(objtype_priority, sizeof(uchar), MAX_TGTTYPE, file);	

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	push	36					; 00000024H
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 170				; 000000aaH
	push	edx
	call	_fwrite
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax

; 834  : 		retval += fwrite(unittype_priority, sizeof(uchar), MAX_UNITTYPE, file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	20					; 00000014H
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 206				; 000000ceH
	push	ecx
	call	_fwrite
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax

; 835  : 		retval += fwrite(mission_priority, sizeof(uchar), AMIS_OTHER, file);	

	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	push	41					; 00000029H
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 226				; 000000e2H
	push	eax
	call	_fwrite
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax

; 836  : 		retval += fwrite(max_vehicle, sizeof(uchar), 4, file);				

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	push	4
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 872				; 00000368H
	push	edx
	call	_fwrite
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax

; 837  : 		retval += fwrite(&teamFlag, sizeof(uchar), 1, file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	1
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 888				; 00000378H
	push	ecx
	call	_fwrite
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax

; 838  : 		retval += fwrite(&teamColor, sizeof(uchar), 1, file);

	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	push	1
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 889				; 00000379H
	push	eax
	call	_fwrite
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax

; 839  : 		retval += fwrite(&equipment, sizeof(uchar), 1, file);

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	push	1
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 890				; 0000037aH
	push	edx
	call	_fwrite
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax

; 840  : 		retval += fwrite(name, sizeof(_TCHAR)*MAX_TEAM_NAME_SIZE, 1, file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	1
	push	20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 352				; 00000160H
	push	ecx
	call	_fwrite
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax

; 841  : 		retval += fwrite(teamMotto, sizeof(_TCHAR)*MAX_MOTTO_SIZE, 1, file);

	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	push	1
	push	200					; 000000c8H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 372				; 00000174H
	push	eax
	call	_fwrite
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax

; 842  : 		retval += fwrite(&groundAction, sizeof(TeamGndActionType), 1, file);

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	push	1
	push	19					; 00000013H
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 267				; 0000010bH
	push	edx
	call	_fwrite
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax

; 843  : 		retval += fwrite(&defensiveAirAction, sizeof(TeamAirActionType), 1, file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	1
	push	28					; 0000001cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 288				; 00000120H
	push	ecx
	call	_fwrite
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax

; 844  : 		retval += fwrite(&offensiveAirAction, sizeof(TeamAirActionType), 1, file);

	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	push	1
	push	28					; 0000001cH
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 316				; 0000013cH
	push	eax
	call	_fwrite
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax

; 845  : 		retval += atm->Save(file);

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+876]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+876]
	mov	eax, DWORD PTR [edx+32]
	call	eax
	add	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax

; 846  : 		retval += gtm->Save(file);

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+880]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+880]
	mov	eax, DWORD PTR [edx+32]
	call	eax
	add	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax

; 847  : 		retval += ntm->Save(file);

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+884]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+884]
	mov	eax, DWORD PTR [edx+32]
	call	eax
	add	eax, DWORD PTR _retval$[ebp]
	mov	DWORD PTR _retval$[ebp], eax
$LN1@Save:

; 848  : 	}
; 849  : 	return retval;

	mov	eax, DWORD PTR _retval$[ebp]

; 850  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Save@TeamClass@@UAEHPAU_iobuf@@@Z ENDP			; TeamClass::Save
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
$T1 = -36						; size = 8
$T2 = -28						; size = 8
$T3 = -20						; size = 8
_tmpID$ = -12						; size = 8
_this$ = -4						; size = 4
_stream$ = 8						; size = 4
?Save@TeamClass@@UAEHPAPAE@Z PROC			; TeamClass::Save
; _this$ = ecx

; 712  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 713  : 	VU_ID			tmpID;

	lea	ecx, DWORD PTR _tmpID$[ebp]
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID

; 714  : 
; 715  : 	// Write vu stuff here
; 716  : 	memcpy(*stream, &share_.id_, sizeof(VU_ID));						*stream += sizeof(VU_ID);

	push	8
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], ecx

; 717  : 	memcpy(*stream, &share_.ownerId_, sizeof(VU_ID));					*stream += sizeof(VU_ID);

	push	8
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], ecx

; 718  : 	memcpy(*stream, &share_.entityType_, sizeof(ushort));				*stream += sizeof(ushort);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 2
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], ecx

; 719  : 
; 720  : 	memcpy(*stream, &who, sizeof(Team));								*stream += sizeof(Team);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 348				; 0000015cH
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], ecx

; 721  : 	memcpy(*stream, &cteam, sizeof(Team));								*stream += sizeof(Team);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 349				; 0000015dH
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], ecx

; 722  : 	memcpy(*stream, &flags, sizeof(short));								*stream += sizeof(short);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 350				; 0000015eH
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 2
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], ecx

; 723  : 	memcpy(*stream, member, sizeof(uchar)*NUM_COUNS);					*stream += sizeof(uchar)*NUM_COUNS;

	push	8
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 572				; 0000023cH
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], ecx

; 724  : 	memcpy(*stream, stance, sizeof(short)*NUM_TEAMS);					*stream += sizeof(short)*NUM_TEAMS;

	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 580				; 00000244H
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], ecx

; 725  : 	memcpy(*stream, &firstColonel, sizeof(short));						*stream += sizeof(short);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 596				; 00000254H
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 2
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], ecx

; 726  : 	memcpy(*stream, &firstCommander, sizeof(short));					*stream += sizeof(short);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 598				; 00000256H
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 2
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], ecx

; 727  : 	memcpy(*stream, &firstWingman, sizeof(short));						*stream += sizeof(short);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 600				; 00000258H
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 2
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], ecx

; 728  : 	memcpy(*stream, &lastWingman, sizeof(short));						*stream += sizeof(short);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 602				; 0000025aH
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 2
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], ecx

; 729  : 	memcpy(*stream, &airExperience, sizeof(uchar));						*stream += sizeof(uchar);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 612				; 00000264H
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], ecx

; 730  : 	memcpy(*stream, &airDefenseExperience, sizeof(uchar));				*stream += sizeof(uchar);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 613				; 00000265H
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], ecx

; 731  : 	memcpy(*stream, &groundExperience, sizeof(uchar));					*stream += sizeof(uchar);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 614				; 00000266H
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], ecx

; 732  : 	memcpy(*stream, &navalExperience, sizeof(uchar));					*stream += sizeof(uchar);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 615				; 00000267H
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], ecx

; 733  : 	memcpy(*stream, &initiative, sizeof(short));						*stream += sizeof(short);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 144				; 00000090H
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 2
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], ecx

; 734  : 	memcpy(*stream, &supplyAvail, sizeof(ushort));						*stream += sizeof(ushort);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 146				; 00000092H
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 2
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], ecx

; 735  : 	memcpy(*stream, &fuelAvail, sizeof(ushort));						*stream += sizeof(ushort);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 148				; 00000094H
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 2
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], ecx

; 736  : 	memcpy(*stream, &replacementsAvail, sizeof(ushort));				*stream += sizeof(ushort);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 150				; 00000096H
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 2
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], ecx

; 737  : 	memcpy(*stream, &playerRating, sizeof(float));						*stream += sizeof(float);

	push	4
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 604				; 0000025cH
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], ecx

; 738  : 	memcpy(*stream, &lastPlayerMission, sizeof(CampaignTime));			*stream += sizeof(CampaignTime);

	push	4
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 608				; 00000260H
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], ecx

; 739  : 	memcpy(*stream, &currentStats, sizeof(TeamStatusType));				*stream += sizeof(TeamStatusType);

	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 152				; 00000098H
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], ecx

; 740  : 	memcpy(*stream, &startStats, sizeof(TeamStatusType));				*stream += sizeof(TeamStatusType);

	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 616				; 00000268H
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], ecx

; 741  : 	memcpy(*stream, &reinforcement, sizeof(short));						*stream += sizeof(short);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 168				; 000000a8H
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 2
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], ecx

; 742  : 	memcpy(*stream, bonusObjs, sizeof(VU_ID)*MAX_BONUSES);				*stream += sizeof(VU_ID)*MAX_BONUSES;

	push	160					; 000000a0H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 632				; 00000278H
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 160				; 000000a0H
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], ecx

; 743  : 	memcpy(*stream, bonusTime, sizeof(CampaignTime)*MAX_BONUSES);		*stream += sizeof(CampaignTime)*MAX_BONUSES;

	push	80					; 00000050H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 792				; 00000318H
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 80					; 00000050H
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], ecx

; 744  : 	memcpy(*stream, objtype_priority, sizeof(uchar)*MAX_TGTTYPE);		*stream += sizeof(uchar)*MAX_TGTTYPE;

	push	36					; 00000024H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 170				; 000000aaH
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 36					; 00000024H
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], ecx

; 745  : 	memcpy(*stream, unittype_priority, sizeof(uchar)*MAX_UNITTYPE);		*stream += sizeof(uchar)*MAX_UNITTYPE;

	push	20					; 00000014H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 206				; 000000ceH
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], ecx

; 746  : 	memcpy(*stream, mission_priority, sizeof(uchar)*AMIS_OTHER);		*stream += sizeof(uchar)*AMIS_OTHER;

	push	41					; 00000029H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 226				; 000000e2H
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 41					; 00000029H
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], ecx

; 747  : 	memcpy(*stream, max_vehicle, sizeof(uchar)*4);						*stream += sizeof(uchar)*4;

	push	4
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 872				; 00000368H
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], ecx

; 748  : 	memcpy(*stream, &teamFlag, sizeof(uchar));							*stream += sizeof(uchar);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 888				; 00000378H
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], ecx

; 749  : 	memcpy(*stream, &teamColor, sizeof(uchar));							*stream += sizeof(uchar);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 889				; 00000379H
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], ecx

; 750  : 	memcpy(*stream, &equipment, sizeof(uchar));							*stream += sizeof(uchar);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 890				; 0000037aH
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], ecx

; 751  : 	memcpy(*stream, name, sizeof(_TCHAR)*MAX_TEAM_NAME_SIZE);			*stream += sizeof(_TCHAR)*MAX_TEAM_NAME_SIZE;

	push	20					; 00000014H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 352				; 00000160H
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], ecx

; 752  : 	memcpy(*stream, teamMotto, sizeof(_TCHAR)*MAX_MOTTO_SIZE);			*stream += sizeof(_TCHAR)*MAX_MOTTO_SIZE;

	push	200					; 000000c8H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 372				; 00000174H
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 200				; 000000c8H
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], ecx

; 753  : 	memcpy(*stream, &groundAction, sizeof(TeamGndActionType));			*stream += sizeof(TeamGndActionType);

	push	19					; 00000013H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 267				; 0000010bH
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 19					; 00000013H
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], ecx

; 754  : 	memcpy(*stream, &defensiveAirAction, sizeof(TeamAirActionType));	*stream += sizeof(TeamAirActionType);

	push	28					; 0000001cH
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 288				; 00000120H
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], ecx

; 755  : 	memcpy(*stream, &offensiveAirAction, sizeof(TeamAirActionType));	*stream += sizeof(TeamAirActionType);

	push	28					; 0000001cH
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 316				; 0000013cH
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], ecx

; 756  : 
; 757  : 	// Send our managersz
; 758  : 	if (atm)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+876], 0
	je	SHORT $LN6@Save

; 759  : 	{
; 760  : 		tmpID = atm->Id();

	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+876]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _tmpID$[ebp], ecx
	mov	DWORD PTR _tmpID$[ebp+4], edx

; 761  : 	}
; 762  : 	else

	jmp	SHORT $LN5@Save
$LN6@Save:

; 763  : 	{
; 764  : 		tmpID = FalconNullId;

	mov	eax, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR _tmpID$[ebp], eax
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR _tmpID$[ebp+4], ecx
$LN5@Save:

; 765  : 	}
; 766  : 
; 767  : 	memcpy(*stream, &tmpID, sizeof(VU_ID));								*stream += sizeof(VU_ID);

	push	8
	lea	edx, DWORD PTR _tmpID$[ebp]
	push	edx
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 8
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx], eax

; 768  : 	if (gtm)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+880], 0
	je	SHORT $LN4@Save

; 769  : 	{
; 770  : 		tmpID = gtm->Id();

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+880]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _tmpID$[ebp], edx
	mov	DWORD PTR _tmpID$[ebp+4], eax

; 771  : 	}
; 772  : 	else

	jmp	SHORT $LN3@Save
$LN4@Save:

; 773  : 	{
; 774  : 		tmpID = FalconNullId;

	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR _tmpID$[ebp], ecx
	mov	edx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR _tmpID$[ebp+4], edx
$LN3@Save:

; 775  : 	}
; 776  : 
; 777  : 	memcpy(*stream, &tmpID, sizeof(VU_ID));								*stream += sizeof(VU_ID);

	push	8
	lea	eax, DWORD PTR _tmpID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	mov	edx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [edx], ecx

; 778  : 	if (ntm)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+884], 0
	je	SHORT $LN2@Save

; 779  : 	{
; 780  : 		tmpID = ntm->Id();

	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+884]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _tmpID$[ebp], ecx
	mov	DWORD PTR _tmpID$[ebp+4], edx

; 781  : 	}
; 782  : 	else

	jmp	SHORT $LN1@Save
$LN2@Save:

; 783  : 	{
; 784  : 		tmpID = FalconNullId;

	mov	eax, DWORD PTR ?FalconNullId@@3VVU_ID@@A
	mov	DWORD PTR _tmpID$[ebp], eax
	mov	ecx, DWORD PTR ?FalconNullId@@3VVU_ID@@A+4
	mov	DWORD PTR _tmpID$[ebp+4], ecx
$LN1@Save:

; 785  : 	}
; 786  : 
; 787  : 	memcpy(*stream, &tmpID, sizeof(VU_ID));								*stream += sizeof(VU_ID);

	push	8
	lea	edx, DWORD PTR _tmpID$[ebp]
	push	edx
	mov	eax, DWORD PTR _stream$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _stream$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 8
	mov	ecx, DWORD PTR _stream$[ebp]
	mov	DWORD PTR [ecx], eax

; 788  : 
; 789  : 	return TeamClass::SaveSize() + 3*sizeof(VU_ID);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SaveSize@TeamClass@@UAEHXZ		; TeamClass::SaveSize
	add	eax, 24					; 00000018H

; 790  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Save@TeamClass@@UAEHPAPAE@Z ENDP			; TeamClass::Save
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SaveSize@TeamClass@@UAEHXZ PROC			; TeamClass::SaveSize
; _this$ = ecx

; 666  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 667  : 	return sizeof(VU_ID)
; 668  : 			+ sizeof(VU_ID)
; 669  : 			+ sizeof(ushort)
; 670  : 			+ sizeof(Team)
; 671  : 			+ sizeof(Team)
; 672  : 			+ sizeof(short)
; 673  : 			+ sizeof(uchar)*NUM_COUNS
; 674  : 			+ sizeof(short)*NUM_TEAMS
; 675  : 			+ sizeof(short)
; 676  : 			+ sizeof(short)
; 677  : 			+ sizeof(short)
; 678  : 			+ sizeof(short)
; 679  : 			+ sizeof(uchar)
; 680  : 			+ sizeof(uchar)
; 681  : 			+ sizeof(uchar)
; 682  : 			+ sizeof(uchar)
; 683  : 			+ sizeof(short)
; 684  : 			+ sizeof(ushort)
; 685  : 			+ sizeof(ushort)
; 686  : 			+ sizeof(ushort)
; 687  : 			+ sizeof(float)
; 688  : 			+ sizeof(CampaignTime)
; 689  : 			+ sizeof(TeamStatusType)
; 690  : 			+ sizeof(TeamStatusType)
; 691  : 			+ sizeof(short)
; 692  : 			+ sizeof(VU_ID)*MAX_BONUSES
; 693  : 			+ sizeof(CampaignTime)*MAX_BONUSES
; 694  : 			+ sizeof(uchar)*MAX_TGTTYPE
; 695  : 			+ sizeof(uchar)*MAX_UNITTYPE
; 696  : 			+ sizeof(uchar)*AMIS_OTHER
; 697  : 			+ sizeof(uchar)*4
; 698  : 			+ sizeof(uchar)
; 699  : 			+ sizeof(uchar)
; 700  : 			+ sizeof(uchar)
; 701  : 			+ sizeof(_TCHAR)*MAX_TEAM_NAME_SIZE
; 702  : 			+ sizeof(_TCHAR)*MAX_MOTTO_SIZE
; 703  : 			+ sizeof(TeamGndActionType)
; 704  : 			+ sizeof(TeamAirActionType)
; 705  : 			+ sizeof(TeamAirActionType)
; 706  : 			+ sizeof(VU_ID)
; 707  : 			+ sizeof(VU_ID)
; 708  : 			+ sizeof(VU_ID);

	mov	eax, 771				; 00000303H

; 709  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SaveSize@TeamClass@@UAEHXZ ENDP			; TeamClass::SaveSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_min$ = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 2
?AddReinforcement@TeamClass@@QAEXF@Z PROC		; TeamClass::AddReinforcement
; _this$ = ecx

; 1657 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1658 : 	int		min;
; 1659 : 
; 1660 : 	// Calculate minimum reinforcement number
; 1661 : 	// KCK TODO: Impliment a "start time"
; 1662 : 	min = (TheCampaign.CurrentTime - 9*CampaignHours)/CampaignHours;

	mov	eax, DWORD PTR ?TheCampaign@@3VCampaignClass@@A
	sub	eax, 32400000				; 01ee6280H
	xor	edx, edx
	mov	ecx, 3600000				; 0036ee80H
	div	ecx
	mov	DWORD PTR _min$[ebp], eax

; 1663 : 
; 1664 : 	if (reinforcement + i < min)

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+168]
	movsx	ecx, WORD PTR _i$[ebp]
	add	eax, ecx
	cmp	eax, DWORD PTR _min$[ebp]
	jge	SHORT $LN1@AddReinfor

; 1665 : 		return;

	jmp	SHORT $LN2@AddReinfor
$LN1@AddReinfor:

; 1666 : 
; 1667 : 	reinforcement += i;

	movsx	edx, WORD PTR _i$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+168]
	add	ecx, edx
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+168], cx

; 1668 : 
; 1669 : 	//MakeTeamDirty (DIRTY_TEAM_REINFORCEMENT, DDP[18].priority);
; 1670 : 	MakeTeamDirty (DIRTY_TEAM_REINFORCEMENT, SEND_EVENTUALLY);

	push	1
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeTeamDirty@TeamClass@@QAEXW4Dirty_Team@@W4Dirtyness@@@Z ; TeamClass::MakeTeamDirty
$LN2@AddReinfor:

; 1671 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?AddReinforcement@TeamClass@@QAEXF@Z ENDP		; TeamClass::AddReinforcement
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 2
?AddInitiative@TeamClass@@QAEXF@Z PROC			; TeamClass::AddInitiative
; _this$ = ecx

; 1642 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1643 : 	initiative += i;

	movsx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+144]
	add	edx, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+144], dx

; 1644 : 
; 1645 : 	if (initiative > 100) initiative = 100;

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+144]
	cmp	edx, 100				; 00000064H
	jle	SHORT $LN2@AddInitiat
	mov	eax, 100				; 00000064H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+144], ax
$LN2@AddInitiat:

; 1646 : 	if (initiative < 0) initiative = 0;

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+144]
	test	eax, eax
	jge	SHORT $LN1@AddInitiat
	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+144], cx
$LN1@AddInitiat:

; 1647 : 
; 1648 : 	//MakeTeamDirty (DIRTY_TEAM_INITIATIVE, DDP[17].priority);
; 1649 : 	MakeTeamDirty (DIRTY_TEAM_INITIATIVE, SEND_EVENTUALLY);

	push	1
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeTeamDirty@TeamClass@@QAEXW4Dirty_Team@@W4Dirtyness@@@Z ; TeamClass::MakeTeamDirty

; 1650 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?AddInitiative@TeamClass@@QAEXF@Z ENDP			; TeamClass::AddInitiative
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetGroundAction@TeamClass@@QAEPAUTeamGndActionType@@XZ PROC ; TeamClass::SetGroundAction
; _this$ = ecx

; 2746 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2747 : 	//MakeTeamDirty (DIRTY_GROUND_ACTION, DDP[31].priority);
; 2748 : 	MakeTeamDirty (DIRTY_GROUND_ACTION, SEND_EVENTUALLY);

	push	1
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeTeamDirty@TeamClass@@QAEXW4Dirty_Team@@W4Dirtyness@@@Z ; TeamClass::MakeTeamDirty

; 2749 : 	return &groundAction;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 267				; 0000010bH

; 2750 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetGroundAction@TeamClass@@QAEPAUTeamGndActionType@@XZ ENDP ; TeamClass::SetGroundAction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ PROC ; TeamClass::SetCurrentStats
; _this$ = ecx

; 2735 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2736 : 	//MakeTeamDirty (DIRTY_CURRENT_STATS, DDP[30].priority);
; 2737 : 	MakeTeamDirty (DIRTY_CURRENT_STATS, SEND_EVENTUALLY);

	push	1
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeTeamDirty@TeamClass@@QAEXW4Dirty_Team@@W4Dirtyness@@@Z ; TeamClass::MakeTeamDirty

; 2738 : 	return &currentStats;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 152				; 00000098H

; 2739 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ENDP ; TeamClass::SetCurrentStats
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_r$ = 8							; size = 4
?SetReplacementsAvail@TeamClass@@QAEXH@Z PROC		; TeamClass::SetReplacementsAvail
; _this$ = ecx

; 2701 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2702 : 	//MakeTeamDirty (DIRTY_SUPPLY_FUEL_AVAIL, DDP[27].priority);
; 2703 : 	MakeTeamDirty (DIRTY_SUPPLY_FUEL_AVAIL, SEND_EVENTUALLY);

	push	1
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeTeamDirty@TeamClass@@QAEXW4Dirty_Team@@W4Dirtyness@@@Z ; TeamClass::MakeTeamDirty

; 2704 : 	if (r < 0){	r = 0; }

	cmp	DWORD PTR _r$[ebp], 0
	jge	SHORT $LN1@SetReplace
	mov	DWORD PTR _r$[ebp], 0
$LN1@SetReplace:

; 2705 : 	replacementsAvail = r;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _r$[ebp]
	mov	WORD PTR [eax+150], cx

; 2706 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetReplacementsAvail@TeamClass@@QAEXH@Z ENDP		; TeamClass::SetReplacementsAvail
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fa$ = 8						; size = 4
?SetFuelAvail@TeamClass@@QAEXH@Z PROC			; TeamClass::SetFuelAvail
; _this$ = ecx

; 2677 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2678 : 	//MakeTeamDirty (DIRTY_SUPPLY_FUEL_AVAIL, DDP[25].priority);
; 2679 : 	MakeTeamDirty (DIRTY_SUPPLY_FUEL_AVAIL, SEND_EVENTUALLY);

	push	1
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeTeamDirty@TeamClass@@QAEXW4Dirty_Team@@W4Dirtyness@@@Z ; TeamClass::MakeTeamDirty

; 2680 : 	if (fa < 0){ fa = 0; }

	cmp	DWORD PTR _fa$[ebp], 0
	jge	SHORT $LN1@SetFuelAva
	mov	DWORD PTR _fa$[ebp], 0
$LN1@SetFuelAva:

; 2681 : 	fuelAvail = fa;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _fa$[ebp]
	mov	WORD PTR [eax+148], cx

; 2682 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetFuelAvail@TeamClass@@QAEXH@Z ENDP			; TeamClass::SetFuelAvail
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_sa$ = 8						; size = 4
?SetSupplyAvail@TeamClass@@QAEXH@Z PROC			; TeamClass::SetSupplyAvail
; _this$ = ecx

; 2689 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2690 : 	//MakeTeamDirty (DIRTY_SUPPLY_FUEL_AVAIL, DDP[26].priority);
; 2691 : 	MakeTeamDirty (DIRTY_SUPPLY_FUEL_AVAIL, SEND_EVENTUALLY);

	push	1
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeTeamDirty@TeamClass@@QAEXW4Dirty_Team@@W4Dirtyness@@@Z ; TeamClass::MakeTeamDirty

; 2692 : 	if (sa < 0){ sa = 0; }

	cmp	DWORD PTR _sa$[ebp], 0
	jge	SHORT $LN1@SetSupplyA
	mov	DWORD PTR _sa$[ebp], 0
$LN1@SetSupplyA:

; 2693 : 	supplyAvail = sa;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _sa$[ebp]
	mov	WORD PTR [eax+146], cx

; 2694 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSupplyAvail@TeamClass@@QAEXH@Z ENDP			; TeamClass::SetSupplyAvail
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
_c$ = 12						; size = 1
?SetMissionPriority@TeamClass@@QAEXHE@Z PROC		; TeamClass::SetMissionPriority
; _this$ = ecx

; 2605 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2606 : 	mission_priority[i] = c;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	cl, BYTE PTR _c$[ebp]
	mov	BYTE PTR [eax+226], cl

; 2607 : 
; 2608 : 	//MakeTeamDirty (DIRTY_MISSION_PRIORITY, DDP[19].priority);
; 2609 : 	MakeTeamDirty (DIRTY_MISSION_PRIORITY, SEND_EVENTUALLY);

	push	1
	push	128					; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeTeamDirty@TeamClass@@QAEXW4Dirty_Team@@W4Dirtyness@@@Z ; TeamClass::MakeTeamDirty

; 2610 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetMissionPriority@TeamClass@@QAEXHE@Z ENDP		; TeamClass::SetMissionPriority
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
_c$ = 12						; size = 1
?SetUnitTypePriority@TeamClass@@QAEXHE@Z PROC		; TeamClass::SetUnitTypePriority
; _this$ = ecx

; 2629 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2630 : 	unittype_priority[i] = c;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	cl, BYTE PTR _c$[ebp]
	mov	BYTE PTR [eax+206], cl

; 2631 : 
; 2632 : 	//MakeTeamDirty (DIRTY_UNITTYPE_PRIORITY, DDP[21].priority);
; 2633 : 	MakeTeamDirty (DIRTY_UNITTYPE_PRIORITY, SEND_EVENTUALLY);

	push	1
	push	64					; 00000040H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeTeamDirty@TeamClass@@QAEXW4Dirty_Team@@W4Dirtyness@@@Z ; TeamClass::MakeTeamDirty

; 2634 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetUnitTypePriority@TeamClass@@QAEXHE@Z ENDP		; TeamClass::SetUnitTypePriority
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
_c$ = 12						; size = 1
?SetObjTypePriority@TeamClass@@QAEXHE@Z PROC		; TeamClass::SetObjTypePriority
; _this$ = ecx

; 2653 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2654 : 	//MakeTeamDirty (DIRTY_OBJTYPE_PRIORITY, DDP[23].priority);
; 2655 : 	MakeTeamDirty (DIRTY_OBJTYPE_PRIORITY, SEND_EVENTUALLY);

	push	1
	push	32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeTeamDirty@TeamClass@@QAEXW4Dirty_Team@@W4Dirtyness@@@Z ; TeamClass::MakeTeamDirty

; 2656 : 
; 2657 : 	objtype_priority[i] = c;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	cl, BYTE PTR _c$[ebp]
	mov	BYTE PTR [eax+170], cl

; 2658 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetObjTypePriority@TeamClass@@QAEXHE@Z ENDP		; TeamClass::SetObjTypePriority
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetAllMissionPriority@TeamClass@@QAEPAEXZ PROC		; TeamClass::SetAllMissionPriority
; _this$ = ecx

; 2617 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2618 : 	//MakeTeamDirty (DIRTY_MISSION_PRIORITY, DDP[20].priority);
; 2619 : 	MakeTeamDirty (DIRTY_MISSION_PRIORITY, SEND_EVENTUALLY);

	push	1
	push	128					; 00000080H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeTeamDirty@TeamClass@@QAEXW4Dirty_Team@@W4Dirtyness@@@Z ; TeamClass::MakeTeamDirty

; 2620 : 
; 2621 : 	return mission_priority;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 226				; 000000e2H

; 2622 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetAllMissionPriority@TeamClass@@QAEPAEXZ ENDP		; TeamClass::SetAllMissionPriority
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetAllUnitTypePriority@TeamClass@@QAEPAEXZ PROC	; TeamClass::SetAllUnitTypePriority
; _this$ = ecx

; 2641 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2642 : 	//MakeTeamDirty (DIRTY_UNITTYPE_PRIORITY, DDP[22].priority);
; 2643 : 	MakeTeamDirty (DIRTY_UNITTYPE_PRIORITY, SEND_EVENTUALLY);

	push	1
	push	64					; 00000040H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeTeamDirty@TeamClass@@QAEXW4Dirty_Team@@W4Dirtyness@@@Z ; TeamClass::MakeTeamDirty

; 2644 : 
; 2645 : 	return unittype_priority;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 206				; 000000ceH

; 2646 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetAllUnitTypePriority@TeamClass@@QAEPAEXZ ENDP	; TeamClass::SetAllUnitTypePriority
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetAllObjTypePriority@TeamClass@@QAEPAEXZ PROC		; TeamClass::SetAllObjTypePriority
; _this$ = ecx

; 2665 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2666 : 	//MakeTeamDirty (DIRTY_OBJTYPE_PRIORITY, DDP[24].priority);
; 2667 : 	MakeTeamDirty (DIRTY_OBJTYPE_PRIORITY, SEND_EVENTUALLY);

	push	1
	push	32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeTeamDirty@TeamClass@@QAEXW4Dirty_Team@@W4Dirtyness@@@Z ; TeamClass::MakeTeamDirty

; 2668 : 
; 2669 : 	return objtype_priority;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 170				; 000000aaH

; 2670 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetAllObjTypePriority@TeamClass@@QAEPAEXZ ENDP		; TeamClass::SetAllObjTypePriority
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_r$ = 8							; size = 2
?SetReinforcement@TeamClass@@QAEXF@Z PROC		; TeamClass::SetReinforcement
; _this$ = ecx

; 2724 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2725 : 	//MakeTeamDirty (DIRTY_TEAM_REINFORCEMENT, DDP[29].priority);
; 2726 : 	MakeTeamDirty (DIRTY_TEAM_REINFORCEMENT, SEND_EVENTUALLY);

	push	1
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeTeamDirty@TeamClass@@QAEXW4Dirty_Team@@W4Dirtyness@@@Z ; TeamClass::MakeTeamDirty

; 2727 : 	reinforcement = r;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _r$[ebp]
	mov	WORD PTR [eax+168], cx

; 2728 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetReinforcement@TeamClass@@QAEXF@Z ENDP		; TeamClass::SetReinforcement
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 2
?SetInitiative@TeamClass@@QAEXF@Z PROC			; TeamClass::SetInitiative
; _this$ = ecx

; 2713 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2714 : 	//MakeTeamDirty (DIRTY_TEAM_INITIATIVE, DDP[28].priority);
; 2715 : 	MakeTeamDirty (DIRTY_TEAM_INITIATIVE, SEND_EVENTUALLY);

	push	1
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeTeamDirty@TeamClass@@QAEXW4Dirty_Team@@W4Dirtyness@@@Z ; TeamClass::MakeTeamDirty

; 2716 : 	initiative = i;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _i$[ebp]
	mov	WORD PTR [eax+144], cx

; 2717 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetInitiative@TeamClass@@QAEXF@Z ENDP			; TeamClass::SetInitiative
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\team.h
;	COMDAT ?GetCountry@TeamClass@@UAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCountry@TeamClass@@UAEEXZ PROC			; TeamClass::GetCountry, COMDAT
; _this$ = ecx

; 282  : 	virtual uchar GetCountry(void){ return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	al, al
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCountry@TeamClass@@UAEEXZ ENDP			; TeamClass::GetCountry
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\team.h
;	COMDAT ?GetTeam@TeamClass@@UAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTeam@TeamClass@@UAEEXZ PROC				; TeamClass::GetTeam, COMDAT
; _this$ = ecx

; 281  : 	virtual uchar GetTeam(void)   { return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	al, al
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTeam@TeamClass@@UAEEXZ ENDP				; TeamClass::GetTeam
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\team.h
;	COMDAT ?GetCampID@TeamClass@@UAEFXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCampID@TeamClass@@UAEFXZ PROC			; TeamClass::GetCampID, COMDAT
; _this$ = ecx

; 280  : 	virtual short GetCampID(void) { return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCampID@TeamClass@@UAEFXZ ENDP			; TeamClass::GetCampID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\team.h
;	COMDAT ?GetGroundAction@TeamClass@@QAEPAUTeamGndActionType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGroundAction@TeamClass@@QAEPAUTeamGndActionType@@XZ PROC ; TeamClass::GetGroundAction, COMDAT
; _this$ = ecx

; 277  : 	TeamGndActionType *GetGroundAction (void) { return &groundAction; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 267				; 0000010bH
	mov	esp, ebp
	pop	ebp
	ret	0
?GetGroundAction@TeamClass@@QAEPAUTeamGndActionType@@XZ ENDP ; TeamClass::GetGroundAction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\team.h
;	COMDAT ?GetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ PROC ; TeamClass::GetCurrentStats, COMDAT
; _this$ = ecx

; 276  : 	TeamStatusType *GetCurrentStats (void) { return &currentStats; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 152				; 00000098H
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCurrentStats@TeamClass@@QAEPAUTeamStatusType@@XZ ENDP ; TeamClass::GetCurrentStats
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\team.h
;	COMDAT ?GetMissionPriority@TeamClass@@QAEEH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_type$ = 8						; size = 4
?GetMissionPriority@TeamClass@@QAEEH@Z PROC		; TeamClass::GetMissionPriority, COMDAT
; _this$ = ecx

; 275  : 	uchar GetMissionPriority (int type) { return mission_priority[type]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _type$[ebp]
	mov	al, BYTE PTR [eax+226]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetMissionPriority@TeamClass@@QAEEH@Z ENDP		; TeamClass::GetMissionPriority
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\team.h
;	COMDAT ?GetUnitTypePriority@TeamClass@@QAEEH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_type$ = 8						; size = 4
?GetUnitTypePriority@TeamClass@@QAEEH@Z PROC		; TeamClass::GetUnitTypePriority, COMDAT
; _this$ = ecx

; 274  : 	uchar GetUnitTypePriority (int type) { return unittype_priority[type]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _type$[ebp]
	mov	al, BYTE PTR [eax+206]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitTypePriority@TeamClass@@QAEEH@Z ENDP		; TeamClass::GetUnitTypePriority
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\team.h
;	COMDAT ?GetObjTypePriority@TeamClass@@QAEEH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_type$ = 8						; size = 4
?GetObjTypePriority@TeamClass@@QAEEH@Z PROC		; TeamClass::GetObjTypePriority, COMDAT
; _this$ = ecx

; 273  : 	uchar GetObjTypePriority (int type) { return objtype_priority[type]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _type$[ebp]
	mov	al, BYTE PTR [eax+170]
	mov	esp, ebp
	pop	ebp
	ret	4
?GetObjTypePriority@TeamClass@@QAEEH@Z ENDP		; TeamClass::GetObjTypePriority
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\team.h
;	COMDAT ?GetReinforcement@TeamClass@@QAEFXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetReinforcement@TeamClass@@QAEFXZ PROC		; TeamClass::GetReinforcement, COMDAT
; _this$ = ecx

; 272  : 	short GetReinforcement (void) { return reinforcement; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+168]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetReinforcement@TeamClass@@QAEFXZ ENDP		; TeamClass::GetReinforcement
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\team.h
;	COMDAT ?GetReplacementsAvail@TeamClass@@QAEGXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetReplacementsAvail@TeamClass@@QAEGXZ PROC		; TeamClass::GetReplacementsAvail, COMDAT
; _this$ = ecx

; 271  : 	ushort GetReplacementsAvail (void) { return replacementsAvail; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+150]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetReplacementsAvail@TeamClass@@QAEGXZ ENDP		; TeamClass::GetReplacementsAvail
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\team.h
;	COMDAT ?GetFuelAvail@TeamClass@@QAEGXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFuelAvail@TeamClass@@QAEGXZ PROC			; TeamClass::GetFuelAvail, COMDAT
; _this$ = ecx

; 270  : 	ushort GetFuelAvail (void) { return fuelAvail; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+148]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFuelAvail@TeamClass@@QAEGXZ ENDP			; TeamClass::GetFuelAvail
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\team.h
;	COMDAT ?GetSupplyAvail@TeamClass@@QAEGXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSupplyAvail@TeamClass@@QAEGXZ PROC			; TeamClass::GetSupplyAvail, COMDAT
; _this$ = ecx

; 269  : 	ushort GetSupplyAvail (void) { return supplyAvail; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+146]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSupplyAvail@TeamClass@@QAEGXZ ENDP			; TeamClass::GetSupplyAvail
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\team.h
;	COMDAT ?GetInitiative@TeamClass@@QAEFXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetInitiative@TeamClass@@QAEFXZ PROC			; TeamClass::GetInitiative, COMDAT
; _this$ = ecx

; 268  : 	short GetInitiative (void) { return initiative; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+144]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetInitiative@TeamClass@@QAEFXZ ENDP			; TeamClass::GetInitiative
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\team.h
;	COMDAT ?Sleep@TeamClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Sleep@TeamClass@@UAEHXZ PROC				; TeamClass::Sleep, COMDAT
; _this$ = ecx

; 265  : 	virtual int Sleep (void) {return 0;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?Sleep@TeamClass@@UAEHXZ ENDP				; TeamClass::Sleep
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\team.h
;	COMDAT ?Wake@TeamClass@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Wake@TeamClass@@UAEHXZ PROC				; TeamClass::Wake, COMDAT
; _this$ = ecx

; 264  : 	virtual int Wake (void) {return 0;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?Wake@TeamClass@@UAEHXZ ENDP				; TeamClass::Wake
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RemovalCallback@TeamClass@@UAEHXZ PROC			; TeamClass::RemovalCallback
; _this$ = ecx

; 1046 : VU_ERRCODE TeamClass::RemovalCallback(void){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1047 : 	if (TeamInfo[who] == this){

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+348]
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	cmp	edx, DWORD PTR _this$[ebp]
	jne	SHORT $LN1@RemovalCal

; 1048 : 		TeamInfo[who] = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+348]
	mov	DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4], 0

; 1049 : 		VuDeReferenceEntity(this);

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?VuDeReferenceEntity@@YAHPAVVuEntity@@@Z ; VuDeReferenceEntity
	add	esp, 4
$LN1@RemovalCal:

; 1050 : 	}
; 1051 : 	return FalconEntity::RemovalCallback();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemovalCallback@FalconEntity@@UAEHXZ	; FalconEntity::RemovalCallback

; 1052 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RemovalCallback@TeamClass@@UAEHXZ ENDP			; TeamClass::RemovalCallback
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?InsertionCallback@TeamClass@@UAEHXZ PROC		; TeamClass::InsertionCallback
; _this$ = ecx

; 1037 : VU_ERRCODE TeamClass::InsertionCallback(void){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1038 : 	if (TeamInfo[who] != this){

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+348]
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	cmp	edx, DWORD PTR _this$[ebp]
	je	SHORT $LN1@InsertionC

; 1039 : 		RemoveTeam(who);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+348]
	push	ecx
	call	?RemoveTeam@@YAXH@Z			; RemoveTeam
	add	esp, 4

; 1040 : 		TeamInfo[who] = this;

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+348]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4], ecx

; 1041 : 		VuReferenceEntity(this);

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?VuReferenceEntity@@YAHPAVVuEntity@@@Z	; VuReferenceEntity
	add	esp, 4
$LN1@InsertionC:

; 1042 : 	}
; 1043 : 	return FalconEntity::InsertionCallback();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertionCallback@VuEntity@@MAEHXZ	; VuEntity::InsertionCallback

; 1044 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InsertionCallback@TeamClass@@UAEHXZ ENDP		; TeamClass::InsertionCallback
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_event$ = 8						; size = 4
?Handle@TeamClass@@UAEHPAVVuSessionEvent@@@Z PROC	; TeamClass::Handle
; _this$ = ecx

; 1033 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1034 : 	return (VuEntity::Handle(event));

	mov	eax, DWORD PTR _event$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Handle@VuEntity@@UAEHPAVVuSessionEvent@@@Z ; VuEntity::Handle

; 1035 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Handle@TeamClass@@UAEHPAVVuSessionEvent@@@Z ENDP	; TeamClass::Handle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_event$ = 8						; size = 4
?Handle@TeamClass@@UAEHPAVVuTransferEvent@@@Z PROC	; TeamClass::Handle
; _this$ = ecx

; 1028 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 	return (VuEntity::Handle(event));

	mov	eax, DWORD PTR _event$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Handle@VuEntity@@UAEHPAVVuTransferEvent@@@Z ; VuEntity::Handle

; 1030 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Handle@TeamClass@@UAEHPAVVuTransferEvent@@@Z ENDP	; TeamClass::Handle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_event$ = 8						; size = 4
?Handle@TeamClass@@UAEHPAVVuEntityCollisionEvent@@@Z PROC ; TeamClass::Handle
; _this$ = ecx

; 1023 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1024 : 	return (VuEntity::Handle(event));

	mov	eax, DWORD PTR _event$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Handle@VuEntity@@UAEHPAVVuEntityCollisionEvent@@@Z ; VuEntity::Handle

; 1025 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Handle@TeamClass@@UAEHPAVVuEntityCollisionEvent@@@Z ENDP ; TeamClass::Handle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_event$ = 8						; size = 4
?Handle@TeamClass@@UAEHPAVVuPositionUpdateEvent@@@Z PROC ; TeamClass::Handle
; _this$ = ecx

; 1018 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1019 : 	return (VuEntity::Handle(event));

	mov	eax, DWORD PTR _event$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Handle@VuEntity@@UAEHPAVVuPositionUpdateEvent@@@Z ; VuEntity::Handle

; 1020 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Handle@TeamClass@@UAEHPAVVuPositionUpdateEvent@@@Z ENDP ; TeamClass::Handle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_retval$ = -16						; size = 4
_i$1 = -12						; size = 4
_tmpTeam$ = -8						; size = 4
_this$ = -4						; size = 4
_event$ = 8						; size = 4
?Handle@TeamClass@@UAEHPAVVuFullUpdateEvent@@@Z PROC	; TeamClass::Handle
; _this$ = ecx

; 965  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 966  : 	TeamClass*	tmpTeam = (TeamClass*)(event->expandedData_.get());

	mov	ecx, DWORD PTR _event$[ebp]
	add	ecx, 48					; 00000030H
	call	?get@?$VuBin@VVuEntity@@@@QBEPAVVuEntity@@XZ ; VuBin<VuEntity>::get
	mov	DWORD PTR _tmpTeam$[ebp], eax

; 967  : 	int			retval;
; 968  : 
; 969  : 	// Copy in new data
; 970  : 	memcpy(&share_.id_, &tmpTeam->share_.id_, sizeof(VU_ID));

	push	8
	mov	eax, DWORD PTR _tmpTeam$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 971  : 	memcpy(&share_.entityType_, &tmpTeam->share_.entityType_, sizeof(ushort));

	push	2
	mov	edx, DWORD PTR _tmpTeam$[ebp]
	add	edx, 4
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 972  : 	memcpy(&who, &tmpTeam->who, sizeof(Team));

	push	1
	mov	ecx, DWORD PTR _tmpTeam$[ebp]
	add	ecx, 348				; 0000015cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 348				; 0000015cH
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 973  : 	memcpy(&cteam, &tmpTeam->cteam, sizeof(Team));

	push	1
	mov	eax, DWORD PTR _tmpTeam$[ebp]
	add	eax, 349				; 0000015dH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 349				; 0000015dH
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 974  : 	ShiAssert((cteam > 0 || cteam == 0) && cteam < NUM_TEAMS);
; 975  : 	memcpy(&flags, &tmpTeam->flags, sizeof(short));							

	push	2
	mov	edx, DWORD PTR _tmpTeam$[ebp]
	add	edx, 350				; 0000015eH
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 350				; 0000015eH
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 976  : 	memcpy(member, tmpTeam->member, sizeof(uchar)*NUM_COUNS);				

	push	8
	mov	ecx, DWORD PTR _tmpTeam$[ebp]
	add	ecx, 572				; 0000023cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 572				; 0000023cH
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 977  : 	memcpy(stance, tmpTeam->stance, sizeof(short)*NUM_TEAMS);				

	push	16					; 00000010H
	mov	eax, DWORD PTR _tmpTeam$[ebp]
	add	eax, 580				; 00000244H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 580				; 00000244H
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 978  : 	memcpy(&airExperience, &tmpTeam->airExperience, sizeof(uchar));					

	push	1
	mov	edx, DWORD PTR _tmpTeam$[ebp]
	add	edx, 612				; 00000264H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 612				; 00000264H
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 979  : 	memcpy(&airDefenseExperience, &tmpTeam->airDefenseExperience, sizeof(uchar));					

	push	1
	mov	ecx, DWORD PTR _tmpTeam$[ebp]
	add	ecx, 613				; 00000265H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 613				; 00000265H
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 980  : 	memcpy(&groundExperience, &tmpTeam->groundExperience, sizeof(uchar));					

	push	1
	mov	eax, DWORD PTR _tmpTeam$[ebp]
	add	eax, 614				; 00000266H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 614				; 00000266H
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 981  : 	memcpy(&navalExperience, &tmpTeam->navalExperience, sizeof(uchar));					

	push	1
	mov	edx, DWORD PTR _tmpTeam$[ebp]
	add	edx, 615				; 00000267H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 615				; 00000267H
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 982  : 	memcpy(&initiative, &tmpTeam->initiative, sizeof(short));					

	push	2
	mov	ecx, DWORD PTR _tmpTeam$[ebp]
	add	ecx, 144				; 00000090H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 144				; 00000090H
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 983  : 	memcpy(&supplyAvail, &tmpTeam->supplyAvail, sizeof(ushort));					

	push	2
	mov	eax, DWORD PTR _tmpTeam$[ebp]
	add	eax, 146				; 00000092H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 146				; 00000092H
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 984  : 	memcpy(&fuelAvail, &tmpTeam->fuelAvail, sizeof(ushort));					

	push	2
	mov	edx, DWORD PTR _tmpTeam$[ebp]
	add	edx, 148				; 00000094H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 148				; 00000094H
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 985  : 	memcpy(&currentStats, &tmpTeam->currentStats, sizeof(TeamStatusType));			

	push	16					; 00000010H
	mov	ecx, DWORD PTR _tmpTeam$[ebp]
	add	ecx, 152				; 00000098H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 152				; 00000098H
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 986  : 	memcpy(&startStats, &tmpTeam->startStats, sizeof(TeamStatusType));			

	push	16					; 00000010H
	mov	eax, DWORD PTR _tmpTeam$[ebp]
	add	eax, 616				; 00000268H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 616				; 00000268H
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 987  : 	memcpy(&reinforcement, &tmpTeam->reinforcement, sizeof(short));					

	push	2
	mov	edx, DWORD PTR _tmpTeam$[ebp]
	add	edx, 168				; 000000a8H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 168				; 000000a8H
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 988  : 	memcpy(bonusObjs, tmpTeam->bonusObjs, sizeof(VU_ID)*MAX_BONUSES);			

	push	160					; 000000a0H
	mov	ecx, DWORD PTR _tmpTeam$[ebp]
	add	ecx, 632				; 00000278H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 632				; 00000278H
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 989  : 	memcpy(bonusTime, tmpTeam->bonusTime, sizeof(CampaignTime)*MAX_BONUSES);	

	push	80					; 00000050H
	mov	eax, DWORD PTR _tmpTeam$[ebp]
	add	eax, 792				; 00000318H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 792				; 00000318H
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 990  : 	memcpy(objtype_priority, tmpTeam->objtype_priority, sizeof(uchar)*MAX_TGTTYPE);	

	push	36					; 00000024H
	mov	edx, DWORD PTR _tmpTeam$[ebp]
	add	edx, 170				; 000000aaH
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 170				; 000000aaH
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 991  : 	memcpy(unittype_priority, tmpTeam->unittype_priority, sizeof(uchar)*MAX_UNITTYPE);	

	push	20					; 00000014H
	mov	ecx, DWORD PTR _tmpTeam$[ebp]
	add	ecx, 206				; 000000ceH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 206				; 000000ceH
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 992  : 	memcpy(mission_priority, tmpTeam->mission_priority, sizeof(uchar)*AMIS_OTHER);	

	push	41					; 00000029H
	mov	eax, DWORD PTR _tmpTeam$[ebp]
	add	eax, 226				; 000000e2H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 226				; 000000e2H
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 993  : 	memcpy(max_vehicle, tmpTeam->max_vehicle, sizeof(uchar)*4);

	push	4
	mov	edx, DWORD PTR _tmpTeam$[ebp]
	add	edx, 872				; 00000368H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 872				; 00000368H
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 994  : 	memcpy(&groundAction, &tmpTeam->groundAction, sizeof(TeamGndActionType));

	push	19					; 00000013H
	mov	ecx, DWORD PTR _tmpTeam$[ebp]
	add	ecx, 267				; 0000010bH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 267				; 0000010bH
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 995  : 	memcpy(&defensiveAirAction, &tmpTeam->defensiveAirAction, sizeof(TeamAirActionType));

	push	28					; 0000001cH
	mov	eax, DWORD PTR _tmpTeam$[ebp]
	add	eax, 288				; 00000120H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 288				; 00000120H
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 996  : 	memcpy(&offensiveAirAction, &tmpTeam->offensiveAirAction, sizeof(TeamAirActionType));

	push	28					; 0000001cH
	mov	edx, DWORD PTR _tmpTeam$[ebp]
	add	edx, 316				; 0000013cH
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 316				; 0000013cH
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 997  : 
; 998  : 	retval = VuEntity::Handle(event);

	mov	ecx, DWORD PTR _event$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Handle@VuEntity@@UAEHPAVVuFullUpdateEvent@@@Z ; VuEntity::Handle
	mov	DWORD PTR _retval$[ebp], eax

; 999  : 
; 1000 : 	// Set our flag if we've got all the team's info
; 1001 : 	// WARNING: we don't guarentee receipt of the managers!
; 1002 : 	flags |= TEAM_UPDATED;

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+350]
	or	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+350], ax

; 1003 : 	// Mark team data as received if we have all the teams.
; 1004 : 	for (int i=0; i<NUM_TEAMS; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN5@Handle
$LN4@Handle:
	mov	edx, DWORD PTR _i$1[ebp]
	add	edx, 1
	mov	DWORD PTR _i$1[ebp], edx
$LN5@Handle:
	cmp	DWORD PTR _i$1[ebp], 8
	jge	SHORT $LN3@Handle

; 1005 : 	{
; 1006 : 		if ((TeamInfo[i]) && (!(TeamInfo[i]->flags & TEAM_UPDATED)))

	mov	eax, DWORD PTR _i$1[ebp]
	cmp	DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[eax*4], 0
	je	SHORT $LN2@Handle
	mov	ecx, DWORD PTR _i$1[ebp]
	mov	edx, DWORD PTR ?TeamInfo@@3PAPAVTeamClass@@A[ecx*4]
	movsx	eax, WORD PTR [edx+350]
	and	eax, 4
	jne	SHORT $LN2@Handle

; 1007 : 			return retval;

	mov	eax, DWORD PTR _retval$[ebp]
	jmp	SHORT $LN6@Handle
$LN2@Handle:

; 1008 : 	}

	jmp	SHORT $LN4@Handle
$LN3@Handle:

; 1009 : 	if (TheCampaign.Flags & CAMP_SLAVE)

	mov	ecx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+64
	and	ecx, 64					; 00000040H
	je	SHORT $LN1@Handle

; 1010 : 	{
; 1011 : 		TheCampaign.Flags &= ~CAMP_NEED_TEAM_DATA;

	mov	edx, DWORD PTR ?TheCampaign@@3VCampaignClass@@A+64
	and	edx, -33554433				; fdffffffH
	mov	DWORD PTR ?TheCampaign@@3VCampaignClass@@A+64, edx

; 1012 : 		TheCampaign.GotJoinData();

	mov	ecx, OFFSET ?TheCampaign@@3VCampaignClass@@A ; TheCampaign
	call	?GotJoinData@CampaignClass@@QAEXXZ	; CampaignClass::GotJoinData
$LN1@Handle:

; 1013 : 	}
; 1014 : 	return retval;

	mov	eax, DWORD PTR _retval$[ebp]
$LN6@Handle:

; 1015 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Handle@TeamClass@@UAEHPAVVuFullUpdateEvent@@@Z ENDP	; TeamClass::Handle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_event$ = 8						; size = 4
?Handle@TeamClass@@UAEHPAVVuEvent@@@Z PROC		; TeamClass::Handle
; _this$ = ecx

; 959  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 960  : 	//Event Handler
; 961  : 	return (VuEntity::Handle(event));

	mov	eax, DWORD PTR _event$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Handle@VuEntity@@UAEHPAVVuEvent@@@Z	; VuEntity::Handle

; 962  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Handle@TeamClass@@UAEHPAVVuEvent@@@Z ENDP		; TeamClass::Handle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\team.h
;	COMDAT ?GetKias@TeamClass@@UBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetKias@TeamClass@@UBEMXZ PROC				; TeamClass::GetKias, COMDAT
; _this$ = ecx

; 253  : 	virtual float GetKias() const { return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	fldz
	mov	esp, ebp
	pop	ebp
	ret	0
?GetKias@TeamClass@@UBEMXZ ENDP				; TeamClass::GetKias
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\team.h
;	COMDAT ?GetVt@TeamClass@@UBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetVt@TeamClass@@UBEMXZ PROC				; TeamClass::GetVt, COMDAT
; _this$ = ecx

; 252  : 	virtual float GetVt() const { return 0; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	fldz
	mov	esp, ebp
	pop	ebp
	ret	0
?GetVt@TeamClass@@UBEMXZ ENDP				; TeamClass::GetVt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
$T1 = -72						; size = 8
tv274 = -64						; size = 4
tv252 = -60						; size = 4
_tid$ = -56						; size = 2
_this$ = -52						; size = 4
_towner$ = -48						; size = 41
__$ArrayPad$ = -4					; size = 4
_owner$ = 8						; size = 1
?InitLocalData@TeamClass@@AAEXE@Z PROC			; TeamClass::InitLocalData
; _this$ = ecx

; 594  : void TeamClass::InitLocalData(Control owner){

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 595  : 	_TCHAR	towner[41];
; 596  : 	short		tid;
; 597  : 	who = owner;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _owner$[ebp]
	mov	BYTE PTR [eax+348], cl

; 598  : 	cteam = owner;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR _owner$[ebp]
	mov	BYTE PTR [edx+349], al

; 599  : 	flags = 0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+350], cx

; 600  : 	memset(member,0,NUM_COUNS);

	push	8
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 572				; 0000023cH
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 601  : 	memset(stance,0,sizeof(short)*NUM_TEAMS);

	push	16					; 00000010H
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 580				; 00000244H
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 602  : 	// These members are for this COUNTRY
; 603  : 	firstColonel = FIRST_COLONEL;			// Pilot ID indexies for this country - init to US names

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR ?FIRST_COLONEL@@3FA	; FIRST_COLONEL
	mov	WORD PTR [edx+596], ax

; 604  : 	firstCommander = FIRST_COMMANDER;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR ?FIRST_COMMANDER@@3FA	; FIRST_COMMANDER
	mov	WORD PTR [ecx+598], dx

; 605  : 	firstWingman = FIRST_WINGMAN;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR ?FIRST_WINGMAN@@3FA	; FIRST_WINGMAN
	mov	WORD PTR [eax+600], cx

; 606  : 	lastWingman = LAST_WINGMAN;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR ?LAST_WINGMAN@@3FA		; LAST_WINGMAN
	mov	WORD PTR [edx+602], ax

; 607  : 	airExperience = 80;							// Experience for aircraft (effects pilot's skill)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+612], 80			; 00000050H

; 608  : 	airDefenseExperience = 80;					// Experience for air defenses

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+613], 80			; 00000050H

; 609  : 	groundExperience = 80;						// Experience for ground troops

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+614], 80			; 00000050H

; 610  : 	navalExperience = 80;						// Experience for ships

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+615], 80			; 00000050H

; 611  : 	equipment = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+890], 0

; 612  : 	// These members are for this TEAM
; 613  : 	initiative = 50;

	mov	eax, 50					; 00000032H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+144], ax

; 614  : 	supplyAvail = 1000;

	mov	edx, 1000				; 000003e8H
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+146], dx

; 615  : 	fuelAvail = 1000;

	mov	ecx, 1000				; 000003e8H
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+148], cx

; 616  : 	reinforcement = -1;

	or	eax, -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+168], ax

; 617  : 	ReadIndexedString(40+who,towner,40);

	push	40					; 00000028H
	lea	edx, DWORD PTR _towner$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+348]
	add	ecx, 40					; 00000028H
	push	ecx
	call	?ReadIndexedString@@YAXHPADH@Z		; ReadIndexedString
	add	esp, 12					; 0000000cH

; 618  : 	_tcscpy(name, towner);

	lea	edx, DWORD PTR _towner$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 352				; 00000160H
	push	eax
	call	_strcpy
	add	esp, 8

; 619  : 	teamColor = who;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+348]
	mov	BYTE PTR [ecx+889], al

; 620  : 	teamFlag = who;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+348]
	mov	BYTE PTR [ecx+888], al

; 621  : 	memset(teamMotto, 0, sizeof(_TCHAR)*MAX_MOTTO_SIZE);

	push	200					; 000000c8H
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 372				; 00000174H
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 622  : 	currentStats.airDefenseVehs = startStats.airDefenseVehs = 0;

	xor	edx, edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+616], dx
	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+152], cx

; 623  : 	currentStats.aircraft = startStats.aircraft = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+618], ax
	xor	edx, edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+154], dx

; 624  : 	currentStats.groundVehs = startStats.groundVehs = 0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+620], cx
	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+156], ax

; 625  : 	currentStats.ships = startStats.ships = 0;

	xor	edx, edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+622], dx
	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+158], cx

; 626  : 	currentStats.supply = startStats.supply = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+624], ax
	xor	edx, edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+160], dx

; 627  : 	currentStats.fuel = startStats.fuel = 0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+626], cx
	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+162], ax

; 628  : 	currentStats.airbases = startStats.airbases = 0;

	xor	edx, edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+628], dx
	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+164], cx

; 629  : 	currentStats.supplyLevel = startStats.supplyLevel = 100;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+630], 100			; 00000064H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+166], 100			; 00000064H

; 630  : 	currentStats.fuelLevel = startStats.fuelLevel = 100;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+631], 100			; 00000064H
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+167], 100			; 00000064H

; 631  : 	memset(bonusObjs,0,sizeof(VU_ID)*MAX_BONUSES);

	push	160					; 000000a0H
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 632				; 00000278H
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 632  : 	memset(bonusTime,0,sizeof(CampaignTime)*MAX_BONUSES);

	push	80					; 00000050H
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 792				; 00000318H
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 633  : 	memcpy(objtype_priority,DefaultObjtypePriority[TAT_CAS-1],sizeof(uchar)*MAX_TGTTYPE);

	push	36					; 00000024H
	mov	eax, 36					; 00000024H
	shl	eax, 2
	add	eax, OFFSET ?DefaultObjtypePriority@@3PAY0CE@EA ; DefaultObjtypePriority
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 170				; 000000aaH
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 634  : 	memcpy(unittype_priority,DefaultUnittypePriority[TAT_CAS-1],sizeof(uchar)*MAX_UNITTYPE);

	push	20					; 00000014H
	mov	edx, 20					; 00000014H
	shl	edx, 2
	add	edx, OFFSET ?DefaultUnittypePriority@@3PAY0BE@EA ; DefaultUnittypePriority
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 206				; 000000ceH
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 635  : 	memcpy(mission_priority,DefaultMissionPriority[TAT_CAS-1],sizeof(uchar)*AMIS_OTHER);

	push	41					; 00000029H
	mov	ecx, 41					; 00000029H
	shl	ecx, 2
	add	ecx, OFFSET ?DefaultMissionPriority@@3PAY0CJ@EA ; DefaultMissionPriority
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 226				; 000000e2H
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 636  : 	memset(max_vehicle,16,sizeof(uchar)*4);

	push	4
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 872				; 00000368H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 637  : 	memset(&groundAction,0,sizeof(TeamGndActionType));

	push	19					; 00000013H
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 267				; 0000010bH
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 638  : 	memset(&defensiveAirAction,0,sizeof(TeamAirActionType));

	push	28					; 0000001cH
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 288				; 00000120H
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 639  : 	memset(&offensiveAirAction,0,sizeof(TeamAirActionType));

	push	28					; 0000001cH
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 316				; 0000013cH
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 640  : 
; 641  : 	// Set some default values
; 642  : 	for (tid=1; tid<NUM_TEAMS; tid++){

	mov	ecx, 1
	mov	WORD PTR _tid$[ebp], cx
	jmp	SHORT $LN4@InitLocalD
$LN3@InitLocalD:
	mov	dx, WORD PTR _tid$[ebp]
	add	dx, 1
	mov	WORD PTR _tid$[ebp], dx
$LN4@InitLocalD:
	movsx	eax, WORD PTR _tid$[ebp]
	cmp	eax, 8
	jge	SHORT $LN2@InitLocalD

; 643  : 		stance[tid] = Neutral;

	movsx	ecx, WORD PTR _tid$[ebp]
	mov	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+ecx*2+580], dx

; 644  : 	}

	jmp	SHORT $LN3@InitLocalD
$LN2@InitLocalD:

; 645  : 	stance[owner] = Allied;

	movzx	ecx, BYTE PTR _owner$[ebp]
	mov	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+ecx*2+580], dx

; 646  : 	member[owner] = 1;

	movzx	ecx, BYTE PTR _owner$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+572], 1

; 647  : 	stance[0] = NoRelations;

	mov	eax, 2
	imul	eax, 0
	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+eax+580], cx

; 648  : 
; 649  : 	atm = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+876], 0

; 650  : 	gtm = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+880], 0

; 651  : 	ntm = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+884], 0

; 652  : 
; 653  : 	playerRating = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+604], xmm0

; 654  : 	lastPlayerMission = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+608], 0

; 655  : 
; 656  : 	ReadDoctrineFile();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadDoctrineFile@TeamClass@@QAEXXZ	; TeamClass::ReadDoctrineFile

; 657  : 	dirty_team = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+344], 0

; 658  : 
; 659  : 	if (FalconLocalGame){

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@InitLocalD
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv252[ebp], eax
	jmp	SHORT $LN8@InitLocalD
$LN7@InitLocalD:
	mov	DWORD PTR tv252[ebp], 0
$LN8@InitLocalD:
	cmp	DWORD PTR tv252[ebp], 0
	je	SHORT $LN1@InitLocalD

; 660  : 		SetAssociation(FalconLocalGame->Id());

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN9@InitLocalD
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv274[ebp], eax
	jmp	SHORT $LN10@InitLocalD
$LN9@InitLocalD:
	mov	DWORD PTR tv274[ebp], 0
$LN10@InitLocalD:
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR tv274[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAssociation@VuEntity@@QAEXVVU_ID@@@Z ; VuEntity::SetAssociation
$LN1@InitLocalD:

; 661  : 	}
; 662  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?InitLocalData@TeamClass@@AAEXE@Z ENDP			; TeamClass::InitLocalData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?InitData@TeamClass@@UAEXXZ PROC			; TeamClass::InitData
; _this$ = ecx

; 589  : void TeamClass::InitData(){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 590  : 	FalconEntity::InitData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitData@FalconEntity@@UAEXXZ		; FalconEntity::InitData

; 591  : 	InitLocalData(who);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+348]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitLocalData@TeamClass@@AAEXE@Z	; TeamClass::InitLocalData

; 592  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InitData@TeamClass@@UAEXXZ ENDP			; TeamClass::InitData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1TeamClass@@UAE@XZ PROC				; TeamClass::~TeamClass
; _this$ = ecx

; 586  : TeamClass::~TeamClass (void){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7TeamClass@@6B@

; 587  : }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1FalconEntity@@UAE@XZ			; FalconEntity::~FalconEntity
	mov	esp, ebp
	pop	ebp
	ret	0
??1TeamClass@@UAE@XZ ENDP				; TeamClass::~TeamClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
$T2 = -184						; size = 8
$T3 = -176						; size = 8
_attackTime$4 = -168					; size = 4
tv471 = -164						; size = 4
tv428 = -160						; size = 4
tv679 = -156						; size = 4
tv570 = -152						; size = 4
tv414 = -148						; size = 4
tv978 = -144						; size = 4
tv510 = -140						; size = 4
tv956 = -136						; size = 4
tv703 = -132						; size = 4
tv924 = -128						; size = 4
tv665 = -124						; size = 4
tv898 = -120						; size = 4
tv615 = -116						; size = 4
tv881 = -112						; size = 4
tv556 = -108						; size = 4
tv818 = -104						; size = 4
tv491 = -100						; size = 4
tv804 = -96						; size = 4
tv457 = -92						; size = 4
tv717 = -88						; size = 4
tv629 = -84						; size = 4
_offensiveLoss$5 = -77					; size = 1
_junk$6 = -76						; size = 2
_dummy$7 = -72						; size = 2
_i$8 = -68						; size = 4
_this$ = -64						; size = 4
_owner$9 = -60						; size = 41
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_file$ = 8						; size = 4
??0TeamClass@@QAE@PAU_iobuf@@@Z PROC			; TeamClass::TeamClass
; _this$ = ecx

; 260  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0TeamClass@@QAE@PAU_iobuf@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 172				; 000000acH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET ?VolatileNS@@3VIdNamespace@@A	; VolatileNS
	call	?GetIdFromNamespace@@YAKAAVIdNamespace@@@Z ; GetIdFromNamespace
	add	esp, 4
	push	eax
	push	100					; 00000064H
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0FalconEntity@@QAE@GK@Z		; FalconEntity::FalconEntity
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7TeamClass@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 267				; 0000010bH
	call	??0TeamGndActionType@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 288				; 00000120H
	call	??0TeamAirActionType@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 316				; 0000013cH
	call	??0TeamAirActionType@@QAE@XZ
	push	OFFSET ??0VU_ID@@QAE@XZ			; VU_ID::VU_ID
	push	20					; 00000014H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 632				; 00000278H
	push	ecx
	call	??_H@YGXPAXIHP6EPAX0@Z@Z
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 892				; 0000037cH
	call	??0TeamDoctrine@@QAE@XZ			; TeamDoctrine::TeamDoctrine

; 261  : 	// these are read from file by each side
; 262  : 	SetSendCreate(VuEntity::VU_SC_DONT_SEND);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSendCreate@VuEntity@@QAEXW4VU_SEND_TYPE@1@@Z ; VuEntity::SetSendCreate

; 263  : 
; 264  : 	// Read vu stuff here
; 265  : 	fread(&share_.id_, sizeof(VU_ID), 1, file);

	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	push	1
	push	8
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 266  : 	fread(&share_.entityType_, sizeof(ushort), 1, file);

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	push	1
	push	2
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 267  : 	//	SetEntityType(share_.entityType_);
; 268  : 	//
; 269  : 	//#ifdef DEBUG
; 270  : 	//	// Somehow this entity type got changed.. 
; 271  : 	//	if (gCampDataVersion < 35)
; 272  : 	//		SetEntityType(883);
; 273  : 	//#endif
; 274  : 
; 275  : //#ifdef CAMPTOOL
; 276  : //	if (gRenameIds)
; 277  : //	{
; 278  : //		VU_ID		new_id = FalconNullId;
; 279  : //
; 280  : //		// Rename this ID
; 281  : //		for (new_id.num_ = LAST_NON_VOLATILE_VU_ID_NUMBER-1; new_id.num_ > FIRST_NON_VOLATILE_VU_ID_NUMBER ; new_id.num_--)
; 282  : //		{
; 283  : //			if (!vuDatabase->Find(new_id))
; 284  : //			{
; 285  : //				RenameTable[share_.id_.num_] = new_id.num_;
; 286  : //				share_.id_ = new_id;
; 287  : //				break;
; 288  : //			}
; 289  : //		}
; 290  : //	}
; 291  : //#endif
; 292  : 
; 293  : 	// Reset the entity type, just to be sure.
; 294  : 	SetEntityType(teamManagerDIndex);

	movzx	eax, WORD PTR ?teamManagerDIndex@@3FA	; teamManagerDIndex
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetEntityType@VuEntity@@QAEXG@Z	; VuEntity::SetEntityType

; 295  : 	fread(&who, sizeof(Team), 1, file);

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	push	1
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 348				; 0000015cH
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 296  : 	fread(&cteam, sizeof(Team), 1, file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	1
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 349				; 0000015dH
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 297  : 	ShiAssert((cteam > 0 || who == 0) && cteam < NUM_TEAMS);
; 298  : 	fread(&flags, sizeof(short), 1, file);					

	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	push	1
	push	2
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 350				; 0000015eH
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 299  : 
; 300  : 	if (gCampDataVersion > 2)

	cmp	DWORD PTR ?gCampDataVersion@@3HA, 2	; gCampDataVersion
	jle	SHORT $LN78@TeamClass

; 301  : 	{
; 302  : 		fread(member, sizeof(uchar), NUM_COUNS, file);

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	push	8
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 572				; 0000023cH
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 303  : 		fread(stance, sizeof(short), NUM_TEAMS, file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	8
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 580				; 00000244H
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 304  : 	}
; 305  : 	else

	jmp	SHORT $LN77@TeamClass
$LN78@TeamClass:

; 306  : 	{
; 307  : 		memset(member,0,NUM_COUNS);

	push	8
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 572				; 0000023cH
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 308  : 		fread(member, sizeof(uchar), 7, file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	7
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 572				; 0000023cH
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 309  : 		fread(stance, sizeof(short), 7, file);

	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	push	7
	push	2
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 580				; 00000244H
	push	eax
	call	_fread
	add	esp, 16					; 00000010H
$LN77@TeamClass:

; 310  : 	}
; 311  : 
; 312  : 	fread(&firstColonel, sizeof(short), 1, file);			

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	push	1
	push	2
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 596				; 00000254H
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 313  : 	fread(&firstCommander, sizeof(short), 1, file);			

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	1
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 598				; 00000256H
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 314  : 	fread(&firstWingman, sizeof(short), 1, file);			

	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	push	1
	push	2
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 600				; 00000258H
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 315  : 	fread(&lastWingman, sizeof(short), 1, file);			

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	push	1
	push	2
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 602				; 0000025aH
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 316  : 
; 317  : 	playerRating = 0.0F;

	mov	eax, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [eax+604], xmm0

; 318  : 	lastPlayerMission = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+608], 0

; 319  : 
; 320  : 	if (gCampDataVersion > 11)

	cmp	DWORD PTR ?gCampDataVersion@@3HA, 11	; gCampDataVersion, 0000000bH
	jle	SHORT $LN76@TeamClass

; 321  : 	{
; 322  : 		fread(&airExperience, sizeof(uchar), 1, file);		

	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	push	1
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 612				; 00000264H
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 323  : 		fread(&airDefenseExperience, sizeof(uchar), 1, file);		

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	push	1
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 613				; 00000265H
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 324  : 		fread(&groundExperience, sizeof(uchar), 1, file);		

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	1
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 614				; 00000266H
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 325  : 		fread(&navalExperience, sizeof(uchar), 1, file);		

	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	push	1
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 615				; 00000267H
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 326  : 	}
; 327  : 	else

	jmp	SHORT $LN75@TeamClass
$LN76@TeamClass:

; 328  : 	{
; 329  : 		short	junk;
; 330  : 		fread(&junk, sizeof(short), 1, file);		

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	push	1
	push	2
	lea	edx, DWORD PTR _junk$6[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 331  : 		fread(&junk, sizeof(short), 1, file);		

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	1
	push	2
	lea	ecx, DWORD PTR _junk$6[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 332  : 		airExperience = 80;			

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+612], 80			; 00000050H

; 333  : 		airDefenseExperience = 80;	

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+613], 80			; 00000050H

; 334  : 		groundExperience = 80;		

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+614], 80			; 00000050H

; 335  : 		navalExperience = 80;		

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+615], 80			; 00000050H
$LN75@TeamClass:

; 336  : 	}
; 337  : 	fread(&initiative, sizeof(short), 1, file);	

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	1
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 144				; 00000090H
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 338  : 	fread(&supplyAvail, sizeof(ushort), 1, file);				

	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	push	1
	push	2
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 146				; 00000092H
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 339  : 	fread(&fuelAvail, sizeof(ushort), 1, file);				

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	push	1
	push	2
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 148				; 00000094H
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 340  : 	if (gCampDataVersion > 53)

	cmp	DWORD PTR ?gCampDataVersion@@3HA, 53	; gCampDataVersion, 00000035H
	jle	SHORT $LN74@TeamClass

; 341  : 	{
; 342  : 		fread(&replacementsAvail, sizeof(ushort), 1, file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	1
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 150				; 00000096H
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 343  : 		fread(&playerRating, sizeof(float), 1, file);		

	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	push	1
	push	4
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 604				; 0000025cH
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 344  : 		fread(&lastPlayerMission, sizeof(CampaignTime), 1, file);

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	push	1
	push	4
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 608				; 00000260H
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 345  : 	}
; 346  : 	else

	jmp	SHORT $LN73@TeamClass
$LN74@TeamClass:

; 347  : 	{
; 348  : 		replacementsAvail = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+150], ax

; 349  : 		playerRating = 0.0F;

	mov	edx, DWORD PTR _this$[ebp]
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [edx+604], xmm0

; 350  : 		lastPlayerMission = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+608], 0
$LN73@TeamClass:

; 351  : 	}
; 352  : 	if (gCampDataVersion < 40)

	cmp	DWORD PTR ?gCampDataVersion@@3HA, 40	; gCampDataVersion, 00000028H
	jge	SHORT $LN72@TeamClass

; 353  : 	{
; 354  : 		ushort
; 355  : 				dummy;
; 356  : 
; 357  : 		fread(&dummy, sizeof(ushort), 1, file);			

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	push	1
	push	2
	lea	edx, DWORD PTR _dummy$7[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 358  : 		fread(&dummy, sizeof(ushort), 1, file);				

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	1
	push	2
	lea	ecx, DWORD PTR _dummy$7[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H
$LN72@TeamClass:

; 359  : 	}
; 360  : 	fread(&currentStats, sizeof(TeamStatusType), 1, file);

	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	push	1
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 152				; 00000098H
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 361  : 	fread(&startStats, sizeof(TeamStatusType), 1, file);

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	push	1
	push	16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 616				; 00000268H
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 362  : 	fread(&reinforcement, sizeof(short), 1, file);			

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	1
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 168				; 000000a8H
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 363  : 	fread(bonusObjs, sizeof(VU_ID), MAX_BONUSES, file);

	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	push	20					; 00000014H
	push	8
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 632				; 00000278H
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 364  : 	fread(bonusTime, sizeof(CampaignTime), MAX_BONUSES, file);

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	push	20					; 00000014H
	push	4
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 792				; 00000318H
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 365  : 	fread(objtype_priority, sizeof(uchar), MAX_TGTTYPE, file);	

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	36					; 00000024H
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 170				; 000000aaH
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 366  : 	fread(unittype_priority, sizeof(uchar), MAX_UNITTYPE, file);

	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	push	20					; 00000014H
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 206				; 000000ceH
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 367  : 	if (gCampDataVersion < 30)

	cmp	DWORD PTR ?gCampDataVersion@@3HA, 30	; gCampDataVersion, 0000001eH
	jge	SHORT $LN71@TeamClass

; 368  : 		fread(mission_priority, sizeof(uchar), 40, file);	

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	push	40					; 00000028H
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 226				; 000000e2H
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 369  : 	else

	jmp	SHORT $LN70@TeamClass
$LN71@TeamClass:

; 370  : 		fread(mission_priority, sizeof(uchar), AMIS_OTHER, file);	

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	41					; 00000029H
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 226				; 000000e2H
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H
$LN70@TeamClass:

; 371  : 
; 372  : 	if (gCampDataVersion < 46)

	cmp	DWORD PTR ?gCampDataVersion@@3HA, 46	; gCampDataVersion, 0000002eH
	jge	SHORT $LN69@TeamClass

; 373  : 	{
; 374  : 		memcpy(objtype_priority,DefaultObjtypePriority[TAT_CAS-1],sizeof(uchar)*MAX_TGTTYPE);

	push	36					; 00000024H
	mov	edx, 36					; 00000024H
	shl	edx, 2
	add	edx, OFFSET ?DefaultObjtypePriority@@3PAY0CE@EA ; DefaultObjtypePriority
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 170				; 000000aaH
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 375  : 		memcpy(unittype_priority,DefaultUnittypePriority[TAT_CAS-1],sizeof(uchar)*MAX_UNITTYPE);

	push	20					; 00000014H
	mov	ecx, 20					; 00000014H
	shl	ecx, 2
	add	ecx, OFFSET ?DefaultUnittypePriority@@3PAY0BE@EA ; DefaultUnittypePriority
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 206				; 000000ceH
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 376  : 		memcpy(mission_priority,DefaultMissionPriority[TAT_CAS-1],sizeof(uchar)*AMIS_OTHER);

	push	41					; 00000029H
	mov	eax, 41					; 00000029H
	shl	eax, 2
	add	eax, OFFSET ?DefaultMissionPriority@@3PAY0CJ@EA ; DefaultMissionPriority
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 226				; 000000e2H
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN69@TeamClass:

; 377  : 	}
; 378  : 
; 379  : 	if (gCampDataVersion < 34)

	cmp	DWORD PTR ?gCampDataVersion@@3HA, 34	; gCampDataVersion, 00000022H
	jge	SHORT $LN68@TeamClass

; 380  : 	{
; 381  : 		CampaignTime	attackTime;
; 382  : 		uchar			offensiveLoss;
; 383  : 		fread(&attackTime, sizeof(CampaignTime), 1, file);			

	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	push	1
	push	4
	lea	eax, DWORD PTR _attackTime$4[ebp]
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 384  : 		fread(&offensiveLoss, sizeof(uchar), 1, file);				

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	push	1
	push	1
	lea	edx, DWORD PTR _offensiveLoss$5[ebp]
	push	edx
	call	_fread
	add	esp, 16					; 00000010H
$LN68@TeamClass:

; 385  : 	}
; 386  : 	fread(max_vehicle, sizeof(uchar), 4, file);				

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	4
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 872				; 00000368H
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 387  : 
; 388  : 	if (gCampDataVersion > 4)

	cmp	DWORD PTR ?gCampDataVersion@@3HA, 4	; gCampDataVersion
	jle	SHORT $LN67@TeamClass

; 389  : 	{
; 390  : 		fread(&teamFlag, sizeof(uchar), 1, file);

	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	push	1
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 888				; 00000378H
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 391  : 		if(gCampDataVersion > 32)

	cmp	DWORD PTR ?gCampDataVersion@@3HA, 32	; gCampDataVersion, 00000020H
	jle	SHORT $LN66@TeamClass

; 392  : 		{
; 393  : 			fread(&teamColor, sizeof(uchar), 1,file);

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	push	1
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 889				; 00000379H
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 394  : 		}
; 395  : 		else

	jmp	SHORT $LN65@TeamClass
$LN66@TeamClass:

; 396  : 		{
; 397  : 			teamColor = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+889], 0
$LN65@TeamClass:

; 398  : 		}
; 399  : 		fread(&equipment, sizeof(uchar), 1, file);

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	push	1
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 890				; 0000037aH
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 400  : 		fread(name, sizeof(_TCHAR)*MAX_TEAM_NAME_SIZE, 1, file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	1
	push	20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 352				; 00000160H
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H
$LN67@TeamClass:

; 401  : 	}
; 402  : 	if (gCampDataVersion < 41)

	cmp	DWORD PTR ?gCampDataVersion@@3HA, 41	; gCampDataVersion, 00000029H
	jge	$LN55@TeamClass

; 403  : 	{
; 404  : 		// Hand set colors correctly
; 405  : 		if (FalconLocalGame && FalconLocalGame->GetGameType() == game_Campaign)

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN81@TeamClass
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv414[ebp], eax
	jmp	SHORT $LN82@TeamClass
$LN81@TeamClass:
	mov	DWORD PTR tv414[ebp], 0
$LN82@TeamClass:
	cmp	DWORD PTR tv414[ebp], 0
	je	$LN63@TeamClass
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN83@TeamClass
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv428[ebp], eax
	jmp	SHORT $LN84@TeamClass
$LN83@TeamClass:
	mov	DWORD PTR tv428[ebp], 0
$LN84@TeamClass:
	mov	ecx, DWORD PTR tv428[ebp]
	call	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ ; FalconGameEntity::GetGameType
	cmp	eax, 4
	jne	SHORT $LN63@TeamClass

; 406  : 		{
; 407  : 			_TCHAR	owner[41];
; 408  : 			ReadIndexedString(40+who,owner,40);

	push	40					; 00000028H
	lea	ecx, DWORD PTR _owner$9[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+348]
	add	eax, 40					; 00000028H
	push	eax
	call	?ReadIndexedString@@YAXHPADH@Z		; ReadIndexedString
	add	esp, 12					; 0000000cH

; 409  : 			_tcscpy(name, owner);

	lea	ecx, DWORD PTR _owner$9[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 352				; 00000160H
	push	edx
	call	_strcpy
	add	esp, 8

; 410  : 			teamColor = who;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+348]
	mov	BYTE PTR [eax+889], dl

; 411  : 			teamFlag = who;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+348]
	mov	BYTE PTR [eax+888], dl
	jmp	$LN60@TeamClass
$LN63@TeamClass:

; 412  : 		}
; 413  : 		else if (FalconLocalGame && FalconLocalGame->GetGameType() == game_TacticalEngagement)

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN85@TeamClass
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv457[ebp], eax
	jmp	SHORT $LN86@TeamClass
$LN85@TeamClass:
	mov	DWORD PTR tv457[ebp], 0
$LN86@TeamClass:
	cmp	DWORD PTR tv457[ebp], 0
	je	SHORT $LN60@TeamClass
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN87@TeamClass
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv471[ebp], eax
	jmp	SHORT $LN88@TeamClass
$LN87@TeamClass:
	mov	DWORD PTR tv471[ebp], 0
$LN88@TeamClass:
	mov	ecx, DWORD PTR tv471[ebp]
	call	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ ; FalconGameEntity::GetGameType
	cmp	eax, 3
	jne	SHORT $LN60@TeamClass

; 414  : 		{
; 415  : 			if (who == 1)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+348]
	cmp	eax, 1
	jne	SHORT $LN60@TeamClass

; 416  : 				teamColor = 2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+889], 2
$LN60@TeamClass:

; 417  : 		}
; 418  : 		if (FalconLocalGame->GetGameType() != game_InstantAction)

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN89@TeamClass
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv491[ebp], eax
	jmp	SHORT $LN90@TeamClass
$LN89@TeamClass:
	mov	DWORD PTR tv491[ebp], 0
$LN90@TeamClass:
	mov	ecx, DWORD PTR tv491[ebp]
	call	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ ; FalconGameEntity::GetGameType
	cmp	eax, 1
	je	SHORT $LN59@TeamClass

; 419  : 			stance[0] = NoRelations;

	mov	eax, 2
	imul	eax, 0
	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+eax+580], cx
$LN59@TeamClass:

; 420  : 		if (FalconLocalGame->GetGameType() == game_TacticalEngagement)

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN91@TeamClass
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv510[ebp], eax
	jmp	SHORT $LN92@TeamClass
$LN91@TeamClass:
	mov	DWORD PTR tv510[ebp], 0
$LN92@TeamClass:
	mov	ecx, DWORD PTR tv510[ebp]
	call	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ ; FalconGameEntity::GetGameType
	cmp	eax, 3
	jne	$LN55@TeamClass

; 421  : 		{
; 422  : 			int	i;
; 423  : 			for (i=0; i<NUM_TEAMS; i++)

	mov	DWORD PTR _i$8[ebp], 0
	jmp	SHORT $LN57@TeamClass
$LN56@TeamClass:
	mov	ecx, DWORD PTR _i$8[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$8[ebp], ecx
$LN57@TeamClass:
	cmp	DWORD PTR _i$8[ebp], 8
	jge	$LN55@TeamClass

; 424  : 			{
; 425  : 				if (!i || !who)

	cmp	DWORD PTR _i$8[ebp], 0
	je	SHORT $LN53@TeamClass
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+348]
	test	eax, eax
	jne	SHORT $LN54@TeamClass
$LN53@TeamClass:

; 426  : 					stance[i] = NoRelations;

	xor	ecx, ecx
	mov	edx, DWORD PTR _i$8[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+edx*2+580], cx
	jmp	SHORT $LN50@TeamClass
$LN54@TeamClass:

; 427  : 				else if (i != who)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+348]
	cmp	DWORD PTR _i$8[ebp], edx
	je	SHORT $LN51@TeamClass

; 428  : 					stance[i] = War;

	mov	eax, 5
	mov	ecx, DWORD PTR _i$8[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+ecx*2+580], ax

; 429  : 				else

	jmp	SHORT $LN50@TeamClass
$LN51@TeamClass:

; 430  : 					stance[i] = Allied;

	mov	eax, 1
	mov	ecx, DWORD PTR _i$8[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+ecx*2+580], ax
$LN50@TeamClass:

; 431  : 				max_vehicle[0] = max_vehicle[1] = max_vehicle[2] = max_vehicle[3] = 16;

	mov	eax, 1
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+eax+872], 16		; 00000010H
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+edx+872], 16		; 00000010H
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+ecx+872], 16		; 00000010H
	mov	eax, 1
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+eax+872], 16		; 00000010H

; 432  : 			}

	jmp	$LN56@TeamClass
$LN55@TeamClass:

; 433  : 		}
; 434  : 	}
; 435  : 	// KCK HACK: Hand clobber instant action and dogfight colors
; 436  : 	if (FalconLocalGame && FalconLocalGame->GetGameType() == game_Dogfight)

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN93@TeamClass
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv556[ebp], eax
	jmp	SHORT $LN94@TeamClass
$LN93@TeamClass:
	mov	DWORD PTR tv556[ebp], 0
$LN94@TeamClass:
	cmp	DWORD PTR tv556[ebp], 0
	je	$LN49@TeamClass
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN95@TeamClass
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv570[ebp], eax
	jmp	SHORT $LN96@TeamClass
$LN95@TeamClass:
	mov	DWORD PTR tv570[ebp], 0
$LN96@TeamClass:
	mov	ecx, DWORD PTR tv570[ebp]
	call	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ ; FalconGameEntity::GetGameType
	cmp	eax, 2
	jne	$LN49@TeamClass

; 437  : 	{
; 438  : 		if (who == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+348]
	test	edx, edx
	jne	SHORT $LN48@TeamClass

; 439  : 			teamColor = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+889], 0
	jmp	SHORT $LN39@TeamClass
$LN48@TeamClass:

; 440  : 		else if (who == 1)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+348]
	cmp	edx, 1
	jne	SHORT $LN46@TeamClass

; 441  : 			teamColor = 6;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+889], 6
	jmp	SHORT $LN39@TeamClass
$LN46@TeamClass:

; 442  : 		else if (who == 2)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+348]
	cmp	edx, 2
	jne	SHORT $LN44@TeamClass

; 443  : 			teamColor = 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+889], 2
	jmp	SHORT $LN39@TeamClass
$LN44@TeamClass:

; 444  : 		else if (who == 3)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+348]
	cmp	edx, 3
	jne	SHORT $LN42@TeamClass

; 445  : 			teamColor = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+889], 0
	jmp	SHORT $LN39@TeamClass
$LN42@TeamClass:

; 446  : 		else if (who == 4)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+348]
	cmp	edx, 4
	jne	SHORT $LN40@TeamClass

; 447  : 			teamColor = 5;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+889], 5

; 448  : 		else

	jmp	SHORT $LN39@TeamClass
$LN40@TeamClass:

; 449  : 			teamColor = who;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+348]
	mov	BYTE PTR [ecx+889], al
$LN39@TeamClass:

; 450  : 		SetName(DogfightTeamNames[who]);

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+348]
	imul	edx, 20					; 00000014H
	add	edx, OFFSET ?DogfightTeamNames@@3PAY0BE@DA ; DogfightTeamNames
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetName@TeamClass@@QAEXPAD@Z		; TeamClass::SetName
	jmp	$LN33@TeamClass
$LN49@TeamClass:

; 451  : 	}
; 452  : 	else if (FalconLocalGame && FalconLocalGame->GetGameType() == game_InstantAction)

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN97@TeamClass
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv615[ebp], eax
	jmp	SHORT $LN98@TeamClass
$LN97@TeamClass:
	mov	DWORD PTR tv615[ebp], 0
$LN98@TeamClass:
	cmp	DWORD PTR tv615[ebp], 0
	je	$LN33@TeamClass
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN99@TeamClass
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv629[ebp], eax
	jmp	SHORT $LN100@TeamClass
$LN99@TeamClass:
	mov	DWORD PTR tv629[ebp], 0
$LN100@TeamClass:
	mov	ecx, DWORD PTR tv629[ebp]
	call	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ ; FalconGameEntity::GetGameType
	cmp	eax, 1
	jne	$LN33@TeamClass

; 453  : 	{
; 454  : 		if (who == 0)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+348]
	test	eax, eax
	jne	SHORT $LN36@TeamClass

; 455  : 			teamColor = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+889], 1
	jmp	SHORT $LN34@TeamClass
$LN36@TeamClass:

; 456  : 		else if (who == 1)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+348]
	cmp	eax, 1
	jne	SHORT $LN34@TeamClass

; 457  : 		{
; 458  : 			cteam = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+349], 1

; 459  : 			member[2] = 0;

	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+edx+572], 0

; 460  : 			teamColor = 2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+889], 2
$LN34@TeamClass:

; 461  : 		}
; 462  : 		if (who == 2)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+348]
	cmp	eax, 2
	jne	SHORT $LN33@TeamClass

; 463  : 		{
; 464  : 			cteam = 2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+349], 2

; 465  : 			teamColor = 6;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+889], 6

; 466  : 			member[1] = 0;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+eax+572], 0
$LN33@TeamClass:

; 467  : 		}
; 468  : 	}
; 469  : 
; 470  : 	// SCR HACK: Hand clobber instant action skill levels
; 471  : 	if (FalconLocalGame && FalconLocalGame->GetGameType() == game_InstantAction)

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN101@TeamClass
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv665[ebp], eax
	jmp	SHORT $LN102@TeamClass
$LN101@TeamClass:
	mov	DWORD PTR tv665[ebp], 0
$LN102@TeamClass:
	cmp	DWORD PTR tv665[ebp], 0
	je	SHORT $LN32@TeamClass
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN103@TeamClass
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv679[ebp], eax
	jmp	SHORT $LN104@TeamClass
$LN103@TeamClass:
	mov	DWORD PTR tv679[ebp], 0
$LN104@TeamClass:
	mov	ecx, DWORD PTR tv679[ebp]
	call	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ ; FalconGameEntity::GetGameType
	cmp	eax, 1
	jne	SHORT $LN32@TeamClass

; 472  : 	{
; 473  : 		ShiAssert(InstantActionSettings.PilotLevel >= 0  &&  InstantActionSettings.PilotLevel <= 4);
; 474  : 		airExperience			= 60 + 10 * InstantActionSettings.PilotLevel;

	mov	ecx, DWORD PTR ?InstantActionSettings@@3UUI_IA@@A+4
	imul	ecx, 10					; 0000000aH
	add	ecx, 60					; 0000003cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+612], cl

; 475  : 		airDefenseExperience	= 60 + 10 * InstantActionSettings.PilotLevel;

	mov	eax, DWORD PTR ?InstantActionSettings@@3UUI_IA@@A+4
	imul	eax, 10					; 0000000aH
	add	eax, 60					; 0000003cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+613], al
$LN32@TeamClass:

; 476  : 	}
; 477  : 	// KCK HACK: For campaign (and localization), clobber team names
; 478  : 	if (FalconLocalGame && FalconLocalGame->GetGameType() == game_Campaign)

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN105@TeamClass
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv703[ebp], eax
	jmp	SHORT $LN106@TeamClass
$LN105@TeamClass:
	mov	DWORD PTR tv703[ebp], 0
$LN106@TeamClass:
	cmp	DWORD PTR tv703[ebp], 0
	je	SHORT $LN31@TeamClass
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN107@TeamClass
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv717[ebp], eax
	jmp	SHORT $LN108@TeamClass
$LN107@TeamClass:
	mov	DWORD PTR tv717[ebp], 0
$LN108@TeamClass:
	mov	ecx, DWORD PTR tv717[ebp]
	call	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ ; FalconGameEntity::GetGameType
	cmp	eax, 4
	jne	SHORT $LN31@TeamClass

; 479  : 		ReadIndexedString(40+who,name,MAX_TEAM_NAME_SIZE);

	push	20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 352				; 00000160H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+348]
	add	eax, 40					; 00000028H
	push	eax
	call	?ReadIndexedString@@YAXHPADH@Z		; ReadIndexedString
	add	esp, 12					; 0000000cH
$LN31@TeamClass:

; 480  : 
; 481  : 	if(gCampDataVersion > 32)

	cmp	DWORD PTR ?gCampDataVersion@@3HA, 32	; gCampDataVersion, 00000020H
	jle	SHORT $LN30@TeamClass

; 482  : 	{
; 483  : 		fread(teamMotto, sizeof(_TCHAR)*MAX_MOTTO_SIZE,1,file);

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	push	1
	push	200					; 000000c8H
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 372				; 00000174H
	push	edx
	call	_fread
	add	esp, 16					; 00000010H

; 484  : 	}
; 485  : 	else

	jmp	SHORT $LN29@TeamClass
$LN30@TeamClass:

; 486  : 	{
; 487  : 		memset(teamMotto, 0, sizeof(_TCHAR)*MAX_MOTTO_SIZE);

	push	200					; 000000c8H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 372				; 00000174H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN29@TeamClass:

; 488  : 	}
; 489  : 
; 490  : 	if (gCampDataVersion > 33)

	cmp	DWORD PTR ?gCampDataVersion@@3HA, 33	; gCampDataVersion, 00000021H
	jle	$LN28@TeamClass

; 491  : 	{
; 492  : 		if (gCampDataVersion > 50)

	cmp	DWORD PTR ?gCampDataVersion@@3HA, 50	; gCampDataVersion, 00000032H
	jle	SHORT $LN27@TeamClass

; 493  : 			fread(&groundAction, sizeof(TeamGndActionType), 1, file);

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	push	1
	push	19					; 00000013H
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 267				; 0000010bH
	push	edx
	call	_fread
	add	esp, 16					; 00000010H
	jmp	SHORT $LN24@TeamClass
$LN27@TeamClass:

; 494  : 		else if (gCampDataVersion > 41)

	cmp	DWORD PTR ?gCampDataVersion@@3HA, 41	; gCampDataVersion, 00000029H
	jle	SHORT $LN25@TeamClass

; 495  : 		{
; 496  : 			fread(&groundAction, 27, 1, file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	1
	push	27					; 0000001bH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 267				; 0000010bH
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 497  : 			memset(&groundAction,0,sizeof(TeamGndActionType));

	push	19					; 00000013H
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 267				; 0000010bH
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 498  : 		}
; 499  : 		else

	jmp	SHORT $LN24@TeamClass
$LN25@TeamClass:

; 500  : 		{
; 501  : 			fread(&groundAction, 23, 1, file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	1
	push	23					; 00000017H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 267				; 0000010bH
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 502  : 			memset(&groundAction,0,sizeof(TeamGndActionType));

	push	19					; 00000013H
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 267				; 0000010bH
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH
$LN24@TeamClass:

; 503  : 		}	
; 504  : 		fread(&defensiveAirAction, sizeof(TeamAirActionType), 1, file);

	mov	eax, DWORD PTR _file$[ebp]
	push	eax
	push	1
	push	28					; 0000001cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 288				; 00000120H
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 505  : 		fread(&offensiveAirAction, sizeof(TeamAirActionType), 1, file);

	mov	edx, DWORD PTR _file$[ebp]
	push	edx
	push	1
	push	28					; 0000001cH
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 316				; 0000013cH
	push	eax
	call	_fread
	add	esp, 16					; 00000010H

; 506  : 	}
; 507  : 	else

	jmp	SHORT $LN23@TeamClass
$LN28@TeamClass:

; 508  : 	{
; 509  : 		memset(&groundAction,0,sizeof(TeamGndActionType));

	push	19					; 00000013H
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 267				; 0000010bH
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 510  : 		memset(&defensiveAirAction,0,sizeof(TeamAirActionType));

	push	28					; 0000001cH
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 288				; 00000120H
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 511  : 		memset(&offensiveAirAction,0,sizeof(TeamAirActionType));

	push	28					; 0000001cH
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 316				; 0000013cH
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN23@TeamClass:

; 512  : 	}
; 513  : 	if (gCampDataVersion < 43)

	cmp	DWORD PTR ?gCampDataVersion@@3HA, 43	; gCampDataVersion, 0000002bH
	jge	SHORT $LN22@TeamClass

; 514  : 	{
; 515  : 		groundAction.actionType = GACTION_CONSOLIDATE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+283], 2

; 516  : 		supplyAvail = fuelAvail = 1000;

	mov	edx, 1000				; 000003e8H
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+148], dx
	mov	ecx, 1000				; 000003e8H
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+146], cx
$LN22@TeamClass:

; 517  : 	}
; 518  : 	if (gCampDataVersion < 60 && FalconLocalGame && FalconLocalGame->GetGameType() == game_Campaign)

	cmp	DWORD PTR ?gCampDataVersion@@3HA, 60	; gCampDataVersion, 0000003cH
	jge	$LN11@TeamClass
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN109@TeamClass
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv804[ebp], eax
	jmp	SHORT $LN110@TeamClass
$LN109@TeamClass:
	mov	DWORD PTR tv804[ebp], 0
$LN110@TeamClass:
	cmp	DWORD PTR tv804[ebp], 0
	je	$LN11@TeamClass
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN111@TeamClass
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv818[ebp], eax
	jmp	SHORT $LN112@TeamClass
$LN111@TeamClass:
	mov	DWORD PTR tv818[ebp], 0
$LN112@TeamClass:
	mov	ecx, DWORD PTR tv818[ebp]
	call	?GetGameType@FalconGameEntity@@QAE?AW4FalconGameType@@XZ ; FalconGameEntity::GetGameType
	cmp	eax, 4
	jne	$LN11@TeamClass

; 519  : 	{
; 520  : 		if (who == COUN_US)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+348]
	cmp	eax, 1
	jne	SHORT $LN20@TeamClass

; 521  : 			equipment = toe_us;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+890], 5
	jmp	SHORT $LN11@TeamClass
$LN20@TeamClass:

; 522  : 		else if (who == COUN_SOUTH_KOREA)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+348]
	cmp	eax, 2
	jne	SHORT $LN18@TeamClass

; 523  : 			equipment = toe_rok;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+890], 3
	jmp	SHORT $LN11@TeamClass
$LN18@TeamClass:

; 524  : 		else if (who == COUN_JAPAN)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+348]
	cmp	eax, 3
	jne	SHORT $LN16@TeamClass

; 525  : 			equipment = toe_us;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+890], 5
	jmp	SHORT $LN11@TeamClass
$LN16@TeamClass:

; 526  : 		else if (who == COUN_RUSSIA)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+348]
	cmp	eax, 4
	jne	SHORT $LN14@TeamClass

; 527  : 			equipment = toe_soviet;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+890], 4
	jmp	SHORT $LN11@TeamClass
$LN14@TeamClass:

; 528  : 		else if (who == COUN_CHINA)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+348]
	cmp	eax, 5
	jne	SHORT $LN12@TeamClass

; 529  : 			equipment = toe_chinese;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+890], 1

; 530  : 		else

	jmp	SHORT $LN11@TeamClass
$LN12@TeamClass:

; 531  : 			equipment = toe_dprk;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+890], 2
$LN11@TeamClass:

; 532  : 	}
; 533  : 	if (gCampDataVersion < 51)

	cmp	DWORD PTR ?gCampDataVersion@@3HA, 51	; gCampDataVersion, 00000033H
	jge	$LN4@TeamClass

; 534  : 	{
; 535  : 		if (who == COUN_RUSSIA)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+348]
	cmp	ecx, 4
	jne	SHORT $LN9@TeamClass

; 536  : 		{
; 537  : 			firstColonel = 500; 

	mov	edx, 500				; 000001f4H
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+596], dx

; 538  : 			firstCommander = 505;

	mov	ecx, 505				; 000001f9H
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+598], cx

; 539  : 			firstWingman = 538;

	mov	eax, 538				; 0000021aH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+600], ax

; 540  : 			lastWingman = 583;

	mov	edx, 583				; 00000247H
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+602], dx
	jmp	$LN4@TeamClass
$LN9@TeamClass:

; 541  : 		}
; 542  : 		else if (who == COUN_CHINA)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+348]
	cmp	edx, 5
	jne	SHORT $LN7@TeamClass

; 543  : 		{
; 544  : 			firstColonel = 600; 

	mov	eax, 600				; 00000258H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+596], ax

; 545  : 			firstCommander = 605;

	mov	edx, 605				; 0000025dH
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+598], dx

; 546  : 			firstWingman = 639;

	mov	ecx, 639				; 0000027fH
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+600], cx

; 547  : 			lastWingman = 686;

	mov	eax, 686				; 000002aeH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+602], ax
	jmp	$LN4@TeamClass
$LN7@TeamClass:

; 548  : 		}
; 549  : 		else if (who == COUN_US)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+348]
	cmp	eax, 1
	jne	SHORT $LN5@TeamClass

; 550  : 		{
; 551  : 			firstColonel = 0; 

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+596], cx

; 552  : 			firstCommander = 20;

	mov	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+598], ax

; 553  : 			firstWingman = 149;

	mov	edx, 149				; 00000095H
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+600], dx

; 554  : 			lastWingman = 373;

	mov	ecx, 373				; 00000175H
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+602], cx

; 555  : 		}
; 556  : 		else

	jmp	SHORT $LN4@TeamClass
$LN5@TeamClass:

; 557  : 		{
; 558  : 			firstColonel = 400; 

	mov	eax, 400				; 00000190H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+596], ax

; 559  : 			firstCommander = 408;

	mov	edx, 408				; 00000198H
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+598], dx

; 560  : 			firstWingman = 460;

	mov	ecx, 460				; 000001ccH
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+600], cx

; 561  : 			lastWingman = 499;

	mov	eax, 499				; 000001f3H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+602], ax
$LN4@TeamClass:

; 562  : 		}
; 563  : 	}
; 564  : 
; 565  : 	// Set the owner to the game master.
; 566  : 	if ((FalconLocalGame) && (!FalconLocalGame->IsLocal()))

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN113@TeamClass
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv881[ebp], eax
	jmp	SHORT $LN114@TeamClass
$LN113@TeamClass:
	mov	DWORD PTR tv881[ebp], 0
$LN114@TeamClass:
	cmp	DWORD PTR tv881[ebp], 0
	je	$LN3@TeamClass
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN115@TeamClass
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv898[ebp], eax
	jmp	SHORT $LN116@TeamClass
$LN115@TeamClass:
	mov	DWORD PTR tv898[ebp], 0
$LN116@TeamClass:
	mov	ecx, DWORD PTR tv898[ebp]
	call	?IsLocal@VuEntity@@QBEEXZ		; VuEntity::IsLocal
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@TeamClass

; 567  : 	{
; 568  : 		SetOwner(FalconLocalGame->OwnerId());

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN117@TeamClass
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv924[ebp], eax
	jmp	SHORT $LN118@TeamClass
$LN117@TeamClass:
	mov	DWORD PTR tv924[ebp], 0
$LN118@TeamClass:
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR tv924[ebp]
	call	?OwnerId@VuEntity@@QBE?AVVU_ID@@XZ	; VuEntity::OwnerId
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetOwner@FalconEntity@@QAEXVVU_ID@@@Z	; FalconEntity::SetOwner

; 569  : 		flags &= ~TEAM_UPDATED;			// We're not updated until we get data from the master

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+350]
	and	ecx, -5					; fffffffbH
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+350], cx

; 570  : 	}
; 571  : 	else

	jmp	SHORT $LN2@TeamClass
$LN3@TeamClass:

; 572  : 		flags |= TEAM_UPDATED;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+350]
	or	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+350], cx
$LN2@TeamClass:

; 573  : 
; 574  : 	atm = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+876], 0

; 575  : 	gtm = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+880], 0

; 576  : 	ntm = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+884], 0

; 577  : 	dirty_team = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+344], 0

; 578  : 
; 579  : 	// Associate this entity with the game owner.
; 580  : 	if (FalconLocalGame){

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN119@TeamClass
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv956[ebp], eax
	jmp	SHORT $LN120@TeamClass
$LN119@TeamClass:
	mov	DWORD PTR tv956[ebp], 0
$LN120@TeamClass:
	cmp	DWORD PTR tv956[ebp], 0
	je	SHORT $LN1@TeamClass

; 581  : 		SetAssociation(FalconLocalGame->Id());

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN121@TeamClass
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv978[ebp], eax
	jmp	SHORT $LN122@TeamClass
$LN121@TeamClass:
	mov	DWORD PTR tv978[ebp], 0
$LN122@TeamClass:
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR tv978[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAssociation@VuEntity@@QAEXVVU_ID@@@Z ; VuEntity::SetAssociation
$LN1@TeamClass:

; 582  : 	}
; 583  : 	ReadDoctrineFile();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadDoctrineFile@TeamClass@@QAEXXZ	; TeamClass::ReadDoctrineFile

; 584  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0TeamClass@@QAE@PAU_iobuf@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1FalconEntity@@UAE@XZ			; FalconEntity::~FalconEntity
__ehhandler$??0TeamClass@@QAE@PAU_iobuf@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-176]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0TeamClass@@QAE@PAU_iobuf@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0TeamClass@@QAE@PAU_iobuf@@@Z ENDP			; TeamClass::TeamClass
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
$T2 = -40						; size = 8
_tmpID$ = -32						; size = 8
tv408 = -24						; size = 4
tv386 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_stream$ = 8						; size = 4
_rem$ = 12						; size = 4
??0TeamClass@@QAE@PAPAEPAJ@Z PROC			; TeamClass::TeamClass
; _this$ = ecx

; 186  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0TeamClass@@QAE@PAPAEPAJ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET ?VolatileNS@@3VIdNamespace@@A	; VolatileNS
	call	?GetIdFromNamespace@@YAKAAVIdNamespace@@@Z ; GetIdFromNamespace
	add	esp, 4
	push	eax
	push	100					; 00000064H
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0FalconEntity@@QAE@GK@Z		; FalconEntity::FalconEntity
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7TeamClass@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 267				; 0000010bH
	call	??0TeamGndActionType@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 288				; 00000120H
	call	??0TeamAirActionType@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 316				; 0000013cH
	call	??0TeamAirActionType@@QAE@XZ
	push	OFFSET ??0VU_ID@@QAE@XZ			; VU_ID::VU_ID
	push	20					; 00000014H
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 632				; 00000278H
	push	ecx
	call	??_H@YGXPAXIHP6EPAX0@Z@Z
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 892				; 0000037cH
	call	??0TeamDoctrine@@QAE@XZ			; TeamDoctrine::TeamDoctrine

; 187  : 	// these are read from file by each side
; 188  : 	SetSendCreate(VuEntity::VU_SC_DONT_SEND);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSendCreate@VuEntity@@QAEXW4VU_SEND_TYPE@1@@Z ; VuEntity::SetSendCreate

; 189  : 
; 190  : 	VU_ID tmpID;

	lea	ecx, DWORD PTR _tmpID$[ebp]
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID

; 191  : 
; 192  : 	// Read vu stuff here
; 193  : 	memcpychk(&share_.id_, stream, sizeof(VU_ID), rem);

	mov	edx, DWORD PTR _rem$[ebp]
	push	edx
	push	8
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 194  : 	memcpychk(&share_.ownerId_, stream, sizeof(VU_ID), rem);			   

	mov	edx, DWORD PTR _rem$[ebp]
	push	edx
	push	8
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 195  : 	memcpychk(&share_.entityType_, stream, sizeof(ushort), rem);		   

	mov	edx, DWORD PTR _rem$[ebp]
	push	edx
	push	2
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	push	ecx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 196  : 	SetEntityType(share_.entityType_);

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, WORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetEntityType@VuEntity@@QAEXG@Z	; VuEntity::SetEntityType

; 197  : 
; 198  : 	// Start reading the shit
; 199  : 	memcpychk(&who, stream, sizeof(Team), rem);							   

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 348				; 0000015cH
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 200  : 	ShiAssert (TeamInfo[who] && TeamInfo[who]->share_.id_ == share_.id_)
; 201  : 
; 202  : 	memcpychk(&cteam, stream, sizeof(Team), rem);						

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 349				; 0000015dH
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 203  : 	ShiAssert((cteam > 0 || who == 0) && cteam < NUM_TEAMS);
; 204  : 	memcpychk(&flags, stream, sizeof(short), rem);						   

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 350				; 0000015eH
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 205  : 	memcpychk(member, stream, sizeof(uchar)*NUM_COUNS, rem);			   

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	8
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 572				; 0000023cH
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 206  : 	memcpychk(stance, stream, sizeof(short)*NUM_TEAMS, rem);			   

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	16					; 00000010H
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 580				; 00000244H
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 207  : 	memcpychk(&firstColonel, stream, sizeof(short), rem);				   

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 596				; 00000254H
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 208  : 	memcpychk(&firstCommander, stream, sizeof(short), rem);				   

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 598				; 00000256H
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 209  : 	memcpychk(&firstWingman, stream, sizeof(short), rem);				   

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 600				; 00000258H
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 210  : 	memcpychk(&lastWingman, stream, sizeof(short), rem);				   

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 602				; 0000025aH
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 211  : 
; 212  : 	memcpychk(&airExperience, stream, sizeof(uchar), rem);				   

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 612				; 00000264H
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 213  : 	memcpychk(&airDefenseExperience, stream, sizeof(uchar), rem);		   

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 613				; 00000265H
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 214  : 	memcpychk(&groundExperience, stream, sizeof(uchar), rem);			   

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 614				; 00000266H
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 215  : 	memcpychk(&navalExperience, stream, sizeof(uchar), rem);			   

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 615				; 00000267H
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 216  : 	memcpychk(&initiative, stream, sizeof(short), rem);					   

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 144				; 00000090H
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 217  : 	memcpychk(&supplyAvail, stream, sizeof(ushort), rem);				   

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 146				; 00000092H
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 218  : 	memcpychk(&fuelAvail, stream, sizeof(ushort), rem);					   

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 148				; 00000094H
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 219  : 	memcpychk(&replacementsAvail, stream, sizeof(ushort), rem);			   

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 150				; 00000096H
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 220  : 	memcpychk(&playerRating, stream, sizeof(float), rem);				   

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	4
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 604				; 0000025cH
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 221  : 	memcpychk(&lastPlayerMission, stream, sizeof(CampaignTime), rem);	   

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	4
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 608				; 00000260H
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 222  : 	memcpychk(&currentStats, stream, sizeof(TeamStatusType), rem);		   

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	16					; 00000010H
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 152				; 00000098H
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 223  : 	memcpychk(&startStats, stream, sizeof(TeamStatusType), rem);		   

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	16					; 00000010H
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 616				; 00000268H
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 224  : 	memcpychk(&reinforcement, stream, sizeof(short), rem);				   

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 168				; 000000a8H
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 225  : 	memcpychk(bonusObjs, stream, sizeof(VU_ID)*MAX_BONUSES, rem);		   

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	160					; 000000a0H
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 632				; 00000278H
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 226  : 	memcpychk(bonusTime, stream, sizeof(CampaignTime)*MAX_BONUSES, rem);   

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	80					; 00000050H
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 792				; 00000318H
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 227  : 	memcpychk(objtype_priority, stream, sizeof(uchar)*MAX_TGTTYPE, rem);   

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	36					; 00000024H
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 170				; 000000aaH
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 228  : 	memcpychk(unittype_priority, stream, sizeof(uchar)*MAX_UNITTYPE, rem); 

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	20					; 00000014H
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 206				; 000000ceH
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 229  : 	memcpychk(mission_priority, stream, sizeof(uchar)*AMIS_OTHER, rem);	   

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	41					; 00000029H
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 226				; 000000e2H
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 230  : 	memcpychk(max_vehicle, stream, sizeof(uchar)*4, rem);				   

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	4
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 872				; 00000368H
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 231  : 	memcpychk(&teamFlag, stream, sizeof(uchar), rem);					   

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 888				; 00000378H
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 232  : 	memcpychk(&teamColor, stream, sizeof(uchar), rem);					   

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 889				; 00000379H
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 233  : 	memcpychk(&equipment, stream, sizeof(uchar), rem);					   

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 890				; 0000037aH
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 234  : 	memcpychk(name, stream, sizeof(_TCHAR)*MAX_TEAM_NAME_SIZE, rem);	   

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	20					; 00000014H
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 352				; 00000160H
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 235  : 	memcpychk(teamMotto, stream, sizeof(_TCHAR)*MAX_MOTTO_SIZE, rem);	   

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	200					; 000000c8H
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 372				; 00000174H
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 236  : 	memcpychk(&groundAction, stream, sizeof(TeamGndActionType), rem);	   

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	19					; 00000013H
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 267				; 0000010bH
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 237  : 	memcpychk(&defensiveAirAction, stream, sizeof(TeamAirActionType), rem);

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	28					; 0000001cH
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 288				; 00000120H
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 238  : 	memcpychk(&offensiveAirAction, stream, sizeof(TeamAirActionType), rem);

	mov	ecx, DWORD PTR _rem$[ebp]
	push	ecx
	push	28					; 0000001cH
	mov	edx, DWORD PTR _stream$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 316				; 0000013cH
	push	eax
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 239  : 
; 240  : 	atm = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+876], 0

; 241  : 	gtm = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+880], 0

; 242  : 	ntm = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+884], 0

; 243  : 
; 244  : 	dirty_team = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+344], 0

; 245  : 
; 246  : 	// Attach our managers, if we have them already
; 247  : 	memcpychk(&tmpID, stream, sizeof(VU_ID), rem);

	mov	edx, DWORD PTR _rem$[ebp]
	push	edx
	push	8
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmpID$[ebp]
	push	ecx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 248  : 	memcpychk(&tmpID, stream, sizeof(VU_ID), rem);

	mov	edx, DWORD PTR _rem$[ebp]
	push	edx
	push	8
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmpID$[ebp]
	push	ecx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 249  : 	memcpychk(&tmpID, stream, sizeof(VU_ID), rem);

	mov	edx, DWORD PTR _rem$[ebp]
	push	edx
	push	8
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmpID$[ebp]
	push	ecx
	call	?memcpychk@@YAXPAXPAPAEIPAJ@Z		; memcpychk
	add	esp, 16					; 00000010H

; 250  : 
; 251  : 	// Associate this entity with the game owner.
; 252  : 	if (FalconLocalGame){

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN4@TeamClass
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv386[ebp], eax
	jmp	SHORT $LN5@TeamClass
$LN4@TeamClass:
	mov	DWORD PTR tv386[ebp], 0
$LN5@TeamClass:
	cmp	DWORD PTR tv386[ebp], 0
	je	SHORT $LN1@TeamClass

; 253  : 		SetAssociation(FalconLocalGame->Id());

	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ	; VuBin<VuSessionEntity>::operator bool
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@TeamClass
	mov	ecx, OFFSET ?vuLocalSessionEntity@@3V?$VuBin@VVuSessionEntity@@@@A ; vuLocalSessionEntity
	call	?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ; VuBin<VuSessionEntity>::get
	mov	ecx, eax
	call	?GetGame@FalconSessionEntity@@QAEPAVFalconGameEntity@@XZ ; FalconSessionEntity::GetGame
	mov	DWORD PTR tv408[ebp], eax
	jmp	SHORT $LN7@TeamClass
$LN6@TeamClass:
	mov	DWORD PTR tv408[ebp], 0
$LN7@TeamClass:
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR tv408[ebp]
	call	?Id@VuEntity@@QBE?AVVU_ID@@XZ		; VuEntity::Id
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAssociation@VuEntity@@QAEXVVU_ID@@@Z ; VuEntity::SetAssociation
$LN1@TeamClass:

; 254  : 	}
; 255  : 	ReadDoctrineFile();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadDoctrineFile@TeamClass@@QAEXXZ	; TeamClass::ReadDoctrineFile

; 256  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0TeamClass@@QAE@PAPAEPAJ@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1FalconEntity@@UAE@XZ			; FalconEntity::~FalconEntity
__ehhandler$??0TeamClass@@QAE@PAPAEPAJ@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0TeamClass@@QAE@PAPAEPAJ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0TeamClass@@QAE@PAPAEPAJ@Z ENDP			; TeamClass::TeamClass
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\camplib\team.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_typeindex$ = 8						; size = 4
_owner$ = 12						; size = 1
??0TeamClass@@QAE@HE@Z PROC				; TeamClass::TeamClass
; _this$ = ecx

; 178  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0TeamClass@@QAE@HE@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET ?VolatileNS@@3VIdNamespace@@A	; VolatileNS
	call	?GetIdFromNamespace@@YAKAAVIdNamespace@@@Z ; GetIdFromNamespace
	add	esp, 4
	push	eax
	movzx	eax, WORD PTR _typeindex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0FalconEntity@@QAE@GK@Z		; FalconEntity::FalconEntity
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7TeamClass@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 267				; 0000010bH
	call	??0TeamGndActionType@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 288				; 00000120H
	call	??0TeamAirActionType@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 316				; 0000013cH
	call	??0TeamAirActionType@@QAE@XZ
	push	OFFSET ??0VU_ID@@QAE@XZ			; VU_ID::VU_ID
	push	20					; 00000014H
	push	8
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 632				; 00000278H
	push	edx
	call	??_H@YGXPAXIHP6EPAX0@Z@Z
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 892				; 0000037cH
	call	??0TeamDoctrine@@QAE@XZ			; TeamDoctrine::TeamDoctrine

; 179  : 	// these are read from file by each side
; 180  : 	SetSendCreate(VuEntity::VU_SC_DONT_SEND);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSendCreate@VuEntity@@QAEXW4VU_SEND_TYPE@1@@Z ; VuEntity::SetSendCreate

; 181  : 	InitLocalData(owner);

	movzx	eax, BYTE PTR _owner$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitLocalData@TeamClass@@AAEXE@Z	; TeamClass::InitLocalData

; 182  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0TeamClass@@QAE@HE@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1FalconEntity@@UAE@XZ			; FalconEntity::~FalconEntity
__ehhandler$??0TeamClass@@QAE@HE@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0TeamClass@@QAE@HE@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0TeamClass@@QAE@HE@Z ENDP				; TeamClass::TeamClass
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\team.h
;	COMDAT ??0TeamDoctrine@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0TeamDoctrine@@QAE@XZ PROC				; TeamDoctrine::TeamDoctrine, COMDAT
; _this$ = ecx

; 179  : 	TeamDoctrine (void) {simFlags = 0;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0TeamDoctrine@@QAE@XZ ENDP				; TeamDoctrine::TeamDoctrine
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0TeamAirActionType@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0TeamAirActionType@@QAE@XZ PROC			; TeamAirActionType::TeamAirActionType, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0TeamAirActionType@@QAE@XZ ENDP			; TeamAirActionType::TeamAirActionType
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0TeamGndActionType@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0TeamGndActionType@@QAE@XZ PROC			; TeamGndActionType::TeamGndActionType, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0VU_ID@@QAE@XZ			; VU_ID::VU_ID
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0TeamGndActionType@@QAE@XZ ENDP			; TeamGndActionType::TeamGndActionType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\objectiv.h
;	COMDAT ?GetObjectiveStatus@ObjectiveClass@@QAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetObjectiveStatus@ObjectiveClass@@QAEEXZ PROC		; ObjectiveClass::GetObjectiveStatus, COMDAT
; _this$ = ecx

; 270  : 	uchar GetObjectiveStatus (void)							{	return obj_data.status; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+199]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetObjectiveStatus@ObjectiveClass@@QAEEXZ ENDP		; ObjectiveClass::GetObjectiveStatus
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\objectiv.h
;	COMDAT ?GetObjectivePriority@ObjectiveClass@@QAEFXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetObjectivePriority@ObjectiveClass@@QAEFXZ PROC	; ObjectiveClass::GetObjectivePriority, COMDAT
; _this$ = ecx

; 269  : 	short GetObjectivePriority (void)						{	return obj_data.priority; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ax, BYTE PTR [eax+200]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetObjectivePriority@ObjectiveClass@@QAEFXZ ENDP	; ObjectiveClass::GetObjectivePriority
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\objectiv.h
;	COMDAT ?IsNearfront@ObjectiveClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsNearfront@ObjectiveClass@@QAEHXZ PROC		; ObjectiveClass::IsNearfront, COMDAT
; _this$ = ecx

; 189  : 	int IsNearfront (void)									{ return (int)((O_THIRDLINE | O_SECONDLINE | O_FRONTLINE) & obj_data.obj_flags); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+192]
	and	eax, 7
	mov	esp, ebp
	pop	ebp
	ret	0
?IsNearfront@ObjectiveClass@@QAEHXZ ENDP		; ObjectiveClass::IsNearfront
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?GetUnitReinforcementLevel@UnitClass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitReinforcementLevel@UnitClass@@QAEHXZ PROC	; UnitClass::GetUnitReinforcementLevel, COMDAT
; _this$ = ecx

; 376  : 	int GetUnitReinforcementLevel (void)			{ return reinforcement; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [eax+228]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitReinforcementLevel@UnitClass@@QAEHXZ ENDP	; UnitClass::GetUnitReinforcementLevel
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Cargo@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Cargo@UnitClass@@QBEHXZ PROC				; UnitClass::Cargo, COMDAT
; _this$ = ecx

; 318  : 	int Cargo () const								{ return (int)unit_flags & U_CARGO; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	and	eax, 8192				; 00002000H
	mov	esp, ebp
	pop	ebp
	ret	0
?Cargo@UnitClass@@QBEHXZ ENDP				; UnitClass::Cargo
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\unit.h
;	COMDAT ?Parent@UnitClass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Parent@UnitClass@@QBEHXZ PROC				; UnitClass::Parent, COMDAT
; _this$ = ecx

; 312  : 	int Parent() const								{ return (int)unit_flags & U_PARENT; }		

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]
	and	eax, 32					; 00000020H
	mov	esp, ebp
	pop	ebp
	ret	0
?Parent@UnitClass@@QBEHXZ ENDP				; UnitClass::Parent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campaign.h
;	COMDAT ?CampLeaveCriticalSection@@YAXXZ
_TEXT	SEGMENT
?CampLeaveCriticalSection@@YAXXZ PROC			; CampLeaveCriticalSection, COMDAT

; 51   : inline void CampLeaveCriticalSection(){ F4LeaveCriticalSection(campCritical); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ?campCritical@@3PAUF4CSECTIONHANDLE@@A ; campCritical
	push	eax
	call	_F4LeaveCriticalSection
	add	esp, 4
	pop	ebp
	ret	0
?CampLeaveCriticalSection@@YAXXZ ENDP			; CampLeaveCriticalSection
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campaign.h
;	COMDAT ?CampEnterCriticalSection@@YAXXZ
_TEXT	SEGMENT
?CampEnterCriticalSection@@YAXXZ PROC			; CampEnterCriticalSection, COMDAT

; 50   : inline void CampEnterCriticalSection(){ F4EnterCriticalSection(campCritical); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ?campCritical@@3PAUF4CSECTIONHANDLE@@A ; campCritical
	push	eax
	call	_F4EnterCriticalSection
	add	esp, 4
	pop	ebp
	ret	0
?CampEnterCriticalSection@@YAXXZ ENDP			; CampEnterCriticalSection
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GListClass@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GListClass@@QAEPAXI@Z PROC				; ListClass::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ListClass@@QAE@XZ			; ListClass::~ListClass
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GListClass@@QAEPAXI@Z ENDP				; ListClass::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\listadt.h
;	COMDAT ?GetLastElement@ListClass@@QAEPAVListElementClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLastElement@ListClass@@QAEPAVListElementClass@@XZ PROC ; ListClass::GetLastElement, COMDAT
; _this$ = ecx

; 83   : 		ListElementClass* GetLastElement(void)		{ return end; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLastElement@ListClass@@QAEPAVListElementClass@@XZ ENDP ; ListClass::GetLastElement
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\listadt.h
;	COMDAT ?GetFirstElement@ListClass@@QAEPAVListElementClass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFirstElement@ListClass@@QAEPAVListElementClass@@XZ PROC ; ListClass::GetFirstElement, COMDAT
; _this$ = ecx

; 82   : 		ListElementClass* GetFirstElement(void)		{ return front; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFirstElement@ListClass@@QAEPAVListElementClass@@XZ ENDP ; ListClass::GetFirstElement
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\listadt.h
;	COMDAT ?GetPrev@ListElementClass@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPrev@ListElementClass@@QAEPAV1@XZ PROC		; ListElementClass::GetPrev, COMDAT
; _this$ = ecx

; 46   : 		ListElementClass* GetPrev(void)				{ return prev; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPrev@ListElementClass@@QAEPAV1@XZ ENDP		; ListElementClass::GetPrev
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\listadt.h
;	COMDAT ?GetNext@ListElementClass@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNext@ListElementClass@@QAEPAV1@XZ PROC		; ListElementClass::GetNext, COMDAT
; _this$ = ecx

; 45   : 		ListElementClass* GetNext(void)				{ return next; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNext@ListElementClass@@QAEPAV1@XZ ENDP		; ListElementClass::GetNext
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\listadt.h
;	COMDAT ?GetUserData@ListElementClass@@QAEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUserData@ListElementClass@@QAEPAXXZ PROC		; ListElementClass::GetUserData, COMDAT
; _this$ = ecx

; 39   : 		void* GetUserData(void)						{ return user_data; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUserData@ListElementClass@@QAEPAXXZ ENDP		; ListElementClass::GetUserData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetSType@CampBaseClass@@QBEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSType@CampBaseClass@@QBEEXZ PROC			; CampBaseClass::GetSType, COMDAT
; _this$ = ecx

; 290  : 	uchar GetSType (void)	const						{	return (EntityType())->classInfo_[VU_STYPE]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ; VuEntity::EntityType
	mov	ecx, 1
	imul	ecx, 3
	mov	al, BYTE PTR [eax+ecx+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSType@CampBaseClass@@QBEEXZ ENDP			; CampBaseClass::GetSType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetType@CampBaseClass@@QBEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetType@CampBaseClass@@QBEEXZ PROC			; CampBaseClass::GetType, COMDAT
; _this$ = ecx

; 289  : 	uchar GetType()	const						{	return (EntityType())->classInfo_[VU_TYPE]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ; VuEntity::EntityType
	mov	ecx, 1
	shl	ecx, 1
	mov	al, BYTE PTR [eax+ecx+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetType@CampBaseClass@@QBEEXZ ENDP			; CampBaseClass::GetType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetDomain@CampBaseClass@@QBEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDomain@CampBaseClass@@QBEEXZ PROC			; CampBaseClass::GetDomain, COMDAT
; _this$ = ecx

; 287  : 	uchar GetDomain (void)	const						{	return (EntityType())->classInfo_[VU_DOMAIN]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ; VuEntity::EntityType
	mov	ecx, 1
	imul	ecx, 0
	mov	al, BYTE PTR [eax+ecx+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDomain@CampBaseClass@@QBEEXZ ENDP			; CampBaseClass::GetDomain
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\campaign\include\campbase.h
;	COMDAT ?GetOwner@CampBaseClass@@QAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetOwner@CampBaseClass@@QAEEXZ PROC			; CampBaseClass::GetOwner, COMDAT
; _this$ = ecx

; 241  : 	Control GetOwner (void)										{	return owner; }			// Old form

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+154]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetOwner@CampBaseClass@@QAEEXZ ENDP			; CampBaseClass::GetOwner
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\invalidbufferexception.h
;	COMDAT ?memcpychk@@YAXPAXPAPAEIPAJ@Z
_TEXT	SEGMENT
$T2 = -152						; size = 12
_s$3 = -140						; size = 24
_err$4 = -116						; size = 100
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_size$ = 16						; size = 4
_rem$ = 20						; size = 4
?memcpychk@@YAXPAXPAPAEIPAJ@Z PROC			; memcpychk, COMDAT

; 25   : inline void memcpychk(void *dst, VU_BYTE **src, size_t size, long *rem){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?memcpychk@@YAXPAXPAPAEIPAJ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 26   : 	if ((size_t)*rem < size){

	mov	eax, DWORD PTR _rem$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _size$[ebp]
	jae	SHORT $LN1@memcpychk

; 27   : 		char err[100];
; 28   : 		sprintf(err, "Trying to write %lu bytes to %ld buffer", static_cast<unsigned long>(size), *rem);

	mov	edx, DWORD PTR _rem$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CI@MPKJAHJH@Trying?5to?5write?5?$CFlu?5bytes?5to?5?$CFld@
	lea	edx, DWORD PTR _err$4[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 29   : 		std::string s(err);

	lea	eax, DWORD PTR _err$4[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$3[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 30   : 		throw InvalidBufferException(s);

	lea	ecx, DWORD PTR _s$3[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T2[ebp]
	call	??0InvalidBufferException@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; InvalidBufferException::InvalidBufferException
	push	OFFSET __TI4?AVInvalidBufferException@@
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	call	__CxxThrowException@8

; 31   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _s$3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1@memcpychk:

; 32   : 	memcpy(dst, *src, size);

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _dst$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 33   : 	*rem -= size;

	mov	ecx, DWORD PTR _rem$[ebp]
	mov	edx, DWORD PTR [ecx]
	sub	edx, DWORD PTR _size$[ebp]
	mov	eax, DWORD PTR _rem$[ebp]
	mov	DWORD PTR [eax], edx

; 34   : 	*src += size;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, DWORD PTR _size$[ebp]
	mov	eax, DWORD PTR _src$[ebp]
	mov	DWORD PTR [eax], edx
$LN3@memcpychk:

; 35   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?memcpychk@@YAXPAXPAPAEIPAJ@Z$0:
	lea	ecx, DWORD PTR _s$3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?memcpychk@@YAXPAXPAPAEIPAJ@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-144]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?memcpychk@@YAXPAXPAPAEIPAJ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?memcpychk@@YAXPAXPAPAEIPAJ@Z ENDP			; memcpychk
; Function compile flags: /Odtp
;	COMDAT ??_GInvalidBufferException@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GInvalidBufferException@@UAEPAXI@Z PROC		; InvalidBufferException::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1InvalidBufferException@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GInvalidBufferException@@UAEPAXI@Z ENDP		; InvalidBufferException::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0InvalidBufferException@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0InvalidBufferException@@QAE@ABV0@@Z PROC		; InvalidBufferException::InvalidBufferException, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0out_of_range@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7InvalidBufferException@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0InvalidBufferException@@QAE@ABV0@@Z ENDP		; InvalidBufferException::InvalidBufferException
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1InvalidBufferException@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1InvalidBufferException@@UAE@XZ PROC			; InvalidBufferException::~InvalidBufferException, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1out_of_range@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1InvalidBufferException@@UAE@XZ ENDP			; InvalidBufferException::~InvalidBufferException
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\invalidbufferexception.h
;	COMDAT ??0InvalidBufferException@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_msg$ = 8						; size = 4
??0InvalidBufferException@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; InvalidBufferException::InvalidBufferException, COMDAT
; _this$ = ecx

; 19   : 	InvalidBufferException(const std::string &msg) : out_of_range(msg){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _msg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7InvalidBufferException@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0InvalidBufferException@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; InvalidBufferException::InvalidBufferException
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?GetSEARCHtimer@FalconEntity@@UAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSEARCHtimer@FalconEntity@@UAEKXZ PROC		; FalconEntity::GetSEARCHtimer, COMDAT
; _this$ = ecx

; 198  : 	virtual VU_TIME GetSEARCHtimer(void)				{ return 0; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSEARCHtimer@FalconEntity@@UAEKXZ ENDP		; FalconEntity::GetSEARCHtimer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?GetAQUIREtimer@FalconEntity@@UAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAQUIREtimer@FalconEntity@@UAEKXZ PROC		; FalconEntity::GetAQUIREtimer, COMDAT
; _this$ = ecx

; 197  : 	virtual VU_TIME GetAQUIREtimer(void)				{ return 0; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAQUIREtimer@FalconEntity@@UAEKXZ ENDP		; FalconEntity::GetAQUIREtimer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?SetStepSearchMode@FalconEntity@@UAEXE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
?SetStepSearchMode@FalconEntity@@UAEXE@Z PROC		; FalconEntity::SetStepSearchMode, COMDAT
; _this$ = ecx

; 196  : 	virtual void SetStepSearchMode(uchar)					{ };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetStepSearchMode@FalconEntity@@UAEXE@Z ENDP		; FalconEntity::SetStepSearchMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?SetSEARCHtimer@FalconEntity@@UAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newTime$ = 8						; size = 4
?SetSEARCHtimer@FalconEntity@@UAEXK@Z PROC		; FalconEntity::SetSEARCHtimer, COMDAT
; _this$ = ecx

; 194  : 	virtual void SetSEARCHtimer(VU_TIME newTime)		{ };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSEARCHtimer@FalconEntity@@UAEXK@Z ENDP		; FalconEntity::SetSEARCHtimer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?SetAQUIREtimer@FalconEntity@@UAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newTime$ = 8						; size = 4
?SetAQUIREtimer@FalconEntity@@UAEXK@Z PROC		; FalconEntity::SetAQUIREtimer, COMDAT
; _this$ = ecx

; 193  : 	virtual void SetAQUIREtimer(VU_TIME newTime)		{ };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetAQUIREtimer@FalconEntity@@UAEXK@Z ENDP		; FalconEntity::SetAQUIREtimer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?GetIRFactor@FalconEntity@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetIRFactor@FalconEntity@@UAEMXZ PROC			; FalconEntity::GetIRFactor, COMDAT
; _this$ = ecx

; 164  : 	virtual float GetIRFactor (void)			{ return 0.0f; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	fldz
	mov	esp, ebp
	pop	ebp
	ret	0
?GetIRFactor@FalconEntity@@UAEMXZ ENDP			; FalconEntity::GetIRFactor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?GetRCSFactor@FalconEntity@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRCSFactor@FalconEntity@@UAEMXZ PROC			; FalconEntity::GetRCSFactor, COMDAT
; _this$ = ecx

; 163  : 	virtual float GetRCSFactor (void)			{ return 0.0f; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	fldz
	mov	esp, ebp
	pop	ebp
	ret	0
?GetRCSFactor@FalconEntity@@UAEMXZ ENDP			; FalconEntity::GetRCSFactor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?HasAreaJamming@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?HasAreaJamming@FalconEntity@@UAEHXZ PROC		; FalconEntity::HasAreaJamming, COMDAT
; _this$ = ecx

; 162  : 	virtual int HasAreaJamming (void)			{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?HasAreaJamming@FalconEntity@@UAEHXZ ENDP		; FalconEntity::HasAreaJamming
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?HasSPJamming@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?HasSPJamming@FalconEntity@@UAEHXZ PROC			; FalconEntity::HasSPJamming, COMDAT
; _this$ = ecx

; 161  : 	virtual int HasSPJamming (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?HasSPJamming@FalconEntity@@UAEHXZ ENDP			; FalconEntity::HasSPJamming
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsAreaJamming@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAreaJamming@FalconEntity@@UAEHXZ PROC		; FalconEntity::IsAreaJamming, COMDAT
; _this$ = ecx

; 160  : 	virtual int IsAreaJamming (void)            { return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAreaJamming@FalconEntity@@UAEHXZ ENDP		; FalconEntity::IsAreaJamming
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsSPJamming@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsSPJamming@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsSPJamming, COMDAT
; _this$ = ecx

; 159  : 	virtual int IsSPJamming (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSPJamming@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsSPJamming
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsTaskForce@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsTaskForce@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsTaskForce, COMDAT
; _this$ = ecx

; 158  : 	virtual int IsTaskForce (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsTaskForce@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsTaskForce
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsPackage@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsPackage@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsPackage, COMDAT
; _this$ = ecx

; 156  : 	virtual int IsPackage (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPackage@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsPackage
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsSquadron@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsSquadron@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsSquadron, COMDAT
; _this$ = ecx

; 155  : 	virtual int IsSquadron (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSquadron@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsSquadron
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsFlight@FalconEntity@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsFlight@FalconEntity@@UBEHXZ PROC			; FalconEntity::IsFlight, COMDAT
; _this$ = ecx

; 154  : 	virtual int IsFlight() const				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsFlight@FalconEntity@@UBEHXZ ENDP			; FalconEntity::IsFlight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsBrigade@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsBrigade@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsBrigade, COMDAT
; _this$ = ecx

; 153  : 	virtual int IsBrigade (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsBrigade@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsBrigade
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsBattalion@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsBattalion@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsBattalion, COMDAT
; _this$ = ecx

; 152  : 	virtual int IsBattalion (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsBattalion@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsBattalion
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsObjective@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsObjective@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsObjective, COMDAT
; _this$ = ecx

; 151  : 	virtual int IsObjective (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsObjective@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsObjective
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsUnit@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsUnit@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsUnit, COMDAT
; _this$ = ecx

; 150  : 	virtual int IsUnit (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsUnit@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsUnit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?GetMovementType@FalconEntity@@UAE?AW4MoveType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMovementType@FalconEntity@@UAE?AW4MoveType@@XZ PROC	; FalconEntity::GetMovementType, COMDAT
; _this$ = ecx

; 149  : 	virtual MoveType GetMovementType (void)		{ return NoMove; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMovementType@FalconEntity@@UAE?AW4MoveType@@XZ ENDP	; FalconEntity::GetMovementType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsEmitting@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsEmitting@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsEmitting, COMDAT
; _this$ = ecx

; 145  : 	virtual int IsEmitting (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsEmitting@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsEmitting
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsDead@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsDead@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsDead, COMDAT
; _this$ = ecx

; 144  : 	virtual int IsDead (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsDead@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsDead
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsExploding@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsExploding@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsExploding, COMDAT
; _this$ = ecx

; 143  : 	virtual int IsExploding (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsExploding@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsExploding
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsWeapon@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsWeapon@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsWeapon, COMDAT
; _this$ = ecx

; 142  : 	virtual int IsWeapon (void)   				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsWeapon@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsWeapon
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsShip@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsShip@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsShip, COMDAT
; _this$ = ecx

; 141  : 	virtual int IsShip (void) 			        { return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsShip@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsShip
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsGroundVehicle@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsGroundVehicle@FalconEntity@@UAEHXZ PROC		; FalconEntity::IsGroundVehicle, COMDAT
; _this$ = ecx

; 140  : 	virtual int IsGroundVehicle (void) 			{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsGroundVehicle@FalconEntity@@UAEHXZ ENDP		; FalconEntity::IsGroundVehicle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsAirplane@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAirplane@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsAirplane, COMDAT
; _this$ = ecx

; 139  : 	virtual int IsAirplane (void)	   			{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAirplane@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsAirplane
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsEject@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsEject@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsEject, COMDAT
; _this$ = ecx

; 138  : 	virtual int IsEject (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsEject@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsEject
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsHelicopter@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsHelicopter@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsHelicopter, COMDAT
; _this$ = ecx

; 137  : 	virtual int IsHelicopter (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsHelicopter@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsHelicopter
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsStatic@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsStatic@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsStatic, COMDAT
; _this$ = ecx

; 136  : 	virtual int IsStatic (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsStatic@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsStatic
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsVehicle@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsVehicle@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsVehicle, COMDAT
; _this$ = ecx

; 135  : 	virtual int IsVehicle (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsVehicle@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsVehicle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsMover@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsMover@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsMover, COMDAT
; _this$ = ecx

; 134  : 	virtual int IsMover (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMover@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsMover
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsGun@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsGun@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsGun, COMDAT
; _this$ = ecx

; 133  : 	virtual int IsGun (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsGun@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsGun
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsBomb@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsBomb@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsBomb, COMDAT
; _this$ = ecx

; 132  : 	virtual int IsBomb (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsBomb@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsBomb
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsLauncher@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsLauncher@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsLauncher, COMDAT
; _this$ = ecx

; 131  : 	virtual int IsLauncher (void)               { return FALSE; } // MLR 3/4/2004 - rocket pods

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsLauncher@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsLauncher
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsMissile@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsMissile@FalconEntity@@UAEHXZ PROC			; FalconEntity::IsMissile, COMDAT
; _this$ = ecx

; 130  : 	virtual int IsMissile (void)				{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMissile@FalconEntity@@UAEHXZ ENDP			; FalconEntity::IsMissile
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?HasEntity@FalconEntity@@UBEHPAVVuEntity@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv69 = -4						; size = 4
_e$ = 8							; size = 4
?HasEntity@FalconEntity@@UBEHPAVVuEntity@@@Z PROC	; FalconEntity::HasEntity, COMDAT
; _this$ = ecx

; 129  : 	virtual int HasEntity(VuEntity *e) const    { return this == e; } // sfr: added for new driver

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR _e$[ebp]
	jne	SHORT $LN3@HasEntity
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@HasEntity
$LN3@HasEntity:
	mov	DWORD PTR tv69[ebp], 0
$LN4@HasEntity:
	mov	eax, DWORD PTR tv69[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?HasEntity@FalconEntity@@UBEHPAVVuEntity@@@Z ENDP	; FalconEntity::HasEntity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?OnGround@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnGround@FalconEntity@@UAEHXZ PROC			; FalconEntity::OnGround, COMDAT
; _this$ = ecx

; 128  : 	virtual int OnGround (void)					{ return FALSE; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?OnGround@FalconEntity@@UAEHXZ ENDP			; FalconEntity::OnGround
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?CombatClass@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CombatClass@FalconEntity@@UAEHXZ PROC			; FalconEntity::CombatClass, COMDAT
; _this$ = ecx

; 127  : 	virtual int CombatClass (void)				{ return 999; } // 2002-02-25 ADDED BY S.G. No combat class for non flight or non aircraft class

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 999				; 000003e7H
	mov	esp, ebp
	pop	ebp
	ret	0
?CombatClass@FalconEntity@@UAEHXZ ENDP			; FalconEntity::CombatClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?SetSearchMode@FalconEntity@@UAEXE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
?SetSearchMode@FalconEntity@@UAEXE@Z PROC		; FalconEntity::SetSearchMode, COMDAT
; _this$ = ecx

; 126  : 	virtual void SetSearchMode (uchar)		{};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSearchMode@FalconEntity@@UAEXE@Z ENDP		; FalconEntity::SetSearchMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?ReturnToSearch@FalconEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ReturnToSearch@FalconEntity@@UAEXXZ PROC		; FalconEntity::ReturnToSearch, COMDAT
; _this$ = ecx

; 124  : 	virtual void ReturnToSearch (void)			{};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReturnToSearch@FalconEntity@@UAEXXZ ENDP		; FalconEntity::ReturnToSearch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?SetRadarMode@FalconEntity@@UAEXE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
?SetRadarMode@FalconEntity@@UAEXE@Z PROC		; FalconEntity::SetRadarMode, COMDAT
; _this$ = ecx

; 123  : 	virtual void SetRadarMode (uchar)		{};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetRadarMode@FalconEntity@@UAEXE@Z ENDP		; FalconEntity::SetRadarMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?GetRadarMode@FalconEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRadarMode@FalconEntity@@UAEHXZ PROC			; FalconEntity::GetRadarMode, COMDAT
; _this$ = ecx

; 121  : 	virtual int GetRadarMode (void)				{ return FEC_RADAR_OFF; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?GetRadarMode@FalconEntity@@UAEHXZ ENDP			; FalconEntity::GetRadarMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsCampBase@FalconEntity@@UAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsCampBase@FalconEntity@@UAE_NXZ PROC			; FalconEntity::IsCampBase, COMDAT
; _this$ = ecx

; 99   : 	virtual bool IsCampBase() { return false; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	al, al
	mov	esp, ebp
	pop	ebp
	ret	0
?IsCampBase@FalconEntity@@UAE_NXZ ENDP			; FalconEntity::IsCampBase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\falcent.h
;	COMDAT ?IsSimBase@FalconEntity@@UAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsSimBase@FalconEntity@@UAE_NXZ PROC			; FalconEntity::IsSimBase, COMDAT
; _this$ = ecx

; 98   : 	virtual bool IsSimBase() { return false; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	al, al
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSimBase@FalconEntity@@UAE_NXZ ENDP			; FalconEntity::IsSimBase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VVuEntity@@@@QBEPAVVuEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VVuEntity@@@@QBEPAVVuEntity@@XZ PROC	; VuBin<VuEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VVuEntity@@@@QBEPAVVuEntity@@XZ ENDP	; VuBin<VuEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuevent.h
;	COMDAT ?RequestReliableTransmit@VuMessage@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RequestReliableTransmit@VuMessage@@QAEXXZ PROC		; VuMessage::RequestReliableTransmit, COMDAT
; _this$ = ecx

; 180  : 	void RequestReliableTransmit() { flags_ |= VU_RELIABLE_MSG_FLAG; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+6]
	or	ecx, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+6], cl
	mov	esp, ebp
	pop	ebp
	ret	0
?RequestReliableTransmit@VuMessage@@QAEXXZ ENDP		; VuMessage::RequestReliableTransmit
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ PROC ; VuBin<VuSessionEntity>::get, COMDAT
; _this$ = ecx

; 55   : 	E *get() const{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return e;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?get@?$VuBin@VVuSessionEntity@@@@QBEPAVVuSessionEntity@@XZ ENDP ; VuBin<VuSessionEntity>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vu_templates.h
;	COMDAT ??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ PROC		; VuBin<VuSessionEntity>::operator bool, COMDAT
; _this$ = ecx

; 40   : 	operator bool() const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		return e != NULL;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@operator
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv66[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv66[ebp]

; 42   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$VuBin@VVuSessionEntity@@@@QBE_NXZ ENDP		; VuBin<VuSessionEntity>::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gout_of_range@std@@UAEPAXI@Z PROC			; std::out_of_range::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1out_of_range@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gout_of_range@std@@UAEPAXI@Z ENDP			; std::out_of_range::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV01@@Z PROC			; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7out_of_range@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0out_of_range@std@@QAE@ABV01@@Z ENDP			; std::out_of_range::out_of_range
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1out_of_range@std@@UAE@XZ PROC			; std::out_of_range::~out_of_range, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1out_of_range@std@@UAE@XZ ENDP			; std::out_of_range::~out_of_range
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\stdexcept
;	COMDAT ??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx

; 145  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR __Message$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@PBD@Z		; std::logic_error::logic_error
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7out_of_range@std@@6B@

; 146  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::out_of_range::out_of_range
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2275 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2270 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2271 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2272 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2260 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2266 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2241 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2243 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2224 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2225 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2226 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2219 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -48						; size = 4
tv204 = -44						; size = 4
tv203 = -40						; size = 4
tv202 = -36						; size = 4
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+20]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN5@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Newres$[ebp], eax

; 2191 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2204 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2210 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2213 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1737 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1740 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1732 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1734 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1717 : 		{	// return pointer to null-terminated nonmutable array

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1718 : 		return (this->_Myptr());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 1719 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1319 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1320 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], eax

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1327 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1309 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1310 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1311 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1312 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1142 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1136 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1139 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1106 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1107 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1108 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1117 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 963  : 		{	// destroy the string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 964  : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 965  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 792  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 793  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 794  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 688  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 635  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 636  : 		{	// construct allocator from _Al
; 637  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 525  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 518  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 499  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 500  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@std@@QAE@ABV01@@Z		; std::exception::exception
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	mov	esp, ebp
	pop	ebp
	ret	0
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\stdexcept
;	COMDAT ??0logic_error@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@PBD@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 38   : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@

; 39   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0logic_error@std@@QAE@PBD@Z ENDP			; std::logic_error::logic_error
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	push	ecx

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 65   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ PROC	; VuEntity::EntityType, COMDAT
; _this$ = ecx

; 176  : 	VuEntityType *EntityType() const { return const_cast<VuEntityType*>(entityTypePtr_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+112]
	mov	esp, ebp
	pop	ebp
	ret	0
?EntityType@VuEntity@@QBEPAUVuEntityType@@XZ ENDP	; VuEntity::EntityType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?VuState@VuEntity@@QBE?AW4VU_MEM@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?VuState@VuEntity@@QBE?AW4VU_MEM@@XZ PROC		; VuEntity::VuState, COMDAT
; _this$ = ecx

; 153  : 	VU_MEM VuState() const    { return vuState_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+92]
	mov	esp, ebp
	pop	ebp
	ret	0
?VuState@VuEntity@@QBE?AW4VU_MEM@@XZ ENDP		; VuEntity::VuState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?OwnerId@VuEntity@@QBE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?OwnerId@VuEntity@@QBE?AVVU_ID@@XZ PROC			; VuEntity::OwnerId, COMDAT
; _this$ = ecx

; 152  : 	VU_ID OwnerId() const     { return share_.ownerId_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [eax+24]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?OwnerId@VuEntity@@QBE?AVVU_ID@@XZ ENDP			; VuEntity::OwnerId
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?SetSendCreate@VuEntity@@QAEXW4VU_SEND_TYPE@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_sc$ = 8						; size = 4
?SetSendCreate@VuEntity@@QAEXW4VU_SEND_TYPE@1@@Z PROC	; VuEntity::SetSendCreate, COMDAT
; _this$ = ecx

; 148  : 	void SetSendCreate(VU_SEND_TYPE sc) { share_.flags_.breakdown_.sendCreate_ = sc; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _sc$[ebp]
	and	eax, 3
	shl	eax, 6
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, -193				; ffffff3fH
	or	edx, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetSendCreate@VuEntity@@QAEXW4VU_SEND_TYPE@1@@Z ENDP	; VuEntity::SetSendCreate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?Id@VuEntity@@QBE?AVVU_ID@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?Id@VuEntity@@QBE?AVVU_ID@@XZ PROC			; VuEntity::Id, COMDAT
; _this$ = ecx

; 131  : 	VU_ID Id() const	{ return share_.id_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?Id@VuEntity@@QBE?AVVU_ID@@XZ ENDP			; VuEntity::Id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\vu2\include\vuentity.h
;	COMDAT ?SetAssociation@VuEntity@@QAEXVVU_ID@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_assoc$ = 8						; size = 8
?SetAssociation@VuEntity@@QAEXVVU_ID@@@Z PROC		; VuEntity::SetAssociation, COMDAT
; _this$ = ecx

; 124  : 	void SetAssociation(VU_ID assoc) { share_.assoc_ = assoc; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _assoc$[ebp]
	mov	DWORD PTR [eax+28], ecx
	mov	edx, DWORD PTR _assoc$[ebp+4]
	mov	DWORD PTR [eax+32], edx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetAssociation@VuEntity@@QAEXVVU_ID@@@Z ENDP		; VuEntity::SetAssociation
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?FloatToInt32@@YAHM@Z PROC				; FloatToInt32

; 179  : {

	push	ebp
	mov	ebp, esp

; 180  : #if WIN32
; 181  :   __asm {
; 182  :     fld dword ptr [x];

	fld	DWORD PTR _x$[ebp]

; 183  :     fistp dword ptr [x];

	fistp	DWORD PTR _x$[ebp]

; 184  :     mov eax,dword ptr [x];

	mov	eax, DWORD PTR _x$[ebp]

; 185  :   }
; 186  : #else 
; 187  : 	return static_cast<int>(x);	
; 188  : #endif
; 189  : }

	pop	ebp
	ret	0
?FloatToInt32@@YAHM@Z ENDP				; FloatToInt32
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?SqrtSSE@@YAMM@Z PROC					; SqrtSSE

; 91   : static inline float SqrtSSE(float x){ 

	push	ebp
	mov	ebp, esp

; 92   :     __asm 
; 93   :     { 
; 94   :         sqrtss xmm0,x 

	sqrtss	xmm0, DWORD PTR _x$[ebp]

; 95   :         movss x,xmm0 

	movss	XMMWORD PTR _x$[ebp], xmm0

; 96   :     } 
; 97   : 
; 98   :     return x; 

	fld	DWORD PTR _x$[ebp]

; 99   : } 

	pop	ebp
	ret	0
?SqrtSSE@@YAMM@Z ENDP					; SqrtSSE
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT ?atan@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?atan@@YAMM@Z PROC					; atan, COMDAT

; 505  :         {return (atanf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	movss	xmm0, DWORD PTR __X$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	_atanf
	add	esp, 4
	pop	ebp
	ret	0
?atan@@YAMM@Z ENDP					; atan
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\math.h
;	COMDAT _atanf
_TEXT	SEGMENT
tv74 = -12						; size = 8
tv76 = -4						; size = 4
__X$ = 8						; size = 4
_atanf	PROC						; COMDAT

; 404  :         {return ((float)atan((double)_X)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_atan
	add	esp, 8
	fstp	QWORD PTR tv74[ebp]
	movsd	xmm0, QWORD PTR tv74[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_atanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??9VU_ID@@QBE_NABV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -2						; size = 1
tv73 = -1						; size = 1
_rhs$ = 8						; size = 4
??9VU_ID@@QBE_NABV0@@Z PROC				; VU_ID::operator!=, COMDAT
; _this$ = ecx

; 111  : 	bool operator != (const VU_ID &rhs) const { 

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 112  : 		return (
; 113  : 			num_ == rhs.num_ ? 
; 114  : 			(creator_ == rhs.creator_ ? false : true) : 
; 115  : 			true
; 116  : 		); 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN5@operator
	mov	eax, DWORD PTR _rhs$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??8VU_SESSION_ID@@QBEHABV0@@Z		; VU_SESSION_ID::operator==
	test	eax, eax
	je	SHORT $LN3@operator
	mov	BYTE PTR tv73[ebp], 0
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	BYTE PTR tv73[ebp], 1
$LN4@operator:
	mov	cl, BYTE PTR tv73[ebp]
	mov	BYTE PTR tv74[ebp], cl
	jmp	SHORT $LN6@operator
$LN5@operator:
	mov	BYTE PTR tv74[ebp], 1
$LN6@operator:
	mov	al, BYTE PTR tv74[ebp]

; 117  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??9VU_ID@@QBE_NABV0@@Z ENDP				; VU_ID::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??8VU_ID@@QBE_NABV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -2						; size = 1
tv73 = -1						; size = 1
_rhs$ = 8						; size = 4
??8VU_ID@@QBE_NABV0@@Z PROC				; VU_ID::operator==, COMDAT
; _this$ = ecx

; 104  : 	bool operator == (const VU_ID &rhs) const { 

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 105  : 		return (
; 106  : 			num_ == rhs.num_ ? 
; 107  : 			(creator_ == rhs.creator_ ? true : false) : 
; 108  : 			false
; 109  : 		); 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN5@operator
	mov	eax, DWORD PTR _rhs$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??8VU_SESSION_ID@@QBEHABV0@@Z		; VU_SESSION_ID::operator==
	test	eax, eax
	je	SHORT $LN3@operator
	mov	BYTE PTR tv73[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	BYTE PTR tv73[ebp], 0
$LN4@operator:
	mov	cl, BYTE PTR tv73[ebp]
	mov	BYTE PTR tv74[ebp], cl
	jmp	SHORT $LN6@operator
$LN5@operator:
	mov	BYTE PTR tv74[ebp], 0
$LN6@operator:
	mov	al, BYTE PTR tv74[ebp]

; 110  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??8VU_ID@@QBE_NABV0@@Z ENDP				; VU_ID::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??0VU_ID@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0VU_ID@@QAE@XZ PROC					; VU_ID::VU_ID, COMDAT
; _this$ = ecx

; 100  : 	VU_ID() : num_(0), creator_(0){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0VU_SESSION_ID@@QAE@K@Z		; VU_SESSION_ID::VU_SESSION_ID
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0VU_ID@@QAE@XZ ENDP					; VU_ID::VU_ID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??8VU_SESSION_ID@@QBEHABV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_rhs$ = 8						; size = 4
??8VU_SESSION_ID@@QBEHABV0@@Z PROC			; VU_SESSION_ID::operator==, COMDAT
; _this$ = ecx

; 55   : 	int operator == (const VU_SESSION_ID &rhs) const{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		return (value_ == rhs.value_ ? TRUE : FALSE); 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv67[ebp], 0
$LN4@operator:
	mov	eax, DWORD PTR tv67[ebp]

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??8VU_SESSION_ID@@QBEHABV0@@Z ENDP			; VU_SESSION_ID::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\falclib\include\vutypes.h
;	COMDAT ??0VU_SESSION_ID@@QAE@K@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??0VU_SESSION_ID@@QAE@K@Z PROC				; VU_SESSION_ID::VU_SESSION_ID, COMDAT
; _this$ = ecx

; 53   : 	VU_SESSION_ID(unsigned long value) : value_((unsigned long)value) { }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0VU_SESSION_ID@@QAE@K@Z ENDP				; VU_SESSION_ID::VU_SESSION_ID
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
$LN2@vector:
	mov	eax, DWORD PTR ___n$[ebp]
	sub	eax, 1
	mov	DWORD PTR ___n$[ebp], eax
	js	SHORT $LN3@vector
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	ecx, DWORD PTR ___t$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], ecx
	jmp	SHORT $LN2@vector
$LN3@vector:
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
