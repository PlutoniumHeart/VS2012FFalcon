; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\ui95\cwindow.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?pmField@?$CVarTypeInfo@PAK@ATL@@2QQtagVARIANT@@PAKQ3@ ; ATL::CVarTypeInfo<unsigned long *>::pmField
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?VT@?$CVarTypeInfo@_J@ATL@@2GB			; ATL::CVarTypeInfo<__int64>::VT
PUBLIC	?pmField@?$CVarTypeInfo@_J@ATL@@2QQtagVARIANT@@_JQ3@ ; ATL::CVarTypeInfo<__int64>::pmField
PUBLIC	___pobjMapEntryFirst
PUBLIC	___pobjMapEntryLast
PUBLIC	?VT@?$CVarTypeInfo@PA_J@ATL@@2GB		; ATL::CVarTypeInfo<__int64 *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PA_J@ATL@@2QQtagVARIANT@@PA_JQ3@ ; ATL::CVarTypeInfo<__int64 *>::pmField
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B ; std::ios_base::failure::_Stream_err
PUBLIC	?VT@?$CVarTypeInfo@_K@ATL@@2GB			; ATL::CVarTypeInfo<unsigned __int64>::VT
PUBLIC	??_C@_0BF@HDDNNDFH@Component?5Categories?$AA@	; `string'
PUBLIC	?pmField@?$CVarTypeInfo@_K@ATL@@2QQtagVARIANT@@_KQ3@ ; ATL::CVarTypeInfo<unsigned __int64>::pmField
PUBLIC	??_C@_08PICKODJL@FileType?$AA@			; `string'
PUBLIC	??_C@_09JKPGEJCH@Interface?$AA@			; `string'
PUBLIC	??_C@_08PPIOJEA@Hardware?$AA@			; `string'
PUBLIC	?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA	; ATL::_pPerfRegFunc
PUBLIC	??_C@_04IHBFOLAC@Mime?$AA@			; `string'
PUBLIC	?_pPerfUnRegFunc@ATL@@3P6AJXZA			; ATL::_pPerfUnRegFunc
PUBLIC	??_C@_03DDIMFGBA@SAM?$AA@			; `string'
PUBLIC	?_AtlRegisterPerUser@ATL@@3_NA			; ATL::_AtlRegisterPerUser
PUBLIC	??_C@_08LOPHEHKG@SECURITY?$AA@			; `string'
PUBLIC	??_C@_06FDHFNJBJ@SYSTEM?$AA@			; `string'
PUBLIC	??_C@_08KEKAJNJI@Software?$AA@			; `string'
PUBLIC	??_C@_07KJLOKDKB@TypeLib?$AA@			; `string'
PUBLIC	?VT@?$CVarTypeInfo@PA_K@ATL@@2GB		; ATL::CVarTypeInfo<unsigned __int64 *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PA_K@ATL@@2QQtagVARIANT@@PA_KQ3@ ; ATL::CVarTypeInfo<unsigned __int64 *>::pmField
PUBLIC	__GUID_00000000_0000_0000_c000_000000000046
PUBLIC	?VT@?$CVarTypeInfo@M@ATL@@2GB			; ATL::CVarTypeInfo<float>::VT
PUBLIC	?pmField@?$CVarTypeInfo@M@ATL@@2QQtagVARIANT@@MQ3@ ; ATL::CVarTypeInfo<float>::pmField
PUBLIC	__GUID_a6bc3ac0_dbaa_11ce_9de3_00aa004bb851
PUBLIC	?VT@?$CVarTypeInfo@PAM@ATL@@2GB			; ATL::CVarTypeInfo<float *>::VT
PUBLIC	__GUID_00020400_0000_0000_c000_000000000046
PUBLIC	?pmField@?$CVarTypeInfo@PAM@ATL@@2QQtagVARIANT@@PAMQ3@ ; ATL::CVarTypeInfo<float *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@N@ATL@@2GB			; ATL::CVarTypeInfo<double>::VT
PUBLIC	?pmField@?$CVarTypeInfo@N@ATL@@2QQtagVARIANT@@NQ3@ ; ATL::CVarTypeInfo<double>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAN@ATL@@2GB			; ATL::CVarTypeInfo<double *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAN@ATL@@2QQtagVARIANT@@PANQ3@ ; ATL::CVarTypeInfo<double *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@PAUtagVARIANT@@@ATL@@2GB	; ATL::CVarTypeInfo<tagVARIANT *>::VT
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	__GUID_0002e012_0000_0000_c000_000000000046
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?VT@?$CVarTypeInfo@PA_W@ATL@@2GB		; ATL::CVarTypeInfo<wchar_t *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PA_W@ATL@@2QQtagVARIANT@@PA_WQ3@ ; ATL::CVarTypeInfo<wchar_t *>::pmField
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?VT@?$CVarTypeInfo@PAPA_W@ATL@@2GB		; ATL::CVarTypeInfo<wchar_t * *>::VT
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?pmField@?$CVarTypeInfo@PAPA_W@ATL@@2QQtagVARIANT@@PAPA_WQ3@ ; ATL::CVarTypeInfo<wchar_t * *>::pmField
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?VT@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2GB	; ATL::CVarTypeInfo<IUnknown *>::VT
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?pmField@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2QQtagVARIANT@@PAUIUnknown@@Q3@ ; ATL::CVarTypeInfo<IUnknown *>::pmField
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?C_Win_Tokens@@3PAPADA				; C_Win_Tokens
PUBLIC	??_C@_09NLBFAKCN@?$FLNOTHING?$FN?$AA@		; `string'
PUBLIC	??_C@_07NDMCPPCN@?$FLSetup?$FN?$AA@		; `string'
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?VT@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2GB	; ATL::CVarTypeInfo<IUnknown * *>::VT
PUBLIC	??_C@_03KPANPEFB@?$FLX?$FN?$AA@			; `string'
PUBLIC	??_C@_03KOMPJOGG@?$FLY?$FN?$AA@			; `string'
PUBLIC	?pmField@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2QQtagVARIANT@@PAPAUIUnknown@@Q3@ ; ATL::CVarTypeInfo<IUnknown * *>::pmField
PUBLIC	??_C@_04BENPOHFD@?$FLXY?$FN?$AA@		; `string'
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	??_C@_03KEFBLDGM@?$FLW?$FN?$AA@			; `string'
PUBLIC	??_C@_03LDCLFHCB@?$FLH?$FN?$AA@			; `string'
PUBLIC	??_C@_08JPIFLAEG@?$FLRanges?$FN?$AA@		; `string'
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	??_C@_0N@OIFFBCOJ@?$FLClientArea?$FN?$AA@	; `string'
PUBLIC	??_C@_06GDGPHIE@?$FLFont?$FN?$AA@		; `string'
PUBLIC	??_C@_07EJLANDEA@?$FLGroup?$FN?$AA@		; `string'
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	__GUID_0000010c_0000_0000_c000_000000000046
PUBLIC	??_C@_0M@BJDPLCOH@?$FLFLAGBITON?$FN?$AA@	; `string'
PUBLIC	??_C@_0N@OEKFAPAO@?$FLFLAGBITOFF?$FN?$AA@	; `string'
PUBLIC	??_C@_07HAKAKNOM@?$FLDEPTH?$FN?$AA@		; `string'
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	??_C@_0L@JKDBOFEC@?$FLOPENMENU?$FN?$AA@		; `string'
PUBLIC	?VT@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2GB	; ATL::CVarTypeInfo<IDispatch *>::VT
PUBLIC	??_C@_0BB@NOAFCABC@?$FLOPENCLIENTMENU?$FN?$AA@	; `string'
PUBLIC	??_C@_08KCKBLKKP@?$FLCURSOR?$FN?$AA@		; `string'
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?pmField@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2QQtagVARIANT@@PAUIDispatch@@Q3@ ; ATL::CVarTypeInfo<IDispatch *>::pmField
PUBLIC	??_C@_07HBFPNJIM@?$FLDRAGH?$FN?$AA@		; `string'
PUBLIC	??_C@_0N@IFCKHDOD@?$FLCLIENTFLAG?$FN?$AA@	; `string'
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	??_C@_05GIBEAPNE@CLSID?$AA@			; `string'
PUBLIC	?SubTable@@3PAFA				; SubTable
PUBLIC	?TableVal@@3PAFA				; TableVal
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	_IID_IAxWinHostWindow
PUBLIC	?VT@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2GB	; ATL::CVarTypeInfo<IDispatch * *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2QQtagVARIANT@@PAPAUIDispatch@@Q3@ ; ATL::CVarTypeInfo<IDispatch * *>::pmField
PUBLIC	?VT@?$CVarTypeInfo@TtagCY@@@ATL@@2GB		; ATL::CVarTypeInfo<tagCY>::VT
PUBLIC	?Circle8@@3PAY01MA				; Circle8
PUBLIC	?pmField@?$CVarTypeInfo@TtagCY@@@ATL@@2QQtagVARIANT@@TtagCY@@Q3@ ; ATL::CVarTypeInfo<tagCY>::pmField
PUBLIC	??_C@_05PDIKPLII@AppID?$AA@			; `string'
PUBLIC	?VT@?$CVarTypeInfo@PATtagCY@@@ATL@@2GB		; ATL::CVarTypeInfo<tagCY *>::VT
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?pmField@?$CVarTypeInfo@PATtagCY@@@ATL@@2QQtagVARIANT@@PATtagCY@@Q3@ ; ATL::CVarTypeInfo<tagCY *>::pmField
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?chDirSep@ATL@@3DB				; ATL::chDirSep
PUBLIC	?chRightBracket@ATL@@3DB			; ATL::chRightBracket
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?chLeftBracket@ATL@@3DB				; ATL::chLeftBracket
PUBLIC	?chQuote@ATL@@3DB				; ATL::chQuote
PUBLIC	?chEquals@ATL@@3DB				; ATL::chEquals
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?szStringVal@ATL@@3QBDB				; ATL::szStringVal
PUBLIC	??_C@_01CPLAODJH@S?$AA@				; `string'
PUBLIC	?multiszStringVal@ATL@@3QBDB			; ATL::multiszStringVal
PUBLIC	_IID_IAxWinHostWindowLic
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	??_C@_01PLPBNMEI@M?$AA@				; `string'
PUBLIC	?szDwordVal@ATL@@3QBDB				; ATL::szDwordVal
PUBLIC	??_C@_01CKDDGHAB@D?$AA@				; `string'
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?szBinaryVal@ATL@@3QBDB				; ATL::szBinaryVal
PUBLIC	??_C@_01HMGJMAIH@B?$AA@				; `string'
PUBLIC	?szValToken@ATL@@3QBDB				; ATL::szValToken
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	??_C@_03LAIAPFCB@Val?$AA@			; `string'
PUBLIC	?szForceRemove@ATL@@3QBDB			; ATL::szForceRemove
PUBLIC	??_C@_0M@DBGDLGLL@ForceRemove?$AA@		; `string'
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?szNoRemove@ATL@@3QBDB				; ATL::szNoRemove
PUBLIC	??_C@_08KAAPDIAN@NoRemove?$AA@			; `string'
PUBLIC	?szDelete@ATL@@3QBDB				; ATL::szDelete
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	??_C@_06JBKGCNBB@Delete?$AA@			; `string'
PUBLIC	?ATL_CREATE_OBJECT@CComApartment@ATL@@2IA	; ATL::CComApartment::ATL_CREATE_OBJECT
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	_IID_IAxWinAmbientDispatch
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A ; ATL::_pAtlAutoThreadModule
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?m_bInitFailed@CAtlBaseModule@ATL@@2_NA		; ATL::CAtlBaseModule::m_bInitFailed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?table_size@?$ctype@D@std@@2IB			; std::ctype<char>::table_size
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	__GUID_00000000_0000_0000_0000_000000000000
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?MAX_VALUE@CRegParser@ATL@@1HB			; ATL::CRegParser::MAX_VALUE
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?rgszNeverDelete@CRegParser@ATL@@1QBQBDB	; ATL::CRegParser::rgszNeverDelete
PUBLIC	?cbNeverDelete@CRegParser@ATL@@1HB		; ATL::CRegParser::cbNeverDelete
PUBLIC	?MAX_TYPE@CRegParser@ATL@@1HB			; ATL::CRegParser::MAX_TYPE
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	__GUID_fc4801a3_2ba9_11cf_a229_00aa003d7352
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	_IID_IAxWinAmbientDispatchEx
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	_IID_IInternalConnection
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	__GUID_1cf2b120_547d_101b_8e65_08002b2bd119
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?_pAtlModule@ATL@@3PAVCAtlModule@1@A		; ATL::_pAtlModule
PUBLIC	?m_libid@CAtlModule@ATL@@2U_GUID@@A		; ATL::CAtlModule::m_libid
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	__GUID_00000146_0000_0000_c000_000000000046
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?VT@?$CVarTypeInfo@D@ATL@@2GB			; ATL::CVarTypeInfo<char>::VT
PUBLIC	?pmField@?$CVarTypeInfo@D@ATL@@2QQtagVARIANT@@DQ3@ ; ATL::CVarTypeInfo<char>::pmField
PUBLIC	?VT@?$CVarTypeInfo@E@ATL@@2GB			; ATL::CVarTypeInfo<unsigned char>::VT
PUBLIC	?pmField@?$CVarTypeInfo@E@ATL@@2QQtagVARIANT@@EQ3@ ; ATL::CVarTypeInfo<unsigned char>::pmField
PUBLIC	_CLSID_Registrar
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?_Min@?$AtlLimits@H@ATL@@2HB			; ATL::AtlLimits<int>::_Min
PUBLIC	?VT@?$CVarTypeInfo@PAD@ATL@@2GB			; ATL::CVarTypeInfo<char *>::VT
PUBLIC	?_Max@?$AtlLimits@H@ATL@@2HB			; ATL::AtlLimits<int>::_Max
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?pmField@?$CVarTypeInfo@PAD@ATL@@2QQtagVARIANT@@PADQ3@ ; ATL::CVarTypeInfo<char *>::pmField
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?_Min@?$AtlLimits@I@ATL@@2IB			; ATL::AtlLimits<unsigned int>::_Min
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?_Max@?$AtlLimits@I@ATL@@2IB			; ATL::AtlLimits<unsigned int>::_Max
PUBLIC	?VT@?$CVarTypeInfo@PAE@ATL@@2GB			; ATL::CVarTypeInfo<unsigned char *>::VT
PUBLIC	__GUID_00000109_0000_0000_c000_000000000046
PUBLIC	?pmField@?$CVarTypeInfo@PAE@ATL@@2QQtagVARIANT@@PAEQ3@ ; ATL::CVarTypeInfo<unsigned char *>::pmField
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	__GUID_7fd52380_4e07_101b_ae2d_08002b2ec713
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?_Min@?$AtlLimits@J@ATL@@2JB			; ATL::AtlLimits<long>::_Min
PUBLIC	__GUID_b196b284_bab4_101a_b69c_00aa00341d07
PUBLIC	?_Max@?$AtlLimits@J@ATL@@2JB			; ATL::AtlLimits<long>::_Max
PUBLIC	?VT@?$CVarTypeInfo@F@ATL@@2GB			; ATL::CVarTypeInfo<short>::VT
PUBLIC	_IID_IRegistrar
PUBLIC	?pmField@?$CVarTypeInfo@F@ATL@@2QQtagVARIANT@@FQ3@ ; ATL::CVarTypeInfo<short>::pmField
PUBLIC	?_Min@?$AtlLimits@K@ATL@@2KB			; ATL::AtlLimits<unsigned long>::_Min
PUBLIC	?_Max@?$AtlLimits@K@ATL@@2KB			; ATL::AtlLimits<unsigned long>::_Max
PUBLIC	?VT@?$CVarTypeInfo@PAF@ATL@@2GB			; ATL::CVarTypeInfo<short *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAF@ATL@@2QQtagVARIANT@@PAFQ3@ ; ATL::CVarTypeInfo<short *>::pmField
PUBLIC	?_Min@?$AtlLimits@_J@ATL@@2_JB			; ATL::AtlLimits<__int64>::_Min
PUBLIC	__GUID_00000001_0000_0000_c000_000000000046
PUBLIC	?_Max@?$AtlLimits@_J@ATL@@2_JB			; ATL::AtlLimits<__int64>::_Max
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?VT@?$CVarTypeInfo@G@ATL@@2GB			; ATL::CVarTypeInfo<unsigned short>::VT
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?pmField@?$CVarTypeInfo@G@ATL@@2QQtagVARIANT@@GQ3@ ; ATL::CVarTypeInfo<unsigned short>::pmField
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	__GUID_00020401_0000_0000_c000_000000000046
PUBLIC	?_Min@?$AtlLimits@_K@ATL@@2_KB			; ATL::AtlLimits<unsigned __int64>::_Min
PUBLIC	_LIBID_ATLLib
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?_Max@?$AtlLimits@_K@ATL@@2_KB			; ATL::AtlLimits<unsigned __int64>::_Max
PUBLIC	__GUID_00020412_0000_0000_c000_000000000046
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?VT@?$CVarTypeInfo@PAG@ATL@@2GB			; ATL::CVarTypeInfo<unsigned short *>::VT
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?pmField@?$CVarTypeInfo@PAG@ATL@@2QQtagVARIANT@@PAGQ3@ ; ATL::CVarTypeInfo<unsigned short *>::pmField
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?VT@?$CVarTypeInfo@H@ATL@@2GB			; ATL::CVarTypeInfo<int>::VT
PUBLIC	?pmField@?$CVarTypeInfo@H@ATL@@2QQtagVARIANT@@HQ3@ ; ATL::CVarTypeInfo<int>::pmField
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?VT@?$CVarTypeInfo@PAH@ATL@@2GB			; ATL::CVarTypeInfo<int *>::VT
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?pmField@?$CVarTypeInfo@PAH@ATL@@2QQtagVARIANT@@PAHQ3@ ; ATL::CVarTypeInfo<int *>::pmField
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?VT@?$CVarTypeInfo@I@ATL@@2GB			; ATL::CVarTypeInfo<unsigned int>::VT
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?pmField@?$CVarTypeInfo@I@ATL@@2QQtagVARIANT@@IQ3@ ; ATL::CVarTypeInfo<unsigned int>::pmField
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?VT@?$CVarTypeInfo@PAI@ATL@@2GB			; ATL::CVarTypeInfo<unsigned int *>::VT
PUBLIC	?pmField@?$CVarTypeInfo@PAI@ATL@@2QQtagVARIANT@@PAIQ3@ ; ATL::CVarTypeInfo<unsigned int *>::pmField
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?VT@?$CVarTypeInfo@J@ATL@@2GB			; ATL::CVarTypeInfo<long>::VT
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?pmField@?$CVarTypeInfo@J@ATL@@2QQtagVARIANT@@JQ3@ ; ATL::CVarTypeInfo<long>::pmField
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?_pModule@ATL@@3PAVCComModule@1@A		; ATL::_pModule
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?VT@?$CVarTypeInfo@PAJ@ATL@@2GB			; ATL::CVarTypeInfo<long *>::VT
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?pmField@?$CVarTypeInfo@PAJ@ATL@@2QQtagVARIANT@@PAJQ3@ ; ATL::CVarTypeInfo<long *>::pmField
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	_IID_IDocHostUIHandlerDispatch
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?VT@?$CVarTypeInfo@K@ATL@@2GB			; ATL::CVarTypeInfo<unsigned long>::VT
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?pmField@?$CVarTypeInfo@K@ATL@@2QQtagVARIANT@@KQ3@ ; ATL::CVarTypeInfo<unsigned long>::pmField
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?VT@?$CVarTypeInfo@PAK@ATL@@2GB			; ATL::CVarTypeInfo<unsigned long *>::VT
;	COMDAT ?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA
_BSS	SEGMENT
?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA DD 01H DUP (?) ; ATL::_pPerfRegFunc
_BSS	ENDS
;	COMDAT ?_pPerfUnRegFunc@ATL@@3P6AJXZA
_BSS	SEGMENT
?_pPerfUnRegFunc@ATL@@3P6AJXZA DD 01H DUP (?)		; ATL::_pPerfUnRegFunc
_BSS	ENDS
;	COMDAT ?_AtlRegisterPerUser@ATL@@3_NA
_BSS	SEGMENT
?_AtlRegisterPerUser@ATL@@3_NA DB 01H DUP (?)		; ATL::_AtlRegisterPerUser
_BSS	ENDS
;	COMDAT ?ATL_CREATE_OBJECT@CComApartment@ATL@@2IA
_BSS	SEGMENT
?ATL_CREATE_OBJECT@CComApartment@ATL@@2IA DD 01H DUP (?) ; ATL::CComApartment::ATL_CREATE_OBJECT
_BSS	ENDS
;	COMDAT ?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A
_BSS	SEGMENT
?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A DD 01H DUP (?) ; ATL::_pAtlAutoThreadModule
_BSS	ENDS
;	COMDAT ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA
_BSS	SEGMENT
?m_bInitFailed@CAtlBaseModule@ATL@@2_NA DB 01H DUP (?)	; ATL::CAtlBaseModule::m_bInitFailed
_BSS	ENDS
;	COMDAT ?_pAtlModule@ATL@@3PAVCAtlModule@1@A
_BSS	SEGMENT
?_pAtlModule@ATL@@3PAVCAtlModule@1@A DD 01H DUP (?)	; ATL::_pAtlModule
_BSS	ENDS
;	COMDAT ?m_libid@CAtlModule@ATL@@2U_GUID@@A
_BSS	SEGMENT
?m_libid@CAtlModule@ATL@@2U_GUID@@A DB 010H DUP (?)	; ATL::CAtlModule::m_libid
_BSS	ENDS
;	COMDAT ?_pModule@ATL@@3PAVCComModule@1@A
_BSS	SEGMENT
?_pModule@ATL@@3PAVCComModule@1@A DD 01H DUP (?)	; ATL::_pModule
_BSS	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAK@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAK@ATL@@2GB DW 04013H		; ATL::CVarTypeInfo<unsigned long *>::VT
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@K@ATL@@2QQtagVARIANT@@KQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@K@ATL@@2QQtagVARIANT@@KQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned long>::pmField
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@K@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@K@ATL@@2GB DW 013H			; ATL::CVarTypeInfo<unsigned long>::VT
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT _IID_IDocHostUIHandlerDispatch
CONST	SEGMENT
_IID_IDocHostUIHandlerDispatch DD 0425b5af0H
	DW	065f1H
	DW	011d1H
	DB	096H
	DB	011H
	DB	00H
	DB	00H
	DB	0f8H
	DB	01eH
	DB	0dH
	DB	0dH
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAJ@ATL@@2QQtagVARIANT@@PAJQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAJ@ATL@@2QQtagVARIANT@@PAJQ3@ DD 08H ; ATL::CVarTypeInfo<long *>::pmField
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAJ@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAJ@ATL@@2GB DW 04003H		; ATL::CVarTypeInfo<long *>::VT
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@J@ATL@@2QQtagVARIANT@@JQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@J@ATL@@2QQtagVARIANT@@JQ3@ DD 08H ; ATL::CVarTypeInfo<long>::pmField
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@J@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@J@ATL@@2GB DW 03H			; ATL::CVarTypeInfo<long>::VT
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAI@ATL@@2QQtagVARIANT@@PAIQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAI@ATL@@2QQtagVARIANT@@PAIQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned int *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAI@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAI@ATL@@2GB DW 04013H		; ATL::CVarTypeInfo<unsigned int *>::VT
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@I@ATL@@2QQtagVARIANT@@IQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@I@ATL@@2QQtagVARIANT@@IQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned int>::pmField
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@I@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@I@ATL@@2GB DW 013H			; ATL::CVarTypeInfo<unsigned int>::VT
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAH@ATL@@2QQtagVARIANT@@PAHQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAH@ATL@@2QQtagVARIANT@@PAHQ3@ DD 08H ; ATL::CVarTypeInfo<int *>::pmField
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAH@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAH@ATL@@2GB DW 04003H		; ATL::CVarTypeInfo<int *>::VT
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@H@ATL@@2QQtagVARIANT@@HQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@H@ATL@@2QQtagVARIANT@@HQ3@ DD 08H ; ATL::CVarTypeInfo<int>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@H@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@H@ATL@@2GB DW 03H			; ATL::CVarTypeInfo<int>::VT
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAG@ATL@@2QQtagVARIANT@@PAGQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAG@ATL@@2QQtagVARIANT@@PAGQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned short *>::pmField
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAG@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAG@ATL@@2GB DW 04012H		; ATL::CVarTypeInfo<unsigned short *>::VT
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT __GUID_00020412_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_00020412_0000_0000_c000_000000000046 DD 020412H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT ?_Max@?$AtlLimits@_K@ATL@@2_KB
CONST	SEGMENT
?_Max@?$AtlLimits@_K@ATL@@2_KB DQ ffffffffffffffffH	; ATL::AtlLimits<unsigned __int64>::_Max
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT _LIBID_ATLLib
CONST	SEGMENT
_LIBID_ATLLib DD 044ec0535H
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT ?_Min@?$AtlLimits@_K@ATL@@2_KB
CONST	SEGMENT
?_Min@?$AtlLimits@_K@ATL@@2_KB DQ 0000000000000000H	; ATL::AtlLimits<unsigned __int64>::_Min
CONST	ENDS
;	COMDAT __GUID_00020401_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_00020401_0000_0000_c000_000000000046 DD 020401H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@G@ATL@@2QQtagVARIANT@@GQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@G@ATL@@2QQtagVARIANT@@GQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned short>::pmField
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@G@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@G@ATL@@2GB DW 012H			; ATL::CVarTypeInfo<unsigned short>::VT
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?_Max@?$AtlLimits@_J@ATL@@2_JB
CONST	SEGMENT
?_Max@?$AtlLimits@_J@ATL@@2_JB DQ 7fffffffffffffffH	; ATL::AtlLimits<__int64>::_Max
CONST	ENDS
;	COMDAT __GUID_00000001_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_00000001_0000_0000_c000_000000000046 DD 01H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT ?_Min@?$AtlLimits@_J@ATL@@2_JB
CONST	SEGMENT
?_Min@?$AtlLimits@_J@ATL@@2_JB DQ 8000000000000000H	; ATL::AtlLimits<__int64>::_Min
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAF@ATL@@2QQtagVARIANT@@PAFQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAF@ATL@@2QQtagVARIANT@@PAFQ3@ DD 08H ; ATL::CVarTypeInfo<short *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAF@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAF@ATL@@2GB DW 04002H		; ATL::CVarTypeInfo<short *>::VT
CONST	ENDS
;	COMDAT ?_Max@?$AtlLimits@K@ATL@@2KB
CONST	SEGMENT
?_Max@?$AtlLimits@K@ATL@@2KB DD 0ffffffffH		; ATL::AtlLimits<unsigned long>::_Max
CONST	ENDS
;	COMDAT ?_Min@?$AtlLimits@K@ATL@@2KB
CONST	SEGMENT
?_Min@?$AtlLimits@K@ATL@@2KB DD 00H			; ATL::AtlLimits<unsigned long>::_Min
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@F@ATL@@2QQtagVARIANT@@FQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@F@ATL@@2QQtagVARIANT@@FQ3@ DD 08H ; ATL::CVarTypeInfo<short>::pmField
CONST	ENDS
;	COMDAT _IID_IRegistrar
CONST	SEGMENT
_IID_IRegistrar DD 044ec053bH
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@F@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@F@ATL@@2GB DW 02H			; ATL::CVarTypeInfo<short>::VT
CONST	ENDS
;	COMDAT ?_Max@?$AtlLimits@J@ATL@@2JB
CONST	SEGMENT
?_Max@?$AtlLimits@J@ATL@@2JB DD 07fffffffH		; ATL::AtlLimits<long>::_Max
CONST	ENDS
;	COMDAT __GUID_b196b284_bab4_101a_b69c_00aa00341d07
CONST	SEGMENT
__GUID_b196b284_bab4_101a_b69c_00aa00341d07 DD 0b196b284H
	DW	0bab4H
	DW	0101aH
	DB	0b6H
	DB	09cH
	DB	00H
	DB	0aaH
	DB	00H
	DB	034H
	DB	01dH
	DB	07H
CONST	ENDS
;	COMDAT ?_Min@?$AtlLimits@J@ATL@@2JB
CONST	SEGMENT
?_Min@?$AtlLimits@J@ATL@@2JB DD 080000000H		; ATL::AtlLimits<long>::_Min
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT __GUID_7fd52380_4e07_101b_ae2d_08002b2ec713
CONST	SEGMENT
__GUID_7fd52380_4e07_101b_ae2d_08002b2ec713 DD 07fd52380H
	DW	04e07H
	DW	0101bH
	DB	0aeH
	DB	02dH
	DB	08H
	DB	00H
	DB	02bH
	DB	02eH
	DB	0c7H
	DB	013H
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAE@ATL@@2QQtagVARIANT@@PAEQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAE@ATL@@2QQtagVARIANT@@PAEQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned char *>::pmField
CONST	ENDS
;	COMDAT __GUID_00000109_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_00000109_0000_0000_c000_000000000046 DD 0109H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAE@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAE@ATL@@2GB DW 04011H		; ATL::CVarTypeInfo<unsigned char *>::VT
CONST	ENDS
;	COMDAT ?_Max@?$AtlLimits@I@ATL@@2IB
CONST	SEGMENT
?_Max@?$AtlLimits@I@ATL@@2IB DD 0ffffffffH		; ATL::AtlLimits<unsigned int>::_Max
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?_Min@?$AtlLimits@I@ATL@@2IB
CONST	SEGMENT
?_Min@?$AtlLimits@I@ATL@@2IB DD 00H			; ATL::AtlLimits<unsigned int>::_Min
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAD@ATL@@2QQtagVARIANT@@PADQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAD@ATL@@2QQtagVARIANT@@PADQ3@ DD 08H ; ATL::CVarTypeInfo<char *>::pmField
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?_Max@?$AtlLimits@H@ATL@@2HB
CONST	SEGMENT
?_Max@?$AtlLimits@H@ATL@@2HB DD 07fffffffH		; ATL::AtlLimits<int>::_Max
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAD@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAD@ATL@@2GB DW 04010H		; ATL::CVarTypeInfo<char *>::VT
CONST	ENDS
;	COMDAT ?_Min@?$AtlLimits@H@ATL@@2HB
CONST	SEGMENT
?_Min@?$AtlLimits@H@ATL@@2HB DD 080000000H		; ATL::AtlLimits<int>::_Min
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT _CLSID_Registrar
CONST	SEGMENT
_CLSID_Registrar DD 044ec053aH
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@E@ATL@@2QQtagVARIANT@@EQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@E@ATL@@2QQtagVARIANT@@EQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned char>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@E@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@E@ATL@@2GB DW 011H			; ATL::CVarTypeInfo<unsigned char>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@D@ATL@@2QQtagVARIANT@@DQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@D@ATL@@2QQtagVARIANT@@DQ3@ DD 08H ; ATL::CVarTypeInfo<char>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@D@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@D@ATL@@2GB DW 010H			; ATL::CVarTypeInfo<char>::VT
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT __GUID_00000146_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_00000146_0000_0000_c000_000000000046 DD 0146H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT __GUID_1cf2b120_547d_101b_8e65_08002b2bd119
CONST	SEGMENT
__GUID_1cf2b120_547d_101b_8e65_08002b2bd119 DD 01cf2b120H
	DW	0547dH
	DW	0101bH
	DB	08eH
	DB	065H
	DB	08H
	DB	00H
	DB	02bH
	DB	02bH
	DB	0d1H
	DB	019H
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT _IID_IInternalConnection
CONST	SEGMENT
_IID_IInternalConnection DD 072ad0770H
	DW	06a9fH
	DW	011d1H
	DB	0bcH
	DB	0ecH
	DB	00H
	DB	060H
	DB	08H
	DB	08fH
	DB	044H
	DB	04eH
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT _IID_IAxWinAmbientDispatchEx
CONST	SEGMENT
_IID_IAxWinAmbientDispatchEx DD 0b2d0778bH
	DW	0ac99H
	DW	04c58H
	DB	0a5H
	DB	0c8H
	DB	0e7H
	DB	072H
	DB	04eH
	DB	053H
	DB	016H
	DB	0b5H
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT __GUID_fc4801a3_2ba9_11cf_a229_00aa003d7352
CONST	SEGMENT
__GUID_fc4801a3_2ba9_11cf_a229_00aa003d7352 DD 0fc4801a3H
	DW	02ba9H
	DW	011cfH
	DB	0a2H
	DB	029H
	DB	00H
	DB	0aaH
	DB	00H
	DB	03dH
	DB	073H
	DB	052H
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?MAX_TYPE@CRegParser@ATL@@1HB
CONST	SEGMENT
?MAX_TYPE@CRegParser@ATL@@1HB DD 01000H			; ATL::CRegParser::MAX_TYPE
CONST	ENDS
;	COMDAT ?cbNeverDelete@CRegParser@ATL@@1HB
CONST	SEGMENT
?cbNeverDelete@CRegParser@ATL@@1HB DD 0cH		; ATL::CRegParser::cbNeverDelete
CONST	ENDS
;	COMDAT ?rgszNeverDelete@CRegParser@ATL@@1QBQBDB
CONST	SEGMENT
?rgszNeverDelete@CRegParser@ATL@@1QBQBDB DD FLAT:??_C@_05PDIKPLII@AppID?$AA@ ; ATL::CRegParser::rgszNeverDelete
	DD	FLAT:??_C@_05GIBEAPNE@CLSID?$AA@
	DD	FLAT:??_C@_0BF@HDDNNDFH@Component?5Categories?$AA@
	DD	FLAT:??_C@_08PICKODJL@FileType?$AA@
	DD	FLAT:??_C@_09JKPGEJCH@Interface?$AA@
	DD	FLAT:??_C@_08PPIOJEA@Hardware?$AA@
	DD	FLAT:??_C@_04IHBFOLAC@Mime?$AA@
	DD	FLAT:??_C@_03DDIMFGBA@SAM?$AA@
	DD	FLAT:??_C@_08LOPHEHKG@SECURITY?$AA@
	DD	FLAT:??_C@_06FDHFNJBJ@SYSTEM?$AA@
	DD	FLAT:??_C@_08KEKAJNJI@Software?$AA@
	DD	FLAT:??_C@_07KJLOKDKB@TypeLib?$AA@
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?MAX_VALUE@CRegParser@ATL@@1HB
CONST	SEGMENT
?MAX_VALUE@CRegParser@ATL@@1HB DD 01000H		; ATL::CRegParser::MAX_VALUE
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT __GUID_00000000_0000_0000_0000_000000000000
CONST	SEGMENT
__GUID_00000000_0000_0000_0000_000000000000 DD 00H
	DW	00H
	DW	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2IB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2IB DD 0100H			; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT _IID_IAxWinAmbientDispatch
CONST	SEGMENT
_IID_IAxWinAmbientDispatch DD 0b6ea2051H
	DW	048aH
	DW	011d1H
	DB	082H
	DB	0b9H
	DB	00H
	DB	0c0H
	DB	04fH
	DB	0b9H
	DB	094H
	DB	02eH
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ??_C@_06JBKGCNBB@Delete?$AA@
CONST	SEGMENT
??_C@_06JBKGCNBB@Delete?$AA@ DB 'Delete', 00H		; `string'
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?szDelete@ATL@@3QBDB
CONST	SEGMENT
?szDelete@ATL@@3QBDB DD FLAT:??_C@_06JBKGCNBB@Delete?$AA@ ; ATL::szDelete
CONST	ENDS
;	COMDAT ??_C@_08KAAPDIAN@NoRemove?$AA@
CONST	SEGMENT
??_C@_08KAAPDIAN@NoRemove?$AA@ DB 'NoRemove', 00H	; `string'
CONST	ENDS
;	COMDAT ?szNoRemove@ATL@@3QBDB
CONST	SEGMENT
?szNoRemove@ATL@@3QBDB DD FLAT:??_C@_08KAAPDIAN@NoRemove?$AA@ ; ATL::szNoRemove
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ??_C@_0M@DBGDLGLL@ForceRemove?$AA@
CONST	SEGMENT
??_C@_0M@DBGDLGLL@ForceRemove?$AA@ DB 'ForceRemove', 00H ; `string'
CONST	ENDS
CONST	SEGMENT
_L_2	DD	03f317218r			; 0.693147
CONST	ENDS
;	COMDAT ?szForceRemove@ATL@@3QBDB
CONST	SEGMENT
?szForceRemove@ATL@@3QBDB DD FLAT:??_C@_0M@DBGDLGLL@ForceRemove?$AA@ ; ATL::szForceRemove
CONST	ENDS
;	COMDAT ??_C@_03LAIAPFCB@Val?$AA@
CONST	SEGMENT
??_C@_03LAIAPFCB@Val?$AA@ DB 'Val', 00H			; `string'
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?szValToken@ATL@@3QBDB
CONST	SEGMENT
?szValToken@ATL@@3QBDB DD FLAT:??_C@_03LAIAPFCB@Val?$AA@ ; ATL::szValToken
CONST	ENDS
;	COMDAT ??_C@_01HMGJMAIH@B?$AA@
CONST	SEGMENT
??_C@_01HMGJMAIH@B?$AA@ DB 'B', 00H			; `string'
CONST	ENDS
;	COMDAT ?szBinaryVal@ATL@@3QBDB
CONST	SEGMENT
?szBinaryVal@ATL@@3QBDB DD FLAT:??_C@_01HMGJMAIH@B?$AA@	; ATL::szBinaryVal
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ??_C@_01CKDDGHAB@D?$AA@
CONST	SEGMENT
??_C@_01CKDDGHAB@D?$AA@ DB 'D', 00H			; `string'
CONST	ENDS
;	COMDAT ?szDwordVal@ATL@@3QBDB
CONST	SEGMENT
?szDwordVal@ATL@@3QBDB DD FLAT:??_C@_01CKDDGHAB@D?$AA@	; ATL::szDwordVal
CONST	ENDS
;	COMDAT ??_C@_01PLPBNMEI@M?$AA@
CONST	SEGMENT
??_C@_01PLPBNMEI@M?$AA@ DB 'M', 00H			; `string'
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT _IID_IAxWinHostWindowLic
CONST	SEGMENT
_IID_IAxWinHostWindowLic DD 03935bda8H
	DW	04ed9H
	DW	0495cH
	DB	086H
	DB	050H
	DB	0e0H
	DB	01fH
	DB	0c1H
	DB	0e3H
	DB	08aH
	DB	04bH
CONST	ENDS
;	COMDAT ?multiszStringVal@ATL@@3QBDB
CONST	SEGMENT
?multiszStringVal@ATL@@3QBDB DD FLAT:??_C@_01PLPBNMEI@M?$AA@ ; ATL::multiszStringVal
CONST	ENDS
;	COMDAT ??_C@_01CPLAODJH@S?$AA@
CONST	SEGMENT
??_C@_01CPLAODJH@S?$AA@ DB 'S', 00H			; `string'
CONST	ENDS
;	COMDAT ?szStringVal@ATL@@3QBDB
CONST	SEGMENT
?szStringVal@ATL@@3QBDB DD FLAT:??_C@_01CPLAODJH@S?$AA@	; ATL::szStringVal
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?chEquals@ATL@@3DB
CONST	SEGMENT
?chEquals@ATL@@3DB DB 03dH				; ATL::chEquals
CONST	ENDS
;	COMDAT ?chQuote@ATL@@3DB
CONST	SEGMENT
?chQuote@ATL@@3DB DB 027H				; ATL::chQuote
CONST	ENDS
;	COMDAT ?chLeftBracket@ATL@@3DB
CONST	SEGMENT
?chLeftBracket@ATL@@3DB DB 07bH				; ATL::chLeftBracket
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?chRightBracket@ATL@@3DB
CONST	SEGMENT
?chRightBracket@ATL@@3DB DB 07dH			; ATL::chRightBracket
CONST	ENDS
;	COMDAT ?chDirSep@ATL@@3DB
CONST	SEGMENT
?chDirSep@ATL@@3DB DB 05cH				; ATL::chDirSep
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PATtagCY@@@ATL@@2QQtagVARIANT@@PATtagCY@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PATtagCY@@@ATL@@2QQtagVARIANT@@PATtagCY@@Q3@ DD 08H ; ATL::CVarTypeInfo<tagCY *>::pmField
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PATtagCY@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PATtagCY@@@ATL@@2GB DW 04006H	; ATL::CVarTypeInfo<tagCY *>::VT
CONST	ENDS
;	COMDAT ??_C@_05PDIKPLII@AppID?$AA@
CONST	SEGMENT
??_C@_05PDIKPLII@AppID?$AA@ DB 'AppID', 00H		; `string'
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@TtagCY@@@ATL@@2QQtagVARIANT@@TtagCY@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@TtagCY@@@ATL@@2QQtagVARIANT@@TtagCY@@Q3@ DD 08H ; ATL::CVarTypeInfo<tagCY>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@TtagCY@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@TtagCY@@@ATL@@2GB DW 06H		; ATL::CVarTypeInfo<tagCY>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2QQtagVARIANT@@PAPAUIDispatch@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2QQtagVARIANT@@PAPAUIDispatch@@Q3@ DD 08H ; ATL::CVarTypeInfo<IDispatch * *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAPAUIDispatch@@@ATL@@2GB DW 04009H	; ATL::CVarTypeInfo<IDispatch * *>::VT
CONST	ENDS
;	COMDAT _IID_IAxWinHostWindow
CONST	SEGMENT
_IID_IAxWinHostWindow DD 0b6ea2050H
	DW	048aH
	DW	011d1H
	DB	082H
	DB	0b9H
	DB	00H
	DB	0c0H
	DB	04fH
	DB	0b9H
	DB	094H
	DB	02eH
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ??_C@_05GIBEAPNE@CLSID?$AA@
CONST	SEGMENT
??_C@_05GIBEAPNE@CLSID?$AA@ DB 'CLSID', 00H		; `string'
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ??_C@_0N@IFCKHDOD@?$FLCLIENTFLAG?$FN?$AA@
CONST	SEGMENT
??_C@_0N@IFCKHDOD@?$FLCLIENTFLAG?$FN?$AA@ DB '[CLIENTFLAG]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07HBFPNJIM@?$FLDRAGH?$FN?$AA@
CONST	SEGMENT
??_C@_07HBFPNJIM@?$FLDRAGH?$FN?$AA@ DB '[DRAGH]', 00H	; `string'
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2QQtagVARIANT@@PAUIDispatch@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2QQtagVARIANT@@PAUIDispatch@@Q3@ DD 08H ; ATL::CVarTypeInfo<IDispatch *>::pmField
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ??_C@_08KCKBLKKP@?$FLCURSOR?$FN?$AA@
CONST	SEGMENT
??_C@_08KCKBLKKP@?$FLCURSOR?$FN?$AA@ DB '[CURSOR]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NOAFCABC@?$FLOPENCLIENTMENU?$FN?$AA@
CONST	SEGMENT
??_C@_0BB@NOAFCABC@?$FLOPENCLIENTMENU?$FN?$AA@ DB '[OPENCLIENTMENU]', 00H ; `string'
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAUIDispatch@@@ATL@@2GB DW 09H	; ATL::CVarTypeInfo<IDispatch *>::VT
CONST	ENDS
;	COMDAT ??_C@_0L@JKDBOFEC@?$FLOPENMENU?$FN?$AA@
CONST	SEGMENT
??_C@_0L@JKDBOFEC@?$FLOPENMENU?$FN?$AA@ DB '[OPENMENU]', 00H ; `string'
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ??_C@_07HAKAKNOM@?$FLDEPTH?$FN?$AA@
CONST	SEGMENT
??_C@_07HAKAKNOM@?$FLDEPTH?$FN?$AA@ DB '[DEPTH]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OEKFAPAO@?$FLFLAGBITOFF?$FN?$AA@
CONST	SEGMENT
??_C@_0N@OEKFAPAO@?$FLFLAGBITOFF?$FN?$AA@ DB '[FLAGBITOFF]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BJDPLCOH@?$FLFLAGBITON?$FN?$AA@
CONST	SEGMENT
??_C@_0M@BJDPLCOH@?$FLFLAGBITON?$FN?$AA@ DB '[FLAGBITON]', 00H ; `string'
CONST	ENDS
;	COMDAT __GUID_0000010c_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_0000010c_0000_0000_c000_000000000046 DD 010cH
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ??_C@_07EJLANDEA@?$FLGroup?$FN?$AA@
CONST	SEGMENT
??_C@_07EJLANDEA@?$FLGroup?$FN?$AA@ DB '[Group]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06GDGPHIE@?$FLFont?$FN?$AA@
CONST	SEGMENT
??_C@_06GDGPHIE@?$FLFont?$FN?$AA@ DB '[Font]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OIFFBCOJ@?$FLClientArea?$FN?$AA@
CONST	SEGMENT
??_C@_0N@OIFFBCOJ@?$FLClientArea?$FN?$AA@ DB '[ClientArea]', 00H ; `string'
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ??_C@_08JPIFLAEG@?$FLRanges?$FN?$AA@
CONST	SEGMENT
??_C@_08JPIFLAEG@?$FLRanges?$FN?$AA@ DB '[Ranges]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03LDCLFHCB@?$FLH?$FN?$AA@
CONST	SEGMENT
??_C@_03LDCLFHCB@?$FLH?$FN?$AA@ DB '[H]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03KEFBLDGM@?$FLW?$FN?$AA@
CONST	SEGMENT
??_C@_03KEFBLDGM@?$FLW?$FN?$AA@ DB '[W]', 00H		; `string'
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ??_C@_04BENPOHFD@?$FLXY?$FN?$AA@
CONST	SEGMENT
??_C@_04BENPOHFD@?$FLXY?$FN?$AA@ DB '[XY]', 00H		; `string'
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2QQtagVARIANT@@PAPAUIUnknown@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2QQtagVARIANT@@PAPAUIUnknown@@Q3@ DD 08H ; ATL::CVarTypeInfo<IUnknown * *>::pmField
CONST	ENDS
;	COMDAT ??_C@_03KOMPJOGG@?$FLY?$FN?$AA@
CONST	SEGMENT
??_C@_03KOMPJOGG@?$FLY?$FN?$AA@ DB '[Y]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03KPANPEFB@?$FLX?$FN?$AA@
CONST	SEGMENT
??_C@_03KPANPEFB@?$FLX?$FN?$AA@ DB '[X]', 00H		; `string'
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAPAUIUnknown@@@ATL@@2GB DW 0400dH	; ATL::CVarTypeInfo<IUnknown * *>::VT
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ??_C@_07NDMCPPCN@?$FLSetup?$FN?$AA@
CONST	SEGMENT
??_C@_07NDMCPPCN@?$FLSetup?$FN?$AA@ DB '[Setup]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09NLBFAKCN@?$FLNOTHING?$FN?$AA@
CONST	SEGMENT
??_C@_09NLBFAKCN@?$FLNOTHING?$FN?$AA@ DB '[NOTHING]', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
?C_Win_Tokens@@3PAPADA DD FLAT:??_C@_09NLBFAKCN@?$FLNOTHING?$FN?$AA@ ; C_Win_Tokens
	DD	FLAT:??_C@_07NDMCPPCN@?$FLSetup?$FN?$AA@
	DD	FLAT:??_C@_03KPANPEFB@?$FLX?$FN?$AA@
	DD	FLAT:??_C@_03KOMPJOGG@?$FLY?$FN?$AA@
	DD	FLAT:??_C@_04BENPOHFD@?$FLXY?$FN?$AA@
	DD	FLAT:??_C@_03KEFBLDGM@?$FLW?$FN?$AA@
	DD	FLAT:??_C@_03LDCLFHCB@?$FLH?$FN?$AA@
	DD	FLAT:??_C@_08JPIFLAEG@?$FLRanges?$FN?$AA@
	DD	FLAT:??_C@_0N@OIFFBCOJ@?$FLClientArea?$FN?$AA@
	DD	FLAT:??_C@_06GDGPHIE@?$FLFont?$FN?$AA@
	DD	FLAT:??_C@_07EJLANDEA@?$FLGroup?$FN?$AA@
	DD	FLAT:??_C@_0M@BJDPLCOH@?$FLFLAGBITON?$FN?$AA@
	DD	FLAT:??_C@_0N@OEKFAPAO@?$FLFLAGBITOFF?$FN?$AA@
	DD	FLAT:??_C@_07HAKAKNOM@?$FLDEPTH?$FN?$AA@
	DD	FLAT:??_C@_0L@JKDBOFEC@?$FLOPENMENU?$FN?$AA@
	DD	FLAT:??_C@_0BB@NOAFCABC@?$FLOPENCLIENTMENU?$FN?$AA@
	DD	FLAT:??_C@_08KCKBLKKP@?$FLCURSOR?$FN?$AA@
	DD	FLAT:??_C@_07HBFPNJIM@?$FLDRAGH?$FN?$AA@
	DD	FLAT:??_C@_0N@IFCKHDOD@?$FLCLIENTFLAG?$FN?$AA@
	DD	00H
?SubTable@@3PAFA DW 08H					; SubTable
	DW	08H
	DW	07H
	DW	07H
	DW	06H
	DW	06H
	DW	05H
	DW	05H
	DW	04H
	DW	04H
	DW	03H
	DW	03H
	DW	02H
	DW	02H
	DW	01H
	DW	01H
?TableVal@@3PAFA DW 00H					; TableVal
	DW	02H
	DW	04H
	DW	06H
	DW	08H
	DW	0aH
	DW	0cH
	DW	0eH
	DW	010H
	DW	012H
	DW	014H
	DW	016H
	DW	018H
	DW	01aH
	DW	01cH
	DW	01eH
	DW	020H
	DW	020H
	DW	020H
	DW	020H
	DW	020H
	DW	020H
	DW	020H
	DW	020H
	DW	020H
	DW	020H
	DW	020H
	DW	020H
	DW	020H
	DW	020H
	DW	020H
	DW	020H
	DW	020H
	DW	020H
	DW	020H
	DW	020H
	DW	020H
	DW	020H
	DW	020H
	DW	020H
	DW	020H
	DW	020H
	DW	020H
	DW	020H
	DW	020H
	DW	020H
	DW	020H
	DW	020H
?Circle8@@3PAY01MA DD 000000000r		; 0	; Circle8
	DD	03f800000r			; 1
	DD	03e47c5c2r			; 0.19509
	DD	03f7b14ber			; 0.980785
	DD	03ec3ef15r			; 0.382683
	DD	03f6c835er			; 0.92388
	DD	03f0e39dar			; 0.55557
	DD	03f54db31r			; 0.83147
	DD	03f3504f3r			; 0.707107
	DD	03f3504f3r			; 0.707107
_DATA	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2QQtagVARIANT@@PAUIUnknown@@Q3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2QQtagVARIANT@@PAUIUnknown@@Q3@ DD 08H ; ATL::CVarTypeInfo<IUnknown *>::pmField
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAUIUnknown@@@ATL@@2GB DW 0dH	; ATL::CVarTypeInfo<IUnknown *>::VT
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAPA_W@ATL@@2QQtagVARIANT@@PAPA_WQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAPA_W@ATL@@2QQtagVARIANT@@PAPA_WQ3@ DD 08H ; ATL::CVarTypeInfo<wchar_t * *>::pmField
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAPA_W@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAPA_W@ATL@@2GB DW 04008H		; ATL::CVarTypeInfo<wchar_t * *>::VT
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PA_W@ATL@@2QQtagVARIANT@@PA_WQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PA_W@ATL@@2QQtagVARIANT@@PA_WQ3@ DD 08H ; ATL::CVarTypeInfo<wchar_t *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PA_W@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PA_W@ATL@@2GB DW 08H			; ATL::CVarTypeInfo<wchar_t *>::VT
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT __GUID_0002e012_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_0002e012_0000_0000_c000_000000000046 DD 02e012H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAUtagVARIANT@@@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAUtagVARIANT@@@ATL@@2GB DW 0400cH	; ATL::CVarTypeInfo<tagVARIANT *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAN@ATL@@2QQtagVARIANT@@PANQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAN@ATL@@2QQtagVARIANT@@PANQ3@ DD 08H ; ATL::CVarTypeInfo<double *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAN@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAN@ATL@@2GB DW 04005H		; ATL::CVarTypeInfo<double *>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@N@ATL@@2QQtagVARIANT@@NQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@N@ATL@@2QQtagVARIANT@@NQ3@ DD 08H ; ATL::CVarTypeInfo<double>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@N@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@N@ATL@@2GB DW 05H			; ATL::CVarTypeInfo<double>::VT
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAM@ATL@@2QQtagVARIANT@@PAMQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAM@ATL@@2QQtagVARIANT@@PAMQ3@ DD 08H ; ATL::CVarTypeInfo<float *>::pmField
CONST	ENDS
;	COMDAT __GUID_00020400_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_00020400_0000_0000_c000_000000000046 DD 020400H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PAM@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PAM@ATL@@2GB DW 04004H		; ATL::CVarTypeInfo<float *>::VT
CONST	ENDS
;	COMDAT __GUID_a6bc3ac0_dbaa_11ce_9de3_00aa004bb851
CONST	SEGMENT
__GUID_a6bc3ac0_dbaa_11ce_9de3_00aa004bb851 DD 0a6bc3ac0H
	DW	0dbaaH
	DW	011ceH
	DB	09dH
	DB	0e3H
	DB	00H
	DB	0aaH
	DB	00H
	DB	04bH
	DB	0b8H
	DB	051H
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@M@ATL@@2QQtagVARIANT@@MQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@M@ATL@@2QQtagVARIANT@@MQ3@ DD 08H ; ATL::CVarTypeInfo<float>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@M@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@M@ATL@@2GB DW 04H			; ATL::CVarTypeInfo<float>::VT
CONST	ENDS
;	COMDAT __GUID_00000000_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_00000000_0000_0000_c000_000000000046 DD 00H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PA_K@ATL@@2QQtagVARIANT@@PA_KQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PA_K@ATL@@2QQtagVARIANT@@PA_KQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned __int64 *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PA_K@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PA_K@ATL@@2GB DW 04015H		; ATL::CVarTypeInfo<unsigned __int64 *>::VT
CONST	ENDS
;	COMDAT ??_C@_07KJLOKDKB@TypeLib?$AA@
CONST	SEGMENT
??_C@_07KJLOKDKB@TypeLib?$AA@ DB 'TypeLib', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KEKAJNJI@Software?$AA@
CONST	SEGMENT
??_C@_08KEKAJNJI@Software?$AA@ DB 'Software', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06FDHFNJBJ@SYSTEM?$AA@
CONST	SEGMENT
??_C@_06FDHFNJBJ@SYSTEM?$AA@ DB 'SYSTEM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LOPHEHKG@SECURITY?$AA@
CONST	SEGMENT
??_C@_08LOPHEHKG@SECURITY?$AA@ DB 'SECURITY', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03DDIMFGBA@SAM?$AA@
CONST	SEGMENT
??_C@_03DDIMFGBA@SAM?$AA@ DB 'SAM', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04IHBFOLAC@Mime?$AA@
CONST	SEGMENT
??_C@_04IHBFOLAC@Mime?$AA@ DB 'Mime', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08PPIOJEA@Hardware?$AA@
CONST	SEGMENT
??_C@_08PPIOJEA@Hardware?$AA@ DB 'Hardware', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09JKPGEJCH@Interface?$AA@
CONST	SEGMENT
??_C@_09JKPGEJCH@Interface?$AA@ DB 'Interface', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08PICKODJL@FileType?$AA@
CONST	SEGMENT
??_C@_08PICKODJL@FileType?$AA@ DB 'FileType', 00H	; `string'
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@_K@ATL@@2QQtagVARIANT@@_KQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@_K@ATL@@2QQtagVARIANT@@_KQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned __int64>::pmField
CONST	ENDS
;	COMDAT ??_C@_0BF@HDDNNDFH@Component?5Categories?$AA@
CONST	SEGMENT
??_C@_0BF@HDDNNDFH@Component?5Categories?$AA@ DB 'Component Categories', 00H ; `string'
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@_K@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@_K@ATL@@2GB DW 015H			; ATL::CVarTypeInfo<unsigned __int64>::VT
CONST	ENDS
;	COMDAT ?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B
CONST	SEGMENT
?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B DD 01H ; std::ios_base::failure::_Stream_err
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PA_J@ATL@@2QQtagVARIANT@@PA_JQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PA_J@ATL@@2QQtagVARIANT@@PA_JQ3@ DD 08H ; ATL::CVarTypeInfo<__int64 *>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@PA_J@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@PA_J@ATL@@2GB DW 04014H		; ATL::CVarTypeInfo<__int64 *>::VT
CONST	ENDS
;	COMDAT ___pobjMapEntryLast
ATL$__z	SEGMENT
___pobjMapEntryLast DD 00H
ATL$__z	ENDS
;	COMDAT ___pobjMapEntryFirst
ATL$__a	SEGMENT
___pobjMapEntryFirst DD 00H
ATL$__a	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@_J@ATL@@2QQtagVARIANT@@_JQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@_J@ATL@@2QQtagVARIANT@@_JQ3@ DD 08H ; ATL::CVarTypeInfo<__int64>::pmField
CONST	ENDS
;	COMDAT ?VT@?$CVarTypeInfo@_J@ATL@@2GB
CONST	SEGMENT
?VT@?$CVarTypeInfo@_J@ATL@@2GB DW 014H			; ATL::CVarTypeInfo<__int64>::VT
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?pmField@?$CVarTypeInfo@PAK@ATL@@2QQtagVARIANT@@PAKQ3@
CONST	SEGMENT
?pmField@?$CVarTypeInfo@PAK@ATL@@2QQtagVARIANT@@PAKQ3@ DD 08H ; ATL::CVarTypeInfo<unsigned long *>::pmField
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??1CComBSTR@ATL@@QAE@XZ				; ATL::CComBSTR::~CComBSTR
PUBLIC	??1stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ	; ATL::CComTypeInfoHolder::stringdispid::~stringdispid
PUBLIC	??_Estringdispid@CComTypeInfoHolder@ATL@@QAEPAXI@Z ; ATL::CComTypeInfoHolder::stringdispid::`vector deleting destructor'
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??0error_category@std@@QAE@XZ			; std::error_category::error_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??_Gerror_category@std@@UAEPAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8error_condition@std@@QBE_NABV01@@Z		; std::error_condition::operator==
PUBLIC	??0_Generic_error_category@std@@QAE@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	??0_Iostream_error_category@std@@QAE@XZ		; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	?name@_Iostream_error_category@std@@UBEPBDXZ	; std::_Iostream_error_category::name
PUBLIC	?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	??1_Iostream_error_category@std@@UAE@XZ		; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UAEPAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	??0_System_error_category@std@@QAE@XZ		; std::_System_error_category::_System_error_category
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	??_GC_Hash@@QAEPAXI@Z				; C_Hash::`scalar deleting destructor'
PUBLIC	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
PUBLIC	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z		; UI_Leave
PUBLIC	?EnableGroup@C_Base@@QAEXJ@Z			; C_Base::EnableGroup
PUBLIC	?DisableGroup@C_Base@@QAEXJ@Z			; C_Base::DisableGroup
PUBLIC	?SetParent@C_Base@@QAEXPAVC_Window@@@Z		; C_Base::SetParent
PUBLIC	?GetID@C_Base@@QAEJXZ				; C_Base::GetID
PUBLIC	?GetType@C_Base@@QAEFXZ				; C_Base::GetType
PUBLIC	?GetGroup@C_Base@@QAEJXZ			; C_Base::GetGroup
PUBLIC	?GetCluster@C_Base@@QAEJXZ			; C_Base::GetCluster
PUBLIC	?GetFlags@C_Base@@QAEJXZ			; C_Base::GetFlags
PUBLIC	?GetClient@C_Base@@QAEFXZ			; C_Base::GetClient
PUBLIC	?GetX@C_Base@@QAEJXZ				; C_Base::GetX
PUBLIC	?GetY@C_Base@@QAEJXZ				; C_Base::GetY
PUBLIC	?GetW@C_Base@@QAEJXZ				; C_Base::GetW
PUBLIC	?GetH@C_Base@@QAEJXZ				; C_Base::GetH
PUBLIC	?ClearVW@C_ScrollBar@@QAEXXZ			; C_ScrollBar::ClearVW
PUBLIC	?ClearVH@C_ScrollBar@@QAEXXZ			; C_ScrollBar::ClearVH
PUBLIC	?SetVirtualW@C_ScrollBar@@QAEXJ@Z		; C_ScrollBar::SetVirtualW
PUBLIC	?SetVirtualH@C_ScrollBar@@QAEXJ@Z		; C_ScrollBar::SetVirtualH
PUBLIC	?FindControlInList@C_Window@@AAEPAUControlListStr@@PAVC_Base@@@Z ; C_Window::FindControlInList
PUBLIC	?GetScreenFormat@C_Window@@AAEXXZ		; C_Window::GetScreenFormat
PUBLIC	?SetCheckedUpdateRect@C_Window@@AAEJJJJJ@Z	; C_Window::SetCheckedUpdateRect
PUBLIC	?Fill@C_Window@@AAEXPAVSCREEN@@GPAUUI95_RECT@@@Z ; C_Window::Fill
PUBLIC	??0C_Window@@QAE@XZ				; C_Window::C_Window
PUBLIC	?GetCritical@C_Window@@QAEPAUF4CSECTIONHANDLE@@XZ ; C_Window::GetCritical
PUBLIC	?Setup@C_Window@@QAEXJFFF@Z			; C_Window::Setup
PUBLIC	?ResizeSurface@C_Window@@QAEXFF@Z		; C_Window::ResizeSurface
PUBLIC	?SetX@C_Window@@QAEXF@Z				; C_Window::SetX
PUBLIC	?SetY@C_Window@@QAEXF@Z				; C_Window::SetY
PUBLIC	?SetXY@C_Window@@QAEXFF@Z			; C_Window::SetXY
PUBLIC	?SetW@C_Window@@QAEXF@Z				; C_Window::SetW
PUBLIC	?SetH@C_Window@@QAEXF@Z				; C_Window::SetH
PUBLIC	?SetRanges@C_Window@@QAEXFFFFFF@Z		; C_Window::SetRanges
PUBLIC	?SetDepth@C_Window@@QAEXF@Z			; C_Window::SetDepth
PUBLIC	?SetDragH@C_Window@@QAEXF@Z			; C_Window::SetDragH
PUBLIC	?ScanClientArea@C_Window@@QAEXJ@Z		; C_Window::ScanClientArea
PUBLIC	?ScanClientAreas@C_Window@@QAEXXZ		; C_Window::ScanClientAreas
PUBLIC	?SetClientArea@C_Window@@QAEXJJJJF@Z		; C_Window::SetClientArea
PUBLIC	?SetVirtual@C_Window@@QAEXJJJJF@Z		; C_Window::SetVirtual
PUBLIC	?SetFlags@C_Window@@QAEXJ@Z			; C_Window::SetFlags
PUBLIC	?DeactivateControl@C_Window@@QAEXXZ		; C_Window::DeactivateControl
PUBLIC	?Activate@C_Window@@QAEXXZ			; C_Window::Activate
PUBLIC	?Deactivate@C_Window@@QAEXXZ			; C_Window::Deactivate
PUBLIC	?SetCursorID@C_Window@@QAEXJ@Z			; C_Window::SetCursorID
PUBLIC	?SetFlagBitOn@C_Window@@QAEXJ@Z			; C_Window::SetFlagBitOn
PUBLIC	?SetFlagBitOff@C_Window@@QAEXJ@Z		; C_Window::SetFlagBitOff
PUBLIC	?SetMenu@C_Window@@QAEXJ@Z			; C_Window::SetMenu
PUBLIC	?SetClientMenu@C_Window@@QAEXJJ@Z		; C_Window::SetClientMenu
PUBLIC	?SetClientFlags@C_Window@@QAEXJJ@Z		; C_Window::SetClientFlags
PUBLIC	?AdjustScrollbar@C_Window@@QAEXJ@Z		; C_Window::AdjustScrollbar
PUBLIC	?AddScrollBar@C_Window@@QAEXPAVC_ScrollBar@@@Z	; C_Window::AddScrollBar
PUBLIC	?AddControl@C_Window@@QAEXPAVC_Base@@@Z		; C_Window::AddControl
PUBLIC	?AddControlTop@C_Window@@QAEXPAVC_Base@@@Z	; C_Window::AddControlTop
PUBLIC	?RemoveControl@C_Window@@QAEXJ@Z		; C_Window::RemoveControl
PUBLIC	?RemoveControl@C_Window@@QAEPAUControlListStr@@PAU2@@Z ; C_Window::RemoveControl
PUBLIC	?RemoveAllControls@C_Window@@QAEXXZ		; C_Window::RemoveAllControls
PUBLIC	?SetFont@C_Window@@QAEHJ@Z			; C_Window::SetFont
PUBLIC	?CheckKeyboard@C_Window@@QAEHEEEJ@Z		; C_Window::CheckKeyboard
PUBLIC	?CheckHotKeys@C_Window@@QAEHEEEJ@Z		; C_Window::CheckHotKeys
PUBLIC	?SetControl@C_Window@@QAEXJ@Z			; C_Window::SetControl
PUBLIC	?SetPrevControl@C_Window@@QAEXXZ		; C_Window::SetPrevControl
PUBLIC	?SetNextControl@C_Window@@QAEXXZ		; C_Window::SetNextControl
PUBLIC	?Cleanup@C_Window@@QAEXXZ			; C_Window::Cleanup
PUBLIC	?SetDefaultFlags@C_Window@@QAEXXZ		; C_Window::SetDefaultFlags
PUBLIC	?AddUpdateRect@C_Window@@QAEXJJJJ@Z		; C_Window::AddUpdateRect
PUBLIC	?SetUpdateRect@C_Window@@QAEXJJJJJJ@Z		; C_Window::SetUpdateRect
PUBLIC	?ClearCheckedUpdateRect@C_Window@@QAEXJJJJ@Z	; C_Window::ClearCheckedUpdateRect
PUBLIC	?ClearUpdateRect@C_Window@@QAEXJJJJ@Z		; C_Window::ClearUpdateRect
PUBLIC	?SetGroup@C_Window@@QAEXJ@Z			; C_Window::SetGroup
PUBLIC	?GetX@C_Window@@QAEFXZ				; C_Window::GetX
PUBLIC	?GetY@C_Window@@QAEFXZ				; C_Window::GetY
PUBLIC	?GetW@C_Window@@QAEFXZ				; C_Window::GetW
PUBLIC	?GetH@C_Window@@QAEFXZ				; C_Window::GetH
PUBLIC	?GetPrimaryW@C_Window@@QAEFXZ			; C_Window::GetPrimaryW
PUBLIC	?Minimize@C_Window@@QAEXXZ			; C_Window::Minimize
PUBLIC	?Maximize@C_Window@@QAEXXZ			; C_Window::Maximize
PUBLIC	?ClipToArea@C_Window@@QAEHPAUUI95_RECT@@00@Z	; C_Window::ClipToArea
PUBLIC	?InsideClientWidth@C_Window@@QAEHJJJ@Z		; C_Window::InsideClientWidth
PUBLIC	?InsideClientHeight@C_Window@@QAEHJJJ@Z		; C_Window::InsideClientHeight
PUBLIC	?BelowClient@C_Window@@QAEHJJ@Z			; C_Window::BelowClient
PUBLIC	?EnableGroup@C_Window@@QAEXJ@Z			; C_Window::EnableGroup
PUBLIC	?DisableGroup@C_Window@@QAEXJ@Z			; C_Window::DisableGroup
PUBLIC	?UnHideGroup@C_Window@@QAEXJ@Z			; C_Window::UnHideGroup
PUBLIC	?HideGroup@C_Window@@QAEXJ@Z			; C_Window::HideGroup
PUBLIC	?EnableCluster@C_Window@@QAEXJ@Z		; C_Window::EnableCluster
PUBLIC	?DisableCluster@C_Window@@QAEXJ@Z		; C_Window::DisableCluster
PUBLIC	?UnHideCluster@C_Window@@QAEXJ@Z		; C_Window::UnHideCluster
PUBLIC	?HideCluster@C_Window@@QAEXJ@Z			; C_Window::HideCluster
PUBLIC	?SetGroupState@C_Window@@QAEXJF@Z		; C_Window::SetGroupState
PUBLIC	?RefreshWindow@C_Window@@QAEXXZ			; C_Window::RefreshWindow
PUBLIC	?RefreshClient@C_Window@@QAEXJ@Z		; C_Window::RefreshClient
PUBLIC	?DrawWindow@C_Window@@QAEXPAVSCREEN@@@Z		; C_Window::DrawWindow
PUBLIC	?UpdateTimerControls@C_Window@@QAEHXZ		; C_Window::UpdateTimerControls
PUBLIC	?DrawTimerControls@C_Window@@QAEXXZ		; C_Window::DrawTimerControls
PUBLIC	?Blend@C_Window@@QAEXPAGPAUUI95_RECT@@F01F01FFF@Z ; C_Window::Blend
PUBLIC	?BlendTransparent@C_Window@@QAEXGPAGPAUUI95_RECT@@F01F01FFF@Z ; C_Window::BlendTransparent
PUBLIC	?Translucency@C_Window@@QAEXPAGPAUUI95_RECT@@F01F@Z ; C_Window::Translucency
PUBLIC	?BlitTranslucent@C_Window@@QAEXPAVSCREEN@@KJPAUUI95_RECT@@JJ@Z ; C_Window::BlitTranslucent
PUBLIC	?CustomBlitTranslucent@C_Window@@QAEXPAVSCREEN@@KJPAUUI95_RECT@@JJ@Z ; C_Window::CustomBlitTranslucent
PUBLIC	?DitherFill@C_Window@@QAEXPAVSCREEN@@KJFPADPAUUI95_RECT@@JJ@Z ; C_Window::DitherFill
PUBLIC	?GradientFill@C_Window@@QAEXPAVSCREEN@@KJPAUUI95_RECT@@JJ@Z ; C_Window::GradientFill
PUBLIC	?BlitFill@C_Window@@QAEXPAVSCREEN@@KPAUUI95_RECT@@JJ@Z ; C_Window::BlitFill
PUBLIC	?BlitFill@C_Window@@QAEXPAVSCREEN@@KJJJJJJPAUUI95_RECT@@@Z ; C_Window::BlitFill
PUBLIC	?DrawHLine@C_Window@@QAEXPAVSCREEN@@KJJJJJPAUUI95_RECT@@@Z ; C_Window::DrawHLine
PUBLIC	?DrawVLine@C_Window@@QAEXPAVSCREEN@@KJJJJJPAUUI95_RECT@@@Z ; C_Window::DrawVLine
PUBLIC	?CheckLine@C_Window@@QAEHJJJJJJJJ@Z		; C_Window::CheckLine
PUBLIC	?DrawLine@C_Window@@QAEXPAVSCREEN@@KJJJJJJPAUUI95_RECT@@@Z ; C_Window::DrawLine
PUBLIC	?ClipLine@C_Window@@QAEHPAJ000PAUUI95_RECT@@@Z	; C_Window::ClipLine
PUBLIC	?DrawClipLine@C_Window@@QAEXPAVSCREEN@@JJJJPAUUI95_RECT@@G@Z ; C_Window::DrawClipLine
PUBLIC	?DrawCircle@C_Window@@QAEXPAVSCREEN@@KJJMJJPAUUI95_RECT@@@Z ; C_Window::DrawCircle
PUBLIC	?DrawArc@C_Window@@QAEXPAVSCREEN@@KJJMFJJPAUUI95_RECT@@@Z ; C_Window::DrawArc
PUBLIC	?ClearWindow@C_Window@@QAEXPAVSCREEN@@J@Z	; C_Window::ClearWindow
PUBLIC	?ClearArea@C_Window@@QAEXPAVSCREEN@@JJJJJJ@Z	; C_Window::ClearArea
PUBLIC	?KeyboardMode@C_Window@@QAEHXZ			; C_Window::KeyboardMode
PUBLIC	?RemovingControl@C_Window@@QAEXPAVC_Base@@@Z	; C_Window::RemovingControl
PUBLIC	?FindControl@C_Window@@QAEPAVC_Base@@J@Z	; C_Window::FindControl
PUBLIC	?GetControl@C_Window@@QAEPAVC_Base@@PAJJJ@Z	; C_Window::GetControl
PUBLIC	?MouseOver@C_Window@@QAEPAVC_Base@@JJPAV2@@Z	; C_Window::MouseOver
PUBLIC	?Drag@C_Window@@QAEHPAUGRABBER@@GGPAV1@@Z	; C_Window::Drag
PUBLIC	?Drop@C_Window@@QAEHPAUGRABBER@@GGPAV1@@Z	; C_Window::Drop
PUBLIC	?ConstraintsCorrection@C_Window@@QAEXJJ@Z	; C_Window::ConstraintsCorrection
PUBLIC	?LocalFind@C_Window@@QAEFPAD@Z			; C_Window::LocalFind
PUBLIC	?LocalFunction@C_Window@@QAEXFQAJPADPAVC_Handler@@@Z ; C_Window::LocalFunction
PUBLIC	?SaveTextControls@C_Window@@QAEXPAXPAVC_Parser@@@Z ; C_Window::SaveTextControls
PUBLIC	?SetKeyboardMode@C_Handler@@QAEXH@Z		; C_Handler::SetKeyboardMode
PUBLIC	?KeyboardMode@C_Handler@@QAEHXZ			; C_Handler::KeyboardMode
PUBLIC	?GetW@C_Handler@@QAEJXZ				; C_Handler::GetW
PUBLIC	?GetH@C_Handler@@QAEJXZ				; C_Handler::GetH
PUBLIC	?GetFront@C_Handler@@QAEPAVImageBuffer@@XZ	; C_Handler::GetFront
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strlen:PROC
EXTRN	_memmove:PROC
EXTRN	_strnicmp:PROC
EXTRN	__imp__WriteFile@20:PROC
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp__SysFreeString@4:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	??_Eerror_category@std@@UAEPAXI@Z:PROC		; std::error_category::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAPBDH@Z:PROC		; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	_F4EnterCriticalSection:PROC
EXTRN	_F4LeaveCriticalSection:PROC
EXTRN	?UI95_GetScreenColorInfo@@YAXAAKAAG0101@Z:PROC	; UI95_GetScreenColorInfo
EXTRN	?UI95_RGB24Bit@@YAGK@Z:PROC			; UI95_RGB24Bit
EXTRN	?F4IsBadReadPtr@@YA_NPBXI@Z:PROC		; F4IsBadReadPtr
EXTRN	??0C_Hash@@QAE@XZ:PROC				; C_Hash::C_Hash
EXTRN	??1C_Hash@@QAE@XZ:PROC				; C_Hash::~C_Hash
EXTRN	?Setup@C_Hash@@QAEXJ@Z:PROC			; C_Hash::Setup
EXTRN	?Cleanup@C_Hash@@QAEXXZ:PROC			; C_Hash::Cleanup
EXTRN	?Find@C_Hash@@QAEPAXJ@Z:PROC			; C_Hash::Find
EXTRN	?Add@C_Hash@@QAEXJPAX@Z:PROC			; C_Hash::Add
EXTRN	?Remove@C_Hash@@QAEXJ@Z:PROC			; C_Hash::Remove
EXTRN	?CalcRanges@C_ScrollBar@@AAEXXZ:PROC		; C_ScrollBar::CalcRanges
EXTRN	?UpdatePosition@C_ScrollBar@@QAEXXZ:PROC	; C_ScrollBar::UpdatePosition
EXTRN	?SetBehindWindow@C_Handler@@QAEXPAVC_Window@@@Z:PROC ; C_Handler::SetBehindWindow
EXTRN	?RemovingControl@C_Handler@@QAEXPAVC_Base@@@Z:PROC ; C_Handler::RemovingControl
EXTRN	?RGB565toRGB8@@YAKG@Z:PROC			; RGB565toRGB8
EXTRN	?RGB8toRGB565@@YAGK@Z:PROC			; RGB8toRGB565
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?gMainHandler@@3PAVC_Handler@@A:DWORD		; gMainHandler
EXTRN	?UIColorTable@@3PAY0BAA@GA:BYTE			; UIColorTable
EXTRN	?rShift@@3PAGA:BYTE				; rShift
EXTRN	?bShift@@3PAGA:BYTE				; bShift
EXTRN	?gShift@@3PAGA:BYTE				; gShift
EXTRN	?ParseCRLF@@3PADA:BYTE				; ParseCRLF
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
_allocator_arg DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_BSS	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Generic_object
_BSS	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_BSS	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_Iostream_object
_BSS	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_BSS	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DD 01H DUP (?) ; std::_Error_objects<int>::_System_object
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD FLAT:??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 00H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category@std@@@8
	DD	FLAT:??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
_DATA	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 00H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVerror_category@std@@@8
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DD FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DD	FLAT:??_E_Iostream_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DD FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DD	FLAT:??_Eerror_category@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
__ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?Setup@C_Window@@QAEXJFFF@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Setup@C_Window@@QAEXJFFF@Z$0
__ehfuncinfo$?Setup@C_Window@@QAEXJFFF@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Setup@C_Window@@QAEXJFFF@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA DD FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA DD FLAT:??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@D@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<char>::id$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?id$initializer$@?$numpunct@_W@std@@2P6AXXZA DD FLAT:??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; std::numpunct<wchar_t>::id$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 621  : 		void destroy(_Uty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<wchar_t>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@_W@std@@2V0locale@2@A ; std::numpunct<wchar_t>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<wchar_t>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$yc	SEGMENT
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id'', COMDAT

; 155  : 		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	pop	ebp
	ret	0
??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

	push	ebp
	mov	ebp, esp

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>

; 758  : 		}

	pop	ebp
	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??1_System_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
	call	??0_System_error_category@std@@QAE@XZ	; std::_System_error_category::_System_error_category
	push	OFFSET ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??1_Iostream_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
	call	??0_Iostream_error_category@std@@QAE@XZ	; std::_Iostream_error_category::_Iostream_error_category
	push	OFFSET ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??1_Generic_error_category@std@@UAE@XZ
	pop	ebp
	ret	0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	push	OFFSET ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], -1
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 907  : 		void destroy(_Ty *_Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
	add	esp, 8

; 910  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAD@std@@YAAAPADAAPAD@Z	; std::forward<char * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\chandler.h
;	COMDAT ?GetFront@C_Handler@@QAEPAVImageBuffer@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFront@C_Handler@@QAEPAVImageBuffer@@XZ PROC		; C_Handler::GetFront, COMDAT
; _this$ = ecx

; 242  : 		ImageBuffer *GetFront() { return(Front_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFront@C_Handler@@QAEPAVImageBuffer@@XZ ENDP		; C_Handler::GetFront
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\chandler.h
;	COMDAT ?GetH@C_Handler@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetH@C_Handler@@QAEJXZ PROC				; C_Handler::GetH, COMDAT
; _this$ = ecx

; 214  : 		long  GetH() { return(FrontRect_.bottom-FrontRect_.top);}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+48]
	sub	eax, DWORD PTR [ecx+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetH@C_Handler@@QAEJXZ ENDP				; C_Handler::GetH
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\chandler.h
;	COMDAT ?GetW@C_Handler@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetW@C_Handler@@QAEJXZ PROC				; C_Handler::GetW, COMDAT
; _this$ = ecx

; 213  : 		long  GetW() { return(FrontRect_.right-FrontRect_.left);}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+44]
	sub	eax, DWORD PTR [ecx+36]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetW@C_Handler@@QAEJXZ ENDP				; C_Handler::GetW
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\chandler.h
;	COMDAT ?KeyboardMode@C_Handler@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?KeyboardMode@C_Handler@@QAEHXZ PROC			; C_Handler::KeyboardMode, COMDAT
; _this$ = ecx

; 192  : 		BOOL KeyboardMode() { return(KeyboardMode_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+116]
	mov	esp, ebp
	pop	ebp
	ret	0
?KeyboardMode@C_Handler@@QAEHXZ ENDP			; C_Handler::KeyboardMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\chandler.h
;	COMDAT ?SetKeyboardMode@C_Handler@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_mode$ = 8						; size = 4
?SetKeyboardMode@C_Handler@@QAEXH@Z PROC		; C_Handler::SetKeyboardMode, COMDAT
; _this$ = ecx

; 191  : 		void SetKeyboardMode(BOOL mode) { KeyboardMode_=mode; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _mode$[ebp]
	mov	DWORD PTR [eax+116], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetKeyboardMode@C_Handler@@QAEXH@Z ENDP		; C_Handler::SetKeyboardMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_bw$ = -12						; size = 4
_this$ = -8						; size = 4
_cntrl$ = -4						; size = 4
_ofp$ = 8						; size = 4
_Parser$ = 12						; size = 4
?SaveTextControls@C_Window@@QAEXPAXPAVC_Parser@@@Z PROC	; C_Window::SaveTextControls
; _this$ = ecx

; 2738 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2739 : 	CONTROLLIST *cntrl;
; 2740 : 	DWORD bw;
; 2741 : 
; 2742 : 	cntrl=Controls_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4304]
	mov	DWORD PTR _cntrl$[ebp], ecx
$LN2@SaveTextCo:

; 2743 : 	while(cntrl)

	cmp	DWORD PTR _cntrl$[ebp], 0
	je	SHORT $LN3@SaveTextCo

; 2744 : 	{
; 2745 : 		cntrl->Control_->SaveText(ofp,Parser);

	mov	edx, DWORD PTR _Parser$[ebp]
	push	edx
	mov	eax, DWORD PTR _ofp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cntrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _cntrl$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+244]
	call	eax

; 2746 : 		WriteFile(ofp,ParseCRLF,strlen(ParseCRLF),&bw,NULL);

	push	0
	lea	ecx, DWORD PTR _bw$[ebp]
	push	ecx
	push	OFFSET ?ParseCRLF@@3PADA		; ParseCRLF
	call	_strlen
	add	esp, 4
	push	eax
	push	OFFSET ?ParseCRLF@@3PADA		; ParseCRLF
	mov	edx, DWORD PTR _ofp$[ebp]
	push	edx
	call	DWORD PTR __imp__WriteFile@20

; 2747 : 		cntrl=cntrl->Next;

	mov	eax, DWORD PTR _cntrl$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _cntrl$[ebp], ecx

; 2748 : 	}

	jmp	SHORT $LN2@SaveTextCo
$LN3@SaveTextCo:

; 2749 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SaveTextControls@C_Window@@QAEXPAXPAVC_Parser@@@Z ENDP	; C_Window::SaveTextControls
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
tv65 = -8						; size = 4
_this$ = -4						; size = 4
_ID$ = 8						; size = 2
_P$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
?LocalFunction@C_Window@@QAEXFQAJPADPAVC_Handler@@@Z PROC ; C_Window::LocalFunction
; _this$ = ecx

; 2674 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2675 : 	switch(ID)

	movsx	eax, WORD PTR _ID$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	mov	ecx, DWORD PTR tv65[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 17			; 00000011H
	ja	$LN21@LocalFunct
	mov	edx, DWORD PTR tv65[ebp]
	jmp	DWORD PTR $LN23@LocalFunct[edx*4]
$LN18@LocalFunct:

; 2676 : 	{
; 2677 : 		case CWIN_SETUP:
; 2678 : 			Setup(P[0],(short)P[1],(short)P[2],(short)P[3]);

	mov	eax, 4
	imul	eax, 3
	mov	ecx, DWORD PTR _P$[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	push	edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _P$[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	push	edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _P$[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	push	edx
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _P$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Setup@C_Window@@QAEXJFFF@Z		; C_Window::Setup

; 2679 : 			break;

	jmp	$LN21@LocalFunct
$LN17@LocalFunct:

; 2680 : 		case CWIN_SETX:
; 2681 : 			SetX((short)P[0]);

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _P$[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetX@C_Window@@QAEXF@Z			; C_Window::SetX

; 2682 : 			break;

	jmp	$LN21@LocalFunct
$LN16@LocalFunct:

; 2683 : 		case CWIN_SETY:
; 2684 : 			SetY((short)P[0]);

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _P$[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetY@C_Window@@QAEXF@Z			; C_Window::SetY

; 2685 : 			break;

	jmp	$LN21@LocalFunct
$LN15@LocalFunct:

; 2686 : 		case CWIN_SETXY:
; 2687 : 			SetXY((short)P[0],(short)P[1]);

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _P$[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	push	edx
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _P$[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetXY@C_Window@@QAEXFF@Z		; C_Window::SetXY

; 2688 : 			break;

	jmp	$LN21@LocalFunct
$LN14@LocalFunct:

; 2689 : 		case CWIN_SETW:
; 2690 : 			SetW((short)P[0]);

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _P$[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetW@C_Window@@QAEXF@Z			; C_Window::SetW

; 2691 : 			break;

	jmp	$LN21@LocalFunct
$LN13@LocalFunct:

; 2692 : 		case CWIN_SETH:
; 2693 : 			SetH((short)P[0]);

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _P$[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetH@C_Window@@QAEXF@Z			; C_Window::SetH

; 2694 : 			break;

	jmp	$LN21@LocalFunct
$LN12@LocalFunct:

; 2695 : 		case CWIN_SETRANGES:
; 2696 : 			SetRanges((short)P[0],(short)P[1],(short)P[2],(short)P[3],(short)P[4],(short)P[5]);

	mov	eax, 4
	imul	eax, 5
	mov	ecx, DWORD PTR _P$[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	push	edx
	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _P$[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	push	edx
	mov	eax, 4
	imul	eax, 3
	mov	ecx, DWORD PTR _P$[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	push	edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _P$[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	push	edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _P$[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	push	edx
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _P$[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetRanges@C_Window@@QAEXFFFFFF@Z	; C_Window::SetRanges

; 2697 : 			break;

	jmp	$LN21@LocalFunct
$LN11@LocalFunct:

; 2698 : 		case CWIN_SETFONT:
; 2699 : 			SetFont(P[0]);

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _P$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFont@C_Window@@QAEHJ@Z		; C_Window::SetFont

; 2700 : 			break;

	jmp	$LN21@LocalFunct
$LN10@LocalFunct:

; 2701 : 		case CWIN_SETGROUP:
; 2702 : 			SetGroup(P[0]);

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _P$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetGroup@C_Window@@QAEXJ@Z		; C_Window::SetGroup

; 2703 : 			break;

	jmp	$LN21@LocalFunct
$LN9@LocalFunct:

; 2704 : 		case CWIN_SETCLIENTAREA:
; 2705 : 			SetClientArea((short)P[0],(short)P[1],(short)P[2],(short)P[3],(short)P[4]);

	mov	eax, 4
	shl	eax, 2
	mov	ecx, DWORD PTR _P$[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	push	edx
	mov	eax, 4
	imul	eax, 3
	mov	ecx, DWORD PTR _P$[ebp]
	movsx	edx, WORD PTR [ecx+eax]
	push	edx
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _P$[ebp]
	movsx	edx, WORD PTR [ecx+eax]
	push	edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _P$[ebp]
	movsx	edx, WORD PTR [ecx+eax]
	push	edx
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _P$[ebp]
	movsx	edx, WORD PTR [ecx+eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetClientArea@C_Window@@QAEXJJJJF@Z	; C_Window::SetClientArea

; 2706 : 			break;

	jmp	$LN21@LocalFunct
$LN8@LocalFunct:

; 2707 : 		case CWIN_SETFLAGBITON:
; 2708 : 			SetFlagBitOn(P[0]);

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _P$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlagBitOn@C_Window@@QAEXJ@Z		; C_Window::SetFlagBitOn

; 2709 : 			break;

	jmp	$LN21@LocalFunct
$LN7@LocalFunct:

; 2710 : 		case CWIN_SETFLAGBITOFF:
; 2711 : 			SetFlagBitOff(P[0]);

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _P$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlagBitOff@C_Window@@QAEXJ@Z	; C_Window::SetFlagBitOff

; 2712 : 			break;

	jmp	$LN21@LocalFunct
$LN6@LocalFunct:

; 2713 : 		case CWIN_SETDEPTH:
; 2714 : 			SetDepth((short)P[0]);

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _P$[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDepth@C_Window@@QAEXF@Z		; C_Window::SetDepth

; 2715 : 			break;

	jmp	$LN21@LocalFunct
$LN5@LocalFunct:

; 2716 : 		case CWIN_SETMENUID:
; 2717 : 			SetMenu(P[0]);

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _P$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMenu@C_Window@@QAEXJ@Z		; C_Window::SetMenu

; 2718 : 			break;

	jmp	$LN21@LocalFunct
$LN4@LocalFunct:

; 2719 : 		case CWIN_SETCLIENTMENUID:
; 2720 : 			SetClientMenu(P[0],P[1]);

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _P$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _P$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetClientMenu@C_Window@@QAEXJJ@Z	; C_Window::SetClientMenu

; 2721 : 			break;

	jmp	SHORT $LN21@LocalFunct
$LN3@LocalFunct:

; 2722 : 		case CWIN_SETCURSOR:
; 2723 : 			SetCursorID(P[0]);

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _P$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCursorID@C_Window@@QAEXJ@Z		; C_Window::SetCursorID

; 2724 : 			break;

	jmp	SHORT $LN21@LocalFunct
$LN2@LocalFunct:

; 2725 : 		case CWIN_SETDRAGH:
; 2726 : 			SetDragH((short)P[0]);

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _P$[ebp]
	movzx	edx, WORD PTR [ecx+eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDragH@C_Window@@QAEXF@Z		; C_Window::SetDragH

; 2727 : 			break;

	jmp	SHORT $LN21@LocalFunct
$LN1@LocalFunct:

; 2728 : 		case CWIN_SETCLIENTFLAGS:
; 2729 : 			SetClientFlags(P[0],P[1]);

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _P$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _P$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetClientFlags@C_Window@@QAEXJJ@Z	; C_Window::SetClientFlags
$LN21@LocalFunct:

; 2730 : 			break;
; 2731 : 	}
; 2732 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	npad	3
$LN23@LocalFunct:
	DD	$LN18@LocalFunct
	DD	$LN17@LocalFunct
	DD	$LN16@LocalFunct
	DD	$LN15@LocalFunct
	DD	$LN14@LocalFunct
	DD	$LN13@LocalFunct
	DD	$LN12@LocalFunct
	DD	$LN9@LocalFunct
	DD	$LN11@LocalFunct
	DD	$LN10@LocalFunct
	DD	$LN8@LocalFunct
	DD	$LN7@LocalFunct
	DD	$LN6@LocalFunct
	DD	$LN5@LocalFunct
	DD	$LN4@LocalFunct
	DD	$LN3@LocalFunct
	DD	$LN2@LocalFunct
	DD	$LN1@LocalFunct
?LocalFunction@C_Window@@QAEXFQAJPADPAVC_Handler@@@Z ENDP ; C_Window::LocalFunction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = -4						; size = 2
_token$ = 8						; size = 4
?LocalFind@C_Window@@QAEFPAD@Z PROC			; C_Window::LocalFind
; _this$ = ecx

; 2661 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2662 : 	short i=0;

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
$LN3@LocalFind:

; 2663 : 
; 2664 : 	while(C_Win_Tokens[i])

	movsx	ecx, WORD PTR _i$[ebp]
	cmp	DWORD PTR ?C_Win_Tokens@@3PAPADA[ecx*4], 0
	je	SHORT $LN2@LocalFind

; 2665 : 	{
; 2666 : 		if(strnicmp(token,C_Win_Tokens[i],strlen(C_Win_Tokens[i])) == 0)

	movsx	edx, WORD PTR _i$[ebp]
	mov	eax, DWORD PTR ?C_Win_Tokens@@3PAPADA[edx*4]
	push	eax
	call	_strlen
	add	esp, 4
	push	eax
	movsx	ecx, WORD PTR _i$[ebp]
	mov	edx, DWORD PTR ?C_Win_Tokens@@3PAPADA[ecx*4]
	push	edx
	mov	eax, DWORD PTR _token$[ebp]
	push	eax
	call	_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@LocalFind

; 2667 : 			return(i);

	mov	ax, WORD PTR _i$[ebp]
	jmp	SHORT $LN4@LocalFind
$LN1@LocalFind:

; 2668 : 		i++;

	mov	cx, WORD PTR _i$[ebp]
	add	cx, 1
	mov	WORD PTR _i$[ebp], cx

; 2669 : 	}

	jmp	SHORT $LN3@LocalFind
$LN2@LocalFind:

; 2670 : 	return(0);

	xor	eax, eax
$LN4@LocalFind:

; 2671 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?LocalFind@C_Window@@QAEFPAD@Z ENDP			; C_Window::LocalFind
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_w$ = 8							; size = 4
_h$ = 12						; size = 4
?ConstraintsCorrection@C_Window@@QAEXJJ@Z PROC		; C_Window::ConstraintsCorrection
; _this$ = ecx

; 2649 : void C_Window::ConstraintsCorrection(long w, long h){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2650 : 	// clip window dimensions to screen
; 2651 : 	if (this->x_ + this->Area_.right >= w){

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+428]
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+120]
	cmp	ecx, DWORD PTR _w$[ebp]
	jl	SHORT $LN2@Constraint

; 2652 : 		this->Area_.right -= ((this->x_ + this->Area_.right) - w + 1);

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+428]
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+120]
	sub	ecx, DWORD PTR _w$[ebp]
	add	ecx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+120]
	sub	edx, ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+120], edx
$LN2@Constraint:

; 2653 : 	}
; 2654 : 	if (this->y_ + this->Area_.bottom >= h){

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+430]
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+124]
	cmp	edx, DWORD PTR _h$[ebp]
	jl	SHORT $LN3@Constraint

; 2655 : 		this->Area_.bottom -= ((this->y_ + this->Area_.bottom) - h + 1);

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+430]
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+124]
	sub	edx, DWORD PTR _h$[ebp]
	add	edx, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+124]
	sub	eax, edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+124], eax
$LN3@Constraint:

; 2656 : 	}
; 2657 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ConstraintsCorrection@C_Window@@QAEXJJ@Z ENDP		; C_Window::ConstraintsCorrection
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 2
___formal$ = 16						; size = 2
___formal$ = 20						; size = 4
?Drop@C_Window@@QAEHPAUGRABBER@@GGPAV1@@Z PROC		; C_Window::Drop
; _this$ = ecx

; 2644 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2645 : 	return(FALSE);

	xor	eax, eax

; 2646 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Drop@C_Window@@QAEHPAUGRABBER@@GGPAV1@@Z ENDP		; C_Window::Drop
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_Leave$ = -16						; size = 4
_x$ = -12						; size = 4
_y$ = -8						; size = 4
_this$ = -4						; size = 4
_Drag$ = 8						; size = 4
_MouseX$ = 12						; size = 2
_MouseY$ = 16						; size = 2
___formal$ = 20						; size = 4
?Drag@C_Window@@QAEHPAUGRABBER@@GGPAV1@@Z PROC		; C_Window::Drag
; _this$ = ecx

; 2620 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2621 : 	long x,y;
; 2622 : 	F4CSECTIONHANDLE* Leave;
; 2623 : 
; 2624 : 	x=Drag->ItemX_ + (MouseX - Drag->StartX_);

	movzx	eax, WORD PTR _MouseX$[ebp]
	mov	ecx, DWORD PTR _Drag$[ebp]
	sub	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _Drag$[ebp]
	add	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _x$[ebp], eax

; 2625 : 	y=Drag->ItemY_ + (MouseY - Drag->StartY_);

	movzx	eax, WORD PTR _MouseY$[ebp]
	mov	ecx, DWORD PTR _Drag$[ebp]
	sub	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _Drag$[ebp]
	add	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _y$[ebp], eax

; 2626 : 
; 2627 : 	if(x < MinX_) x=MinX_;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+436]
	cmp	DWORD PTR _x$[ebp], ecx
	jge	SHORT $LN5@Drag
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+436]
	mov	DWORD PTR _x$[ebp], eax
$LN5@Drag:

; 2628 : 	if((x+GetW()) > MaxX_) x=MaxX_-GetW();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetW@C_Window@@QAEFXZ			; C_Window::GetW
	movsx	ecx, ax
	add	ecx, DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+440]
	cmp	ecx, eax
	jle	SHORT $LN4@Drag
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	esi, WORD PTR [ecx+440]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetW@C_Window@@QAEFXZ			; C_Window::GetW
	movsx	edx, ax
	sub	esi, edx
	mov	DWORD PTR _x$[ebp], esi
$LN4@Drag:

; 2629 : 	if(y < MinY_) y=MinY_;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+438]
	cmp	DWORD PTR _y$[ebp], ecx
	jge	SHORT $LN3@Drag
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+438]
	mov	DWORD PTR _y$[ebp], eax
$LN3@Drag:

; 2630 : 	if((y+GetH()) > MaxY_) y=MaxY_-GetH();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetH@C_Window@@QAEFXZ			; C_Window::GetH
	movsx	ecx, ax
	add	ecx, DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+442]
	cmp	ecx, eax
	jle	SHORT $LN2@Drag
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	esi, WORD PTR [ecx+442]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetH@C_Window@@QAEFXZ			; C_Window::GetH
	movsx	edx, ax
	sub	esi, edx
	mov	DWORD PTR _y$[ebp], esi
$LN2@Drag:

; 2631 : 
; 2632 : 	Leave=UI_Enter(this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 2633 : 	Handler_->SetBehindWindow(this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4328]
	call	?SetBehindWindow@C_Handler@@QAEXPAVC_Window@@@Z ; C_Handler::SetBehindWindow

; 2634 : 	SetXY((short)x,(short)y);

	movzx	eax, WORD PTR _y$[ebp]
	push	eax
	movzx	ecx, WORD PTR _x$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetXY@C_Window@@QAEXFF@Z		; C_Window::SetXY

; 2635 : 	if(DragCallback_)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4316], 0
	je	SHORT $LN1@Drag

; 2636 : 		(*DragCallback_)(this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4316]
	call	edx
	add	esp, 4
$LN1@Drag:

; 2637 : 	RefreshWindow();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RefreshWindow@C_Window@@QAEXXZ		; C_Window::RefreshWindow

; 2638 : 	UI_Leave(Leave);

	mov	eax, DWORD PTR _Leave$[ebp]
	push	eax
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4

; 2639 : 	return(TRUE);

	mov	eax, 1

; 2640 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Drag@C_Window@@QAEHPAUGRABBER@@GGPAV1@@Z ENDP		; C_Window::Drag
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_Found_$ = -12						; size = 4
_this$ = -8						; size = 4
_cur$ = -4						; size = 4
_relx$ = 8						; size = 4
_rely$ = 12						; size = 4
_lastover$ = 16						; size = 4
?MouseOver@C_Window@@QAEPAVC_Base@@JJPAV2@@Z PROC	; C_Window::MouseOver
; _this$ = ecx

; 1334 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1335 : 	CONTROLLIST *cur;
; 1336 : 	C_Base *Found_=NULL;

	mov	DWORD PTR _Found_$[ebp], 0

; 1337 : 
; 1338 : 	cur = Controls_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4304]
	mov	DWORD PTR _cur$[ebp], ecx
$LN7@MouseOver:

; 1339 : 	while (cur){

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN6@MouseOver

; 1340 : 		if (cur->Control_->GetFlags() & C_BIT_ABSOLUTE){

	mov	edx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetFlags@C_Base@@QAEJXZ		; C_Base::GetFlags
	and	eax, 262144				; 00040000H
	je	SHORT $LN5@MouseOver

; 1341 : 			if (cur->Control_->MouseOver(relx,rely,lastover)){

	mov	eax, DWORD PTR _lastover$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rely$[ebp]
	push	ecx
	mov	edx, DWORD PTR _relx$[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+208]
	call	edx
	test	eax, eax
	je	SHORT $LN4@MouseOver

; 1342 : 				// 99% of the time this will return cur->Control_ except 
; 1343 : 				// in the case of piggyback controls (like trees)
; 1344 : 				Found_= cur->Control_->GetMe();

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+212]
	call	edx
	mov	DWORD PTR _Found_$[ebp], eax
$LN4@MouseOver:

; 1345 : 			}
; 1346 : 		}
; 1347 : 		else if (

	jmp	$LN3@MouseOver
$LN5@MouseOver:

; 1348 : 			relx >= ClientArea_[cur->Control_->GetClient()].left && 
; 1349 : 			relx <= ClientArea_[cur->Control_->GetClient()].right && 
; 1350 : 			rely >= ClientArea_[cur->Control_->GetClient()].top && 
; 1351 : 			rely <= ClientArea_[cur->Control_->GetClient()].bottom
; 1352 : 		){

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	movsx	ecx, ax
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _relx$[ebp]
	cmp	eax, DWORD PTR [edx+ecx+168]
	jl	$LN3@MouseOver
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	movsx	edx, ax
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _relx$[ebp]
	cmp	ecx, DWORD PTR [eax+edx+176]
	jg	$LN3@MouseOver
	mov	edx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	cwde
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _rely$[ebp]
	cmp	edx, DWORD PTR [ecx+eax+172]
	jl	$LN3@MouseOver
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	movsx	ecx, ax
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _rely$[ebp]
	cmp	eax, DWORD PTR [edx+ecx+180]
	jg	SHORT $LN3@MouseOver

; 1353 : 			if (
; 1354 : 				cur->Control_->MouseOver(
; 1355 : 					relx-VX_[cur->Control_->GetClient()], rely-VY_[cur->Control_->GetClient()], lastover
; 1356 : 				)
; 1357 : 			){

	mov	ecx, DWORD PTR _lastover$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	cwde
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _rely$[ebp]
	sub	edx, DWORD PTR [ecx+eax*4+512]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	movsx	ecx, ax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _relx$[ebp]
	sub	eax, DWORD PTR [edx+ecx*4+480]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+208]
	call	eax
	test	eax, eax
	je	SHORT $LN3@MouseOver

; 1358 : 				Found_ = cur->Control_->GetMe();

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+212]
	call	eax
	mov	DWORD PTR _Found_$[ebp], eax
$LN3@MouseOver:

; 1359 : 			}
; 1360 : 		}
; 1361 : 		cur=cur->Next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _cur$[ebp], edx

; 1362 : 	}

	jmp	$LN7@MouseOver
$LN6@MouseOver:

; 1363 : 	return (Found_);

	mov	eax, DWORD PTR _Found_$[ebp]

; 1364 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?MouseOver@C_Window@@QAEPAVC_Base@@JJPAV2@@Z ENDP	; C_Window::MouseOver
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_last$ = -20						; size = 4
_lastID$ = -16						; size = 4
_thisID$ = -12						; size = 4
_this$ = -8						; size = 4
_cur$1 = -4						; size = 4
_ID$ = 8						; size = 4
_relX$ = 12						; size = 4
_relY$ = 16						; size = 4
?GetControl@C_Window@@QAEPAVC_Base@@PAJJJ@Z PROC	; C_Window::GetControl
; _this$ = ecx

; 1265 : C_Base *C_Window::GetControl(long *ID,long relX,long relY){

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 1266 : 	C_Base *last=NULL;

	mov	DWORD PTR _last$[ebp], 0

; 1267 : 	long thisID,lastID=0;

	mov	DWORD PTR _lastID$[ebp], 0

; 1268 : 
; 1269 : 	// run all controls in window
; 1270 : 	for(CONTROLLIST *cur=Controls_;cur!=NULL;cur=cur->Next){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4304]
	mov	DWORD PTR _cur$1[ebp], ecx
	jmp	SHORT $LN10@GetControl
$LN9@GetControl:
	mov	edx, DWORD PTR _cur$1[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _cur$1[ebp], eax
$LN10@GetControl:
	cmp	DWORD PTR _cur$1[ebp], 0
	je	$LN8@GetControl

; 1271 : 		if(cur->Control_->IsControl()){

	mov	ecx, DWORD PTR _cur$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _cur$1[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+156]
	call	eax
	test	eax, eax
	je	$LN7@GetControl

; 1272 : 			if(cur->Control_->GetFlags() & C_BIT_ABSOLUTE){

	mov	ecx, DWORD PTR _cur$1[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetFlags@C_Base@@QAEJXZ		; C_Base::GetFlags
	and	eax, 262144				; 00040000H
	je	SHORT $LN6@GetControl

; 1273 : 				thisID=cur->Control_->CheckHotSpots(relX,relY);

	mov	edx, DWORD PTR _relY$[ebp]
	push	edx
	mov	eax, DWORD PTR _relX$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _cur$1[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+192]
	call	eax
	mov	DWORD PTR _thisID$[ebp], eax

; 1274 : 				if(thisID){

	cmp	DWORD PTR _thisID$[ebp], 0
	je	SHORT $LN5@GetControl

; 1275 : 					lastID=thisID;

	mov	ecx, DWORD PTR _thisID$[ebp]
	mov	DWORD PTR _lastID$[ebp], ecx

; 1276 : 					last=cur->Control_;

	mov	edx, DWORD PTR _cur$1[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _last$[ebp], eax
$LN5@GetControl:

; 1277 : 				}
; 1278 : 			}
; 1279 : 			else{

	jmp	$LN7@GetControl
$LN6@GetControl:

; 1280 : 				if(relX >= ClientArea_[cur->Control_->GetClient()].left && relX <= ClientArea_[cur->Control_->GetClient()].right && relY >= ClientArea_[cur->Control_->GetClient()].top && relY <= ClientArea_[cur->Control_->GetClient()].bottom){

	mov	ecx, DWORD PTR _cur$1[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	movsx	edx, ax
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _relX$[ebp]
	cmp	ecx, DWORD PTR [eax+edx+168]
	jl	$LN7@GetControl
	mov	edx, DWORD PTR _cur$1[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	cwde
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _relX$[ebp]
	cmp	edx, DWORD PTR [ecx+eax+176]
	jg	$LN7@GetControl
	mov	eax, DWORD PTR _cur$1[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	movsx	ecx, ax
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _relY$[ebp]
	cmp	eax, DWORD PTR [edx+ecx+172]
	jl	SHORT $LN7@GetControl
	mov	ecx, DWORD PTR _cur$1[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	movsx	edx, ax
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _relY$[ebp]
	cmp	ecx, DWORD PTR [eax+edx+180]
	jg	SHORT $LN7@GetControl

; 1281 : 					thisID=cur->Control_->CheckHotSpots(relX-VX_[cur->Control_->GetClient()],relY-VY_[cur->Control_->GetClient()]);

	mov	edx, DWORD PTR _cur$1[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	cwde
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _relY$[ebp]
	sub	edx, DWORD PTR [ecx+eax*4+512]
	push	edx
	mov	eax, DWORD PTR _cur$1[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	movsx	ecx, ax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _relX$[ebp]
	sub	eax, DWORD PTR [edx+ecx*4+480]
	push	eax
	mov	ecx, DWORD PTR _cur$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _cur$1[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+192]
	call	eax
	mov	DWORD PTR _thisID$[ebp], eax

; 1282 : 					if(thisID){

	cmp	DWORD PTR _thisID$[ebp], 0
	je	SHORT $LN7@GetControl

; 1283 : 						lastID=thisID;

	mov	ecx, DWORD PTR _thisID$[ebp]
	mov	DWORD PTR _lastID$[ebp], ecx

; 1284 : 						last=cur->Control_;

	mov	edx, DWORD PTR _cur$1[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _last$[ebp], eax
$LN7@GetControl:

; 1285 : 					}
; 1286 : 				}
; 1287 : 			}
; 1288 : 		}
; 1289 : 	}

	jmp	$LN9@GetControl
$LN8@GetControl:

; 1290 : 
; 1291 : 	if(lastID){

	cmp	DWORD PTR _lastID$[ebp], 0
	je	SHORT $LN1@GetControl

; 1292 : 		*ID=lastID;

	mov	ecx, DWORD PTR _ID$[ebp]
	mov	edx, DWORD PTR _lastID$[ebp]
	mov	DWORD PTR [ecx], edx

; 1293 : 		return(last);

	mov	eax, DWORD PTR _last$[ebp]
	jmp	SHORT $LN11@GetControl
$LN1@GetControl:

; 1294 : 	}
; 1295 : 
; 1296 : 	*ID=0;

	mov	eax, DWORD PTR _ID$[ebp]
	mov	DWORD PTR [eax], 0

; 1297 : 	return(NULL);

	xor	eax, eax
$LN11@GetControl:

; 1298 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetControl@C_Window@@QAEPAVC_Base@@PAJJJ@Z ENDP	; C_Window::GetControl
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_cur$ = -4						; size = 4
_ID$ = 8						; size = 4
?FindControl@C_Window@@QAEPAVC_Base@@J@Z PROC		; C_Window::FindControl
; _this$ = ecx

; 1301 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1302 : 	CONTROLLIST *cur=NULL;

	mov	DWORD PTR _cur$[ebp], 0

; 1303 : 
; 1304 : 	if (F4IsBadReadPtr(Hash_, sizeof(C_Hash))) // JB 010404 CTD

	push	20					; 00000014H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4300]
	push	ecx
	call	?F4IsBadReadPtr@@YA_NPBXI@Z		; F4IsBadReadPtr
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@FindContro

; 1305 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN4@FindContro
$LN3@FindContro:

; 1306 : 
; 1307 : 	if(ID > 0)

	cmp	DWORD PTR _ID$[ebp], 0
	jle	SHORT $LN2@FindContro

; 1308 : 		cur=(CONTROLLIST*)Hash_->Find(ID);

	mov	eax, DWORD PTR _ID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4300]
	call	?Find@C_Hash@@QAEPAXJ@Z			; C_Hash::Find
	mov	DWORD PTR _cur$[ebp], eax
$LN2@FindContro:

; 1309 : 	if(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN1@FindContro

; 1310 : 		return(cur->Control_);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx]
	jmp	SHORT $LN4@FindContro
$LN1@FindContro:

; 1311 : 	return(NULL);

	xor	eax, eax
$LN4@FindContro:

; 1312 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?FindControl@C_Window@@QAEPAVC_Base@@J@Z ENDP		; C_Window::FindControl
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_control$ = 8						; size = 4
?RemovingControl@C_Window@@QAEXPAVC_Base@@@Z PROC	; C_Window::RemovingControl
; _this$ = ecx

; 2384 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2385 : 	if(CurControl_ == control)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4312]
	cmp	ecx, DWORD PTR _control$[ebp]
	jne	SHORT $LN1@RemovingCo

; 2386 : 		CurControl_=NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4312], 0
$LN1@RemovingCo:

; 2387 : 	Handler_->RemovingControl(control);

	mov	eax, DWORD PTR _control$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4328]
	call	?RemovingControl@C_Handler@@QAEXPAVC_Base@@@Z ; C_Handler::RemovingControl

; 2388 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?RemovingControl@C_Window@@QAEXPAVC_Base@@@Z ENDP	; C_Window::RemovingControl
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?KeyboardMode@C_Window@@QAEHXZ PROC			; C_Window::KeyboardMode
; _this$ = ecx

; 2368 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2369 : 	if(Handler_)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4328], 0
	je	SHORT $LN1@KeyboardMo

; 2370 : 		return(Handler_->KeyboardMode());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4328]
	call	?KeyboardMode@C_Handler@@QAEHXZ		; C_Handler::KeyboardMode
	jmp	SHORT $LN2@KeyboardMo
$LN1@KeyboardMo:

; 2371 : 	return(FALSE);

	xor	eax, eax
$LN2@KeyboardMo:

; 2372 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?KeyboardMode@C_Window@@QAEHXZ ENDP			; C_Window::KeyboardMode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -24						; size = 4
_rect$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_surface$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_w$ = 20						; size = 4
_h$ = 24						; size = 4
_flags$ = 28						; size = 4
_Client$ = 32						; size = 4
?ClearArea@C_Window@@QAEXPAVSCREEN@@JJJJJJ@Z PROC	; C_Window::ClearArea
; _this$ = ecx

; 1254 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1255 : 	UI95_RECT rect;
; 1256 : 
; 1257 : 	rect.left=x;

	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR _rect$[ebp], eax

; 1258 : 	rect.top=y;

	mov	ecx, DWORD PTR _y$[ebp]
	mov	DWORD PTR _rect$[ebp+4], ecx

; 1259 : 	rect.right=rect.left+w;

	mov	edx, DWORD PTR _rect$[ebp]
	add	edx, DWORD PTR _w$[ebp]
	mov	DWORD PTR _rect$[ebp+8], edx

; 1260 : 	rect.bottom=rect.top+h;

	mov	eax, DWORD PTR _rect$[ebp+4]
	add	eax, DWORD PTR _h$[ebp]
	mov	DWORD PTR _rect$[ebp+12], eax

; 1261 : 
; 1262 : 	BlitFill(surface,BgColor_,&rect,flags,Client);

	mov	ecx, DWORD PTR _Client$[ebp]
	push	ecx
	mov	edx, DWORD PTR _flags$[ebp]
	push	edx
	lea	eax, DWORD PTR _rect$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+164]
	push	edx
	mov	eax, DWORD PTR _surface$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BlitFill@C_Window@@QAEXPAVSCREEN@@KPAUUI95_RECT@@JJ@Z ; C_Window::BlitFill

; 1263 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?ClearArea@C_Window@@QAEXPAVSCREEN@@JJJJJJ@Z ENDP	; C_Window::ClearArea
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_surface$ = 8						; size = 4
_Client$ = 12						; size = 4
?ClearWindow@C_Window@@QAEXPAVSCREEN@@J@Z PROC		; C_Window::ClearWindow
; _this$ = ecx

; 1248 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1249 : 	BlitFill(surface,BgColor_,&ClientArea_[Client],C_BIT_ABSOLUTE,Client);

	mov	eax, DWORD PTR _Client$[ebp]
	push	eax
	push	262144					; 00040000H
	mov	ecx, DWORD PTR _Client$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+168]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+164]
	push	edx
	mov	eax, DWORD PTR _surface$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BlitFill@C_Window@@QAEXPAVSCREEN@@KPAUUI95_RECT@@JJ@Z ; C_Window::BlitFill

; 1250 : 	SetUpdateRect(ClientArea_[Client].left,ClientArea_[Client].top,ClientArea_[Client].right,ClientArea_[Client].bottom,C_BIT_ABSOLUTE,0);

	push	0
	push	262144					; 00040000H
	mov	ecx, DWORD PTR _Client$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+180]
	push	eax
	mov	ecx, DWORD PTR _Client$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+176]
	push	eax
	mov	ecx, DWORD PTR _Client$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+172]
	push	eax
	mov	ecx, DWORD PTR _Client$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+168]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetUpdateRect@C_Window@@QAEXJJJJJJ@Z	; C_Window::SetUpdateRect

; 1251 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ClearWindow@C_Window@@QAEXPAVSCREEN@@J@Z ENDP		; C_Window::ClearWindow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
tv93 = -32						; size = 4
_this$ = -28						; size = 4
_y1$ = -24						; size = 4
_y2$ = -20						; size = 4
_x1$ = -16						; size = 4
_x2$ = -12						; size = 4
_i$ = -8						; size = 2
_j$ = -4						; size = 2
_surface$ = 8						; size = 4
_color$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_radius$ = 24						; size = 4
_section$ = 28						; size = 2
_Flags$ = 32						; size = 4
_Client$ = 36						; size = 4
_clip$ = 40						; size = 4
?DrawArc@C_Window@@QAEXPAVSCREEN@@KJJMFJJPAUUI95_RECT@@@Z PROC ; C_Window::DrawArc
; _this$ = ecx

; 2277 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 2278 : 	short i,j;
; 2279 : 	float x1,y1,x2,y2;
; 2280 : 
; 2281 : 	for(i=0;i<8;i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN16@DrawArc
$LN15@DrawArc:
	mov	cx, WORD PTR _i$[ebp]
	add	cx, 1
	mov	WORD PTR _i$[ebp], cx
$LN16@DrawArc:
	movsx	edx, WORD PTR _i$[ebp]
	cmp	edx, 8
	jge	$LN14@DrawArc

; 2282 : 	{
; 2283 : 		x1=Circle8[0][0]*radius;

	mov	eax, 8
	imul	eax, 0
	mov	ecx, 4
	imul	ecx, 0
	movss	xmm0, DWORD PTR ?Circle8@@3PAY01MA[eax+ecx]
	mulss	xmm0, DWORD PTR _radius$[ebp]
	movss	DWORD PTR _x1$[ebp], xmm0

; 2284 : 		y1=Circle8[0][1]*radius;

	mov	edx, 8
	imul	edx, 0
	mov	eax, 4
	shl	eax, 0
	movss	xmm0, DWORD PTR ?Circle8@@3PAY01MA[edx+eax]
	mulss	xmm0, DWORD PTR _radius$[ebp]
	movss	DWORD PTR _y1$[ebp], xmm0

; 2285 : 
; 2286 : 		for(j=1;j<CIRCLE_POINTS;j++)

	mov	ecx, 1
	mov	WORD PTR _j$[ebp], cx
	jmp	SHORT $LN13@DrawArc
$LN12@DrawArc:
	mov	dx, WORD PTR _j$[ebp]
	add	dx, 1
	mov	WORD PTR _j$[ebp], dx
$LN13@DrawArc:
	movsx	eax, WORD PTR _j$[ebp]
	cmp	eax, 5
	jge	$LN11@DrawArc

; 2287 : 		{
; 2288 : 			x2=Circle8[j][0]*radius;

	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, 4
	imul	edx, 0
	movss	xmm0, DWORD PTR ?Circle8@@3PAY01MA[edx+ecx*8]
	mulss	xmm0, DWORD PTR _radius$[ebp]
	movss	DWORD PTR _x2$[ebp], xmm0

; 2289 : 			y2=Circle8[j][1]*radius;

	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR ?Circle8@@3PAY01MA[ecx+eax*8]
	mulss	xmm0, DWORD PTR _radius$[ebp]
	movss	DWORD PTR _y2$[ebp], xmm0

; 2290 : 
; 2291 : 			switch(section)

	movsx	edx, WORD PTR _section$[ebp]
	mov	DWORD PTR tv93[ebp], edx
	cmp	DWORD PTR tv93[ebp], 7
	ja	$LN9@DrawArc
	mov	eax, DWORD PTR tv93[ebp]
	jmp	DWORD PTR $LN19@DrawArc[eax*4]
$LN8@DrawArc:

; 2292 : 			{
; 2293 : 				case 0:
; 2294 : 					DrawLine(surface,color,x+(long)x1,y-(long)y1,x+(long)x2,y-(long)y2,Flags,Client,clip);

	mov	ecx, DWORD PTR _clip$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Client$[ebp]
	push	edx
	mov	eax, DWORD PTR _Flags$[ebp]
	push	eax
	cvttss2si ecx, DWORD PTR _y2$[ebp]
	mov	edx, DWORD PTR _y$[ebp]
	sub	edx, ecx
	push	edx
	cvttss2si eax, DWORD PTR _x2$[ebp]
	add	eax, DWORD PTR _x$[ebp]
	push	eax
	cvttss2si ecx, DWORD PTR _y1$[ebp]
	mov	edx, DWORD PTR _y$[ebp]
	sub	edx, ecx
	push	edx
	cvttss2si eax, DWORD PTR _x1$[ebp]
	add	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _color$[ebp]
	push	ecx
	mov	edx, DWORD PTR _surface$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawLine@C_Window@@QAEXPAVSCREEN@@KJJJJJJPAUUI95_RECT@@@Z ; C_Window::DrawLine

; 2295 : 					break;

	jmp	$LN9@DrawArc
$LN7@DrawArc:

; 2296 : 				case 1:
; 2297 : 					DrawLine(surface,color,x+(long)y1,y-(long)x1,x+(long)y2,y-(long)x2,Flags,Client,clip);

	mov	eax, DWORD PTR _clip$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Client$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Flags$[ebp]
	push	edx
	cvttss2si eax, DWORD PTR _x2$[ebp]
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, eax
	push	ecx
	cvttss2si edx, DWORD PTR _y2$[ebp]
	add	edx, DWORD PTR _x$[ebp]
	push	edx
	cvttss2si eax, DWORD PTR _x1$[ebp]
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, eax
	push	ecx
	cvttss2si edx, DWORD PTR _y1$[ebp]
	add	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	eax, DWORD PTR _color$[ebp]
	push	eax
	mov	ecx, DWORD PTR _surface$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawLine@C_Window@@QAEXPAVSCREEN@@KJJJJJJPAUUI95_RECT@@@Z ; C_Window::DrawLine

; 2298 : 					break;

	jmp	$LN9@DrawArc
$LN6@DrawArc:

; 2299 : 				case 2:
; 2300 : 					DrawLine(surface,color,x+(long)y1,y+(long)x1,x+(long)y2,y+(long)x2,Flags,Client,clip);

	mov	edx, DWORD PTR _clip$[ebp]
	push	edx
	mov	eax, DWORD PTR _Client$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Flags$[ebp]
	push	ecx
	cvttss2si edx, DWORD PTR _x2$[ebp]
	add	edx, DWORD PTR _y$[ebp]
	push	edx
	cvttss2si eax, DWORD PTR _y2$[ebp]
	add	eax, DWORD PTR _x$[ebp]
	push	eax
	cvttss2si ecx, DWORD PTR _x1$[ebp]
	add	ecx, DWORD PTR _y$[ebp]
	push	ecx
	cvttss2si edx, DWORD PTR _y1$[ebp]
	add	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	eax, DWORD PTR _color$[ebp]
	push	eax
	mov	ecx, DWORD PTR _surface$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawLine@C_Window@@QAEXPAVSCREEN@@KJJJJJJPAUUI95_RECT@@@Z ; C_Window::DrawLine

; 2301 : 					break;

	jmp	$LN9@DrawArc
$LN5@DrawArc:

; 2302 : 				case 3:
; 2303 : 					DrawLine(surface,color,x+(long)x1,y+(long)y1,x+(long)x2,y+(long)y2,Flags,Client,clip);

	mov	edx, DWORD PTR _clip$[ebp]
	push	edx
	mov	eax, DWORD PTR _Client$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Flags$[ebp]
	push	ecx
	cvttss2si edx, DWORD PTR _y2$[ebp]
	add	edx, DWORD PTR _y$[ebp]
	push	edx
	cvttss2si eax, DWORD PTR _x2$[ebp]
	add	eax, DWORD PTR _x$[ebp]
	push	eax
	cvttss2si ecx, DWORD PTR _y1$[ebp]
	add	ecx, DWORD PTR _y$[ebp]
	push	ecx
	cvttss2si edx, DWORD PTR _x1$[ebp]
	add	edx, DWORD PTR _x$[ebp]
	push	edx
	mov	eax, DWORD PTR _color$[ebp]
	push	eax
	mov	ecx, DWORD PTR _surface$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawLine@C_Window@@QAEXPAVSCREEN@@KJJJJJJPAUUI95_RECT@@@Z ; C_Window::DrawLine

; 2304 : 					break;

	jmp	$LN9@DrawArc
$LN4@DrawArc:

; 2305 : 				case 4:
; 2306 : 					DrawLine(surface,color,x-(long)x1,y+(long)y1,x-(long)x2,y+(long)y2,Flags,Client,clip);

	mov	edx, DWORD PTR _clip$[ebp]
	push	edx
	mov	eax, DWORD PTR _Client$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Flags$[ebp]
	push	ecx
	cvttss2si edx, DWORD PTR _y2$[ebp]
	add	edx, DWORD PTR _y$[ebp]
	push	edx
	cvttss2si eax, DWORD PTR _x2$[ebp]
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	push	ecx
	cvttss2si edx, DWORD PTR _y1$[ebp]
	add	edx, DWORD PTR _y$[ebp]
	push	edx
	cvttss2si eax, DWORD PTR _x1$[ebp]
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _color$[ebp]
	push	edx
	mov	eax, DWORD PTR _surface$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawLine@C_Window@@QAEXPAVSCREEN@@KJJJJJJPAUUI95_RECT@@@Z ; C_Window::DrawLine

; 2307 : 					break;

	jmp	$LN9@DrawArc
$LN3@DrawArc:

; 2308 : 				case 5:
; 2309 : 					DrawLine(surface,color,x-(long)y1,y+(long)x1,x-(long)y2,y+(long)x2,Flags,Client,clip);

	mov	ecx, DWORD PTR _clip$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Client$[ebp]
	push	edx
	mov	eax, DWORD PTR _Flags$[ebp]
	push	eax
	cvttss2si ecx, DWORD PTR _x2$[ebp]
	add	ecx, DWORD PTR _y$[ebp]
	push	ecx
	cvttss2si edx, DWORD PTR _y2$[ebp]
	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, edx
	push	eax
	cvttss2si ecx, DWORD PTR _x1$[ebp]
	add	ecx, DWORD PTR _y$[ebp]
	push	ecx
	cvttss2si edx, DWORD PTR _y1$[ebp]
	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _color$[ebp]
	push	ecx
	mov	edx, DWORD PTR _surface$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawLine@C_Window@@QAEXPAVSCREEN@@KJJJJJJPAUUI95_RECT@@@Z ; C_Window::DrawLine

; 2310 : 					break;

	jmp	$LN9@DrawArc
$LN2@DrawArc:

; 2311 : 				case 6:
; 2312 : 					DrawLine(surface,color,x-(long)y1,y-(long)x1,x-(long)y2,y-(long)x2,Flags,Client,clip);

	mov	eax, DWORD PTR _clip$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Client$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Flags$[ebp]
	push	edx
	cvttss2si eax, DWORD PTR _x2$[ebp]
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, eax
	push	ecx
	cvttss2si edx, DWORD PTR _y2$[ebp]
	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, edx
	push	eax
	cvttss2si ecx, DWORD PTR _x1$[ebp]
	mov	edx, DWORD PTR _y$[ebp]
	sub	edx, ecx
	push	edx
	cvttss2si eax, DWORD PTR _y1$[ebp]
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _color$[ebp]
	push	edx
	mov	eax, DWORD PTR _surface$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawLine@C_Window@@QAEXPAVSCREEN@@KJJJJJJPAUUI95_RECT@@@Z ; C_Window::DrawLine

; 2313 : 					break;

	jmp	SHORT $LN9@DrawArc
$LN1@DrawArc:

; 2314 : 				case 7:
; 2315 : 					DrawLine(surface,color,x-(long)x1,y-(long)y1,x-(long)x2,y-(long)y2,Flags,Client,clip);

	mov	ecx, DWORD PTR _clip$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Client$[ebp]
	push	edx
	mov	eax, DWORD PTR _Flags$[ebp]
	push	eax
	cvttss2si ecx, DWORD PTR _y2$[ebp]
	mov	edx, DWORD PTR _y$[ebp]
	sub	edx, ecx
	push	edx
	cvttss2si eax, DWORD PTR _x2$[ebp]
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, eax
	push	ecx
	cvttss2si edx, DWORD PTR _y1$[ebp]
	mov	eax, DWORD PTR _y$[ebp]
	sub	eax, edx
	push	eax
	cvttss2si ecx, DWORD PTR _x1$[ebp]
	mov	edx, DWORD PTR _x$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR _color$[ebp]
	push	eax
	mov	ecx, DWORD PTR _surface$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawLine@C_Window@@QAEXPAVSCREEN@@KJJJJJJPAUUI95_RECT@@@Z ; C_Window::DrawLine
$LN9@DrawArc:

; 2316 : 					break;
; 2317 : 			}
; 2318 : 
; 2319 : 			x1=x2;

	movss	xmm0, DWORD PTR _x2$[ebp]
	movss	DWORD PTR _x1$[ebp], xmm0

; 2320 : 			y1=y2;

	movss	xmm0, DWORD PTR _y2$[ebp]
	movss	DWORD PTR _y1$[ebp], xmm0

; 2321 : 		}

	jmp	$LN12@DrawArc
$LN11@DrawArc:

; 2322 : 	}

	jmp	$LN15@DrawArc
$LN14@DrawArc:

; 2323 : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
	npad	3
$LN19@DrawArc:
	DD	$LN8@DrawArc
	DD	$LN7@DrawArc
	DD	$LN6@DrawArc
	DD	$LN5@DrawArc
	DD	$LN4@DrawArc
	DD	$LN3@DrawArc
	DD	$LN2@DrawArc
	DD	$LN1@DrawArc
?DrawArc@C_Window@@QAEXPAVSCREEN@@KJJMFJJPAUUI95_RECT@@@Z ENDP ; C_Window::DrawArc
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_i$ = -52						; size = 2
_y1$ = -48						; size = 4
_j$ = -44						; size = 2
_x1$ = -40						; size = 4
_y2$ = -36						; size = 4
_x2$ = -32						; size = 4
_linecolor$ = -28					; size = 2
_this$ = -24						; size = 4
_clipper$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_surface$ = 8						; size = 4
_color$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_radius$ = 24						; size = 4
_Flags$ = 28						; size = 4
_Client$ = 32						; size = 4
_clip$ = 36						; size = 4
?DrawCircle@C_Window@@QAEXPAVSCREEN@@KJJMJJPAUUI95_RECT@@@Z PROC ; C_Window::DrawCircle
; _this$ = ecx

; 2216 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 2217 : 	short i,j;
; 2218 : 	long x1,y1,x2,y2;
; 2219 : 	WORD linecolor;
; 2220 : 	UI95_RECT clipper;
; 2221 : 
; 2222 : 	clipper=*clip;

	mov	eax, DWORD PTR _clip$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _clipper$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _clipper$[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _clipper$[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _clipper$[ebp+12], edx

; 2223 : 
; 2224 : 	if(!(Flags & C_BIT_ABSOLUTE))

	mov	eax, DWORD PTR _Flags$[ebp]
	and	eax, 262144				; 00040000H
	jne	$LN8@DrawCircle

; 2225 : 	{
; 2226 : 		x+=VX_[Client];

	mov	ecx, DWORD PTR _Client$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, DWORD PTR [edx+ecx*4+480]
	mov	DWORD PTR _x$[ebp], eax

; 2227 : 		y+=VY_[Client];

	mov	ecx, DWORD PTR _Client$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _y$[ebp]
	add	eax, DWORD PTR [edx+ecx*4+512]
	mov	DWORD PTR _y$[ebp], eax

; 2228 : 		if(clipper.left < ClientArea_[Client].left) clipper.left=ClientArea_[Client].left;

	mov	ecx, DWORD PTR _Client$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _clipper$[ebp]
	cmp	eax, DWORD PTR [edx+ecx+168]
	jge	SHORT $LN11@DrawCircle
	mov	ecx, DWORD PTR _Client$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+168]
	mov	DWORD PTR _clipper$[ebp], eax
$LN11@DrawCircle:

; 2229 : 		if(clipper.top < ClientArea_[Client].top) clipper.top=ClientArea_[Client].top;

	mov	ecx, DWORD PTR _Client$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _clipper$[ebp+4]
	cmp	eax, DWORD PTR [edx+ecx+172]
	jge	SHORT $LN10@DrawCircle
	mov	ecx, DWORD PTR _Client$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+172]
	mov	DWORD PTR _clipper$[ebp+4], eax
$LN10@DrawCircle:

; 2230 : 		if(clipper.right > ClientArea_[Client].right) clipper.right=ClientArea_[Client].right;

	mov	ecx, DWORD PTR _Client$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _clipper$[ebp+8]
	cmp	eax, DWORD PTR [edx+ecx+176]
	jle	SHORT $LN9@DrawCircle
	mov	ecx, DWORD PTR _Client$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+176]
	mov	DWORD PTR _clipper$[ebp+8], eax
$LN9@DrawCircle:

; 2231 : 		if(clipper.bottom > ClientArea_[Client].bottom) clipper.bottom=ClientArea_[Client].bottom;

	mov	ecx, DWORD PTR _Client$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _clipper$[ebp+12]
	cmp	eax, DWORD PTR [edx+ecx+180]
	jle	SHORT $LN8@DrawCircle
	mov	ecx, DWORD PTR _Client$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+180]
	mov	DWORD PTR _clipper$[ebp+12], eax
$LN8@DrawCircle:

; 2232 : 	}
; 2233 : 	x1=x-(long)radius;

	cvttss2si ecx, DWORD PTR _radius$[ebp]
	mov	edx, DWORD PTR _x$[ebp]
	sub	edx, ecx
	mov	DWORD PTR _x1$[ebp], edx

; 2234 : 	y1=y-(long)radius;

	cvttss2si eax, DWORD PTR _radius$[ebp]
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _y1$[ebp], ecx

; 2235 : 	x2=x+(long)radius;

	cvttss2si edx, DWORD PTR _radius$[ebp]
	add	edx, DWORD PTR _x$[ebp]
	mov	DWORD PTR _x2$[ebp], edx

; 2236 : 	y2=y+(long)radius;

	cvttss2si eax, DWORD PTR _radius$[ebp]
	add	eax, DWORD PTR _y$[ebp]
	mov	DWORD PTR _y2$[ebp], eax

; 2237 : 
; 2238 : 	if(!CheckLine(x1,y1,x2,y2,clipper.left,clipper.top,clipper.right,clipper.bottom))

	mov	ecx, DWORD PTR _clipper$[ebp+12]
	push	ecx
	mov	edx, DWORD PTR _clipper$[ebp+8]
	push	edx
	mov	eax, DWORD PTR _clipper$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _clipper$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y2$[ebp]
	push	edx
	mov	eax, DWORD PTR _x2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x1$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckLine@C_Window@@QAEHJJJJJJJJ@Z	; C_Window::CheckLine
	test	eax, eax
	jne	SHORT $LN7@DrawCircle

; 2239 : 		return;

	jmp	$LN13@DrawCircle
$LN7@DrawCircle:

; 2240 : 
; 2241 : 	x+=GetX();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetX@C_Window@@QAEFXZ			; C_Window::GetX
	cwde
	add	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR _x$[ebp], eax

; 2242 : 	y+=GetY();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetY@C_Window@@QAEFXZ			; C_Window::GetY
	movsx	ecx, ax
	add	ecx, DWORD PTR _y$[ebp]
	mov	DWORD PTR _y$[ebp], ecx

; 2243 : 	clipper.left+=GetX();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetX@C_Window@@QAEFXZ			; C_Window::GetX
	movsx	edx, ax
	add	edx, DWORD PTR _clipper$[ebp]
	mov	DWORD PTR _clipper$[ebp], edx

; 2244 : 	clipper.top+=GetY();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetY@C_Window@@QAEFXZ			; C_Window::GetY
	cwde
	add	eax, DWORD PTR _clipper$[ebp+4]
	mov	DWORD PTR _clipper$[ebp+4], eax

; 2245 : 	clipper.right+=GetX();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetX@C_Window@@QAEFXZ			; C_Window::GetX
	movsx	ecx, ax
	add	ecx, DWORD PTR _clipper$[ebp+8]
	mov	DWORD PTR _clipper$[ebp+8], ecx

; 2246 : 	clipper.bottom+=GetY();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetY@C_Window@@QAEFXZ			; C_Window::GetY
	movsx	edx, ax
	add	edx, DWORD PTR _clipper$[ebp+12]
	mov	DWORD PTR _clipper$[ebp+12], edx

; 2247 : 
; 2248 : 	linecolor=(WORD)UI95_RGB24Bit(color);

	mov	eax, DWORD PTR _color$[ebp]
	push	eax
	call	?UI95_RGB24Bit@@YAGK@Z			; UI95_RGB24Bit
	add	esp, 4
	mov	WORD PTR _linecolor$[ebp], ax

; 2249 : 
; 2250 : 	for(i=0;i<8;i++)

	xor	ecx, ecx
	mov	WORD PTR _i$[ebp], cx
	jmp	SHORT $LN6@DrawCircle
$LN5@DrawCircle:
	mov	dx, WORD PTR _i$[ebp]
	add	dx, 1
	mov	WORD PTR _i$[ebp], dx
$LN6@DrawCircle:
	movsx	eax, WORD PTR _i$[ebp]
	cmp	eax, 8
	jge	$LN4@DrawCircle

; 2251 : 	{
; 2252 : 		x1=(long)(Circle8[0][0]*radius);

	mov	ecx, 8
	imul	ecx, 0
	mov	edx, 4
	imul	edx, 0
	movss	xmm0, DWORD PTR ?Circle8@@3PAY01MA[ecx+edx]
	mulss	xmm0, DWORD PTR _radius$[ebp]
	cvttss2si eax, xmm0
	mov	DWORD PTR _x1$[ebp], eax

; 2253 : 		y1=(long)(Circle8[0][1]*radius);

	mov	ecx, 8
	imul	ecx, 0
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR ?Circle8@@3PAY01MA[ecx+edx]
	mulss	xmm0, DWORD PTR _radius$[ebp]
	cvttss2si eax, xmm0
	mov	DWORD PTR _y1$[ebp], eax

; 2254 : 
; 2255 : 		for(j=1;j<CIRCLE_POINTS;j++)

	mov	ecx, 1
	mov	WORD PTR _j$[ebp], cx
	jmp	SHORT $LN3@DrawCircle
$LN2@DrawCircle:
	mov	dx, WORD PTR _j$[ebp]
	add	dx, 1
	mov	WORD PTR _j$[ebp], dx
$LN3@DrawCircle:
	movsx	eax, WORD PTR _j$[ebp]
	cmp	eax, 5
	jge	$LN1@DrawCircle

; 2256 : 		{
; 2257 : 			x2=(long)(Circle8[j][0]*radius);

	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, 4
	imul	edx, 0
	movss	xmm0, DWORD PTR ?Circle8@@3PAY01MA[edx+ecx*8]
	mulss	xmm0, DWORD PTR _radius$[ebp]
	cvttss2si eax, xmm0
	mov	DWORD PTR _x2$[ebp], eax

; 2258 : 			y2=(long)(Circle8[j][1]*radius);

	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR ?Circle8@@3PAY01MA[edx+ecx*8]
	mulss	xmm0, DWORD PTR _radius$[ebp]
	cvttss2si eax, xmm0
	mov	DWORD PTR _y2$[ebp], eax

; 2259 : 
; 2260 : 			DrawClipLine(surface,x+x1,y+y1,x+x2,y+y2,&clipper,linecolor);

	movzx	ecx, WORD PTR _linecolor$[ebp]
	push	ecx
	lea	edx, DWORD PTR _clipper$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	add	eax, DWORD PTR _y2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	add	ecx, DWORD PTR _x2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	add	edx, DWORD PTR _y1$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, DWORD PTR _x1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _surface$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawClipLine@C_Window@@QAEXPAVSCREEN@@JJJJPAUUI95_RECT@@G@Z ; C_Window::DrawClipLine

; 2261 : 			DrawClipLine(surface,x-x1,y+y1,x-x2,y+y2,&clipper,linecolor);

	movzx	edx, WORD PTR _linecolor$[ebp]
	push	edx
	lea	eax, DWORD PTR _clipper$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	add	ecx, DWORD PTR _y2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	sub	edx, DWORD PTR _x2$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	add	eax, DWORD PTR _y1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, DWORD PTR _x1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _surface$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawClipLine@C_Window@@QAEXPAVSCREEN@@JJJJPAUUI95_RECT@@G@Z ; C_Window::DrawClipLine

; 2262 : 			DrawClipLine(surface,x+x1,y-y1,x+x2,y-y2,&clipper,linecolor);

	movzx	eax, WORD PTR _linecolor$[ebp]
	push	eax
	lea	ecx, DWORD PTR _clipper$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	sub	edx, DWORD PTR _y2$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, DWORD PTR _x2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, DWORD PTR _y1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	add	edx, DWORD PTR _x1$[ebp]
	push	edx
	mov	eax, DWORD PTR _surface$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawClipLine@C_Window@@QAEXPAVSCREEN@@JJJJPAUUI95_RECT@@G@Z ; C_Window::DrawClipLine

; 2263 : 			DrawClipLine(surface,x-x1,y-y1,x-x2,y-y2,&clipper,linecolor);

	movzx	ecx, WORD PTR _linecolor$[ebp]
	push	ecx
	lea	edx, DWORD PTR _clipper$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	sub	eax, DWORD PTR _y2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, DWORD PTR _x2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	sub	edx, DWORD PTR _y1$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, DWORD PTR _x1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _surface$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawClipLine@C_Window@@QAEXPAVSCREEN@@JJJJPAUUI95_RECT@@G@Z ; C_Window::DrawClipLine

; 2264 : 
; 2265 : 			DrawClipLine(surface,x+y1,y+x1,x+y2,y+x2,&clipper,linecolor);

	movzx	edx, WORD PTR _linecolor$[ebp]
	push	edx
	lea	eax, DWORD PTR _clipper$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	add	ecx, DWORD PTR _x2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	add	edx, DWORD PTR _y2$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	add	eax, DWORD PTR _x1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	add	ecx, DWORD PTR _y1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _surface$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawClipLine@C_Window@@QAEXPAVSCREEN@@JJJJPAUUI95_RECT@@G@Z ; C_Window::DrawClipLine

; 2266 : 			DrawClipLine(surface,x-y1,y+x1,x-y2,y+x2,&clipper,linecolor);

	movzx	eax, WORD PTR _linecolor$[ebp]
	push	eax
	lea	ecx, DWORD PTR _clipper$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	add	edx, DWORD PTR _x2$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, DWORD PTR _y2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	add	ecx, DWORD PTR _x1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	sub	edx, DWORD PTR _y1$[ebp]
	push	edx
	mov	eax, DWORD PTR _surface$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawClipLine@C_Window@@QAEXPAVSCREEN@@JJJJPAUUI95_RECT@@G@Z ; C_Window::DrawClipLine

; 2267 : 			DrawClipLine(surface,x+y1,y-x1,x+y2,y-x2,&clipper,linecolor);

	movzx	ecx, WORD PTR _linecolor$[ebp]
	push	ecx
	lea	edx, DWORD PTR _clipper$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	sub	eax, DWORD PTR _x2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	add	ecx, DWORD PTR _y2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$[ebp]
	sub	edx, DWORD PTR _x1$[ebp]
	push	edx
	mov	eax, DWORD PTR _x$[ebp]
	add	eax, DWORD PTR _y1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _surface$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawClipLine@C_Window@@QAEXPAVSCREEN@@JJJJPAUUI95_RECT@@G@Z ; C_Window::DrawClipLine

; 2268 : 			DrawClipLine(surface,x-y1,y-x1,x-y2,y-x2,&clipper,linecolor);

	movzx	edx, WORD PTR _linecolor$[ebp]
	push	edx
	lea	eax, DWORD PTR _clipper$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y$[ebp]
	sub	ecx, DWORD PTR _x2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	sub	edx, DWORD PTR _y2$[ebp]
	push	edx
	mov	eax, DWORD PTR _y$[ebp]
	sub	eax, DWORD PTR _x1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	sub	ecx, DWORD PTR _y1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _surface$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawClipLine@C_Window@@QAEXPAVSCREEN@@JJJJPAUUI95_RECT@@G@Z ; C_Window::DrawClipLine

; 2269 : 
; 2270 : 			x1=x2;

	mov	eax, DWORD PTR _x2$[ebp]
	mov	DWORD PTR _x1$[ebp], eax

; 2271 : 			y1=y2;

	mov	ecx, DWORD PTR _y2$[ebp]
	mov	DWORD PTR _y1$[ebp], ecx

; 2272 : 		}

	jmp	$LN2@DrawCircle
$LN1@DrawCircle:

; 2273 : 	}

	jmp	$LN5@DrawCircle
$LN4@DrawCircle:
$LN13@DrawCircle:

; 2274 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?DrawCircle@C_Window@@QAEXPAVSCREEN@@KJJMJJPAUUI95_RECT@@@Z ENDP ; C_Window::DrawCircle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -40						; size = 4
_y_dir$ = -36						; size = 4
_y_unit$ = -32						; size = 4
_length$ = -28						; size = 4
_x_unit$ = -24						; size = 4
_ydiff$ = -20						; size = 4
_i$ = -16						; size = 4
_xdiff$ = -12						; size = 4
_error_term$ = -8					; size = 4
_offset$ = -4						; size = 4
_surface$ = 8						; size = 4
_x1$ = 12						; size = 4
_y1$ = 16						; size = 4
_x2$ = 20						; size = 4
_y2$ = 24						; size = 4
_clip$ = 28						; size = 4
_color$ = 32						; size = 2
?DrawClipLine@C_Window@@QAEXPAVSCREEN@@JJJJPAUUI95_RECT@@G@Z PROC ; C_Window::DrawClipLine
; _this$ = ecx

; 2134 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 2135 : 	long x_unit,y_unit;
; 2136 : 	long offset,y_dir;
; 2137 : 	long xdiff,ydiff;
; 2138 : 	long error_term;
; 2139 : 	long length,i;
; 2140 : 
; 2141 : 	if(!ClipLine(&x1,&y1,&x2,&y2,clip))

	mov	eax, DWORD PTR _clip$[ebp]
	push	eax
	lea	ecx, DWORD PTR _y2$[ebp]
	push	ecx
	lea	edx, DWORD PTR _x2$[ebp]
	push	edx
	lea	eax, DWORD PTR _y1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x1$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClipLine@C_Window@@QAEHPAJ000PAUUI95_RECT@@@Z ; C_Window::ClipLine
	test	eax, eax
	jne	SHORT $LN20@DrawClipLi

; 2142 : 		if(!ClipLine(&x1,&y1,&x2,&y2,clip))

	mov	edx, DWORD PTR _clip$[ebp]
	push	edx
	lea	eax, DWORD PTR _y2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _x2$[ebp]
	push	ecx
	lea	edx, DWORD PTR _y1$[ebp]
	push	edx
	lea	eax, DWORD PTR _x1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClipLine@C_Window@@QAEHPAJ000PAUUI95_RECT@@@Z ; C_Window::ClipLine
	test	eax, eax
	jne	SHORT $LN20@DrawClipLi

; 2143 : 			return;

	jmp	$LN21@DrawClipLi
$LN20@DrawClipLi:

; 2144 : 
; 2145 : 	ydiff=y2-y1;

	mov	ecx, DWORD PTR _y2$[ebp]
	sub	ecx, DWORD PTR _y1$[ebp]
	mov	DWORD PTR _ydiff$[ebp], ecx

; 2146 : 	if(ydiff < 0)

	jns	SHORT $LN18@DrawClipLi

; 2147 : 	{
; 2148 : 		ydiff=-ydiff;

	mov	edx, DWORD PTR _ydiff$[ebp]
	neg	edx
	mov	DWORD PTR _ydiff$[ebp], edx

; 2149 : 		y_unit=-surface->width;

	mov	eax, DWORD PTR _surface$[ebp]
	movsx	ecx, WORD PTR [eax+4]
	neg	ecx
	mov	DWORD PTR _y_unit$[ebp], ecx

; 2150 : 		y_dir=-1;

	mov	DWORD PTR _y_dir$[ebp], -1

; 2151 : 	}
; 2152 : 	else

	jmp	SHORT $LN17@DrawClipLi
$LN18@DrawClipLi:

; 2153 : 	{
; 2154 : 		y_unit=surface->width;

	mov	edx, DWORD PTR _surface$[ebp]
	movsx	eax, WORD PTR [edx+4]
	mov	DWORD PTR _y_unit$[ebp], eax

; 2155 : 		y_dir=1;

	mov	DWORD PTR _y_dir$[ebp], 1
$LN17@DrawClipLi:

; 2156 : 	}
; 2157 : 
; 2158 : 	xdiff=x2-x1;

	mov	ecx, DWORD PTR _x2$[ebp]
	sub	ecx, DWORD PTR _x1$[ebp]
	mov	DWORD PTR _xdiff$[ebp], ecx

; 2159 : 	if(xdiff < 0)

	jns	SHORT $LN16@DrawClipLi

; 2160 : 	{
; 2161 : 		xdiff=-xdiff;

	mov	edx, DWORD PTR _xdiff$[ebp]
	neg	edx
	mov	DWORD PTR _xdiff$[ebp], edx

; 2162 : 		x_unit=-1;

	mov	DWORD PTR _x_unit$[ebp], -1

; 2163 : 	}
; 2164 : 	else

	jmp	SHORT $LN15@DrawClipLi
$LN16@DrawClipLi:

; 2165 : 		x_unit=1;

	mov	DWORD PTR _x_unit$[ebp], 1
$LN15@DrawClipLi:

; 2166 : 
; 2167 : 	offset=y1*surface->width+x1;

	mov	eax, DWORD PTR _surface$[ebp]
	movsx	ecx, WORD PTR [eax+4]
	imul	ecx, DWORD PTR _y1$[ebp]
	add	ecx, DWORD PTR _x1$[ebp]
	mov	DWORD PTR _offset$[ebp], ecx

; 2168 : 	error_term=0;

	mov	DWORD PTR _error_term$[ebp], 0

; 2169 : 
; 2170 : 	if(xdiff > ydiff)

	mov	edx, DWORD PTR _xdiff$[ebp]
	cmp	edx, DWORD PTR _ydiff$[ebp]
	jle	$LN14@DrawClipLi

; 2171 : 	{
; 2172 : 		length=xdiff+1;

	mov	eax, DWORD PTR _xdiff$[ebp]
	add	eax, 1
	mov	DWORD PTR _length$[ebp], eax

; 2173 : 		for(i=0;i<length;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@DrawClipLi
$LN12@DrawClipLi:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN13@DrawClipLi:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _length$[ebp]
	jge	SHORT $LN11@DrawClipLi

; 2174 : 		{
; 2175 : 			if( surface->bpp == 32 )//XX

	mov	eax, DWORD PTR _surface$[ebp]
	movzx	ecx, BYTE PTR [eax+8]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN10@DrawClipLi

; 2176 : 				((DWORD*)surface->mem)[offset] = RGB565toRGB8( color );

	movzx	edx, WORD PTR _color$[ebp]
	push	edx
	call	?RGB565toRGB8@@YAKG@Z			; RGB565toRGB8
	add	esp, 4
	mov	ecx, DWORD PTR _surface$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _offset$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 2177 : 			else

	jmp	SHORT $LN9@DrawClipLi
$LN10@DrawClipLi:

; 2178 : 			surface->mem[offset]=color;

	mov	edx, DWORD PTR _surface$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _offset$[ebp]
	mov	dx, WORD PTR _color$[ebp]
	mov	WORD PTR [eax+ecx*2], dx
$LN9@DrawClipLi:

; 2179 : 
; 2180 : 			error_term+=ydiff;

	mov	eax, DWORD PTR _error_term$[ebp]
	add	eax, DWORD PTR _ydiff$[ebp]
	mov	DWORD PTR _error_term$[ebp], eax

; 2181 : 
; 2182 : 			offset+=x_unit;

	mov	ecx, DWORD PTR _offset$[ebp]
	add	ecx, DWORD PTR _x_unit$[ebp]
	mov	DWORD PTR _offset$[ebp], ecx

; 2183 : 			x1+=x_unit;

	mov	edx, DWORD PTR _x1$[ebp]
	add	edx, DWORD PTR _x_unit$[ebp]
	mov	DWORD PTR _x1$[ebp], edx

; 2184 : 			if(error_term > xdiff)

	mov	eax, DWORD PTR _error_term$[ebp]
	cmp	eax, DWORD PTR _xdiff$[ebp]
	jle	SHORT $LN8@DrawClipLi

; 2185 : 			{
; 2186 : 				error_term-=xdiff;

	mov	ecx, DWORD PTR _error_term$[ebp]
	sub	ecx, DWORD PTR _xdiff$[ebp]
	mov	DWORD PTR _error_term$[ebp], ecx

; 2187 : 				offset+=y_unit;

	mov	edx, DWORD PTR _offset$[ebp]
	add	edx, DWORD PTR _y_unit$[ebp]
	mov	DWORD PTR _offset$[ebp], edx

; 2188 : 				y1+=y_dir;

	mov	eax, DWORD PTR _y1$[ebp]
	add	eax, DWORD PTR _y_dir$[ebp]
	mov	DWORD PTR _y1$[ebp], eax
$LN8@DrawClipLi:

; 2189 : 			}
; 2190 : 		}

	jmp	$LN12@DrawClipLi
$LN11@DrawClipLi:

; 2191 : 	}
; 2192 : 	else

	jmp	$LN21@DrawClipLi
$LN14@DrawClipLi:

; 2193 : 	{
; 2194 : 		length=ydiff+1;

	mov	ecx, DWORD PTR _ydiff$[ebp]
	add	ecx, 1
	mov	DWORD PTR _length$[ebp], ecx

; 2195 : 		for(i=0;i<length;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@DrawClipLi
$LN5@DrawClipLi:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN6@DrawClipLi:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _length$[ebp]
	jge	SHORT $LN21@DrawClipLi

; 2196 : 		{
; 2197 : 			if( surface->bpp == 32 )//XX

	mov	ecx, DWORD PTR _surface$[ebp]
	movzx	edx, BYTE PTR [ecx+8]
	cmp	edx, 32					; 00000020H
	jne	SHORT $LN3@DrawClipLi

; 2198 : 				((DWORD*)surface->mem)[offset] = RGB565toRGB8( color );

	movzx	eax, WORD PTR _color$[ebp]
	push	eax
	call	?RGB565toRGB8@@YAKG@Z			; RGB565toRGB8
	add	esp, 4
	mov	ecx, DWORD PTR _surface$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _offset$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 2199 : 			else

	jmp	SHORT $LN2@DrawClipLi
$LN3@DrawClipLi:

; 2200 : 			surface->mem[offset]=color;

	mov	edx, DWORD PTR _surface$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _offset$[ebp]
	mov	dx, WORD PTR _color$[ebp]
	mov	WORD PTR [eax+ecx*2], dx
$LN2@DrawClipLi:

; 2201 : 
; 2202 : 			error_term+=xdiff;

	mov	eax, DWORD PTR _error_term$[ebp]
	add	eax, DWORD PTR _xdiff$[ebp]
	mov	DWORD PTR _error_term$[ebp], eax

; 2203 : 			offset+=y_unit;

	mov	ecx, DWORD PTR _offset$[ebp]
	add	ecx, DWORD PTR _y_unit$[ebp]
	mov	DWORD PTR _offset$[ebp], ecx

; 2204 : 			y1+=y_dir;

	mov	edx, DWORD PTR _y1$[ebp]
	add	edx, DWORD PTR _y_dir$[ebp]
	mov	DWORD PTR _y1$[ebp], edx

; 2205 : 			if(error_term > 0)

	cmp	DWORD PTR _error_term$[ebp], 0
	jle	SHORT $LN1@DrawClipLi

; 2206 : 			{
; 2207 : 				error_term-=ydiff;

	mov	eax, DWORD PTR _error_term$[ebp]
	sub	eax, DWORD PTR _ydiff$[ebp]
	mov	DWORD PTR _error_term$[ebp], eax

; 2208 : 				offset+=x_unit;

	mov	ecx, DWORD PTR _offset$[ebp]
	add	ecx, DWORD PTR _x_unit$[ebp]
	mov	DWORD PTR _offset$[ebp], ecx

; 2209 : 				x1+=x_unit;

	mov	edx, DWORD PTR _x1$[ebp]
	add	edx, DWORD PTR _x_unit$[ebp]
	mov	DWORD PTR _x1$[ebp], edx
$LN1@DrawClipLi:

; 2210 : 			}
; 2211 : 		}

	jmp	$LN5@DrawClipLi
$LN21@DrawClipLi:

; 2212 : 	}
; 2213 : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?DrawClipLine@C_Window@@QAEXPAVSCREEN@@JJJJPAUUI95_RECT@@G@Z ENDP ; C_Window::DrawClipLine
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
_slope2$ = -12						; size = 4
_slope1$ = -8						; size = 4
_flag2$ = -2						; size = 1
_flag1$ = -1						; size = 1
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_x2$ = 16						; size = 4
_y2$ = 20						; size = 4
_clip$ = 24						; size = 4
?ClipLine@C_Window@@QAEHPAJ000PAUUI95_RECT@@@Z PROC	; C_Window::ClipLine
; _this$ = ecx

; 1985 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1986 : 	char flag1,flag2;
; 1987 : 	float slope1=0.0,slope2=0.0;  //! 

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _slope1$[ebp], xmm0
	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _slope2$[ebp], xmm0

; 1988 : 
; 1989 : 	flag1=0;

	mov	BYTE PTR _flag1$[ebp], 0

; 1990 : 	flag2=0;

	mov	BYTE PTR _flag2$[ebp], 0

; 1991 : 
; 1992 : 	if(*x1 < clip->left)

	mov	eax, DWORD PTR _x1$[ebp]
	mov	ecx, DWORD PTR _clip$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN49@ClipLine

; 1993 : 		flag1 |= LINE_CLIP_LEFT;

	movsx	eax, BYTE PTR _flag1$[ebp]
	or	eax, 1
	mov	BYTE PTR _flag1$[ebp], al
$LN49@ClipLine:

; 1994 : 	if(*x2 < clip->left)

	mov	ecx, DWORD PTR _x2$[ebp]
	mov	edx, DWORD PTR _clip$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jge	SHORT $LN48@ClipLine

; 1995 : 		flag2 |= LINE_CLIP_LEFT;

	movsx	ecx, BYTE PTR _flag2$[ebp]
	or	ecx, 1
	mov	BYTE PTR _flag2$[ebp], cl
$LN48@ClipLine:

; 1996 : 
; 1997 : 	if(*y1 < clip->top)

	mov	edx, DWORD PTR _y1$[ebp]
	mov	eax, DWORD PTR _clip$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $LN47@ClipLine

; 1998 : 		flag1 |= LINE_CLIP_TOP;

	movsx	edx, BYTE PTR _flag1$[ebp]
	or	edx, 4
	mov	BYTE PTR _flag1$[ebp], dl
$LN47@ClipLine:

; 1999 : 	if(*y2 < clip->top)

	mov	eax, DWORD PTR _y2$[ebp]
	mov	ecx, DWORD PTR _clip$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+4]
	jge	SHORT $LN46@ClipLine

; 2000 : 		flag2 |= LINE_CLIP_TOP;

	movsx	eax, BYTE PTR _flag2$[ebp]
	or	eax, 4
	mov	BYTE PTR _flag2$[ebp], al
$LN46@ClipLine:

; 2001 : 
; 2002 : 	if(*x1 > clip->right)

	mov	ecx, DWORD PTR _x1$[ebp]
	mov	edx, DWORD PTR _clip$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx+8]
	jle	SHORT $LN45@ClipLine

; 2003 : 		flag1 |= LINE_CLIP_RIGHT;

	movsx	ecx, BYTE PTR _flag1$[ebp]
	or	ecx, 2
	mov	BYTE PTR _flag1$[ebp], cl
$LN45@ClipLine:

; 2004 : 	if(*x2 > clip->right)

	mov	edx, DWORD PTR _x2$[ebp]
	mov	eax, DWORD PTR _clip$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax+8]
	jle	SHORT $LN44@ClipLine

; 2005 : 		flag2 |= LINE_CLIP_RIGHT;

	movsx	edx, BYTE PTR _flag2$[ebp]
	or	edx, 2
	mov	BYTE PTR _flag2$[ebp], dl
$LN44@ClipLine:

; 2006 : 
; 2007 : 	if(*y1 > clip->bottom)

	mov	eax, DWORD PTR _y1$[ebp]
	mov	ecx, DWORD PTR _clip$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+12]
	jle	SHORT $LN43@ClipLine

; 2008 : 		flag1 |= LINE_CLIP_BOTTOM;

	movsx	eax, BYTE PTR _flag1$[ebp]
	or	eax, 8
	mov	BYTE PTR _flag1$[ebp], al
$LN43@ClipLine:

; 2009 : 	if(*y2 > clip->bottom)

	mov	ecx, DWORD PTR _y2$[ebp]
	mov	edx, DWORD PTR _clip$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx+12]
	jle	SHORT $LN42@ClipLine

; 2010 : 		flag2 |= LINE_CLIP_BOTTOM;

	movsx	ecx, BYTE PTR _flag2$[ebp]
	or	ecx, 8
	mov	BYTE PTR _flag2$[ebp], cl
$LN42@ClipLine:

; 2011 : 
; 2012 : 	if(!flag1 && !flag2) // return, because both points are inside clip rect

	movsx	edx, BYTE PTR _flag1$[ebp]
	test	edx, edx
	jne	SHORT $LN41@ClipLine
	movsx	eax, BYTE PTR _flag2$[ebp]
	test	eax, eax
	jne	SHORT $LN41@ClipLine

; 2013 : 		return(TRUE);

	mov	eax, 1
	jmp	$LN50@ClipLine
$LN41@ClipLine:

; 2014 : 
; 2015 : 	if(((flag1 & flag2) & LINE_CLIP_LEFT) || // If both points are on the same side of the clip rect... don't draw
; 2016 : 	   ((flag1 & flag2) & LINE_CLIP_TOP) ||
; 2017 : 	   ((flag1 & flag2) & LINE_CLIP_RIGHT) ||
; 2018 : 	   ((flag1 & flag2) & LINE_CLIP_BOTTOM))

	movsx	ecx, BYTE PTR _flag1$[ebp]
	movsx	edx, BYTE PTR _flag2$[ebp]
	and	ecx, edx
	and	ecx, 1
	jne	SHORT $LN39@ClipLine
	movsx	eax, BYTE PTR _flag1$[ebp]
	movsx	ecx, BYTE PTR _flag2$[ebp]
	and	eax, ecx
	and	eax, 4
	jne	SHORT $LN39@ClipLine
	movsx	edx, BYTE PTR _flag1$[ebp]
	movsx	eax, BYTE PTR _flag2$[ebp]
	and	edx, eax
	and	edx, 2
	jne	SHORT $LN39@ClipLine
	movsx	ecx, BYTE PTR _flag1$[ebp]
	movsx	edx, BYTE PTR _flag2$[ebp]
	and	ecx, edx
	and	ecx, 8
	je	SHORT $LN40@ClipLine
$LN39@ClipLine:

; 2019 : 		return(FALSE);

	xor	eax, eax
	jmp	$LN50@ClipLine
$LN40@ClipLine:

; 2020 : 
; 2021 : 	if(*x1 == *x2) // if x's are the same... no math required

	mov	eax, DWORD PTR _x1$[ebp]
	mov	ecx, DWORD PTR _x2$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN38@ClipLine

; 2022 : 	{
; 2023 : 		if(flag1 & LINE_CLIP_TOP)

	movsx	eax, BYTE PTR _flag1$[ebp]
	and	eax, 4
	je	SHORT $LN37@ClipLine

; 2024 : 			*y1=clip->top;

	mov	ecx, DWORD PTR _y1$[ebp]
	mov	edx, DWORD PTR _clip$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN35@ClipLine
$LN37@ClipLine:

; 2025 : 		else if(flag1 & LINE_CLIP_BOTTOM)

	movsx	ecx, BYTE PTR _flag1$[ebp]
	and	ecx, 8
	je	SHORT $LN35@ClipLine

; 2026 : 			*y1=clip->bottom;

	mov	edx, DWORD PTR _y1$[ebp]
	mov	eax, DWORD PTR _clip$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx], ecx
$LN35@ClipLine:

; 2027 : 
; 2028 : 		if(flag2 & LINE_CLIP_TOP)

	movsx	edx, BYTE PTR _flag2$[ebp]
	and	edx, 4
	je	SHORT $LN34@ClipLine

; 2029 : 			*y2=clip->top;

	mov	eax, DWORD PTR _y2$[ebp]
	mov	ecx, DWORD PTR _clip$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN32@ClipLine
$LN34@ClipLine:

; 2030 : 		else if(flag2 & LINE_CLIP_BOTTOM)

	movsx	eax, BYTE PTR _flag2$[ebp]
	and	eax, 8
	je	SHORT $LN32@ClipLine

; 2031 : 			*y2=clip->bottom;

	mov	ecx, DWORD PTR _y2$[ebp]
	mov	edx, DWORD PTR _clip$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx], eax
$LN32@ClipLine:

; 2032 : 	}

	jmp	$LN3@ClipLine
$LN38@ClipLine:

; 2033 : 	else if(*y1 == *y2)

	mov	ecx, DWORD PTR _y1$[ebp]
	mov	edx, DWORD PTR _y2$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN30@ClipLine

; 2034 : 	{
; 2035 : 		if(flag1 & LINE_CLIP_LEFT)

	movsx	ecx, BYTE PTR _flag1$[ebp]
	and	ecx, 1
	je	SHORT $LN29@ClipLine

; 2036 : 			*x1=clip->left;

	mov	edx, DWORD PTR _x1$[ebp]
	mov	eax, DWORD PTR _clip$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN27@ClipLine
$LN29@ClipLine:

; 2037 : 		else if(flag1 & LINE_CLIP_RIGHT)

	movsx	edx, BYTE PTR _flag1$[ebp]
	and	edx, 2
	je	SHORT $LN27@ClipLine

; 2038 : 			*x1=clip->right;

	mov	eax, DWORD PTR _x1$[ebp]
	mov	ecx, DWORD PTR _clip$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], edx
$LN27@ClipLine:

; 2039 : 
; 2040 : 		if(flag2 & LINE_CLIP_LEFT)

	movsx	eax, BYTE PTR _flag2$[ebp]
	and	eax, 1
	je	SHORT $LN26@ClipLine

; 2041 : 			*x2=clip->left;

	mov	ecx, DWORD PTR _x2$[ebp]
	mov	edx, DWORD PTR _clip$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN24@ClipLine
$LN26@ClipLine:

; 2042 : 		else if(flag2 & LINE_CLIP_RIGHT)

	movsx	ecx, BYTE PTR _flag2$[ebp]
	and	ecx, 2
	je	SHORT $LN24@ClipLine

; 2043 : 			*x2=clip->right;

	mov	edx, DWORD PTR _x2$[ebp]
	mov	eax, DWORD PTR _clip$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], ecx
$LN24@ClipLine:

; 2044 : 	}
; 2045 : 	else

	jmp	$LN3@ClipLine
$LN30@ClipLine:

; 2046 : 	{
; 2047 : 		if((flag1 | flag2) & (LINE_CLIP_LEFT|LINE_CLIP_RIGHT))

	movsx	edx, BYTE PTR _flag1$[ebp]
	movsx	eax, BYTE PTR _flag2$[ebp]
	or	edx, eax
	and	edx, 3
	je	SHORT $LN22@ClipLine

; 2048 : 			slope1=(float)(*y2 - *y1) / (float)(*x2 - *x1);

	mov	ecx, DWORD PTR _y2$[ebp]
	mov	edx, DWORD PTR _y1$[ebp]
	mov	eax, DWORD PTR [ecx]
	sub	eax, DWORD PTR [edx]
	cvtsi2ss xmm0, eax
	mov	ecx, DWORD PTR _x2$[ebp]
	mov	edx, DWORD PTR _x1$[ebp]
	mov	eax, DWORD PTR [ecx]
	sub	eax, DWORD PTR [edx]
	cvtsi2ss xmm1, eax
	divss	xmm0, xmm1
	movss	DWORD PTR _slope1$[ebp], xmm0
$LN22@ClipLine:

; 2049 : 		if((flag1 | flag2) & (LINE_CLIP_TOP|LINE_CLIP_BOTTOM))

	movsx	ecx, BYTE PTR _flag1$[ebp]
	movsx	edx, BYTE PTR _flag2$[ebp]
	or	ecx, edx
	and	ecx, 12					; 0000000cH
	je	SHORT $LN21@ClipLine

; 2050 : 			slope2=(float)(*x2 - *x1) / (float)(*y2 - *y1);

	mov	eax, DWORD PTR _x2$[ebp]
	mov	ecx, DWORD PTR _x1$[ebp]
	mov	edx, DWORD PTR [eax]
	sub	edx, DWORD PTR [ecx]
	cvtsi2ss xmm0, edx
	mov	eax, DWORD PTR _y2$[ebp]
	mov	ecx, DWORD PTR _y1$[ebp]
	mov	edx, DWORD PTR [eax]
	sub	edx, DWORD PTR [ecx]
	cvtsi2ss xmm1, edx
	divss	xmm0, xmm1
	movss	DWORD PTR _slope2$[ebp], xmm0
$LN21@ClipLine:

; 2051 : 
; 2052 : 		if(flag1 & LINE_CLIP_LEFT)

	movsx	eax, BYTE PTR _flag1$[ebp]
	and	eax, 1
	je	SHORT $LN20@ClipLine

; 2053 : 		{
; 2054 : 			*y1=FloatToInt32(*y1 + (clip->left - *x1) * slope1);

	mov	ecx, DWORD PTR _y1$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _clip$[ebp]
	mov	eax, DWORD PTR _x1$[ebp]
	mov	ecx, DWORD PTR [edx]
	sub	ecx, DWORD PTR [eax]
	cvtsi2ss xmm1, ecx
	mulss	xmm1, DWORD PTR _slope1$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	edx, DWORD PTR _y1$[ebp]
	mov	DWORD PTR [edx], eax

; 2055 : 			*x1=clip->left;

	mov	eax, DWORD PTR _x1$[ebp]
	mov	ecx, DWORD PTR _clip$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	jmp	$LN14@ClipLine
$LN20@ClipLine:

; 2056 : 		}
; 2057 : 		else if(flag1 & LINE_CLIP_RIGHT)

	movsx	eax, BYTE PTR _flag1$[ebp]
	and	eax, 2
	je	SHORT $LN18@ClipLine

; 2058 : 		{
; 2059 : 			*y1=FloatToInt32(*y1 + (clip->right - *x1) * slope1);

	mov	ecx, DWORD PTR _y1$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _clip$[ebp]
	mov	eax, DWORD PTR _x1$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax]
	cvtsi2ss xmm1, ecx
	mulss	xmm1, DWORD PTR _slope1$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	edx, DWORD PTR _y1$[ebp]
	mov	DWORD PTR [edx], eax

; 2060 : 			*x1=clip->right;

	mov	eax, DWORD PTR _x1$[ebp]
	mov	ecx, DWORD PTR _clip$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], edx
	jmp	$LN14@ClipLine
$LN18@ClipLine:

; 2061 : 		}
; 2062 : 		else if(flag1 & LINE_CLIP_TOP)

	movsx	eax, BYTE PTR _flag1$[ebp]
	and	eax, 4
	je	SHORT $LN16@ClipLine

; 2063 : 		{
; 2064 : 			*x1=FloatToInt32(*x1 + (clip->top - *y1) * slope2);

	mov	ecx, DWORD PTR _x1$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _clip$[ebp]
	mov	eax, DWORD PTR _y1$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	sub	ecx, DWORD PTR [eax]
	cvtsi2ss xmm1, ecx
	mulss	xmm1, DWORD PTR _slope2$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	edx, DWORD PTR _x1$[ebp]
	mov	DWORD PTR [edx], eax

; 2065 : 			*y1=clip->top;

	mov	eax, DWORD PTR _y1$[ebp]
	mov	ecx, DWORD PTR _clip$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN14@ClipLine
$LN16@ClipLine:

; 2066 : 		}
; 2067 : 		else if(flag1 & LINE_CLIP_BOTTOM)

	movsx	eax, BYTE PTR _flag1$[ebp]
	and	eax, 8
	je	SHORT $LN14@ClipLine

; 2068 : 		{
; 2069 : 			*x1=FloatToInt32(*x1 + (clip->bottom - *y1) * slope2);

	mov	ecx, DWORD PTR _x1$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _clip$[ebp]
	mov	eax, DWORD PTR _y1$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax]
	cvtsi2ss xmm1, ecx
	mulss	xmm1, DWORD PTR _slope2$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	edx, DWORD PTR _x1$[ebp]
	mov	DWORD PTR [edx], eax

; 2070 : 			*y1=clip->bottom;

	mov	eax, DWORD PTR _y1$[ebp]
	mov	ecx, DWORD PTR _clip$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax], edx
$LN14@ClipLine:

; 2071 : 		}
; 2072 : 
; 2073 : 		if(flag2 & LINE_CLIP_LEFT)

	movsx	eax, BYTE PTR _flag2$[ebp]
	and	eax, 1
	je	SHORT $LN13@ClipLine

; 2074 : 		{
; 2075 : 			*y2=FloatToInt32(*y2 + (clip->left - *x2) * slope1);

	mov	ecx, DWORD PTR _y2$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _clip$[ebp]
	mov	eax, DWORD PTR _x2$[ebp]
	mov	ecx, DWORD PTR [edx]
	sub	ecx, DWORD PTR [eax]
	cvtsi2ss xmm1, ecx
	mulss	xmm1, DWORD PTR _slope1$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	edx, DWORD PTR _y2$[ebp]
	mov	DWORD PTR [edx], eax

; 2076 : 			*x2=clip->left;

	mov	eax, DWORD PTR _x2$[ebp]
	mov	ecx, DWORD PTR _clip$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	jmp	$LN7@ClipLine
$LN13@ClipLine:

; 2077 : 		}
; 2078 : 		else if(flag2 & LINE_CLIP_RIGHT)

	movsx	eax, BYTE PTR _flag2$[ebp]
	and	eax, 2
	je	SHORT $LN11@ClipLine

; 2079 : 		{
; 2080 : 			*y2=FloatToInt32(*y2 + (clip->right - *x2) * slope1);

	mov	ecx, DWORD PTR _y2$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _clip$[ebp]
	mov	eax, DWORD PTR _x2$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax]
	cvtsi2ss xmm1, ecx
	mulss	xmm1, DWORD PTR _slope1$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	edx, DWORD PTR _y2$[ebp]
	mov	DWORD PTR [edx], eax

; 2081 : 			*x2=clip->right;

	mov	eax, DWORD PTR _x2$[ebp]
	mov	ecx, DWORD PTR _clip$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], edx
	jmp	$LN7@ClipLine
$LN11@ClipLine:

; 2082 : 		}
; 2083 : 		else if(flag2 & LINE_CLIP_TOP)

	movsx	eax, BYTE PTR _flag2$[ebp]
	and	eax, 4
	je	SHORT $LN9@ClipLine

; 2084 : 		{
; 2085 : 			*x2=FloatToInt32(*x2 + (clip->top - *y2) * slope2);

	mov	ecx, DWORD PTR _x2$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _clip$[ebp]
	mov	eax, DWORD PTR _y2$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	sub	ecx, DWORD PTR [eax]
	cvtsi2ss xmm1, ecx
	mulss	xmm1, DWORD PTR _slope2$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	edx, DWORD PTR _x2$[ebp]
	mov	DWORD PTR [edx], eax

; 2086 : 			*y2=clip->top;

	mov	eax, DWORD PTR _y2$[ebp]
	mov	ecx, DWORD PTR _clip$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN7@ClipLine
$LN9@ClipLine:

; 2087 : 		}
; 2088 : 		else if(flag2 & LINE_CLIP_BOTTOM)

	movsx	eax, BYTE PTR _flag2$[ebp]
	and	eax, 8
	je	SHORT $LN7@ClipLine

; 2089 : 		{
; 2090 : 			*x2=FloatToInt32(*x2 + (clip->bottom - *y2) * slope2);

	mov	ecx, DWORD PTR _x2$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx]
	mov	edx, DWORD PTR _clip$[ebp]
	mov	eax, DWORD PTR _y2$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax]
	cvtsi2ss xmm1, ecx
	mulss	xmm1, DWORD PTR _slope2$[ebp]
	addss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?FloatToInt32@@YAHM@Z			; FloatToInt32
	add	esp, 4
	mov	edx, DWORD PTR _x2$[ebp]
	mov	DWORD PTR [edx], eax

; 2091 : 			*y2=clip->bottom;

	mov	eax, DWORD PTR _y2$[ebp]
	mov	ecx, DWORD PTR _clip$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax], edx
$LN7@ClipLine:

; 2092 : 		}
; 2093 : 
; 2094 : 		if((*x1 < clip->left || *x2 < clip->left) || (*x1 > clip->right || *x2 > clip->right))

	mov	eax, DWORD PTR _x1$[ebp]
	mov	ecx, DWORD PTR _clip$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN4@ClipLine
	mov	eax, DWORD PTR _x2$[ebp]
	mov	ecx, DWORD PTR _clip$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN4@ClipLine
	mov	eax, DWORD PTR _x1$[ebp]
	mov	ecx, DWORD PTR _clip$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+8]
	jg	SHORT $LN4@ClipLine
	mov	eax, DWORD PTR _x2$[ebp]
	mov	ecx, DWORD PTR _clip$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+8]
	jle	SHORT $LN6@ClipLine
$LN4@ClipLine:

; 2095 : 			return(FALSE);

	xor	eax, eax
	jmp	SHORT $LN50@ClipLine
$LN6@ClipLine:

; 2096 : 		if((*y1 < clip->top || *y2 < clip->top) || (*y1 > clip->bottom || *y2 > clip->bottom))

	mov	eax, DWORD PTR _y1$[ebp]
	mov	ecx, DWORD PTR _clip$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+4]
	jl	SHORT $LN1@ClipLine
	mov	eax, DWORD PTR _y2$[ebp]
	mov	ecx, DWORD PTR _clip$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+4]
	jl	SHORT $LN1@ClipLine
	mov	eax, DWORD PTR _y1$[ebp]
	mov	ecx, DWORD PTR _clip$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+12]
	jg	SHORT $LN1@ClipLine
	mov	eax, DWORD PTR _y2$[ebp]
	mov	ecx, DWORD PTR _clip$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+12]
	jle	SHORT $LN3@ClipLine
$LN1@ClipLine:

; 2097 : 			return(FALSE);

	xor	eax, eax
	jmp	SHORT $LN50@ClipLine
$LN3@ClipLine:

; 2098 : 	}
; 2099 : 	return(TRUE);

	mov	eax, 1
$LN50@ClipLine:

; 2100 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?ClipLine@C_Window@@QAEHPAJ000PAUUI95_RECT@@@Z ENDP	; C_Window::ClipLine
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_drawcolor$ = -28					; size = 2
_this$ = -24						; size = 4
_clipper$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_surface$ = 8						; size = 4
_color$ = 12						; size = 4
_x1$ = 16						; size = 4
_y1$ = 20						; size = 4
_x2$ = 24						; size = 4
_y2$ = 28						; size = 4
_Flags$ = 32						; size = 4
_Client$ = 36						; size = 4
_clip$ = 40						; size = 4
?DrawLine@C_Window@@QAEXPAVSCREEN@@KJJJJJJPAUUI95_RECT@@@Z PROC ; C_Window::DrawLine
; _this$ = ecx

; 2103 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 2104 : 	WORD drawcolor;
; 2105 : 	UI95_RECT clipper;
; 2106 : 
; 2107 : 	clipper=*clip;

	mov	eax, DWORD PTR _clip$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _clipper$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _clipper$[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _clipper$[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _clipper$[ebp+12], edx

; 2108 : 
; 2109 : 	if(!(Flags & C_BIT_ABSOLUTE))

	mov	eax, DWORD PTR _Flags$[ebp]
	and	eax, 262144				; 00040000H
	jne	$LN5@DrawLine

; 2110 : 	{
; 2111 : 		x1+=VX_[Client];

	mov	ecx, DWORD PTR _Client$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _x1$[ebp]
	add	eax, DWORD PTR [edx+ecx*4+480]
	mov	DWORD PTR _x1$[ebp], eax

; 2112 : 		y1+=VY_[Client];

	mov	ecx, DWORD PTR _Client$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _y1$[ebp]
	add	eax, DWORD PTR [edx+ecx*4+512]
	mov	DWORD PTR _y1$[ebp], eax

; 2113 : 		x2+=VX_[Client];

	mov	ecx, DWORD PTR _Client$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _x2$[ebp]
	add	eax, DWORD PTR [edx+ecx*4+480]
	mov	DWORD PTR _x2$[ebp], eax

; 2114 : 		y2+=VY_[Client];

	mov	ecx, DWORD PTR _Client$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _y2$[ebp]
	add	eax, DWORD PTR [edx+ecx*4+512]
	mov	DWORD PTR _y2$[ebp], eax

; 2115 : 		if(clipper.left < ClientArea_[Client].left) clipper.left=ClientArea_[Client].left;

	mov	ecx, DWORD PTR _Client$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _clipper$[ebp]
	cmp	eax, DWORD PTR [edx+ecx+168]
	jge	SHORT $LN4@DrawLine
	mov	ecx, DWORD PTR _Client$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+168]
	mov	DWORD PTR _clipper$[ebp], eax
$LN4@DrawLine:

; 2116 : 		if(clipper.top < ClientArea_[Client].top) clipper.top=ClientArea_[Client].top;

	mov	ecx, DWORD PTR _Client$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _clipper$[ebp+4]
	cmp	eax, DWORD PTR [edx+ecx+172]
	jge	SHORT $LN3@DrawLine
	mov	ecx, DWORD PTR _Client$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+172]
	mov	DWORD PTR _clipper$[ebp+4], eax
$LN3@DrawLine:

; 2117 : 		if(clipper.right > ClientArea_[Client].right) clipper.right=ClientArea_[Client].right;

	mov	ecx, DWORD PTR _Client$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _clipper$[ebp+8]
	cmp	eax, DWORD PTR [edx+ecx+176]
	jle	SHORT $LN2@DrawLine
	mov	ecx, DWORD PTR _Client$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+176]
	mov	DWORD PTR _clipper$[ebp+8], eax
$LN2@DrawLine:

; 2118 : 		if(clipper.bottom > ClientArea_[Client].bottom) clipper.bottom=ClientArea_[Client].bottom;

	mov	ecx, DWORD PTR _Client$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _clipper$[ebp+12]
	cmp	eax, DWORD PTR [edx+ecx+180]
	jle	SHORT $LN5@DrawLine
	mov	ecx, DWORD PTR _Client$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+180]
	mov	DWORD PTR _clipper$[ebp+12], eax
$LN5@DrawLine:

; 2119 : 	}
; 2120 : 	x1+=GetX();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetX@C_Window@@QAEFXZ			; C_Window::GetX
	movsx	ecx, ax
	add	ecx, DWORD PTR _x1$[ebp]
	mov	DWORD PTR _x1$[ebp], ecx

; 2121 : 	y1+=GetY();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetY@C_Window@@QAEFXZ			; C_Window::GetY
	movsx	edx, ax
	add	edx, DWORD PTR _y1$[ebp]
	mov	DWORD PTR _y1$[ebp], edx

; 2122 : 	x2+=GetX();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetX@C_Window@@QAEFXZ			; C_Window::GetX
	cwde
	add	eax, DWORD PTR _x2$[ebp]
	mov	DWORD PTR _x2$[ebp], eax

; 2123 : 	y2+=GetY();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetY@C_Window@@QAEFXZ			; C_Window::GetY
	movsx	ecx, ax
	add	ecx, DWORD PTR _y2$[ebp]
	mov	DWORD PTR _y2$[ebp], ecx

; 2124 : 	clipper.left+=GetX();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetX@C_Window@@QAEFXZ			; C_Window::GetX
	movsx	edx, ax
	add	edx, DWORD PTR _clipper$[ebp]
	mov	DWORD PTR _clipper$[ebp], edx

; 2125 : 	clipper.top+=GetY();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetY@C_Window@@QAEFXZ			; C_Window::GetY
	cwde
	add	eax, DWORD PTR _clipper$[ebp+4]
	mov	DWORD PTR _clipper$[ebp+4], eax

; 2126 : 	clipper.right+=GetX();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetX@C_Window@@QAEFXZ			; C_Window::GetX
	movsx	ecx, ax
	add	ecx, DWORD PTR _clipper$[ebp+8]
	mov	DWORD PTR _clipper$[ebp+8], ecx

; 2127 : 	clipper.bottom+=GetY();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetY@C_Window@@QAEFXZ			; C_Window::GetY
	movsx	edx, ax
	add	edx, DWORD PTR _clipper$[ebp+12]
	mov	DWORD PTR _clipper$[ebp+12], edx

; 2128 : 
; 2129 : 	drawcolor=(WORD)UI95_RGB24Bit(color);

	mov	eax, DWORD PTR _color$[ebp]
	push	eax
	call	?UI95_RGB24Bit@@YAGK@Z			; UI95_RGB24Bit
	add	esp, 4
	mov	WORD PTR _drawcolor$[ebp], ax

; 2130 : 	DrawClipLine(surface,x1,y1,x2,y2,&clipper,drawcolor);

	movzx	ecx, WORD PTR _drawcolor$[ebp]
	push	ecx
	lea	edx, DWORD PTR _clipper$[ebp]
	push	edx
	mov	eax, DWORD PTR _y2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y1$[ebp]
	push	edx
	mov	eax, DWORD PTR _x1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _surface$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DrawClipLine@C_Window@@QAEXPAVSCREEN@@JJJJPAUUI95_RECT@@G@Z ; C_Window::DrawClipLine

; 2131 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
?DrawLine@C_Window@@QAEXPAVSCREEN@@KJJJJJJPAUUI95_RECT@@@Z ENDP ; C_Window::DrawLine
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_x2$ = 16						; size = 4
_y2$ = 20						; size = 4
_minx$ = 24						; size = 4
_miny$ = 28						; size = 4
_maxx$ = 32						; size = 4
_maxy$ = 36						; size = 4
?CheckLine@C_Window@@QAEHJJJJJJJJ@Z PROC		; C_Window::CheckLine
; _this$ = ecx

; 1968 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1969 : 	if(x1 < minx && x2 < minx) return(FALSE);

	mov	eax, DWORD PTR _x1$[ebp]
	cmp	eax, DWORD PTR _minx$[ebp]
	jge	SHORT $LN4@CheckLine
	mov	ecx, DWORD PTR _x2$[ebp]
	cmp	ecx, DWORD PTR _minx$[ebp]
	jge	SHORT $LN4@CheckLine
	xor	eax, eax
	jmp	SHORT $LN5@CheckLine
$LN4@CheckLine:

; 1970 : 	if(y1 < miny && y2 < miny) return(FALSE);

	mov	edx, DWORD PTR _y1$[ebp]
	cmp	edx, DWORD PTR _miny$[ebp]
	jge	SHORT $LN3@CheckLine
	mov	eax, DWORD PTR _y2$[ebp]
	cmp	eax, DWORD PTR _miny$[ebp]
	jge	SHORT $LN3@CheckLine
	xor	eax, eax
	jmp	SHORT $LN5@CheckLine
$LN3@CheckLine:

; 1971 : 	if(x1 > maxx && x2 > maxx) return(FALSE);

	mov	ecx, DWORD PTR _x1$[ebp]
	cmp	ecx, DWORD PTR _maxx$[ebp]
	jle	SHORT $LN2@CheckLine
	mov	edx, DWORD PTR _x2$[ebp]
	cmp	edx, DWORD PTR _maxx$[ebp]
	jle	SHORT $LN2@CheckLine
	xor	eax, eax
	jmp	SHORT $LN5@CheckLine
$LN2@CheckLine:

; 1972 : 	if(y1 > maxy && y2 > maxy) return(FALSE);

	mov	eax, DWORD PTR _y1$[ebp]
	cmp	eax, DWORD PTR _maxy$[ebp]
	jle	SHORT $LN1@CheckLine
	mov	ecx, DWORD PTR _y2$[ebp]
	cmp	ecx, DWORD PTR _maxy$[ebp]
	jle	SHORT $LN1@CheckLine
	xor	eax, eax
	jmp	SHORT $LN5@CheckLine
$LN1@CheckLine:

; 1973 : 	return(TRUE);

	mov	eax, 1
$LN5@CheckLine:

; 1974 : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?CheckLine@C_Window@@QAEHJJJJJJJJ@Z ENDP		; C_Window::CheckLine
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -40						; size = 4
_s$ = -36						; size = 16
_rect$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_surface$ = 8						; size = 4
_color$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_h$ = 24						; size = 4
_Flags$ = 28						; size = 4
_Client$ = 32						; size = 4
_clip$ = 36						; size = 4
?DrawVLine@C_Window@@QAEXPAVSCREEN@@KJJJJJPAUUI95_RECT@@@Z PROC ; C_Window::DrawVLine
; _this$ = ecx

; 1938 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1939 : 	UI95_RECT rect,s;
; 1940 : 
; 1941 : 	rect.left=x;

	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR _rect$[ebp], eax

; 1942 : 	rect.right=x+1;

	mov	ecx, DWORD PTR _x$[ebp]
	add	ecx, 1
	mov	DWORD PTR _rect$[ebp+8], ecx

; 1943 : 	rect.top=y;

	mov	edx, DWORD PTR _y$[ebp]
	mov	DWORD PTR _rect$[ebp+4], edx

; 1944 : 	rect.bottom=y+h;

	mov	eax, DWORD PTR _y$[ebp]
	add	eax, DWORD PTR _h$[ebp]
	mov	DWORD PTR _rect$[ebp+12], eax

; 1945 : 	s = rect; // JPO - initialise to something.

	mov	ecx, DWORD PTR _rect$[ebp]
	mov	DWORD PTR _s$[ebp], ecx
	mov	edx, DWORD PTR _rect$[ebp+4]
	mov	DWORD PTR _s$[ebp+4], edx
	mov	eax, DWORD PTR _rect$[ebp+8]
	mov	DWORD PTR _s$[ebp+8], eax
	mov	ecx, DWORD PTR _rect$[ebp+12]
	mov	DWORD PTR _s$[ebp+12], ecx

; 1946 : 
; 1947 : 	if(Flags & C_BIT_ABSOLUTE)

	mov	edx, DWORD PTR _Flags$[ebp]
	and	edx, 262144				; 00040000H
	je	SHORT $LN5@DrawVLine

; 1948 : 	{
; 1949 : 		if(!ClipToArea(&s,&rect,&Area_))

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 112				; 00000070H
	push	eax
	lea	ecx, DWORD PTR _rect$[ebp]
	push	ecx
	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClipToArea@C_Window@@QAEHPAUUI95_RECT@@00@Z ; C_Window::ClipToArea
	test	eax, eax
	jne	SHORT $LN4@DrawVLine

; 1950 : 			return;

	jmp	$LN6@DrawVLine
$LN4@DrawVLine:

; 1951 : 	}
; 1952 : 	else

	jmp	SHORT $LN3@DrawVLine
$LN5@DrawVLine:

; 1953 : 	{
; 1954 : 		rect.left+=VX_[Client];

	mov	eax, DWORD PTR _Client$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _rect$[ebp]
	add	edx, DWORD PTR [ecx+eax*4+480]
	mov	DWORD PTR _rect$[ebp], edx

; 1955 : 		rect.top+=VY_[Client];

	mov	eax, DWORD PTR _Client$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _rect$[ebp+4]
	add	edx, DWORD PTR [ecx+eax*4+512]
	mov	DWORD PTR _rect$[ebp+4], edx

; 1956 : 		rect.right+=VX_[Client];

	mov	eax, DWORD PTR _Client$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _rect$[ebp+8]
	add	edx, DWORD PTR [ecx+eax*4+480]
	mov	DWORD PTR _rect$[ebp+8], edx

; 1957 : 		rect.bottom+=VY_[Client];

	mov	eax, DWORD PTR _Client$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _rect$[ebp+12]
	add	edx, DWORD PTR [ecx+eax*4+512]
	mov	DWORD PTR _rect$[ebp+12], edx

; 1958 : 		if(!ClipToArea(&s,&rect,&ClientArea_[Client]))

	mov	eax, DWORD PTR _Client$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+168]
	push	edx
	lea	eax, DWORD PTR _rect$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClipToArea@C_Window@@QAEHPAUUI95_RECT@@00@Z ; C_Window::ClipToArea
	test	eax, eax
	jne	SHORT $LN3@DrawVLine

; 1959 : 			return;

	jmp	SHORT $LN6@DrawVLine
$LN3@DrawVLine:

; 1960 : 	}
; 1961 : 	if(!ClipToArea(&s,&rect,clip))

	mov	edx, DWORD PTR _clip$[ebp]
	push	edx
	lea	eax, DWORD PTR _rect$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClipToArea@C_Window@@QAEHPAUUI95_RECT@@00@Z ; C_Window::ClipToArea
	test	eax, eax
	jne	SHORT $LN1@DrawVLine

; 1962 : 		return;

	jmp	SHORT $LN6@DrawVLine
$LN1@DrawVLine:

; 1963 : 
; 1964 : 	BlitFill(surface,color,&rect,C_BIT_ABSOLUTE,0);

	push	0
	push	262144					; 00040000H
	lea	edx, DWORD PTR _rect$[ebp]
	push	edx
	mov	eax, DWORD PTR _color$[ebp]
	push	eax
	mov	ecx, DWORD PTR _surface$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BlitFill@C_Window@@QAEXPAVSCREEN@@KPAUUI95_RECT@@JJ@Z ; C_Window::BlitFill
$LN6@DrawVLine:

; 1965 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?DrawVLine@C_Window@@QAEXPAVSCREEN@@KJJJJJPAUUI95_RECT@@@Z ENDP ; C_Window::DrawVLine
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -40						; size = 4
_s$ = -36						; size = 16
_rect$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_surface$ = 8						; size = 4
_color$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_w$ = 24						; size = 4
_Flags$ = 28						; size = 4
_Client$ = 32						; size = 4
_clip$ = 36						; size = 4
?DrawHLine@C_Window@@QAEXPAVSCREEN@@KJJJJJPAUUI95_RECT@@@Z PROC ; C_Window::DrawHLine
; _this$ = ecx

; 1907 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1908 : 	UI95_RECT rect,s;
; 1909 : 
; 1910 : 	rect.left=x;

	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR _rect$[ebp], eax

; 1911 : 	rect.right=x+w;

	mov	ecx, DWORD PTR _x$[ebp]
	add	ecx, DWORD PTR _w$[ebp]
	mov	DWORD PTR _rect$[ebp+8], ecx

; 1912 : 	rect.top=y;

	mov	edx, DWORD PTR _y$[ebp]
	mov	DWORD PTR _rect$[ebp+4], edx

; 1913 : 	rect.bottom=y+1;

	mov	eax, DWORD PTR _y$[ebp]
	add	eax, 1
	mov	DWORD PTR _rect$[ebp+12], eax

; 1914 : 	s = rect; // JPO initialise to something

	mov	ecx, DWORD PTR _rect$[ebp]
	mov	DWORD PTR _s$[ebp], ecx
	mov	edx, DWORD PTR _rect$[ebp+4]
	mov	DWORD PTR _s$[ebp+4], edx
	mov	eax, DWORD PTR _rect$[ebp+8]
	mov	DWORD PTR _s$[ebp+8], eax
	mov	ecx, DWORD PTR _rect$[ebp+12]
	mov	DWORD PTR _s$[ebp+12], ecx

; 1915 : 
; 1916 : 	if(Flags & C_BIT_ABSOLUTE)

	mov	edx, DWORD PTR _Flags$[ebp]
	and	edx, 262144				; 00040000H
	je	SHORT $LN6@DrawHLine

; 1917 : 	{
; 1918 : 		if(!ClipToArea(&s,&rect,&Area_))

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 112				; 00000070H
	push	eax
	lea	ecx, DWORD PTR _rect$[ebp]
	push	ecx
	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClipToArea@C_Window@@QAEHPAUUI95_RECT@@00@Z ; C_Window::ClipToArea
	test	eax, eax
	jne	SHORT $LN5@DrawHLine

; 1919 : 			return;

	jmp	$LN7@DrawHLine
$LN5@DrawHLine:

; 1920 : 	}
; 1921 : 	else

	jmp	$LN4@DrawHLine
$LN6@DrawHLine:

; 1922 : 	{
; 1923 : 		rect.left+=VX_[Client];

	mov	eax, DWORD PTR _Client$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _rect$[ebp]
	add	edx, DWORD PTR [ecx+eax*4+480]
	mov	DWORD PTR _rect$[ebp], edx

; 1924 : 		rect.top+=VY_[Client];

	mov	eax, DWORD PTR _Client$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _rect$[ebp+4]
	add	edx, DWORD PTR [ecx+eax*4+512]
	mov	DWORD PTR _rect$[ebp+4], edx

; 1925 : 		rect.right+=VX_[Client];

	mov	eax, DWORD PTR _Client$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _rect$[ebp+8]
	add	edx, DWORD PTR [ecx+eax*4+480]
	mov	DWORD PTR _rect$[ebp+8], edx

; 1926 : 		rect.bottom+=VY_[Client];

	mov	eax, DWORD PTR _Client$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _rect$[ebp+12]
	add	edx, DWORD PTR [ecx+eax*4+512]
	mov	DWORD PTR _rect$[ebp+12], edx

; 1927 : 		if(!ClipToArea(&s,&rect,clip))

	mov	eax, DWORD PTR _clip$[ebp]
	push	eax
	lea	ecx, DWORD PTR _rect$[ebp]
	push	ecx
	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClipToArea@C_Window@@QAEHPAUUI95_RECT@@00@Z ; C_Window::ClipToArea
	test	eax, eax
	jne	SHORT $LN3@DrawHLine

; 1928 : 			return;

	jmp	SHORT $LN7@DrawHLine
$LN3@DrawHLine:

; 1929 : 		if(!ClipToArea(&s,&rect,&ClientArea_[Client]))

	mov	eax, DWORD PTR _Client$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+168]
	push	edx
	lea	eax, DWORD PTR _rect$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClipToArea@C_Window@@QAEHPAUUI95_RECT@@00@Z ; C_Window::ClipToArea
	test	eax, eax
	jne	SHORT $LN4@DrawHLine

; 1930 : 			return;

	jmp	SHORT $LN7@DrawHLine
$LN4@DrawHLine:

; 1931 : 	}
; 1932 : 	if(!ClipToArea(&s,&rect,clip))

	mov	edx, DWORD PTR _clip$[ebp]
	push	edx
	lea	eax, DWORD PTR _rect$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClipToArea@C_Window@@QAEHPAUUI95_RECT@@00@Z ; C_Window::ClipToArea
	test	eax, eax
	jne	SHORT $LN1@DrawHLine

; 1933 : 		return;

	jmp	SHORT $LN7@DrawHLine
$LN1@DrawHLine:

; 1934 : 	BlitFill(surface,color,&rect,C_BIT_ABSOLUTE,0);

	push	0
	push	262144					; 00040000H
	lea	edx, DWORD PTR _rect$[ebp]
	push	edx
	mov	eax, DWORD PTR _color$[ebp]
	push	eax
	mov	ecx, DWORD PTR _surface$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BlitFill@C_Window@@QAEXPAVSCREEN@@KPAUUI95_RECT@@JJ@Z ; C_Window::BlitFill
$LN7@DrawHLine:

; 1935 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?DrawHLine@C_Window@@QAEXPAVSCREEN@@KJJJJJPAUUI95_RECT@@@Z ENDP ; C_Window::DrawHLine
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -40						; size = 4
_s$ = -36						; size = 16
_d$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_surface$ = 8						; size = 4
_Color$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_w$ = 24						; size = 4
_h$ = 28						; size = 4
_Flags$ = 32						; size = 4
_Client$ = 36						; size = 4
_clip$ = 40						; size = 4
?BlitFill@C_Window@@QAEXPAVSCREEN@@KJJJJJJPAUUI95_RECT@@@Z PROC ; C_Window::BlitFill
; _this$ = ecx

; 1878 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1879 : 	UI95_RECT d,s;
; 1880 : 
; 1881 : 	s.left = s.top = s.right = s.bottom = 0; // JPO initialise to something

	mov	DWORD PTR _s$[ebp+12], 0
	mov	eax, DWORD PTR _s$[ebp+12]
	mov	DWORD PTR _s$[ebp+8], eax
	mov	ecx, DWORD PTR _s$[ebp+8]
	mov	DWORD PTR _s$[ebp+4], ecx
	mov	edx, DWORD PTR _s$[ebp+4]
	mov	DWORD PTR _s$[ebp], edx

; 1882 : 	d.left=x;

	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 1883 : 	d.top=y;

	mov	ecx, DWORD PTR _y$[ebp]
	mov	DWORD PTR _d$[ebp+4], ecx

; 1884 : 	d.right=x+w;

	mov	edx, DWORD PTR _x$[ebp]
	add	edx, DWORD PTR _w$[ebp]
	mov	DWORD PTR _d$[ebp+8], edx

; 1885 : 	d.bottom=y+h;

	mov	eax, DWORD PTR _y$[ebp]
	add	eax, DWORD PTR _h$[ebp]
	mov	DWORD PTR _d$[ebp+12], eax

; 1886 : 
; 1887 : 	if(Flags & C_BIT_ABSOLUTE)

	mov	ecx, DWORD PTR _Flags$[ebp]
	and	ecx, 262144				; 00040000H
	je	SHORT $LN5@BlitFill

; 1888 : 	{
; 1889 : 		if(!ClipToArea(&s,&d,&Area_))

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 112				; 00000070H
	push	edx
	lea	eax, DWORD PTR _d$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClipToArea@C_Window@@QAEHPAUUI95_RECT@@00@Z ; C_Window::ClipToArea
	test	eax, eax
	jne	SHORT $LN4@BlitFill

; 1890 : 			return;

	jmp	$LN6@BlitFill
$LN4@BlitFill:

; 1891 : 	}
; 1892 : 	else

	jmp	SHORT $LN3@BlitFill
$LN5@BlitFill:

; 1893 : 	{
; 1894 : 		d.left+=VX_[Client];

	mov	edx, DWORD PTR _Client$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _d$[ebp]
	add	ecx, DWORD PTR [eax+edx*4+480]
	mov	DWORD PTR _d$[ebp], ecx

; 1895 : 		d.top+=VY_[Client];

	mov	edx, DWORD PTR _Client$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _d$[ebp+4]
	add	ecx, DWORD PTR [eax+edx*4+512]
	mov	DWORD PTR _d$[ebp+4], ecx

; 1896 : 		d.right+=VX_[Client];

	mov	edx, DWORD PTR _Client$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _d$[ebp+8]
	add	ecx, DWORD PTR [eax+edx*4+480]
	mov	DWORD PTR _d$[ebp+8], ecx

; 1897 : 		d.bottom+=VY_[Client];

	mov	edx, DWORD PTR _Client$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _d$[ebp+12]
	add	ecx, DWORD PTR [eax+edx*4+512]
	mov	DWORD PTR _d$[ebp+12], ecx

; 1898 : 		if(!ClipToArea(&s,&d,&ClientArea_[Client]))

	mov	edx, DWORD PTR _Client$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+168]
	push	ecx
	lea	edx, DWORD PTR _d$[ebp]
	push	edx
	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClipToArea@C_Window@@QAEHPAUUI95_RECT@@00@Z ; C_Window::ClipToArea
	test	eax, eax
	jne	SHORT $LN3@BlitFill

; 1899 : 			return;

	jmp	SHORT $LN6@BlitFill
$LN3@BlitFill:

; 1900 : 	}
; 1901 : 	if(!ClipToArea(&s,&d,clip))

	mov	ecx, DWORD PTR _clip$[ebp]
	push	ecx
	lea	edx, DWORD PTR _d$[ebp]
	push	edx
	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClipToArea@C_Window@@QAEHPAUUI95_RECT@@00@Z ; C_Window::ClipToArea
	test	eax, eax
	jne	SHORT $LN1@BlitFill

; 1902 : 		return;

	jmp	SHORT $LN6@BlitFill
$LN1@BlitFill:

; 1903 : 	BlitFill(surface,Color,&d,C_BIT_ABSOLUTE,0);

	push	0
	push	262144					; 00040000H
	lea	ecx, DWORD PTR _d$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Color$[ebp]
	push	edx
	mov	eax, DWORD PTR _surface$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BlitFill@C_Window@@QAEXPAVSCREEN@@KPAUUI95_RECT@@JJ@Z ; C_Window::BlitFill
$LN6@BlitFill:

; 1904 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
?BlitFill@C_Window@@QAEXPAVSCREEN@@KJJJJJJPAUUI95_RECT@@@Z ENDP ; C_Window::BlitFill
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -40						; size = 4
_s$ = -36						; size = 16
_d$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_surface$ = 8						; size = 4
_Color$ = 12						; size = 4
_dst$ = 16						; size = 4
_Flags$ = 20						; size = 4
_Client$ = 24						; size = 4
?BlitFill@C_Window@@QAEXPAVSCREEN@@KPAUUI95_RECT@@JJ@Z PROC ; C_Window::BlitFill
; _this$ = ecx

; 1814 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1815 : 	UI95_RECT s,d;
; 1816 : 
; 1817 : 	d=*dst;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _d$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _d$[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _d$[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _d$[ebp+12], edx

; 1818 : 	if(Flags & C_BIT_ABSOLUTE)

	mov	eax, DWORD PTR _Flags$[ebp]
	and	eax, 262144				; 00040000H
	je	SHORT $LN4@BlitFill

; 1819 : 	{
; 1820 : 		if(!ClipToArea(&s,&d,&Area_))

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	push	ecx
	lea	edx, DWORD PTR _d$[ebp]
	push	edx
	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClipToArea@C_Window@@QAEHPAUUI95_RECT@@00@Z ; C_Window::ClipToArea
	test	eax, eax
	jne	SHORT $LN3@BlitFill

; 1821 : 			return;

	jmp	$LN5@BlitFill
$LN3@BlitFill:

; 1822 : 	}
; 1823 : 	else

	jmp	SHORT $LN2@BlitFill
$LN4@BlitFill:

; 1824 : 	{
; 1825 : 		d.left+=VX_[Client];

	mov	ecx, DWORD PTR _Client$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _d$[ebp]
	add	eax, DWORD PTR [edx+ecx*4+480]
	mov	DWORD PTR _d$[ebp], eax

; 1826 : 		d.top+=VY_[Client];

	mov	ecx, DWORD PTR _Client$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _d$[ebp+4]
	add	eax, DWORD PTR [edx+ecx*4+512]
	mov	DWORD PTR _d$[ebp+4], eax

; 1827 : 		d.right+=VX_[Client];

	mov	ecx, DWORD PTR _Client$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _d$[ebp+8]
	add	eax, DWORD PTR [edx+ecx*4+480]
	mov	DWORD PTR _d$[ebp+8], eax

; 1828 : 		d.bottom+=VY_[Client];

	mov	ecx, DWORD PTR _Client$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _d$[ebp+12]
	add	eax, DWORD PTR [edx+ecx*4+512]
	mov	DWORD PTR _d$[ebp+12], eax

; 1829 : 		if(!ClipToArea(&s,&d,&ClientArea_[Client]))

	mov	ecx, DWORD PTR _Client$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+168]
	push	eax
	lea	ecx, DWORD PTR _d$[ebp]
	push	ecx
	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClipToArea@C_Window@@QAEHPAUUI95_RECT@@00@Z ; C_Window::ClipToArea
	test	eax, eax
	jne	SHORT $LN2@BlitFill

; 1830 : 			return;

	jmp	SHORT $LN5@BlitFill
$LN2@BlitFill:

; 1831 : 	}
; 1832 : 
; 1833 : 	d.left+=GetX();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetX@C_Window@@QAEFXZ			; C_Window::GetX
	cwde
	add	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 1834 : 	d.top+=GetY();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetY@C_Window@@QAEFXZ			; C_Window::GetY
	movsx	ecx, ax
	add	ecx, DWORD PTR _d$[ebp+4]
	mov	DWORD PTR _d$[ebp+4], ecx

; 1835 : 	d.right+=GetX();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetX@C_Window@@QAEFXZ			; C_Window::GetX
	movsx	edx, ax
	add	edx, DWORD PTR _d$[ebp+8]
	mov	DWORD PTR _d$[ebp+8], edx

; 1836 : 	d.bottom+=GetY();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetY@C_Window@@QAEFXZ			; C_Window::GetY
	cwde
	add	eax, DWORD PTR _d$[ebp+12]
	mov	DWORD PTR _d$[ebp+12], eax

; 1837 : 
; 1838 : 	Fill(surface,UI95_RGB24Bit(Color),&d);

	lea	ecx, DWORD PTR _d$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Color$[ebp]
	push	edx
	call	?UI95_RGB24Bit@@YAGK@Z			; UI95_RGB24Bit
	add	esp, 4
	movzx	eax, ax
	push	eax
	mov	ecx, DWORD PTR _surface$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Fill@C_Window@@AAEXPAVSCREEN@@GPAUUI95_RECT@@@Z ; C_Window::Fill
$LN5@BlitFill:

; 1839 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?BlitFill@C_Window@@QAEXPAVSCREEN@@KPAUUI95_RECT@@JJ@Z ENDP ; C_Window::BlitFill
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_b$ = -56						; size = 4
_r$ = -52						; size = 4
_g$ = -48						; size = 4
_col$ = -44						; size = 4
_this$ = -40						; size = 4
_s$ = -36						; size = 16
_d$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_surface$ = 8						; size = 4
_Color$ = 12						; size = 4
_Perc$ = 16						; size = 4
_dst$ = 20						; size = 4
_Flags$ = 24						; size = 4
_Client$ = 28						; size = 4
?GradientFill@C_Window@@QAEXPAVSCREEN@@KJPAUUI95_RECT@@JJ@Z PROC ; C_Window::GradientFill
; _this$ = ecx

; 1842 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1843 : 	UI95_RECT s,d;
; 1844 : 	long col,r,g,b;
; 1845 : 
; 1846 : 	d=*dst;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _d$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _d$[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _d$[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _d$[ebp+12], edx

; 1847 : 	if(Flags & C_BIT_ABSOLUTE)

	mov	eax, DWORD PTR _Flags$[ebp]
	and	eax, 262144				; 00040000H
	je	SHORT $LN4@GradientFi

; 1848 : 	{
; 1849 : 		if(!ClipToArea(&s,&d,&Area_))

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	push	ecx
	lea	edx, DWORD PTR _d$[ebp]
	push	edx
	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClipToArea@C_Window@@QAEHPAUUI95_RECT@@00@Z ; C_Window::ClipToArea
	test	eax, eax
	jne	SHORT $LN3@GradientFi

; 1850 : 			return;

	jmp	$LN5@GradientFi
$LN3@GradientFi:

; 1851 : 	}
; 1852 : 	else

	jmp	SHORT $LN2@GradientFi
$LN4@GradientFi:

; 1853 : 	{
; 1854 : 		d.left+=VX_[Client];

	mov	ecx, DWORD PTR _Client$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _d$[ebp]
	add	eax, DWORD PTR [edx+ecx*4+480]
	mov	DWORD PTR _d$[ebp], eax

; 1855 : 		d.top+=VY_[Client];

	mov	ecx, DWORD PTR _Client$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _d$[ebp+4]
	add	eax, DWORD PTR [edx+ecx*4+512]
	mov	DWORD PTR _d$[ebp+4], eax

; 1856 : 		d.right+=VX_[Client];

	mov	ecx, DWORD PTR _Client$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _d$[ebp+8]
	add	eax, DWORD PTR [edx+ecx*4+480]
	mov	DWORD PTR _d$[ebp+8], eax

; 1857 : 		d.bottom+=VY_[Client];

	mov	ecx, DWORD PTR _Client$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _d$[ebp+12]
	add	eax, DWORD PTR [edx+ecx*4+512]
	mov	DWORD PTR _d$[ebp+12], eax

; 1858 : 		if(!ClipToArea(&s,&d,&ClientArea_[Client]))

	mov	ecx, DWORD PTR _Client$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+168]
	push	eax
	lea	ecx, DWORD PTR _d$[ebp]
	push	ecx
	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClipToArea@C_Window@@QAEHPAUUI95_RECT@@00@Z ; C_Window::ClipToArea
	test	eax, eax
	jne	SHORT $LN2@GradientFi

; 1859 : 			return;

	jmp	$LN5@GradientFi
$LN2@GradientFi:

; 1860 : 	}
; 1861 : 
; 1862 : 	d.left+=GetX();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetX@C_Window@@QAEFXZ			; C_Window::GetX
	cwde
	add	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 1863 : 	d.top+=GetY();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetY@C_Window@@QAEFXZ			; C_Window::GetY
	movsx	ecx, ax
	add	ecx, DWORD PTR _d$[ebp+4]
	mov	DWORD PTR _d$[ebp+4], ecx

; 1864 : 	d.right+=GetX();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetX@C_Window@@QAEFXZ			; C_Window::GetX
	movsx	edx, ax
	add	edx, DWORD PTR _d$[ebp+8]
	mov	DWORD PTR _d$[ebp+8], edx

; 1865 : 	d.bottom+=GetY();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetY@C_Window@@QAEFXZ			; C_Window::GetY
	cwde
	add	eax, DWORD PTR _d$[ebp+12]
	mov	DWORD PTR _d$[ebp+12], eax

; 1866 : 
; 1867 : 	col=UI95_RGB24Bit(Color);

	mov	ecx, DWORD PTR _Color$[ebp]
	push	ecx
	call	?UI95_RGB24Bit@@YAGK@Z			; UI95_RGB24Bit
	add	esp, 4
	movzx	edx, ax
	mov	DWORD PTR _col$[ebp], edx

; 1868 : 	r=UIColorTable[Perc][(col & r_mask_) >> r_shift_];

	mov	eax, DWORD PTR _Perc$[ebp]
	shl	eax, 9
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _col$[ebp]
	and	edx, DWORD PTR [ecx+456]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [ecx+460]
	shr	edx, cl
	movzx	edx, WORD PTR ?UIColorTable@@3PAY0BAA@GA[eax+edx*2]
	mov	DWORD PTR _r$[ebp], edx

; 1869 : 	g=UIColorTable[Perc][(col & g_mask_) >> g_shift_];

	mov	eax, DWORD PTR _Perc$[ebp]
	shl	eax, 9
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _col$[ebp]
	and	edx, DWORD PTR [ecx+464]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [ecx+468]
	shr	edx, cl
	movzx	edx, WORD PTR ?UIColorTable@@3PAY0BAA@GA[eax+edx*2]
	mov	DWORD PTR _g$[ebp], edx

; 1870 : 	b=UIColorTable[Perc][(col & b_mask_) >> b_shift_];

	mov	eax, DWORD PTR _Perc$[ebp]
	shl	eax, 9
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _col$[ebp]
	and	edx, DWORD PTR [ecx+472]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [ecx+476]
	shr	edx, cl
	movzx	edx, WORD PTR ?UIColorTable@@3PAY0BAA@GA[eax+edx*2]
	mov	DWORD PTR _b$[ebp], edx

; 1871 : 
; 1872 : 	col=rShift[r] | gShift[g] | bShift[b];

	mov	eax, DWORD PTR _r$[ebp]
	movzx	ecx, WORD PTR ?rShift@@3PAGA[eax*2]
	mov	edx, DWORD PTR _g$[ebp]
	movzx	eax, WORD PTR ?gShift@@3PAGA[edx*2]
	or	ecx, eax
	mov	edx, DWORD PTR _b$[ebp]
	movzx	eax, WORD PTR ?bShift@@3PAGA[edx*2]
	or	ecx, eax
	mov	DWORD PTR _col$[ebp], ecx

; 1873 : 
; 1874 : 	Fill(surface,(WORD)col,&d);

	lea	ecx, DWORD PTR _d$[ebp]
	push	ecx
	movzx	edx, WORD PTR _col$[ebp]
	push	edx
	mov	eax, DWORD PTR _surface$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Fill@C_Window@@AAEXPAVSCREEN@@GPAUUI95_RECT@@@Z ; C_Window::Fill
$LN5@GradientFi:

; 1875 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?GradientFill@C_Window@@QAEXPAVSCREEN@@KJPAUUI95_RECT@@JJ@Z ENDP ; C_Window::GradientFill
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_ls$ = -100						; size = 4
_bc$ = -96						; size = 4
_rc$ = -92						; size = 4
_gc$ = -88						; size = 4
_i$ = -84						; size = 4
_j$ = -80						; size = 4
_didxstart$ = -76					; size = 4
_convcolor$ = -72					; size = 4
_didx$ = -68						; size = 4
_l$ = -64						; size = 4
_k$ = -60						; size = 4
_rf$ = -56						; size = 4
_gf$ = -52						; size = 4
_mask$ = -48						; size = 4
_bf$ = -44						; size = 4
_this$ = -40						; size = 4
_s$ = -36						; size = 16
_d$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_surface$ = 8						; size = 4
_color$ = 12						; size = 4
_Perc$ = 16						; size = 4
_size$ = 20						; size = 2
_pattern$ = 24						; size = 4
_rect$ = 28						; size = 4
_Flags$ = 32						; size = 4
_Client$ = 36						; size = 4
?DitherFill@C_Window@@QAEXPAVSCREEN@@KJFPADPAUUI95_RECT@@JJ@Z PROC ; C_Window::DitherFill
; _this$ = ecx

; 1692 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1693 : 	long mask;
; 1694 : 	long i,j,k,l,ls;
; 1695 : 	long rf,gf,bf;
; 1696 : 	long didx,didxstart;
; 1697 : 	long rc,gc,bc;
; 1698 : 	long convcolor;
; 1699 : 	UI95_RECT s,d;
; 1700 : 
; 1701 : 	mask=size-1;

	movsx	eax, WORD PTR _size$[ebp]
	sub	eax, 1
	mov	DWORD PTR _mask$[ebp], eax

; 1702 : 
; 1703 : 	d=*rect;

	mov	ecx, DWORD PTR _rect$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _d$[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _d$[ebp+4], eax
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _d$[ebp+8], edx
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR _d$[ebp+12], eax

; 1704 : 	if(Flags & C_BIT_ABSOLUTE)

	mov	ecx, DWORD PTR _Flags$[ebp]
	and	ecx, 262144				; 00040000H
	je	SHORT $LN18@DitherFill

; 1705 : 	{
; 1706 : 		if(!ClipToArea(&s,&d,&Area_))

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 112				; 00000070H
	push	edx
	lea	eax, DWORD PTR _d$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClipToArea@C_Window@@QAEHPAUUI95_RECT@@00@Z ; C_Window::ClipToArea
	test	eax, eax
	jne	SHORT $LN17@DitherFill

; 1707 : 			return;

	jmp	$LN19@DitherFill
$LN17@DitherFill:

; 1708 : 	}
; 1709 : 	else

	jmp	SHORT $LN16@DitherFill
$LN18@DitherFill:

; 1710 : 	{
; 1711 : 		d.left+=VX_[Client];

	mov	edx, DWORD PTR _Client$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _d$[ebp]
	add	ecx, DWORD PTR [eax+edx*4+480]
	mov	DWORD PTR _d$[ebp], ecx

; 1712 : 		d.top+=VY_[Client];

	mov	edx, DWORD PTR _Client$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _d$[ebp+4]
	add	ecx, DWORD PTR [eax+edx*4+512]
	mov	DWORD PTR _d$[ebp+4], ecx

; 1713 : 		d.right+=VX_[Client];

	mov	edx, DWORD PTR _Client$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _d$[ebp+8]
	add	ecx, DWORD PTR [eax+edx*4+480]
	mov	DWORD PTR _d$[ebp+8], ecx

; 1714 : 		d.bottom+=VY_[Client];

	mov	edx, DWORD PTR _Client$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _d$[ebp+12]
	add	ecx, DWORD PTR [eax+edx*4+512]
	mov	DWORD PTR _d$[ebp+12], ecx

; 1715 : 		if(!ClipToArea(&s,&d,&ClientArea_[Client]))

	mov	edx, DWORD PTR _Client$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+168]
	push	ecx
	lea	edx, DWORD PTR _d$[ebp]
	push	edx
	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClipToArea@C_Window@@QAEHPAUUI95_RECT@@00@Z ; C_Window::ClipToArea
	test	eax, eax
	jne	SHORT $LN16@DitherFill

; 1716 : 			return;

	jmp	$LN19@DitherFill
$LN16@DitherFill:

; 1717 : 	}
; 1718 : 
; 1719 : 	k=d.top;

	mov	ecx, DWORD PTR _d$[ebp+4]
	mov	DWORD PTR _k$[ebp], ecx

; 1720 : 	ls=d.left;

	mov	edx, DWORD PTR _d$[ebp]
	mov	DWORD PTR _ls$[ebp], edx

; 1721 : 	d.left+=GetX();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetX@C_Window@@QAEFXZ			; C_Window::GetX
	cwde
	add	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 1722 : 	d.top+=GetY();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetY@C_Window@@QAEFXZ			; C_Window::GetY
	movsx	ecx, ax
	add	ecx, DWORD PTR _d$[ebp+4]
	mov	DWORD PTR _d$[ebp+4], ecx

; 1723 : 	d.right+=GetX();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetX@C_Window@@QAEFXZ			; C_Window::GetX
	movsx	edx, ax
	add	edx, DWORD PTR _d$[ebp+8]
	mov	DWORD PTR _d$[ebp+8], edx

; 1724 : 	d.bottom+=GetY();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetY@C_Window@@QAEFXZ			; C_Window::GetY
	cwde
	add	eax, DWORD PTR _d$[ebp+12]
	mov	DWORD PTR _d$[ebp+12], eax

; 1725 : 
; 1726 : 	convcolor=UI95_RGB24Bit(color);

	mov	ecx, DWORD PTR _color$[ebp]
	push	ecx
	call	?UI95_RGB24Bit@@YAGK@Z			; UI95_RGB24Bit
	add	esp, 4
	movzx	edx, ax
	mov	DWORD PTR _convcolor$[ebp], edx

; 1727 : 	rc=UIColorTable[Perc][(convcolor & r_mask_) >> r_shift_];

	mov	eax, DWORD PTR _Perc$[ebp]
	shl	eax, 9
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _convcolor$[ebp]
	and	edx, DWORD PTR [ecx+456]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [ecx+460]
	shr	edx, cl
	movzx	edx, WORD PTR ?UIColorTable@@3PAY0BAA@GA[eax+edx*2]
	mov	DWORD PTR _rc$[ebp], edx

; 1728 : 	gc=UIColorTable[Perc][(convcolor & g_mask_) >> g_shift_];

	mov	eax, DWORD PTR _Perc$[ebp]
	shl	eax, 9
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _convcolor$[ebp]
	and	edx, DWORD PTR [ecx+464]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [ecx+468]
	shr	edx, cl
	movzx	edx, WORD PTR ?UIColorTable@@3PAY0BAA@GA[eax+edx*2]
	mov	DWORD PTR _gc$[ebp], edx

; 1729 : 	bc=UIColorTable[Perc][(convcolor & b_mask_) >> b_shift_];

	mov	eax, DWORD PTR _Perc$[ebp]
	shl	eax, 9
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _convcolor$[ebp]
	and	edx, DWORD PTR [ecx+472]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [ecx+476]
	shr	edx, cl
	movzx	edx, WORD PTR ?UIColorTable@@3PAY0BAA@GA[eax+edx*2]
	mov	DWORD PTR _bc$[ebp], edx

; 1730 : 
; 1731 : 	didxstart=d.top*surface->width;

	mov	eax, DWORD PTR _surface$[ebp]
	movsx	ecx, WORD PTR [eax+4]
	imul	ecx, DWORD PTR _d$[ebp+4]
	mov	DWORD PTR _didxstart$[ebp], ecx

; 1732 : 	for(i=d.top;i < d.bottom;i++)

	mov	edx, DWORD PTR _d$[ebp+4]
	mov	DWORD PTR _i$[ebp], edx
	jmp	SHORT $LN14@DitherFill
$LN13@DitherFill:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN14@DitherFill:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _d$[ebp+12]
	jge	$LN19@DitherFill

; 1733 : 	{
; 1734 : 		l=ls;

	mov	edx, DWORD PTR _ls$[ebp]
	mov	DWORD PTR _l$[ebp], edx

; 1735 : 		didx=didxstart+d.left;

	mov	eax, DWORD PTR _didxstart$[ebp]
	add	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR _didx$[ebp], eax

; 1736 : 		for(j=d.left;j<d.right;j++)

	mov	ecx, DWORD PTR _d$[ebp]
	mov	DWORD PTR _j$[ebp], ecx
	jmp	SHORT $LN11@DitherFill
$LN10@DitherFill:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN11@DitherFill:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _d$[ebp+8]
	jge	$LN9@DitherFill

; 1737 : 		{
; 1738 : 			rf=(WORD)rc + pattern[(k&mask)*size + (l&mask)];

	movzx	ecx, WORD PTR _rc$[ebp]
	mov	edx, DWORD PTR _k$[ebp]
	and	edx, DWORD PTR _mask$[ebp]
	movsx	eax, WORD PTR _size$[ebp]
	imul	edx, eax
	mov	eax, DWORD PTR _l$[ebp]
	and	eax, DWORD PTR _mask$[ebp]
	add	eax, DWORD PTR _pattern$[ebp]
	movsx	edx, BYTE PTR [eax+edx]
	add	ecx, edx
	mov	DWORD PTR _rf$[ebp], ecx

; 1739 : 			gf=(WORD)gc + pattern[(k&mask)*size + (l&mask)];

	movzx	eax, WORD PTR _gc$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	and	ecx, DWORD PTR _mask$[ebp]
	movsx	edx, WORD PTR _size$[ebp]
	imul	ecx, edx
	mov	edx, DWORD PTR _l$[ebp]
	and	edx, DWORD PTR _mask$[ebp]
	add	edx, DWORD PTR _pattern$[ebp]
	movsx	ecx, BYTE PTR [edx+ecx]
	add	eax, ecx
	mov	DWORD PTR _gf$[ebp], eax

; 1740 : 			bf=(WORD)bc + pattern[(k&mask)*size + (l&mask)];

	movzx	edx, WORD PTR _bc$[ebp]
	mov	eax, DWORD PTR _k$[ebp]
	and	eax, DWORD PTR _mask$[ebp]
	movsx	ecx, WORD PTR _size$[ebp]
	imul	eax, ecx
	mov	ecx, DWORD PTR _l$[ebp]
	and	ecx, DWORD PTR _mask$[ebp]
	add	ecx, DWORD PTR _pattern$[ebp]
	movsx	eax, BYTE PTR [ecx+eax]
	add	edx, eax
	mov	DWORD PTR _bf$[ebp], edx

; 1741 : 			if(rf < 0) rf=0;

	cmp	DWORD PTR _rf$[ebp], 0
	jge	SHORT $LN8@DitherFill
	mov	DWORD PTR _rf$[ebp], 0
$LN8@DitherFill:

; 1742 : 			if(gf < 0) gf=0;

	cmp	DWORD PTR _gf$[ebp], 0
	jge	SHORT $LN7@DitherFill
	mov	DWORD PTR _gf$[ebp], 0
$LN7@DitherFill:

; 1743 : 			if(bf < 0) bf=0;

	cmp	DWORD PTR _bf$[ebp], 0
	jge	SHORT $LN6@DitherFill
	mov	DWORD PTR _bf$[ebp], 0
$LN6@DitherFill:

; 1744 : 			if(rf > 0x1f) rf=0x1f;

	cmp	DWORD PTR _rf$[ebp], 31			; 0000001fH
	jle	SHORT $LN5@DitherFill
	mov	DWORD PTR _rf$[ebp], 31			; 0000001fH
$LN5@DitherFill:

; 1745 : 			if(gf > 0x1f) gf=0x1f;

	cmp	DWORD PTR _gf$[ebp], 31			; 0000001fH
	jle	SHORT $LN4@DitherFill
	mov	DWORD PTR _gf$[ebp], 31			; 0000001fH
$LN4@DitherFill:

; 1746 : 			if(bf > 0x1f) bf=0x1f;

	cmp	DWORD PTR _bf$[ebp], 31			; 0000001fH
	jle	SHORT $LN3@DitherFill
	mov	DWORD PTR _bf$[ebp], 31			; 0000001fH
$LN3@DitherFill:

; 1747 : 
; 1748 : 			if(surface->bpp == 32)//XX

	mov	ecx, DWORD PTR _surface$[ebp]
	movzx	edx, BYTE PTR [ecx+8]
	cmp	edx, 32					; 00000020H
	jne	SHORT $LN2@DitherFill

; 1749 : 				((DWORD*)surface->mem)[didx] = RGB565toRGB8( static_cast<short>(rShift[rf] | gShift[gf] | bShift[bf]) );

	mov	eax, DWORD PTR _rf$[ebp]
	movzx	ecx, WORD PTR ?rShift@@3PAGA[eax*2]
	mov	edx, DWORD PTR _gf$[ebp]
	movzx	eax, WORD PTR ?gShift@@3PAGA[edx*2]
	or	ecx, eax
	mov	edx, DWORD PTR _bf$[ebp]
	movzx	eax, WORD PTR ?bShift@@3PAGA[edx*2]
	or	ecx, eax
	push	ecx
	call	?RGB565toRGB8@@YAKG@Z			; RGB565toRGB8
	add	esp, 4
	mov	ecx, DWORD PTR _surface$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _didx$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 1750 : 			else

	jmp	SHORT $LN1@DitherFill
$LN2@DitherFill:

; 1751 : 			surface->mem[didx]=static_cast<short>(rShift[rf] | gShift[gf] | bShift[bf]);

	mov	edx, DWORD PTR _rf$[ebp]
	movzx	eax, WORD PTR ?rShift@@3PAGA[edx*2]
	mov	ecx, DWORD PTR _gf$[ebp]
	movzx	edx, WORD PTR ?gShift@@3PAGA[ecx*2]
	or	eax, edx
	mov	ecx, DWORD PTR _bf$[ebp]
	movzx	edx, WORD PTR ?bShift@@3PAGA[ecx*2]
	or	eax, edx
	mov	ecx, DWORD PTR _surface$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _didx$[ebp]
	mov	WORD PTR [edx+ecx*2], ax
$LN1@DitherFill:

; 1752 : 
; 1753 : 			l++;

	mov	edx, DWORD PTR _l$[ebp]
	add	edx, 1
	mov	DWORD PTR _l$[ebp], edx

; 1754 : 			didx++;

	mov	eax, DWORD PTR _didx$[ebp]
	add	eax, 1
	mov	DWORD PTR _didx$[ebp], eax

; 1755 : 		}

	jmp	$LN10@DitherFill
$LN9@DitherFill:

; 1756 : 		didxstart+=surface->width;

	mov	ecx, DWORD PTR _surface$[ebp]
	movsx	edx, WORD PTR [ecx+4]
	add	edx, DWORD PTR _didxstart$[ebp]
	mov	DWORD PTR _didxstart$[ebp], edx

; 1757 : 		k++;

	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax

; 1758 : 	}

	jmp	$LN13@DitherFill
$LN19@DitherFill:

; 1759 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?DitherFill@C_Window@@QAEXPAVSCREEN@@KJFPADPAUUI95_RECT@@JJ@Z ENDP ; C_Window::DitherFill
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_rc$ = -136						; size = 4
_bc$ = -132						; size = 4
_gc$ = -128						; size = 4
_dl$ = -124						; size = 4
_dr$ = -120						; size = 4
_db$ = -116						; size = 4
_g$ = -112						; size = 4
_r$ = -108						; size = 4
_b$ = -104						; size = 4
_dt$ = -100						; size = 4
_operc$ = -96						; size = 4
_didxstart$ = -92					; size = 4
_dc$1 = -88						; size = 4
_j$ = -84						; size = 4
_i$ = -80						; size = 4
_didx$ = -76						; size = 4
_suby$ = -72						; size = 4
_subx$ = -68						; size = 4
_bgperc$ = -64						; size = 4
_sub$ = -60						; size = 4
_this$ = -56						; size = 4
_s$ = -52						; size = 16
_orig$ = -36						; size = 16
_d$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_surface$ = 8						; size = 4
_color$ = 12						; size = 4
_Perc$ = 16						; size = 4
_rect$ = 20						; size = 4
_Flags$ = 24						; size = 4
_Client$ = 28						; size = 4
?CustomBlitTranslucent@C_Window@@QAEXPAVSCREEN@@KJPAUUI95_RECT@@JJ@Z PROC ; C_Window::CustomBlitTranslucent
; _this$ = ecx

; 1592 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1593 : 	int i,j;
; 1594 : 	long r,g,b,rc,gc,bc;
; 1595 : 	long didx,didxstart;
; 1596 : 	long bgperc,operc;
; 1597 : 	UI95_RECT s,d,orig;
; 1598 : 	long dl,dt,dr,db,subx,suby,sub;
; 1599 : 
; 1600 : 	d=*rect;

	mov	eax, DWORD PTR _rect$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _d$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _d$[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _d$[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _d$[ebp+12], edx

; 1601 : 	if(Flags & C_BIT_ABSOLUTE)

	mov	eax, DWORD PTR _Flags$[ebp]
	and	eax, 262144				; 00040000H
	je	SHORT $LN23@CustomBlit

; 1602 : 	{
; 1603 : 		orig=d;

	mov	ecx, DWORD PTR _d$[ebp]
	mov	DWORD PTR _orig$[ebp], ecx
	mov	edx, DWORD PTR _d$[ebp+4]
	mov	DWORD PTR _orig$[ebp+4], edx
	mov	eax, DWORD PTR _d$[ebp+8]
	mov	DWORD PTR _orig$[ebp+8], eax
	mov	ecx, DWORD PTR _d$[ebp+12]
	mov	DWORD PTR _orig$[ebp+12], ecx

; 1604 : 		if(!ClipToArea(&s,&d,&Area_))

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 112				; 00000070H
	push	edx
	lea	eax, DWORD PTR _d$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClipToArea@C_Window@@QAEHPAUUI95_RECT@@00@Z ; C_Window::ClipToArea
	test	eax, eax
	jne	SHORT $LN22@CustomBlit

; 1605 : 			return;

	jmp	$LN24@CustomBlit
$LN22@CustomBlit:

; 1606 : 	}
; 1607 : 	else

	jmp	$LN20@CustomBlit
$LN23@CustomBlit:

; 1608 : 	{
; 1609 : 		d.left+=VX_[Client];

	mov	edx, DWORD PTR _Client$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _d$[ebp]
	add	ecx, DWORD PTR [eax+edx*4+480]
	mov	DWORD PTR _d$[ebp], ecx

; 1610 : 		d.top+=VY_[Client];

	mov	edx, DWORD PTR _Client$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _d$[ebp+4]
	add	ecx, DWORD PTR [eax+edx*4+512]
	mov	DWORD PTR _d$[ebp+4], ecx

; 1611 : 		d.right+=VX_[Client];

	mov	edx, DWORD PTR _Client$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _d$[ebp+8]
	add	ecx, DWORD PTR [eax+edx*4+480]
	mov	DWORD PTR _d$[ebp+8], ecx

; 1612 : 		d.bottom+=VY_[Client];

	mov	edx, DWORD PTR _Client$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _d$[ebp+12]
	add	ecx, DWORD PTR [eax+edx*4+512]
	mov	DWORD PTR _d$[ebp+12], ecx

; 1613 : 		orig=d;

	mov	edx, DWORD PTR _d$[ebp]
	mov	DWORD PTR _orig$[ebp], edx
	mov	eax, DWORD PTR _d$[ebp+4]
	mov	DWORD PTR _orig$[ebp+4], eax
	mov	ecx, DWORD PTR _d$[ebp+8]
	mov	DWORD PTR _orig$[ebp+8], ecx
	mov	edx, DWORD PTR _d$[ebp+12]
	mov	DWORD PTR _orig$[ebp+12], edx

; 1614 : 		if(!ClipToArea(&s,&d,&ClientArea_[Client]))

	mov	eax, DWORD PTR _Client$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+168]
	push	edx
	lea	eax, DWORD PTR _d$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClipToArea@C_Window@@QAEHPAUUI95_RECT@@00@Z ; C_Window::ClipToArea
	test	eax, eax
	jne	SHORT $LN20@CustomBlit

; 1615 : 			return;

	jmp	$LN24@CustomBlit
$LN20@CustomBlit:

; 1616 : 	}
; 1617 : 
; 1618 : 	d.left+=GetX();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetX@C_Window@@QAEFXZ			; C_Window::GetX
	movsx	edx, ax
	add	edx, DWORD PTR _d$[ebp]
	mov	DWORD PTR _d$[ebp], edx

; 1619 : 	d.top+=GetY();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetY@C_Window@@QAEFXZ			; C_Window::GetY
	cwde
	add	eax, DWORD PTR _d$[ebp+4]
	mov	DWORD PTR _d$[ebp+4], eax

; 1620 : 	d.right+=GetX();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetX@C_Window@@QAEFXZ			; C_Window::GetX
	movsx	ecx, ax
	add	ecx, DWORD PTR _d$[ebp+8]
	mov	DWORD PTR _d$[ebp+8], ecx

; 1621 : 	d.bottom+=GetY();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetY@C_Window@@QAEFXZ			; C_Window::GetY
	movsx	edx, ax
	add	edx, DWORD PTR _d$[ebp+12]
	mov	DWORD PTR _d$[ebp+12], edx

; 1622 : 	orig.left+=GetX();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetX@C_Window@@QAEFXZ			; C_Window::GetX
	cwde
	add	eax, DWORD PTR _orig$[ebp]
	mov	DWORD PTR _orig$[ebp], eax

; 1623 : 	orig.top+=GetY();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetY@C_Window@@QAEFXZ			; C_Window::GetY
	movsx	ecx, ax
	add	ecx, DWORD PTR _orig$[ebp+4]
	mov	DWORD PTR _orig$[ebp+4], ecx

; 1624 : 	orig.right+=GetX();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetX@C_Window@@QAEFXZ			; C_Window::GetX
	movsx	edx, ax
	add	edx, DWORD PTR _orig$[ebp+8]
	mov	DWORD PTR _orig$[ebp+8], edx

; 1625 : 	orig.bottom+=GetY();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetY@C_Window@@QAEFXZ			; C_Window::GetY
	cwde
	add	eax, DWORD PTR _orig$[ebp+12]
	mov	DWORD PTR _orig$[ebp+12], eax

; 1626 : 
; 1627 : 	rc=(color >>  3) & 0x1f;

	mov	ecx, DWORD PTR _color$[ebp]
	shr	ecx, 3
	and	ecx, 31					; 0000001fH
	mov	DWORD PTR _rc$[ebp], ecx

; 1628 : 	gc=(color >> 11) & 0x1f;

	mov	edx, DWORD PTR _color$[ebp]
	shr	edx, 11					; 0000000bH
	and	edx, 31					; 0000001fH
	mov	DWORD PTR _gc$[ebp], edx

; 1629 : 	bc=(color >> 19) & 0x1f;

	mov	eax, DWORD PTR _color$[ebp]
	shr	eax, 19					; 00000013H
	and	eax, 31					; 0000001fH
	mov	DWORD PTR _bc$[ebp], eax

; 1630 : 	bgperc=100-Perc;

	mov	ecx, 100				; 00000064H
	sub	ecx, DWORD PTR _Perc$[ebp]
	mov	DWORD PTR _bgperc$[ebp], ecx

; 1631 : 	if(bgperc < 0) bgperc=0;

	jns	SHORT $LN19@CustomBlit
	mov	DWORD PTR _bgperc$[ebp], 0
$LN19@CustomBlit:

; 1632 : 	if(bgperc > 100) bgperc=100;

	cmp	DWORD PTR _bgperc$[ebp], 100		; 00000064H
	jle	SHORT $LN18@CustomBlit
	mov	DWORD PTR _bgperc$[ebp], 100		; 00000064H
$LN18@CustomBlit:

; 1633 : 	operc=Perc+bgperc;

	mov	edx, DWORD PTR _Perc$[ebp]
	add	edx, DWORD PTR _bgperc$[ebp]
	mov	DWORD PTR _operc$[ebp], edx

; 1634 : 
; 1635 : 	didxstart=d.top*surface->width;

	mov	eax, DWORD PTR _surface$[ebp]
	movsx	ecx, WORD PTR [eax+4]
	imul	ecx, DWORD PTR _d$[ebp+4]
	mov	DWORD PTR _didxstart$[ebp], ecx

; 1636 : 	for(i=d.top;i < d.bottom;i++)

	mov	edx, DWORD PTR _d$[ebp+4]
	mov	DWORD PTR _i$[ebp], edx
	jmp	SHORT $LN17@CustomBlit
$LN16@CustomBlit:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN17@CustomBlit:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _d$[ebp+12]
	jge	$LN15@CustomBlit

; 1637 : 	{
; 1638 : 		dt=i-orig.top;

	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, DWORD PTR _orig$[ebp+4]
	mov	DWORD PTR _dt$[ebp], edx

; 1639 : 		db=orig.bottom-i;

	mov	eax, DWORD PTR _orig$[ebp+12]
	sub	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _db$[ebp], eax

; 1640 : 		suby=0;

	mov	DWORD PTR _suby$[ebp], 0

; 1641 : 		if(dt < 16)

	cmp	DWORD PTR _dt$[ebp], 16			; 00000010H
	jge	SHORT $LN14@CustomBlit

; 1642 : 			suby+=SubTable[dt];

	mov	ecx, DWORD PTR _dt$[ebp]
	movsx	edx, WORD PTR ?SubTable@@3PAFA[ecx*2]
	add	edx, DWORD PTR _suby$[ebp]
	mov	DWORD PTR _suby$[ebp], edx
$LN14@CustomBlit:

; 1643 : 		if(db < 16)

	cmp	DWORD PTR _db$[ebp], 16			; 00000010H
	jge	SHORT $LN13@CustomBlit

; 1644 : 			suby+=SubTable[db];

	mov	eax, DWORD PTR _db$[ebp]
	movsx	ecx, WORD PTR ?SubTable@@3PAFA[eax*2]
	add	ecx, DWORD PTR _suby$[ebp]
	mov	DWORD PTR _suby$[ebp], ecx
$LN13@CustomBlit:

; 1645 : 		didx=didxstart+d.left;

	mov	edx, DWORD PTR _didxstart$[ebp]
	add	edx, DWORD PTR _d$[ebp]
	mov	DWORD PTR _didx$[ebp], edx

; 1646 : 		for(j=d.left;j < d.right;j++)

	mov	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $LN12@CustomBlit
$LN11@CustomBlit:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN12@CustomBlit:
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR _d$[ebp+8]
	jge	$LN10@CustomBlit

; 1647 : 		{
; 1648 : 			dl=j-orig.left;

	mov	eax, DWORD PTR _j$[ebp]
	sub	eax, DWORD PTR _orig$[ebp]
	mov	DWORD PTR _dl$[ebp], eax

; 1649 : 			dr=orig.right-j;

	mov	ecx, DWORD PTR _orig$[ebp+8]
	sub	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR _dr$[ebp], ecx

; 1650 : 
; 1651 : 			subx=0;

	mov	DWORD PTR _subx$[ebp], 0

; 1652 : 			if(dl < 16)

	cmp	DWORD PTR _dl$[ebp], 16			; 00000010H
	jge	SHORT $LN9@CustomBlit

; 1653 : 				subx+=SubTable[dl];

	mov	edx, DWORD PTR _dl$[ebp]
	movsx	eax, WORD PTR ?SubTable@@3PAFA[edx*2]
	add	eax, DWORD PTR _subx$[ebp]
	mov	DWORD PTR _subx$[ebp], eax
$LN9@CustomBlit:

; 1654 : 			if(dr < 16)

	cmp	DWORD PTR _dr$[ebp], 16			; 00000010H
	jge	SHORT $LN8@CustomBlit

; 1655 : 				subx+=SubTable[dr];

	mov	ecx, DWORD PTR _dr$[ebp]
	movsx	edx, WORD PTR ?SubTable@@3PAFA[ecx*2]
	add	edx, DWORD PTR _subx$[ebp]
	mov	DWORD PTR _subx$[ebp], edx
$LN8@CustomBlit:

; 1656 : 
; 1657 : 			if(subx && suby)

	cmp	DWORD PTR _subx$[ebp], 0
	je	SHORT $LN7@CustomBlit
	cmp	DWORD PTR _suby$[ebp], 0
	je	SHORT $LN7@CustomBlit

; 1658 : 				sub=(long)sqrt((float)(subx*subx + suby*suby));

	mov	eax, DWORD PTR _subx$[ebp]
	imul	eax, DWORD PTR _subx$[ebp]
	mov	ecx, DWORD PTR _suby$[ebp]
	imul	ecx, DWORD PTR _suby$[ebp]
	add	eax, ecx
	cvtsi2ss xmm0, eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SqrtSSE@@YAMM@Z			; SqrtSSE
	add	esp, 4
	call	__ftol2_sse
	mov	DWORD PTR _sub$[ebp], eax

; 1659 : 			else

	jmp	SHORT $LN6@CustomBlit
$LN7@CustomBlit:

; 1660 : 				sub=subx+suby;

	mov	edx, DWORD PTR _subx$[ebp]
	add	edx, DWORD PTR _suby$[ebp]
	mov	DWORD PTR _sub$[ebp], edx
$LN6@CustomBlit:

; 1661 : 
; 1662 : 			sub=TableVal[sub];

	mov	eax, DWORD PTR _sub$[ebp]
	movsx	ecx, WORD PTR ?TableVal@@3PAFA[eax*2]
	mov	DWORD PTR _sub$[ebp], ecx

; 1663 : 
; 1664 : 			if(sub < 17)

	cmp	DWORD PTR _sub$[ebp], 17		; 00000011H
	jge	$LN1@CustomBlit

; 1665 : 			{
; 1666 : 				DWORD dc;//XX
; 1667 : 				if(surface->bpp == 32 ){

	mov	edx, DWORD PTR _surface$[ebp]
	movzx	eax, BYTE PTR [edx+8]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN4@CustomBlit

; 1668 : 					dc = RGB8toRGB565( ((DWORD*)surface->mem)[didx] );

	mov	ecx, DWORD PTR _surface$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _didx$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	?RGB8toRGB565@@YAGK@Z			; RGB8toRGB565
	add	esp, 4
	movzx	edx, ax
	mov	DWORD PTR _dc$1[ebp], edx

; 1669 : 				}
; 1670 : 				else{

	jmp	SHORT $LN3@CustomBlit
$LN4@CustomBlit:

; 1671 : 					dc = surface->mem[didx];

	mov	eax, DWORD PTR _surface$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _didx$[ebp]
	movzx	eax, WORD PTR [ecx+edx*2]
	mov	DWORD PTR _dc$1[ebp], eax
$LN3@CustomBlit:

; 1672 : 				}
; 1673 : 
; 1674 : 				r=UIColorTable[operc][UIColorTable[Perc-sub][rc] + UIColorTable[bgperc+sub][(dc >> r_shift_) & 0x1f]];

	mov	edx, DWORD PTR _operc$[ebp]
	shl	edx, 9
	mov	eax, DWORD PTR _Perc$[ebp]
	sub	eax, DWORD PTR _sub$[ebp]
	shl	eax, 9
	mov	ecx, DWORD PTR _rc$[ebp]
	movzx	eax, WORD PTR ?UIColorTable@@3PAY0BAA@GA[eax+ecx*2]
	mov	esi, DWORD PTR _bgperc$[ebp]
	add	esi, DWORD PTR _sub$[ebp]
	shl	esi, 9
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [ecx+460]
	mov	edi, DWORD PTR _dc$1[ebp]
	shr	edi, cl
	and	edi, 31					; 0000001fH
	movzx	ecx, WORD PTR ?UIColorTable@@3PAY0BAA@GA[esi+edi*2]
	add	eax, ecx
	movzx	edx, WORD PTR ?UIColorTable@@3PAY0BAA@GA[edx+eax*2]
	mov	DWORD PTR _r$[ebp], edx

; 1675 : 				g=UIColorTable[operc][UIColorTable[Perc-sub][gc] + UIColorTable[bgperc+sub][(dc >> g_shift_) & 0x1f]];

	mov	eax, DWORD PTR _operc$[ebp]
	shl	eax, 9
	mov	ecx, DWORD PTR _Perc$[ebp]
	sub	ecx, DWORD PTR _sub$[ebp]
	shl	ecx, 9
	mov	edx, DWORD PTR _gc$[ebp]
	movzx	edx, WORD PTR ?UIColorTable@@3PAY0BAA@GA[ecx+edx*2]
	mov	esi, DWORD PTR _bgperc$[ebp]
	add	esi, DWORD PTR _sub$[ebp]
	shl	esi, 9
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [ecx+468]
	mov	edi, DWORD PTR _dc$1[ebp]
	shr	edi, cl
	and	edi, 31					; 0000001fH
	movzx	ecx, WORD PTR ?UIColorTable@@3PAY0BAA@GA[esi+edi*2]
	add	edx, ecx
	movzx	edx, WORD PTR ?UIColorTable@@3PAY0BAA@GA[eax+edx*2]
	mov	DWORD PTR _g$[ebp], edx

; 1676 : 				b=UIColorTable[operc][UIColorTable[Perc-sub][bc] + UIColorTable[bgperc+sub][(dc >> b_shift_) & 0x1f]];

	mov	eax, DWORD PTR _operc$[ebp]
	shl	eax, 9
	mov	ecx, DWORD PTR _Perc$[ebp]
	sub	ecx, DWORD PTR _sub$[ebp]
	shl	ecx, 9
	mov	edx, DWORD PTR _bc$[ebp]
	movzx	edx, WORD PTR ?UIColorTable@@3PAY0BAA@GA[ecx+edx*2]
	mov	esi, DWORD PTR _bgperc$[ebp]
	add	esi, DWORD PTR _sub$[ebp]
	shl	esi, 9
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [ecx+476]
	mov	edi, DWORD PTR _dc$1[ebp]
	shr	edi, cl
	and	edi, 31					; 0000001fH
	movzx	ecx, WORD PTR ?UIColorTable@@3PAY0BAA@GA[esi+edi*2]
	add	edx, ecx
	movzx	edx, WORD PTR ?UIColorTable@@3PAY0BAA@GA[eax+edx*2]
	mov	DWORD PTR _b$[ebp], edx

; 1677 : 
; 1678 : 				if(surface->bpp == 32 )//XX

	mov	eax, DWORD PTR _surface$[ebp]
	movzx	ecx, BYTE PTR [eax+8]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN2@CustomBlit

; 1679 : 					((DWORD*)surface->mem)[didx] = RGB565toRGB8(static_cast<short>(rShift[r]|gShift[g]|bShift[b]));

	mov	edx, DWORD PTR _r$[ebp]
	movzx	eax, WORD PTR ?rShift@@3PAGA[edx*2]
	mov	ecx, DWORD PTR _g$[ebp]
	movzx	edx, WORD PTR ?gShift@@3PAGA[ecx*2]
	or	eax, edx
	mov	ecx, DWORD PTR _b$[ebp]
	movzx	edx, WORD PTR ?bShift@@3PAGA[ecx*2]
	or	eax, edx
	push	eax
	call	?RGB565toRGB8@@YAKG@Z			; RGB565toRGB8
	add	esp, 4
	mov	ecx, DWORD PTR _surface$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _didx$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 1680 : 				else

	jmp	SHORT $LN1@CustomBlit
$LN2@CustomBlit:

; 1681 : 					surface->mem[didx]=static_cast<short>(rShift[r]|gShift[g]|bShift[b]);

	mov	edx, DWORD PTR _r$[ebp]
	movzx	eax, WORD PTR ?rShift@@3PAGA[edx*2]
	mov	ecx, DWORD PTR _g$[ebp]
	movzx	edx, WORD PTR ?gShift@@3PAGA[ecx*2]
	or	eax, edx
	mov	ecx, DWORD PTR _b$[ebp]
	movzx	edx, WORD PTR ?bShift@@3PAGA[ecx*2]
	or	eax, edx
	mov	ecx, DWORD PTR _surface$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _didx$[ebp]
	mov	WORD PTR [edx+ecx*2], ax
$LN1@CustomBlit:

; 1682 : 
; 1683 : 			}
; 1684 : 			didx++;

	mov	edx, DWORD PTR _didx$[ebp]
	add	edx, 1
	mov	DWORD PTR _didx$[ebp], edx

; 1685 : 		}

	jmp	$LN11@CustomBlit
$LN10@CustomBlit:

; 1686 : 
; 1687 : 		didxstart+=surface->width;

	mov	eax, DWORD PTR _surface$[ebp]
	movsx	ecx, WORD PTR [eax+4]
	add	ecx, DWORD PTR _didxstart$[ebp]
	mov	DWORD PTR _didxstart$[ebp], ecx

; 1688 : 	}

	jmp	$LN16@CustomBlit
$LN15@CustomBlit:
$LN24@CustomBlit:

; 1689 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?CustomBlitTranslucent@C_Window@@QAEXPAVSCREEN@@KJPAUUI95_RECT@@JJ@Z ENDP ; C_Window::CustomBlitTranslucent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_bc$ = -92						; size = 4
_gc$ = -88						; size = 4
_rc$ = -84						; size = 4
_b$ = -80						; size = 4
_r$ = -76						; size = 4
_g$ = -72						; size = 4
_i$ = -68						; size = 4
_j$ = -64						; size = 4
_operc$ = -60						; size = 4
_didxstart$ = -56					; size = 4
_dc$1 = -52						; size = 4
_didx$ = -48						; size = 4
_bgperc$ = -44						; size = 4
_this$ = -40						; size = 4
_s$ = -36						; size = 16
_d$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_surface$ = 8						; size = 4
_color$ = 12						; size = 4
_Perc$ = 16						; size = 4
_rect$ = 20						; size = 4
_Flags$ = 24						; size = 4
_Client$ = 28						; size = 4
?BlitTranslucent@C_Window@@QAEXPAVSCREEN@@KJPAUUI95_RECT@@JJ@Z PROC ; C_Window::BlitTranslucent
; _this$ = ecx

; 1524 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1525 : 
; 1526 : 	int i,j;
; 1527 : 	long r,g,b;
; 1528 : 	long didx,didxstart;
; 1529 : 	long rc,gc,bc;
; 1530 : 	long bgperc,operc;
; 1531 : 	UI95_RECT s,d;
; 1532 : 
; 1533 : 	d=*rect;

	mov	eax, DWORD PTR _rect$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _d$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _d$[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _d$[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _d$[ebp+12], edx

; 1534 : 	if(Flags & C_BIT_ABSOLUTE)

	mov	eax, DWORD PTR _Flags$[ebp]
	and	eax, 262144				; 00040000H
	je	SHORT $LN16@BlitTransl

; 1535 : 	{
; 1536 : 		if(!ClipToArea(&s,&d,&Area_))

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	push	ecx
	lea	edx, DWORD PTR _d$[ebp]
	push	edx
	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClipToArea@C_Window@@QAEHPAUUI95_RECT@@00@Z ; C_Window::ClipToArea
	test	eax, eax
	jne	SHORT $LN15@BlitTransl

; 1537 : 			return;

	jmp	$LN17@BlitTransl
$LN15@BlitTransl:

; 1538 : 	}
; 1539 : 	else

	jmp	SHORT $LN14@BlitTransl
$LN16@BlitTransl:

; 1540 : 	{
; 1541 : 		d.left+=VX_[Client];

	mov	ecx, DWORD PTR _Client$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _d$[ebp]
	add	eax, DWORD PTR [edx+ecx*4+480]
	mov	DWORD PTR _d$[ebp], eax

; 1542 : 		d.top+=VY_[Client];

	mov	ecx, DWORD PTR _Client$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _d$[ebp+4]
	add	eax, DWORD PTR [edx+ecx*4+512]
	mov	DWORD PTR _d$[ebp+4], eax

; 1543 : 		d.right+=VX_[Client];

	mov	ecx, DWORD PTR _Client$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _d$[ebp+8]
	add	eax, DWORD PTR [edx+ecx*4+480]
	mov	DWORD PTR _d$[ebp+8], eax

; 1544 : 		d.bottom+=VY_[Client];

	mov	ecx, DWORD PTR _Client$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _d$[ebp+12]
	add	eax, DWORD PTR [edx+ecx*4+512]
	mov	DWORD PTR _d$[ebp+12], eax

; 1545 : 		if(!ClipToArea(&s,&d,&ClientArea_[Client]))

	mov	ecx, DWORD PTR _Client$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+168]
	push	eax
	lea	ecx, DWORD PTR _d$[ebp]
	push	ecx
	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClipToArea@C_Window@@QAEHPAUUI95_RECT@@00@Z ; C_Window::ClipToArea
	test	eax, eax
	jne	SHORT $LN14@BlitTransl

; 1546 : 			return;

	jmp	$LN17@BlitTransl
$LN14@BlitTransl:

; 1547 : 	}
; 1548 : 
; 1549 : 	d.left+=GetX();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetX@C_Window@@QAEFXZ			; C_Window::GetX
	cwde
	add	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 1550 : 	d.top+=GetY();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetY@C_Window@@QAEFXZ			; C_Window::GetY
	movsx	ecx, ax
	add	ecx, DWORD PTR _d$[ebp+4]
	mov	DWORD PTR _d$[ebp+4], ecx

; 1551 : 	d.right+=GetX();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetX@C_Window@@QAEFXZ			; C_Window::GetX
	movsx	edx, ax
	add	edx, DWORD PTR _d$[ebp+8]
	mov	DWORD PTR _d$[ebp+8], edx

; 1552 : 	d.bottom+=GetY();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetY@C_Window@@QAEFXZ			; C_Window::GetY
	cwde
	add	eax, DWORD PTR _d$[ebp+12]
	mov	DWORD PTR _d$[ebp+12], eax

; 1553 : 
; 1554 : 	rc=UIColorTable[Perc][(color >>  3) & 0x1f];

	mov	ecx, DWORD PTR _Perc$[ebp]
	shl	ecx, 9
	mov	edx, DWORD PTR _color$[ebp]
	shr	edx, 3
	and	edx, 31					; 0000001fH
	movzx	eax, WORD PTR ?UIColorTable@@3PAY0BAA@GA[ecx+edx*2]
	mov	DWORD PTR _rc$[ebp], eax

; 1555 : 	gc=UIColorTable[Perc][(color >> 11) & 0x1f];

	mov	ecx, DWORD PTR _Perc$[ebp]
	shl	ecx, 9
	mov	edx, DWORD PTR _color$[ebp]
	shr	edx, 11					; 0000000bH
	and	edx, 31					; 0000001fH
	movzx	eax, WORD PTR ?UIColorTable@@3PAY0BAA@GA[ecx+edx*2]
	mov	DWORD PTR _gc$[ebp], eax

; 1556 : 	bc=UIColorTable[Perc][(color >> 19) & 0x1f];

	mov	ecx, DWORD PTR _Perc$[ebp]
	shl	ecx, 9
	mov	edx, DWORD PTR _color$[ebp]
	shr	edx, 19					; 00000013H
	and	edx, 31					; 0000001fH
	movzx	eax, WORD PTR ?UIColorTable@@3PAY0BAA@GA[ecx+edx*2]
	mov	DWORD PTR _bc$[ebp], eax

; 1557 : 
; 1558 : 	bgperc=100-Perc;

	mov	ecx, 100				; 00000064H
	sub	ecx, DWORD PTR _Perc$[ebp]
	mov	DWORD PTR _bgperc$[ebp], ecx

; 1559 : 	if(bgperc < 0) bgperc=0;

	jns	SHORT $LN12@BlitTransl
	mov	DWORD PTR _bgperc$[ebp], 0
$LN12@BlitTransl:

; 1560 : 	if(bgperc > 100) bgperc=100;

	cmp	DWORD PTR _bgperc$[ebp], 100		; 00000064H
	jle	SHORT $LN11@BlitTransl
	mov	DWORD PTR _bgperc$[ebp], 100		; 00000064H
$LN11@BlitTransl:

; 1561 : 	operc=Perc+bgperc;

	mov	edx, DWORD PTR _Perc$[ebp]
	add	edx, DWORD PTR _bgperc$[ebp]
	mov	DWORD PTR _operc$[ebp], edx

; 1562 : 
; 1563 : 	didxstart=d.top*surface->width;

	mov	eax, DWORD PTR _surface$[ebp]
	movsx	ecx, WORD PTR [eax+4]
	imul	ecx, DWORD PTR _d$[ebp+4]
	mov	DWORD PTR _didxstart$[ebp], ecx

; 1564 : 	for(i=d.top;i < d.bottom;i++)

	mov	edx, DWORD PTR _d$[ebp+4]
	mov	DWORD PTR _i$[ebp], edx
	jmp	SHORT $LN10@BlitTransl
$LN9@BlitTransl:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@BlitTransl:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _d$[ebp+12]
	jge	$LN17@BlitTransl

; 1565 : 	{
; 1566 : 		didx=didxstart+d.left;

	mov	edx, DWORD PTR _didxstart$[ebp]
	add	edx, DWORD PTR _d$[ebp]
	mov	DWORD PTR _didx$[ebp], edx

; 1567 : 		for(j=d.left;j < d.right;j++)

	mov	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $LN7@BlitTransl
$LN6@BlitTransl:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN7@BlitTransl:
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR _d$[ebp+8]
	jge	$LN5@BlitTransl

; 1568 : 		{
; 1569 : 			DWORD dc;//XX
; 1570 : 			if( surface->bpp == 32 )

	mov	eax, DWORD PTR _surface$[ebp]
	movzx	ecx, BYTE PTR [eax+8]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN4@BlitTransl

; 1571 : 				dc = RGB8toRGB565( ((DWORD*)surface->mem)[ didx ] );

	mov	edx, DWORD PTR _surface$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _didx$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	?RGB8toRGB565@@YAGK@Z			; RGB8toRGB565
	add	esp, 4
	movzx	eax, ax
	mov	DWORD PTR _dc$1[ebp], eax

; 1572 : 			else

	jmp	SHORT $LN3@BlitTransl
$LN4@BlitTransl:

; 1573 : 				dc = surface->mem[didx];

	mov	ecx, DWORD PTR _surface$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _didx$[ebp]
	movzx	ecx, WORD PTR [edx+eax*2]
	mov	DWORD PTR _dc$1[ebp], ecx
$LN3@BlitTransl:

; 1574 : 
; 1575 : 			r=UIColorTable[operc][rc + UIColorTable[bgperc][(dc >> r_shift_) & 0x1f]];

	mov	edx, DWORD PTR _operc$[ebp]
	shl	edx, 9
	mov	eax, DWORD PTR _bgperc$[ebp]
	shl	eax, 9
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [ecx+460]
	mov	esi, DWORD PTR _dc$1[ebp]
	shr	esi, cl
	and	esi, 31					; 0000001fH
	movzx	eax, WORD PTR ?UIColorTable@@3PAY0BAA@GA[eax+esi*2]
	add	eax, DWORD PTR _rc$[ebp]
	movzx	ecx, WORD PTR ?UIColorTable@@3PAY0BAA@GA[edx+eax*2]
	mov	DWORD PTR _r$[ebp], ecx

; 1576 : 			g=UIColorTable[operc][gc + UIColorTable[bgperc][(dc >> g_shift_) & 0x1f]];

	mov	edx, DWORD PTR _operc$[ebp]
	shl	edx, 9
	mov	eax, DWORD PTR _bgperc$[ebp]
	shl	eax, 9
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [ecx+468]
	mov	esi, DWORD PTR _dc$1[ebp]
	shr	esi, cl
	and	esi, 31					; 0000001fH
	movzx	eax, WORD PTR ?UIColorTable@@3PAY0BAA@GA[eax+esi*2]
	add	eax, DWORD PTR _gc$[ebp]
	movzx	ecx, WORD PTR ?UIColorTable@@3PAY0BAA@GA[edx+eax*2]
	mov	DWORD PTR _g$[ebp], ecx

; 1577 : 			b=UIColorTable[operc][bc + UIColorTable[bgperc][(dc >> b_shift_) & 0x1f]];

	mov	edx, DWORD PTR _operc$[ebp]
	shl	edx, 9
	mov	eax, DWORD PTR _bgperc$[ebp]
	shl	eax, 9
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [ecx+476]
	mov	esi, DWORD PTR _dc$1[ebp]
	shr	esi, cl
	and	esi, 31					; 0000001fH
	movzx	eax, WORD PTR ?UIColorTable@@3PAY0BAA@GA[eax+esi*2]
	add	eax, DWORD PTR _bc$[ebp]
	movzx	ecx, WORD PTR ?UIColorTable@@3PAY0BAA@GA[edx+eax*2]
	mov	DWORD PTR _b$[ebp], ecx

; 1578 : 
; 1579 : 			if( surface->bpp == 32 )//XX

	mov	edx, DWORD PTR _surface$[ebp]
	movzx	eax, BYTE PTR [edx+8]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN2@BlitTransl

; 1580 : 				((DWORD*)surface->mem)[ didx ] = RGB565toRGB8( static_cast<WORD>((rShift[r]|gShift[g]|bShift[b])) );

	mov	ecx, DWORD PTR _r$[ebp]
	movzx	edx, WORD PTR ?rShift@@3PAGA[ecx*2]
	mov	eax, DWORD PTR _g$[ebp]
	movzx	ecx, WORD PTR ?gShift@@3PAGA[eax*2]
	or	edx, ecx
	mov	eax, DWORD PTR _b$[ebp]
	movzx	ecx, WORD PTR ?bShift@@3PAGA[eax*2]
	or	edx, ecx
	push	edx
	call	?RGB565toRGB8@@YAKG@Z			; RGB565toRGB8
	add	esp, 4
	mov	edx, DWORD PTR _surface$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _didx$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 1581 : 			else

	jmp	SHORT $LN1@BlitTransl
$LN2@BlitTransl:

; 1582 : 			surface->mem[didx]=static_cast<WORD>((rShift[r]|gShift[g]|bShift[b]));

	mov	eax, DWORD PTR _r$[ebp]
	movzx	ecx, WORD PTR ?rShift@@3PAGA[eax*2]
	mov	edx, DWORD PTR _g$[ebp]
	movzx	eax, WORD PTR ?gShift@@3PAGA[edx*2]
	or	ecx, eax
	mov	edx, DWORD PTR _b$[ebp]
	movzx	eax, WORD PTR ?bShift@@3PAGA[edx*2]
	or	ecx, eax
	mov	edx, DWORD PTR _surface$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _didx$[ebp]
	mov	WORD PTR [eax+edx*2], cx
$LN1@BlitTransl:

; 1583 : 
; 1584 : 
; 1585 : 			didx++;

	mov	eax, DWORD PTR _didx$[ebp]
	add	eax, 1
	mov	DWORD PTR _didx$[ebp], eax

; 1586 : 		}

	jmp	$LN6@BlitTransl
$LN5@BlitTransl:

; 1587 : 		didxstart+=surface->width;

	mov	ecx, DWORD PTR _surface$[ebp]
	movsx	edx, WORD PTR [ecx+4]
	add	edx, DWORD PTR _didxstart$[ebp]
	mov	DWORD PTR _didxstart$[ebp], edx

; 1588 : 	}

	jmp	$LN9@BlitTransl
$LN17@BlitTransl:

; 1589 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?BlitTranslucent@C_Window@@QAEXPAVSCREEN@@KJPAUUI95_RECT@@JJ@Z ENDP ; C_Window::BlitTranslucent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_bf$ = -40						; size = 4
_gf$ = -36						; size = 4
_rf$ = -32						; size = 4
_didx$ = -28						; size = 4
_didxstart$ = -24					; size = 4
_fidxstart$ = -20					; size = 4
_j$ = -16						; size = 4
_i$ = -12						; size = 4
_fidx$ = -8						; size = 4
_this$ = -4						; size = 4
_front$ = 8						; size = 4
_frect$ = 12						; size = 4
_fwidth$ = 16						; size = 2
_dest$ = 20						; size = 4
_drect$ = 24						; size = 4
_dwidth$ = 28						; size = 2
?Translucency@C_Window@@QAEXPAGPAUUI95_RECT@@F01F@Z PROC ; C_Window::Translucency
; _this$ = ecx

; 1493 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 1494 : 	long i,j;
; 1495 : 	long rf,gf,bf;
; 1496 : 	long fidx,fidxstart;
; 1497 : 	long didx,didxstart;
; 1498 : 
; 1499 : 	if(!front || !frect || !fwidth  || !dest || !drect || !dwidth)

	cmp	DWORD PTR _front$[ebp], 0
	je	SHORT $LN7@Translucen
	cmp	DWORD PTR _frect$[ebp], 0
	je	SHORT $LN7@Translucen
	movsx	eax, WORD PTR _fwidth$[ebp]
	test	eax, eax
	je	SHORT $LN7@Translucen
	cmp	DWORD PTR _dest$[ebp], 0
	je	SHORT $LN7@Translucen
	cmp	DWORD PTR _drect$[ebp], 0
	je	SHORT $LN7@Translucen
	movsx	ecx, WORD PTR _dwidth$[ebp]
	test	ecx, ecx
	jne	SHORT $LN8@Translucen
$LN7@Translucen:

; 1500 : 		return;

	jmp	$LN9@Translucen
$LN8@Translucen:

; 1501 : 
; 1502 : 	fidxstart=frect->top*fwidth;

	movsx	edx, WORD PTR _fwidth$[ebp]
	mov	eax, DWORD PTR _frect$[ebp]
	imul	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _fidxstart$[ebp], edx

; 1503 : 	didxstart=drect->top*dwidth;

	movsx	ecx, WORD PTR _dwidth$[ebp]
	mov	edx, DWORD PTR _drect$[ebp]
	imul	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _didxstart$[ebp], ecx

; 1504 : 	for(i=drect->top;i < drect->bottom;i++)

	mov	eax, DWORD PTR _drect$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN6@Translucen
$LN5@Translucen:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN6@Translucen:
	mov	eax, DWORD PTR _drect$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jge	$LN9@Translucen

; 1505 : 	{
; 1506 : 		fidx=fidxstart+frect->left;

	mov	edx, DWORD PTR _frect$[ebp]
	mov	eax, DWORD PTR _fidxstart$[ebp]
	add	eax, DWORD PTR [edx]
	mov	DWORD PTR _fidx$[ebp], eax

; 1507 : 		didx=didxstart+drect->left;

	mov	ecx, DWORD PTR _drect$[ebp]
	mov	edx, DWORD PTR _didxstart$[ebp]
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR _didx$[ebp], edx

; 1508 : 		for(j=drect->left;j<drect->right;j++)

	mov	eax, DWORD PTR _drect$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _j$[ebp], ecx
	jmp	SHORT $LN3@Translucen
$LN2@Translucen:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN3@Translucen:
	mov	eax, DWORD PTR _drect$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jge	$LN1@Translucen

; 1509 : 		{
; 1510 : 			rf=UIColorTable[0][(front[fidx] & r_mask_) >> r_shift_];

	mov	edx, 512				; 00000200H
	imul	edx, 0
	mov	eax, DWORD PTR _fidx$[ebp]
	mov	ecx, DWORD PTR _front$[ebp]
	movzx	eax, WORD PTR [ecx+eax*2]
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+456]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [ecx+460]
	shr	eax, cl
	movzx	edx, WORD PTR ?UIColorTable@@3PAY0BAA@GA[edx+eax*2]
	mov	DWORD PTR _rf$[ebp], edx

; 1511 : 			gf=UIColorTable[0][(front[fidx] & g_mask_) >> g_shift_];

	mov	eax, 512				; 00000200H
	imul	eax, 0
	mov	ecx, DWORD PTR _fidx$[ebp]
	mov	edx, DWORD PTR _front$[ebp]
	movzx	edx, WORD PTR [edx+ecx*2]
	mov	ecx, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [ecx+464]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [ecx+468]
	shr	edx, cl
	movzx	edx, WORD PTR ?UIColorTable@@3PAY0BAA@GA[eax+edx*2]
	mov	DWORD PTR _gf$[ebp], edx

; 1512 : 			bf=UIColorTable[0][(front[fidx] & b_mask_) >> b_shift_];

	mov	eax, 512				; 00000200H
	imul	eax, 0
	mov	ecx, DWORD PTR _fidx$[ebp]
	mov	edx, DWORD PTR _front$[ebp]
	movzx	edx, WORD PTR [edx+ecx*2]
	mov	ecx, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [ecx+472]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [ecx+476]
	shr	edx, cl
	movzx	edx, WORD PTR ?UIColorTable@@3PAY0BAA@GA[eax+edx*2]
	mov	DWORD PTR _bf$[ebp], edx

; 1513 : 
; 1514 : 			dest[j+i*dwidth]=static_cast<WORD>(rShift[rf] | gShift[gf] | bShift[bf]);//! 

	mov	eax, DWORD PTR _rf$[ebp]
	movzx	ecx, WORD PTR ?rShift@@3PAGA[eax*2]
	mov	edx, DWORD PTR _gf$[ebp]
	movzx	eax, WORD PTR ?gShift@@3PAGA[edx*2]
	or	ecx, eax
	mov	edx, DWORD PTR _bf$[ebp]
	movzx	eax, WORD PTR ?bShift@@3PAGA[edx*2]
	or	ecx, eax
	movsx	edx, WORD PTR _dwidth$[ebp]
	imul	edx, DWORD PTR _i$[ebp]
	add	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _dest$[ebp]
	mov	WORD PTR [eax+edx*2], cx

; 1515 : 			fidx++;

	mov	ecx, DWORD PTR _fidx$[ebp]
	add	ecx, 1
	mov	DWORD PTR _fidx$[ebp], ecx

; 1516 : 			didx++;

	mov	edx, DWORD PTR _didx$[ebp]
	add	edx, 1
	mov	DWORD PTR _didx$[ebp], edx

; 1517 : 		}

	jmp	$LN2@Translucen
$LN1@Translucen:

; 1518 : 		fidxstart+=fwidth;

	movsx	eax, WORD PTR _fwidth$[ebp]
	add	eax, DWORD PTR _fidxstart$[ebp]
	mov	DWORD PTR _fidxstart$[ebp], eax

; 1519 : 		didxstart+=dwidth;

	movsx	ecx, WORD PTR _dwidth$[ebp]
	add	ecx, DWORD PTR _didxstart$[ebp]
	mov	DWORD PTR _didxstart$[ebp], ecx

; 1520 : 	}

	jmp	$LN5@Translucen
$LN9@Translucen:

; 1521 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?Translucency@C_Window@@QAEXPAGPAUUI95_RECT@@F01F@Z ENDP ; C_Window::Translucency
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_bb$ = -60						; size = 4
_bf$ = -56						; size = 4
_gb$ = -52						; size = 4
_gf$ = -48						; size = 4
_rb$ = -44						; size = 4
_rf$ = -40						; size = 4
_didxstart$ = -36					; size = 4
_bidxstart$ = -32					; size = 4
_fidxstart$ = -28					; size = 4
_j$ = -24						; size = 4
_i$ = -20						; size = 4
_didx$ = -16						; size = 4
_bidx$ = -12						; size = 4
_fidx$ = -8						; size = 4
_this$ = -4						; size = 4
_Mask$ = 8						; size = 2
_front$ = 12						; size = 4
_frect$ = 16						; size = 4
_fwidth$ = 20						; size = 2
_back$ = 24						; size = 4
_brect$ = 28						; size = 4
_bwidth$ = 32						; size = 2
_dest$ = 36						; size = 4
_drect$ = 40						; size = 4
_dwidth$ = 44						; size = 2
_fperc$ = 48						; size = 2
_bperc$ = 52						; size = 2
?BlendTransparent@C_Window@@QAEXGPAGPAUUI95_RECT@@F01F01FFF@Z PROC ; C_Window::BlendTransparent
; _this$ = ecx

; 1449 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1450 : 	long i,j;
; 1451 : 	long rf,rb,gf,gb,bf,bb;
; 1452 : 	long fidx,bidx,didx;
; 1453 : 	long fidxstart,bidxstart,didxstart;
; 1454 : 
; 1455 : 	if(!front || !frect || !fwidth || !back || !brect || !bwidth || !dest || !drect || !dwidth)

	cmp	DWORD PTR _front$[ebp], 0
	je	SHORT $LN9@BlendTrans
	cmp	DWORD PTR _frect$[ebp], 0
	je	SHORT $LN9@BlendTrans
	movsx	eax, WORD PTR _fwidth$[ebp]
	test	eax, eax
	je	SHORT $LN9@BlendTrans
	cmp	DWORD PTR _back$[ebp], 0
	je	SHORT $LN9@BlendTrans
	cmp	DWORD PTR _brect$[ebp], 0
	je	SHORT $LN9@BlendTrans
	movsx	ecx, WORD PTR _bwidth$[ebp]
	test	ecx, ecx
	je	SHORT $LN9@BlendTrans
	cmp	DWORD PTR _dest$[ebp], 0
	je	SHORT $LN9@BlendTrans
	cmp	DWORD PTR _drect$[ebp], 0
	je	SHORT $LN9@BlendTrans
	movsx	edx, WORD PTR _dwidth$[ebp]
	test	edx, edx
	jne	SHORT $LN10@BlendTrans
$LN9@BlendTrans:

; 1456 : 		return;

	jmp	$LN11@BlendTrans
$LN10@BlendTrans:

; 1457 : 
; 1458 : 	fidxstart=frect->top*fwidth;

	movsx	eax, WORD PTR _fwidth$[ebp]
	mov	ecx, DWORD PTR _frect$[ebp]
	imul	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _fidxstart$[ebp], eax

; 1459 : 	bidxstart=brect->top*bwidth;

	movsx	edx, WORD PTR _bwidth$[ebp]
	mov	eax, DWORD PTR _brect$[ebp]
	imul	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _bidxstart$[ebp], edx

; 1460 : 	didxstart=drect->top*dwidth;

	movsx	ecx, WORD PTR _dwidth$[ebp]
	mov	edx, DWORD PTR _drect$[ebp]
	imul	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _didxstart$[ebp], ecx

; 1461 : 	for(i=drect->top;i < drect->bottom;i++)

	mov	eax, DWORD PTR _drect$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN8@BlendTrans
$LN7@BlendTrans:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN8@BlendTrans:
	mov	eax, DWORD PTR _drect$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jge	$LN11@BlendTrans

; 1462 : 	{
; 1463 : 		fidx=fidxstart+frect->left;

	mov	edx, DWORD PTR _frect$[ebp]
	mov	eax, DWORD PTR _fidxstart$[ebp]
	add	eax, DWORD PTR [edx]
	mov	DWORD PTR _fidx$[ebp], eax

; 1464 : 		bidx=bidxstart+brect->left;

	mov	ecx, DWORD PTR _brect$[ebp]
	mov	edx, DWORD PTR _bidxstart$[ebp]
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR _bidx$[ebp], edx

; 1465 : 		didx=didxstart+drect->left;

	mov	eax, DWORD PTR _drect$[ebp]
	mov	ecx, DWORD PTR _didxstart$[ebp]
	add	ecx, DWORD PTR [eax]
	mov	DWORD PTR _didx$[ebp], ecx

; 1466 : 		for(j=drect->left;j<drect->right;j++)

	mov	edx, DWORD PTR _drect$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $LN5@BlendTrans
$LN4@BlendTrans:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN5@BlendTrans:
	mov	edx, DWORD PTR _drect$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jge	$LN3@BlendTrans

; 1467 : 		{
; 1468 : 			if(front[fidx] != Mask)

	mov	ecx, DWORD PTR _fidx$[ebp]
	mov	edx, DWORD PTR _front$[ebp]
	movzx	eax, WORD PTR [edx+ecx*2]
	movzx	ecx, WORD PTR _Mask$[ebp]
	cmp	eax, ecx
	je	$LN2@BlendTrans

; 1469 : 			{
; 1470 : 				rf=UIColorTable[fperc][(front[fidx] & r_mask_) >> r_shift_];

	movsx	edx, WORD PTR _fperc$[ebp]
	shl	edx, 9
	mov	eax, DWORD PTR _fidx$[ebp]
	mov	ecx, DWORD PTR _front$[ebp]
	movzx	eax, WORD PTR [ecx+eax*2]
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+456]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [ecx+460]
	shr	eax, cl
	movzx	edx, WORD PTR ?UIColorTable@@3PAY0BAA@GA[edx+eax*2]
	mov	DWORD PTR _rf$[ebp], edx

; 1471 : 				gf=UIColorTable[fperc][(front[fidx] & g_mask_) >> g_shift_];

	movsx	eax, WORD PTR _fperc$[ebp]
	shl	eax, 9
	mov	ecx, DWORD PTR _fidx$[ebp]
	mov	edx, DWORD PTR _front$[ebp]
	movzx	edx, WORD PTR [edx+ecx*2]
	mov	ecx, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [ecx+464]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [ecx+468]
	shr	edx, cl
	movzx	edx, WORD PTR ?UIColorTable@@3PAY0BAA@GA[eax+edx*2]
	mov	DWORD PTR _gf$[ebp], edx

; 1472 : 				bf=UIColorTable[fperc][(front[fidx] & b_mask_) >> b_shift_];

	movsx	eax, WORD PTR _fperc$[ebp]
	shl	eax, 9
	mov	ecx, DWORD PTR _fidx$[ebp]
	mov	edx, DWORD PTR _front$[ebp]
	movzx	edx, WORD PTR [edx+ecx*2]
	mov	ecx, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [ecx+472]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [ecx+476]
	shr	edx, cl
	movzx	edx, WORD PTR ?UIColorTable@@3PAY0BAA@GA[eax+edx*2]
	mov	DWORD PTR _bf$[ebp], edx

; 1473 : 
; 1474 : 				rb=UIColorTable[bperc][(back[bidx] & r_mask_) >> r_shift_];

	movsx	eax, WORD PTR _bperc$[ebp]
	shl	eax, 9
	mov	ecx, DWORD PTR _bidx$[ebp]
	mov	edx, DWORD PTR _back$[ebp]
	movzx	edx, WORD PTR [edx+ecx*2]
	mov	ecx, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [ecx+456]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [ecx+460]
	shr	edx, cl
	movzx	edx, WORD PTR ?UIColorTable@@3PAY0BAA@GA[eax+edx*2]
	mov	DWORD PTR _rb$[ebp], edx

; 1475 : 				gb=UIColorTable[bperc][(back[bidx] & g_mask_) >> g_shift_];

	movsx	eax, WORD PTR _bperc$[ebp]
	shl	eax, 9
	mov	ecx, DWORD PTR _bidx$[ebp]
	mov	edx, DWORD PTR _back$[ebp]
	movzx	edx, WORD PTR [edx+ecx*2]
	mov	ecx, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [ecx+464]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [ecx+468]
	shr	edx, cl
	movzx	edx, WORD PTR ?UIColorTable@@3PAY0BAA@GA[eax+edx*2]
	mov	DWORD PTR _gb$[ebp], edx

; 1476 : 				bb=UIColorTable[bperc][(back[bidx] & b_mask_) >> b_shift_];

	movsx	eax, WORD PTR _bperc$[ebp]
	shl	eax, 9
	mov	ecx, DWORD PTR _bidx$[ebp]
	mov	edx, DWORD PTR _back$[ebp]
	movzx	edx, WORD PTR [edx+ecx*2]
	mov	ecx, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [ecx+472]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [ecx+476]
	shr	edx, cl
	movzx	edx, WORD PTR ?UIColorTable@@3PAY0BAA@GA[eax+edx*2]
	mov	DWORD PTR _bb$[ebp], edx

; 1477 : 
; 1478 : 				dest[didx]=static_cast<WORD>(rShift[UIColorTable[100][rf+rb]] | gShift[UIColorTable[100][gf+gb]] | bShift[UIColorTable[100][bf+bb]]);//! 

	mov	eax, 512				; 00000200H
	imul	eax, 100				; 00000064H
	mov	ecx, DWORD PTR _rf$[ebp]
	add	ecx, DWORD PTR _rb$[ebp]
	movzx	edx, WORD PTR ?UIColorTable@@3PAY0BAA@GA[eax+ecx*2]
	movzx	eax, WORD PTR ?rShift@@3PAGA[edx*2]
	mov	ecx, 512				; 00000200H
	imul	ecx, 100				; 00000064H
	mov	edx, DWORD PTR _gf$[ebp]
	add	edx, DWORD PTR _gb$[ebp]
	movzx	ecx, WORD PTR ?UIColorTable@@3PAY0BAA@GA[ecx+edx*2]
	movzx	edx, WORD PTR ?gShift@@3PAGA[ecx*2]
	or	eax, edx
	mov	ecx, 512				; 00000200H
	imul	ecx, 100				; 00000064H
	mov	edx, DWORD PTR _bf$[ebp]
	add	edx, DWORD PTR _bb$[ebp]
	movzx	ecx, WORD PTR ?UIColorTable@@3PAY0BAA@GA[ecx+edx*2]
	movzx	edx, WORD PTR ?bShift@@3PAGA[ecx*2]
	or	eax, edx
	mov	ecx, DWORD PTR _didx$[ebp]
	mov	edx, DWORD PTR _dest$[ebp]
	mov	WORD PTR [edx+ecx*2], ax

; 1479 : 			}
; 1480 : 			else

	jmp	SHORT $LN1@BlendTrans
$LN2@BlendTrans:

; 1481 : 				dest[didx]=back[bidx];

	mov	eax, DWORD PTR _didx$[ebp]
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _bidx$[ebp]
	mov	esi, DWORD PTR _back$[ebp]
	mov	dx, WORD PTR [esi+edx*2]
	mov	WORD PTR [ecx+eax*2], dx
$LN1@BlendTrans:

; 1482 : 			fidx++;

	mov	eax, DWORD PTR _fidx$[ebp]
	add	eax, 1
	mov	DWORD PTR _fidx$[ebp], eax

; 1483 : 			bidx++;

	mov	ecx, DWORD PTR _bidx$[ebp]
	add	ecx, 1
	mov	DWORD PTR _bidx$[ebp], ecx

; 1484 : 			didx++;

	mov	edx, DWORD PTR _didx$[ebp]
	add	edx, 1
	mov	DWORD PTR _didx$[ebp], edx

; 1485 : 		}

	jmp	$LN4@BlendTrans
$LN3@BlendTrans:

; 1486 : 		fidxstart+=fwidth;

	movsx	eax, WORD PTR _fwidth$[ebp]
	add	eax, DWORD PTR _fidxstart$[ebp]
	mov	DWORD PTR _fidxstart$[ebp], eax

; 1487 : 		bidxstart+=bwidth;

	movsx	ecx, WORD PTR _bwidth$[ebp]
	add	ecx, DWORD PTR _bidxstart$[ebp]
	mov	DWORD PTR _bidxstart$[ebp], ecx

; 1488 : 		didxstart+=dwidth;

	movsx	edx, WORD PTR _dwidth$[ebp]
	add	edx, DWORD PTR _didxstart$[ebp]
	mov	DWORD PTR _didxstart$[ebp], edx

; 1489 : 	}

	jmp	$LN7@BlendTrans
$LN11@BlendTrans:

; 1490 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	48					; 00000030H
?BlendTransparent@C_Window@@QAEXGPAGPAUUI95_RECT@@F01F01FFF@Z ENDP ; C_Window::BlendTransparent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_bb$ = -60						; size = 4
_bf$ = -56						; size = 4
_gb$ = -52						; size = 4
_gf$ = -48						; size = 4
_rb$ = -44						; size = 4
_rf$ = -40						; size = 4
_didxstart$ = -36					; size = 4
_bidxstart$ = -32					; size = 4
_fidxstart$ = -28					; size = 4
_didx$ = -24						; size = 4
_j$ = -20						; size = 4
_i$ = -16						; size = 4
_bidx$ = -12						; size = 4
_fidx$ = -8						; size = 4
_this$ = -4						; size = 4
_front$ = 8						; size = 4
_frect$ = 12						; size = 4
_fwidth$ = 16						; size = 2
_back$ = 20						; size = 4
_brect$ = 24						; size = 4
_bwidth$ = 28						; size = 2
_dest$ = 32						; size = 4
_drect$ = 36						; size = 4
_dwidth$ = 40						; size = 2
_fperc$ = 44						; size = 2
_bperc$ = 48						; size = 2
?Blend@C_Window@@QAEXPAGPAUUI95_RECT@@F01F01FFF@Z PROC	; C_Window::Blend
; _this$ = ecx

; 1410 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	DWORD PTR _this$[ebp], ecx

; 1411 : 	long i,j;
; 1412 : 	long rf,rb,gf,gb,bf,bb;
; 1413 : 	long fidx,bidx,didx;
; 1414 : 	long fidxstart,bidxstart,didxstart;
; 1415 : 
; 1416 : 	if(!front || !frect || !fwidth || !back || !brect || !bwidth || !dest || !drect || !dwidth)

	cmp	DWORD PTR _front$[ebp], 0
	je	SHORT $LN7@Blend
	cmp	DWORD PTR _frect$[ebp], 0
	je	SHORT $LN7@Blend
	movsx	eax, WORD PTR _fwidth$[ebp]
	test	eax, eax
	je	SHORT $LN7@Blend
	cmp	DWORD PTR _back$[ebp], 0
	je	SHORT $LN7@Blend
	cmp	DWORD PTR _brect$[ebp], 0
	je	SHORT $LN7@Blend
	movsx	ecx, WORD PTR _bwidth$[ebp]
	test	ecx, ecx
	je	SHORT $LN7@Blend
	cmp	DWORD PTR _dest$[ebp], 0
	je	SHORT $LN7@Blend
	cmp	DWORD PTR _drect$[ebp], 0
	je	SHORT $LN7@Blend
	movsx	edx, WORD PTR _dwidth$[ebp]
	test	edx, edx
	jne	SHORT $LN8@Blend
$LN7@Blend:

; 1417 : 		return;

	jmp	$LN9@Blend
$LN8@Blend:

; 1418 : 
; 1419 : 	fidxstart=frect->top*fwidth;

	movsx	eax, WORD PTR _fwidth$[ebp]
	mov	ecx, DWORD PTR _frect$[ebp]
	imul	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _fidxstart$[ebp], eax

; 1420 : 	bidxstart=brect->top*bwidth;

	movsx	edx, WORD PTR _bwidth$[ebp]
	mov	eax, DWORD PTR _brect$[ebp]
	imul	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _bidxstart$[ebp], edx

; 1421 : 	didxstart=drect->top*dwidth;

	movsx	ecx, WORD PTR _dwidth$[ebp]
	mov	edx, DWORD PTR _drect$[ebp]
	imul	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _didxstart$[ebp], ecx

; 1422 : 	for(i=drect->top;i < drect->bottom;i++)

	mov	eax, DWORD PTR _drect$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN6@Blend
$LN5@Blend:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN6@Blend:
	mov	eax, DWORD PTR _drect$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jge	$LN9@Blend

; 1423 : 	{
; 1424 : 		fidx=fidxstart+frect->left;

	mov	edx, DWORD PTR _frect$[ebp]
	mov	eax, DWORD PTR _fidxstart$[ebp]
	add	eax, DWORD PTR [edx]
	mov	DWORD PTR _fidx$[ebp], eax

; 1425 : 		bidx=bidxstart+brect->left;

	mov	ecx, DWORD PTR _brect$[ebp]
	mov	edx, DWORD PTR _bidxstart$[ebp]
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR _bidx$[ebp], edx

; 1426 : 		didx=didxstart+drect->left;

	mov	eax, DWORD PTR _drect$[ebp]
	mov	ecx, DWORD PTR _didxstart$[ebp]
	add	ecx, DWORD PTR [eax]
	mov	DWORD PTR _didx$[ebp], ecx

; 1427 : 		for(j=drect->left;j<drect->right;j++)

	mov	edx, DWORD PTR _drect$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $LN3@Blend
$LN2@Blend:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN3@Blend:
	mov	edx, DWORD PTR _drect$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jge	$LN1@Blend

; 1428 : 		{
; 1429 : 			rf=UIColorTable[fperc][(front[fidx] & r_mask_) >> r_shift_];

	movsx	edx, WORD PTR _fperc$[ebp]
	shl	edx, 9
	mov	eax, DWORD PTR _fidx$[ebp]
	mov	ecx, DWORD PTR _front$[ebp]
	movzx	eax, WORD PTR [ecx+eax*2]
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+456]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [ecx+460]
	shr	eax, cl
	movzx	edx, WORD PTR ?UIColorTable@@3PAY0BAA@GA[edx+eax*2]
	mov	DWORD PTR _rf$[ebp], edx

; 1430 : 			gf=UIColorTable[fperc][(front[fidx] & g_mask_) >> g_shift_];

	movsx	eax, WORD PTR _fperc$[ebp]
	shl	eax, 9
	mov	ecx, DWORD PTR _fidx$[ebp]
	mov	edx, DWORD PTR _front$[ebp]
	movzx	edx, WORD PTR [edx+ecx*2]
	mov	ecx, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [ecx+464]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [ecx+468]
	shr	edx, cl
	movzx	edx, WORD PTR ?UIColorTable@@3PAY0BAA@GA[eax+edx*2]
	mov	DWORD PTR _gf$[ebp], edx

; 1431 : 			bf=UIColorTable[fperc][(front[fidx] & b_mask_) >> b_shift_];

	movsx	eax, WORD PTR _fperc$[ebp]
	shl	eax, 9
	mov	ecx, DWORD PTR _fidx$[ebp]
	mov	edx, DWORD PTR _front$[ebp]
	movzx	edx, WORD PTR [edx+ecx*2]
	mov	ecx, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [ecx+472]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [ecx+476]
	shr	edx, cl
	movzx	edx, WORD PTR ?UIColorTable@@3PAY0BAA@GA[eax+edx*2]
	mov	DWORD PTR _bf$[ebp], edx

; 1432 : 
; 1433 : 			rb=UIColorTable[bperc][(back[bidx] & r_mask_) >> r_shift_];

	movsx	eax, WORD PTR _bperc$[ebp]
	shl	eax, 9
	mov	ecx, DWORD PTR _bidx$[ebp]
	mov	edx, DWORD PTR _back$[ebp]
	movzx	edx, WORD PTR [edx+ecx*2]
	mov	ecx, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [ecx+456]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [ecx+460]
	shr	edx, cl
	movzx	edx, WORD PTR ?UIColorTable@@3PAY0BAA@GA[eax+edx*2]
	mov	DWORD PTR _rb$[ebp], edx

; 1434 : 			gb=UIColorTable[bperc][(back[bidx] & g_mask_) >> g_shift_];

	movsx	eax, WORD PTR _bperc$[ebp]
	shl	eax, 9
	mov	ecx, DWORD PTR _bidx$[ebp]
	mov	edx, DWORD PTR _back$[ebp]
	movzx	edx, WORD PTR [edx+ecx*2]
	mov	ecx, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [ecx+464]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [ecx+468]
	shr	edx, cl
	movzx	edx, WORD PTR ?UIColorTable@@3PAY0BAA@GA[eax+edx*2]
	mov	DWORD PTR _gb$[ebp], edx

; 1435 : 			bb=UIColorTable[bperc][(back[bidx] & b_mask_) >> b_shift_];

	movsx	eax, WORD PTR _bperc$[ebp]
	shl	eax, 9
	mov	ecx, DWORD PTR _bidx$[ebp]
	mov	edx, DWORD PTR _back$[ebp]
	movzx	edx, WORD PTR [edx+ecx*2]
	mov	ecx, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [ecx+472]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [ecx+476]
	shr	edx, cl
	movzx	edx, WORD PTR ?UIColorTable@@3PAY0BAA@GA[eax+edx*2]
	mov	DWORD PTR _bb$[ebp], edx

; 1436 : 
; 1437 : 			dest[didx]=static_cast<WORD>(rShift[UIColorTable[100][rf+rb]] | gShift[UIColorTable[100][gf+gb]] | bShift[UIColorTable[100][bf+bb]]);//! 

	mov	eax, 512				; 00000200H
	imul	eax, 100				; 00000064H
	mov	ecx, DWORD PTR _rf$[ebp]
	add	ecx, DWORD PTR _rb$[ebp]
	movzx	edx, WORD PTR ?UIColorTable@@3PAY0BAA@GA[eax+ecx*2]
	movzx	eax, WORD PTR ?rShift@@3PAGA[edx*2]
	mov	ecx, 512				; 00000200H
	imul	ecx, 100				; 00000064H
	mov	edx, DWORD PTR _gf$[ebp]
	add	edx, DWORD PTR _gb$[ebp]
	movzx	ecx, WORD PTR ?UIColorTable@@3PAY0BAA@GA[ecx+edx*2]
	movzx	edx, WORD PTR ?gShift@@3PAGA[ecx*2]
	or	eax, edx
	mov	ecx, 512				; 00000200H
	imul	ecx, 100				; 00000064H
	mov	edx, DWORD PTR _bf$[ebp]
	add	edx, DWORD PTR _bb$[ebp]
	movzx	ecx, WORD PTR ?UIColorTable@@3PAY0BAA@GA[ecx+edx*2]
	movzx	edx, WORD PTR ?bShift@@3PAGA[ecx*2]
	or	eax, edx
	mov	ecx, DWORD PTR _didx$[ebp]
	mov	edx, DWORD PTR _dest$[ebp]
	mov	WORD PTR [edx+ecx*2], ax

; 1438 : 			fidx++;

	mov	eax, DWORD PTR _fidx$[ebp]
	add	eax, 1
	mov	DWORD PTR _fidx$[ebp], eax

; 1439 : 			bidx++;

	mov	ecx, DWORD PTR _bidx$[ebp]
	add	ecx, 1
	mov	DWORD PTR _bidx$[ebp], ecx

; 1440 : 			didx++;

	mov	edx, DWORD PTR _didx$[ebp]
	add	edx, 1
	mov	DWORD PTR _didx$[ebp], edx

; 1441 : 		}

	jmp	$LN2@Blend
$LN1@Blend:

; 1442 : 		fidxstart+=fwidth;

	movsx	eax, WORD PTR _fwidth$[ebp]
	add	eax, DWORD PTR _fidxstart$[ebp]
	mov	DWORD PTR _fidxstart$[ebp], eax

; 1443 : 		bidxstart+=bwidth;

	movsx	ecx, WORD PTR _bwidth$[ebp]
	add	ecx, DWORD PTR _bidxstart$[ebp]
	mov	DWORD PTR _bidxstart$[ebp], ecx

; 1444 : 		didxstart+=dwidth;

	movsx	edx, WORD PTR _dwidth$[ebp]
	add	edx, DWORD PTR _didxstart$[ebp]
	mov	DWORD PTR _didxstart$[ebp], edx

; 1445 : 	}

	jmp	$LN5@Blend
$LN9@Blend:

; 1446 : }

	mov	esp, ebp
	pop	ebp
	ret	44					; 0000002cH
?Blend@C_Window@@QAEXPAGPAUUI95_RECT@@F01F01FFF@Z ENDP	; C_Window::Blend
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_cur$ = -4						; size = 4
?DrawTimerControls@C_Window@@QAEXXZ PROC		; C_Window::DrawTimerControls
; _this$ = ecx

; 1235 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1236 : 	CONTROLLIST *cur;
; 1237 : 
; 1238 : 	cur=Controls_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4304]
	mov	DWORD PTR _cur$[ebp], ecx
$LN3@DrawTimerC:

; 1239 : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN4@DrawTimerC

; 1240 : 	{
; 1241 : 		if(cur->Control_->GetFlags() & C_BIT_TIMER)

	mov	edx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetFlags@C_Base@@QAEJXZ		; C_Base::GetFlags
	and	eax, 65536				; 00010000H
	je	SHORT $LN1@DrawTimerC

; 1242 : 			cur->Control_->Refresh();

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+160]
	call	edx
$LN1@DrawTimerC:

; 1243 : 		cur=cur->Next;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _cur$[ebp], ecx

; 1244 : 	}

	jmp	SHORT $LN3@DrawTimerC
$LN4@DrawTimerC:

; 1245 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DrawTimerControls@C_Window@@QAEXXZ ENDP		; C_Window::DrawTimerControls
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_Leave$ = -20						; size = 4
_retval$ = -16						; size = 4
_this$ = -12						; size = 4
_me$ = -8						; size = 4
_cur$ = -4						; size = 4
?UpdateTimerControls@C_Window@@QAEHXZ PROC		; C_Window::UpdateTimerControls
; _this$ = ecx

; 2326 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 2327 : 	BOOL retval=FALSE;

	mov	DWORD PTR _retval$[ebp], 0

; 2328 : 	CONTROLLIST *cur,*me;
; 2329 : 	F4CSECTIONHANDLE *Leave;
; 2330 : 
; 2331 : 	Leave=UI_Enter(this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 2332 : 	cur=Controls_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4304]
	mov	DWORD PTR _cur$[ebp], edx
$LN4@UpdateTime:

; 2333 : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN3@UpdateTime

; 2334 : 	{
; 2335 : 		me = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _me$[ebp], eax

; 2336 : 		cur = cur->Next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _cur$[ebp], edx

; 2337 : 
; 2338 : 		if(me->Control_->GetFlags() & C_BIT_TIMER)

	mov	eax, DWORD PTR _me$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetFlags@C_Base@@QAEJXZ		; C_Base::GetFlags
	and	eax, 65536				; 00010000H
	je	SHORT $LN2@UpdateTime

; 2339 : 			if(me->Control_->TimerUpdate())

	mov	ecx, DWORD PTR _me$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _me$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+180]
	call	eax
	test	eax, eax
	je	SHORT $LN2@UpdateTime

; 2340 : 				retval=TRUE;

	mov	DWORD PTR _retval$[ebp], 1
$LN2@UpdateTime:

; 2341 : 	}

	jmp	SHORT $LN4@UpdateTime
$LN3@UpdateTime:

; 2342 : 	UI_Leave(Leave);

	mov	ecx, DWORD PTR _Leave$[ebp]
	push	ecx
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4

; 2343 : 	return(retval);

	mov	eax, DWORD PTR _retval$[ebp]

; 2344 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateTimerControls@C_Window@@QAEHXZ ENDP		; C_Window::UpdateTimerControls
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_cur$ = -8						; size = 4
_i$ = -4						; size = 4
_surface$ = 8						; size = 4
?DrawWindow@C_Window@@QAEXPAVSCREEN@@@Z PROC		; C_Window::DrawWindow
; _this$ = ecx

; 1098 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1099 : 	long i;
; 1100 : 	CONTROLLIST *cur;
; 1101 : 
; 1102 : 	cur=Controls_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4304]
	mov	DWORD PTR _cur$[ebp], ecx
$LN6@DrawWindow:

; 1103 : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN7@DrawWindow

; 1104 : 	{
; 1105 : 		for(i=0;i<rectcount_;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@DrawWindow
$LN3@DrawWindow:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@DrawWindow:
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+1016]
	cmp	DWORD PTR _i$[ebp], ecx
	jge	SHORT $LN2@DrawWindow

; 1106 : 			if(rectflag_[i])

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+edx*2+616]
	test	ecx, ecx
	je	SHORT $LN1@DrawWindow

; 1107 : 				cur->Control_->Draw(surface,&rectlist_[i]);

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+1020]
	push	ecx
	mov	edx, DWORD PTR _surface$[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+164]
	call	edx
$LN1@DrawWindow:

; 1108 : 		cur=cur->Next;

	jmp	SHORT $LN3@DrawWindow
$LN2@DrawWindow:
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _cur$[ebp], ecx

; 1109 : 	}

	jmp	SHORT $LN6@DrawWindow
$LN7@DrawWindow:

; 1110 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?DrawWindow@C_Window@@QAEXPAVSCREEN@@@Z ENDP		; C_Window::DrawWindow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_Client$ = 8						; size = 4
?RefreshClient@C_Window@@QAEXJ@Z PROC			; C_Window::RefreshClient
; _this$ = ecx

; 1092 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1093 : 	ClearUpdateRect(ClientArea_[Client].left,ClientArea_[Client].top,ClientArea_[Client].right,ClientArea_[Client].bottom);

	mov	eax, DWORD PTR _Client$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+180]
	push	edx
	mov	eax, DWORD PTR _Client$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+176]
	push	edx
	mov	eax, DWORD PTR _Client$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+172]
	push	edx
	mov	eax, DWORD PTR _Client$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+168]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearUpdateRect@C_Window@@QAEXJJJJ@Z	; C_Window::ClearUpdateRect

; 1094 : 	SetUpdateRect(ClientArea_[Client].left,ClientArea_[Client].top,ClientArea_[Client].right,ClientArea_[Client].bottom,C_BIT_ABSOLUTE,0);

	push	0
	push	262144					; 00040000H
	mov	eax, DWORD PTR _Client$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+180]
	push	edx
	mov	eax, DWORD PTR _Client$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+176]
	push	edx
	mov	eax, DWORD PTR _Client$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+172]
	push	edx
	mov	eax, DWORD PTR _Client$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+168]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetUpdateRect@C_Window@@QAEXJJJJJJ@Z	; C_Window::SetUpdateRect

; 1095 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?RefreshClient@C_Window@@QAEXJ@Z ENDP			; C_Window::RefreshClient
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RefreshWindow@C_Window@@QAEXXZ PROC			; C_Window::RefreshWindow
; _this$ = ecx

; 1086 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1087 : 	rectcount_=0;

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1016], ax

; 1088 : 	SetUpdateRect(0,0,GetW(),GetH(),C_BIT_ABSOLUTE,0);

	push	0
	push	262144					; 00040000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetH@C_Window@@QAEFXZ			; C_Window::GetH
	movsx	edx, ax
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetW@C_Window@@QAEFXZ			; C_Window::GetW
	cwde
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetUpdateRect@C_Window@@QAEXJJJJJJ@Z	; C_Window::SetUpdateRect

; 1089 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RefreshWindow@C_Window@@QAEXXZ ENDP			; C_Window::RefreshWindow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_cur$ = -4						; size = 4
_GroupID$ = 8						; size = 4
_state$ = 12						; size = 2
?SetGroupState@C_Window@@QAEXJF@Z PROC			; C_Window::SetGroupState
; _this$ = ecx

; 2347 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2348 : 	CONTROLLIST *cur;
; 2349 : 
; 2350 : 	cur=Controls_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4304]
	mov	DWORD PTR _cur$[ebp], ecx
$LN4@SetGroupSt:

; 2351 : 
; 2352 : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN5@SetGroupSt

; 2353 : 	{
; 2354 : 		if(cur->Control_->GetGroup() == GroupID && cur->Control_->IsControl())

	mov	edx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetGroup@C_Base@@QAEJXZ		; C_Base::GetGroup
	cmp	eax, DWORD PTR _GroupID$[ebp]
	jne	SHORT $LN2@SetGroupSt
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+156]
	call	edx
	test	eax, eax
	je	SHORT $LN2@SetGroupSt

; 2355 : 		{
; 2356 : 			if(cur->Control_->GetState() != state)

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+112]
	call	edx
	cwde
	movsx	ecx, WORD PTR _state$[ebp]
	cmp	eax, ecx
	je	SHORT $LN2@SetGroupSt

; 2357 : 			{
; 2358 : 				cur->Control_->SetState(state);

	movzx	edx, WORD PTR _state$[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+56]
	call	edx

; 2359 : 				cur->Control_->Refresh();

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+160]
	call	edx
$LN2@SetGroupSt:

; 2360 : 			}
; 2361 : 		}
; 2362 : 		cur=cur->Next;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _cur$[ebp], ecx

; 2363 : 	}

	jmp	SHORT $LN4@SetGroupSt
$LN5@SetGroupSt:

; 2364 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetGroupState@C_Window@@QAEXJF@Z ENDP			; C_Window::SetGroupState
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_cur$ = -4						; size = 4
_ID$ = 8						; size = 4
?HideCluster@C_Window@@QAEXJ@Z PROC			; C_Window::HideCluster
; _this$ = ecx

; 1217 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1218 : 	CONTROLLIST *cur;
; 1219 : 
; 1220 : 	cur=Controls_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4304]
	mov	DWORD PTR _cur$[ebp], ecx
$LN4@HideCluste:

; 1221 : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN3@HideCluste

; 1222 : 	{
; 1223 : 		if(cur->Control_->GetCluster() == ID)

	mov	edx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetCluster@C_Base@@QAEJXZ		; C_Base::GetCluster
	cmp	eax, DWORD PTR _ID$[ebp]
	jne	SHORT $LN2@HideCluste

; 1224 : 		{
; 1225 : 			if(!(cur->Control_->GetFlags() & C_BIT_INVISIBLE))

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetFlags@C_Base@@QAEJXZ		; C_Base::GetFlags
	and	eax, 8192				; 00002000H
	jne	SHORT $LN1@HideCluste

; 1226 : 				cur->Control_->Refresh();

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN1@HideCluste:

; 1227 : 			cur->Control_->SetFlagBitOn(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
$LN2@HideCluste:

; 1228 : 		}
; 1229 : 		cur=cur->Next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _cur$[ebp], edx

; 1230 : 	}

	jmp	SHORT $LN4@HideCluste
$LN3@HideCluste:

; 1231 : 	ScanClientAreas();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ScanClientAreas@C_Window@@QAEXXZ	; C_Window::ScanClientAreas

; 1232 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?HideCluster@C_Window@@QAEXJ@Z ENDP			; C_Window::HideCluster
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_cur$ = -4						; size = 4
_ID$ = 8						; size = 4
?UnHideCluster@C_Window@@QAEXJ@Z PROC			; C_Window::UnHideCluster
; _this$ = ecx

; 1200 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1201 : 	CONTROLLIST *cur;
; 1202 : 
; 1203 : 	cur=Controls_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4304]
	mov	DWORD PTR _cur$[ebp], ecx
$LN3@UnHideClus:

; 1204 : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN2@UnHideClus

; 1205 : 	{
; 1206 : 		if(cur->Control_->GetCluster() == ID)

	mov	edx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetCluster@C_Base@@QAEJXZ		; C_Base::GetCluster
	cmp	eax, DWORD PTR _ID$[ebp]
	jne	SHORT $LN1@UnHideClus

; 1207 : 		{
; 1208 : 			cur->Control_->SetFlagBitOff(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+12]
	call	edx

; 1209 : 			cur->Control_->Refresh();

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+160]
	call	edx
$LN1@UnHideClus:

; 1210 : 		}
; 1211 : 		cur=cur->Next;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _cur$[ebp], ecx

; 1212 : 	}

	jmp	SHORT $LN3@UnHideClus
$LN2@UnHideClus:

; 1213 : 	ScanClientAreas();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ScanClientAreas@C_Window@@QAEXXZ	; C_Window::ScanClientAreas

; 1214 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?UnHideCluster@C_Window@@QAEXJ@Z ENDP			; C_Window::UnHideCluster
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_cur$ = -4						; size = 4
_ID$ = 8						; size = 4
?DisableCluster@C_Window@@QAEXJ@Z PROC			; C_Window::DisableCluster
; _this$ = ecx

; 1187 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1188 : 	CONTROLLIST *cur;
; 1189 : 
; 1190 : 	cur=Controls_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4304]
	mov	DWORD PTR _cur$[ebp], ecx
$LN3@DisableClu:

; 1191 : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN4@DisableClu

; 1192 : 	{
; 1193 : 		if(cur->Control_->GetCluster() == ID)

	mov	edx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetCluster@C_Base@@QAEJXZ		; C_Base::GetCluster
	cmp	eax, DWORD PTR _ID$[ebp]
	jne	SHORT $LN1@DisableClu

; 1194 : 			cur->Control_->DisableGroup(ID);

	mov	eax, DWORD PTR _ID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?DisableGroup@C_Base@@QAEXJ@Z		; C_Base::DisableGroup
$LN1@DisableClu:

; 1195 : 		cur=cur->Next;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _cur$[ebp], eax

; 1196 : 	}

	jmp	SHORT $LN3@DisableClu
$LN4@DisableClu:

; 1197 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?DisableCluster@C_Window@@QAEXJ@Z ENDP			; C_Window::DisableCluster
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_cur$ = -4						; size = 4
_ID$ = 8						; size = 4
?EnableCluster@C_Window@@QAEXJ@Z PROC			; C_Window::EnableCluster
; _this$ = ecx

; 1174 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1175 : 	CONTROLLIST *cur;
; 1176 : 
; 1177 : 	cur=Controls_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4304]
	mov	DWORD PTR _cur$[ebp], ecx
$LN3@EnableClus:

; 1178 : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN4@EnableClus

; 1179 : 	{
; 1180 : 		if(cur->Control_->GetCluster() == ID)

	mov	edx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetCluster@C_Base@@QAEJXZ		; C_Base::GetCluster
	cmp	eax, DWORD PTR _ID$[ebp]
	jne	SHORT $LN1@EnableClus

; 1181 : 			cur->Control_->EnableGroup(ID);

	mov	eax, DWORD PTR _ID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?EnableGroup@C_Base@@QAEXJ@Z		; C_Base::EnableGroup
$LN1@EnableClus:

; 1182 : 		cur=cur->Next;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _cur$[ebp], eax

; 1183 : 	}

	jmp	SHORT $LN3@EnableClus
$LN4@EnableClus:

; 1184 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?EnableCluster@C_Window@@QAEXJ@Z ENDP			; C_Window::EnableCluster
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_cur$ = -4						; size = 4
_ID$ = 8						; size = 4
?HideGroup@C_Window@@QAEXJ@Z PROC			; C_Window::HideGroup
; _this$ = ecx

; 1156 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1157 : 	CONTROLLIST *cur;
; 1158 : 
; 1159 : 	cur=Controls_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4304]
	mov	DWORD PTR _cur$[ebp], ecx
$LN4@HideGroup:

; 1160 : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN3@HideGroup

; 1161 : 	{
; 1162 : 		if(cur->Control_->GetGroup() == ID)

	mov	edx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetGroup@C_Base@@QAEJXZ		; C_Base::GetGroup
	cmp	eax, DWORD PTR _ID$[ebp]
	jne	SHORT $LN2@HideGroup

; 1163 : 		{
; 1164 : 			if(!(cur->Control_->GetFlags() & C_BIT_INVISIBLE))

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetFlags@C_Base@@QAEJXZ		; C_Base::GetFlags
	and	eax, 8192				; 00002000H
	jne	SHORT $LN1@HideGroup

; 1165 : 				cur->Control_->Refresh();

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN1@HideGroup:

; 1166 : 			cur->Control_->SetFlagBitOn(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax
$LN2@HideGroup:

; 1167 : 		}
; 1168 : 		cur=cur->Next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _cur$[ebp], edx

; 1169 : 	}

	jmp	SHORT $LN4@HideGroup
$LN3@HideGroup:

; 1170 : 	ScanClientAreas();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ScanClientAreas@C_Window@@QAEXXZ	; C_Window::ScanClientAreas

; 1171 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?HideGroup@C_Window@@QAEXJ@Z ENDP			; C_Window::HideGroup
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_cur$ = -4						; size = 4
_ID$ = 8						; size = 4
?UnHideGroup@C_Window@@QAEXJ@Z PROC			; C_Window::UnHideGroup
; _this$ = ecx

; 1139 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1140 : 	CONTROLLIST *cur;
; 1141 : 
; 1142 : 	cur=Controls_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4304]
	mov	DWORD PTR _cur$[ebp], ecx
$LN3@UnHideGrou:

; 1143 : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN2@UnHideGrou

; 1144 : 	{
; 1145 : 		if(cur->Control_->GetGroup() == ID)

	mov	edx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetGroup@C_Base@@QAEJXZ		; C_Base::GetGroup
	cmp	eax, DWORD PTR _ID$[ebp]
	jne	SHORT $LN1@UnHideGrou

; 1146 : 		{
; 1147 : 			cur->Control_->SetFlagBitOff(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+12]
	call	edx

; 1148 : 			cur->Control_->Refresh();

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+160]
	call	edx
$LN1@UnHideGrou:

; 1149 : 		}
; 1150 : 		cur=cur->Next;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _cur$[ebp], ecx

; 1151 : 	}

	jmp	SHORT $LN3@UnHideGrou
$LN2@UnHideGrou:

; 1152 : 	ScanClientAreas();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ScanClientAreas@C_Window@@QAEXXZ	; C_Window::ScanClientAreas

; 1153 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?UnHideGroup@C_Window@@QAEXJ@Z ENDP			; C_Window::UnHideGroup
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_cur$ = -4						; size = 4
_ID$ = 8						; size = 4
?DisableGroup@C_Window@@QAEXJ@Z PROC			; C_Window::DisableGroup
; _this$ = ecx

; 1126 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1127 : 	CONTROLLIST *cur;
; 1128 : 
; 1129 : 	cur=Controls_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4304]
	mov	DWORD PTR _cur$[ebp], ecx
$LN3@DisableGro:

; 1130 : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN4@DisableGro

; 1131 : 	{
; 1132 : 		if(cur->Control_->GetGroup() == ID)

	mov	edx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetGroup@C_Base@@QAEJXZ		; C_Base::GetGroup
	cmp	eax, DWORD PTR _ID$[ebp]
	jne	SHORT $LN1@DisableGro

; 1133 : 			cur->Control_->DisableGroup(ID);

	mov	eax, DWORD PTR _ID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?DisableGroup@C_Base@@QAEXJ@Z		; C_Base::DisableGroup
$LN1@DisableGro:

; 1134 : 		cur=cur->Next;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _cur$[ebp], eax

; 1135 : 	}

	jmp	SHORT $LN3@DisableGro
$LN4@DisableGro:

; 1136 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?DisableGroup@C_Window@@QAEXJ@Z ENDP			; C_Window::DisableGroup
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_cur$ = -4						; size = 4
_ID$ = 8						; size = 4
?EnableGroup@C_Window@@QAEXJ@Z PROC			; C_Window::EnableGroup
; _this$ = ecx

; 1113 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1114 : 	CONTROLLIST *cur;
; 1115 : 
; 1116 : 	cur=Controls_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4304]
	mov	DWORD PTR _cur$[ebp], ecx
$LN3@EnableGrou:

; 1117 : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN4@EnableGrou

; 1118 : 	{
; 1119 : 		if(cur->Control_->GetGroup() == ID)

	mov	edx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetGroup@C_Base@@QAEJXZ		; C_Base::GetGroup
	cmp	eax, DWORD PTR _ID$[ebp]
	jne	SHORT $LN1@EnableGrou

; 1120 : 			cur->Control_->EnableGroup(ID);

	mov	eax, DWORD PTR _ID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?EnableGroup@C_Base@@QAEXJ@Z		; C_Base::EnableGroup
$LN1@EnableGrou:

; 1121 : 		cur=cur->Next;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _cur$[ebp], eax

; 1122 : 	}

	jmp	SHORT $LN3@EnableGrou
$LN4@EnableGrou:

; 1123 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?EnableGroup@C_Window@@QAEXJ@Z ENDP			; C_Window::EnableGroup
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_y$ = 8							; size = 4
_Client$ = 12						; size = 4
?BelowClient@C_Window@@QAEHJJ@Z PROC			; C_Window::BelowClient
; _this$ = ecx

; 1079 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1080 : 	if(y + VY_[Client] >= ClientArea_[Client].bottom)

	mov	eax, DWORD PTR _Client$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _y$[ebp]
	add	edx, DWORD PTR [ecx+eax*4+512]
	mov	eax, DWORD PTR _Client$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR [ecx+eax+180]
	jl	SHORT $LN1@BelowClien

; 1081 : 		return(TRUE);

	mov	eax, 1
	jmp	SHORT $LN2@BelowClien
$LN1@BelowClien:

; 1082 : 	return(FALSE);

	xor	eax, eax
$LN2@BelowClien:

; 1083 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?BelowClient@C_Window@@QAEHJJ@Z ENDP			; C_Window::BelowClient
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_top$ = 8						; size = 4
_bottom$ = 12						; size = 4
_Client$ = 16						; size = 4
?InsideClientHeight@C_Window@@QAEHJJJ@Z PROC		; C_Window::InsideClientHeight
; _this$ = ecx

; 1072 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1073 : 	if((top+VY_[Client]) < ClientArea_[Client].bottom && (bottom + VY_[Client]) >= ClientArea_[Client].top)

	mov	eax, DWORD PTR _Client$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _top$[ebp]
	add	edx, DWORD PTR [ecx+eax*4+512]
	mov	eax, DWORD PTR _Client$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR [ecx+eax+180]
	jge	SHORT $LN1@InsideClie
	mov	edx, DWORD PTR _Client$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _bottom$[ebp]
	add	ecx, DWORD PTR [eax+edx*4+512]
	mov	edx, DWORD PTR _Client$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [eax+edx+172]
	jl	SHORT $LN1@InsideClie

; 1074 : 		return(TRUE);

	mov	eax, 1
	jmp	SHORT $LN2@InsideClie
$LN1@InsideClie:

; 1075 : 	return(FALSE);

	xor	eax, eax
$LN2@InsideClie:

; 1076 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?InsideClientHeight@C_Window@@QAEHJJJ@Z ENDP		; C_Window::InsideClientHeight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_left$ = 8						; size = 4
_right$ = 12						; size = 4
_Client$ = 16						; size = 4
?InsideClientWidth@C_Window@@QAEHJJJ@Z PROC		; C_Window::InsideClientWidth
; _this$ = ecx

; 1065 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1066 : 	if((left+VX_[Client]+VW_[Client]) < ClientArea_[Client].right && (right + VX_[Client]) >= ClientArea_[Client].left)

	mov	eax, DWORD PTR _Client$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _left$[ebp]
	add	edx, DWORD PTR [ecx+eax*4+480]
	mov	eax, DWORD PTR _Client$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [ecx+eax*4+544]
	mov	eax, DWORD PTR _Client$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR [ecx+eax+176]
	jge	SHORT $LN1@InsideClie
	mov	edx, DWORD PTR _Client$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _right$[ebp]
	add	ecx, DWORD PTR [eax+edx*4+480]
	mov	edx, DWORD PTR _Client$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [eax+edx+168]
	jl	SHORT $LN1@InsideClie

; 1067 : 		return(TRUE);

	mov	eax, 1
	jmp	SHORT $LN2@InsideClie
$LN1@InsideClie:

; 1068 : 	return(FALSE);

	xor	eax, eax
$LN2@InsideClie:

; 1069 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?InsideClientWidth@C_Window@@QAEHJJJ@Z ENDP		; C_Window::InsideClientWidth
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_offset$ = -4						; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
_ClipArea$ = 16						; size = 4
?ClipToArea@C_Window@@QAEHPAUUI95_RECT@@00@Z PROC	; C_Window::ClipToArea
; _this$ = ecx

; 1376 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1377 : 	long offset;
; 1378 : 
; 1379 : 	if(dst->left < ClipArea->left)

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _ClipArea$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN5@ClipToArea

; 1380 : 	{
; 1381 : 		offset=ClipArea->left - dst->left;

	mov	eax, DWORD PTR _ClipArea$[ebp]
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR [eax]
	sub	edx, DWORD PTR [ecx]
	mov	DWORD PTR _offset$[ebp], edx

; 1382 : 		src->left+=offset;

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _offset$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	DWORD PTR [edx], ecx

; 1383 : 		dst->left+=offset;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _offset$[ebp]
	mov	edx, DWORD PTR _dst$[ebp]
	mov	DWORD PTR [edx], ecx
$LN5@ClipToArea:

; 1384 : 	}
; 1385 : 	if(dst->top < ClipArea->top)

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _ClipArea$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jge	SHORT $LN4@ClipToArea

; 1386 : 	{
; 1387 : 		offset=ClipArea->top - dst->top;

	mov	eax, DWORD PTR _ClipArea$[ebp]
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR [eax+4]
	sub	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _offset$[ebp], edx

; 1388 : 		src->top+=offset;

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _offset$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 1389 : 		dst->top+=offset;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _offset$[ebp]
	mov	edx, DWORD PTR _dst$[ebp]
	mov	DWORD PTR [edx+4], ecx
$LN4@ClipToArea:

; 1390 : 	}
; 1391 : 	if(dst->right > ClipArea->right)

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _ClipArea$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jle	SHORT $LN3@ClipToArea

; 1392 : 	{
; 1393 : 		offset= dst->right - ClipArea->right;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _ClipArea$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _offset$[ebp], edx

; 1394 : 		src->right-=offset;

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR _offset$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1395 : 		dst->right-=offset;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR _offset$[ebp]
	mov	edx, DWORD PTR _dst$[ebp]
	mov	DWORD PTR [edx+8], ecx
$LN3@ClipToArea:

; 1396 : 	}
; 1397 : 	if(dst->bottom > ClipArea->bottom)

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _ClipArea$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+12]
	jle	SHORT $LN2@ClipToArea

; 1398 : 	{
; 1399 : 		offset= dst->bottom - ClipArea->bottom;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _ClipArea$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _offset$[ebp], edx

; 1400 : 		src->bottom-=offset;					  

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, DWORD PTR _offset$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 1401 : 		dst->bottom-=offset;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, DWORD PTR _offset$[ebp]
	mov	edx, DWORD PTR _dst$[ebp]
	mov	DWORD PTR [edx+12], ecx
$LN2@ClipToArea:

; 1402 : 	}
; 1403 : 	if(dst->left < dst->right && dst->top < dst->bottom)

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+8]
	jge	SHORT $LN1@ClipToArea
	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+12]
	jge	SHORT $LN1@ClipToArea

; 1404 : 		return(TRUE); // Draw it

	mov	eax, 1
	jmp	SHORT $LN6@ClipToArea
$LN1@ClipToArea:

; 1405 : 
; 1406 : 	return(FALSE);

	xor	eax, eax
$LN6@ClipToArea:

; 1407 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?ClipToArea@C_Window@@QAEHPAUUI95_RECT@@00@Z ENDP	; C_Window::ClipToArea
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Maximize@C_Window@@QAEXXZ PROC				; C_Window::Maximize
; _this$ = ecx

; 447  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 448  : 	SetW(MaxW_);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+448]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetW@C_Window@@QAEXF@Z			; C_Window::SetW

; 449  : 	SetH(MaxH_);

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, WORD PTR [edx+450]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetH@C_Window@@QAEXF@Z			; C_Window::SetH

; 450  : 	if(GetX()+GetW() > Handler_->GetW())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetX@C_Window@@QAEFXZ			; C_Window::GetX
	movsx	esi, ax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetW@C_Window@@QAEFXZ			; C_Window::GetW
	movsx	ecx, ax
	add	esi, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4328]
	call	?GetW@C_Handler@@QAEJXZ			; C_Handler::GetW
	cmp	esi, eax
	jle	SHORT $LN2@Maximize

; 451  : 		SetX(static_cast<short>(Handler_->GetW()-GetW()));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4328]
	call	?GetW@C_Handler@@QAEJXZ			; C_Handler::GetW
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetW@C_Window@@QAEFXZ			; C_Window::GetW
	movsx	ecx, ax
	sub	esi, ecx
	push	esi
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetX@C_Window@@QAEXF@Z			; C_Window::SetX
$LN2@Maximize:

; 452  : 	if(GetY()+GetH() > Handler_->GetH())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetY@C_Window@@QAEFXZ			; C_Window::GetY
	movsx	esi, ax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetH@C_Window@@QAEFXZ			; C_Window::GetH
	movsx	edx, ax
	add	esi, edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4328]
	call	?GetH@C_Handler@@QAEJXZ			; C_Handler::GetH
	cmp	esi, eax
	jle	SHORT $LN1@Maximize

; 453  : 		SetY(static_cast<short>(Handler_->GetH()-GetH()));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4328]
	call	?GetH@C_Handler@@QAEJXZ			; C_Handler::GetH
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetH@C_Window@@QAEFXZ			; C_Window::GetH
	movsx	edx, ax
	sub	esi, edx
	push	esi
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetY@C_Window@@QAEXF@Z			; C_Window::SetY
$LN1@Maximize:

; 454  : 	RefreshWindow();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RefreshWindow@C_Window@@QAEXXZ		; C_Window::RefreshWindow

; 455  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?Maximize@C_Window@@QAEXXZ ENDP				; C_Window::Maximize
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Minimize@C_Window@@QAEXXZ PROC				; C_Window::Minimize
; _this$ = ecx

; 437  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 438  : 	if(Handler_)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4328], 0
	je	SHORT $LN1@Minimize

; 439  : 		Handler_->SetBehindWindow(this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4328]
	call	?SetBehindWindow@C_Handler@@QAEXPAVC_Window@@@Z ; C_Handler::SetBehindWindow
$LN1@Minimize:

; 440  : 
; 441  : 	SetW(MinW_);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+444]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetW@C_Window@@QAEXF@Z			; C_Window::SetW

; 442  : 	SetH(MinH_);

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, WORD PTR [edx+446]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetH@C_Window@@QAEXF@Z			; C_Window::SetH

; 443  : 	RefreshWindow();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RefreshWindow@C_Window@@QAEXXZ		; C_Window::RefreshWindow

; 444  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Minimize@C_Window@@QAEXXZ ENDP				; C_Window::Minimize
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_lResult$ = -12						; size = 4
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?GetPrimaryW@C_Window@@QAEFXZ PROC			; C_Window::GetPrimaryW
; _this$ = ecx

; 336  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 337  : 	long lResult = (Handler_ ? (Handler_->GetW()) : 800); // why 800? default screen width?

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4328], 0
	je	SHORT $LN3@GetPrimary
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4328]
	call	?GetW@C_Handler@@QAEJXZ			; C_Handler::GetW
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@GetPrimary
$LN3@GetPrimary:
	mov	DWORD PTR tv69[ebp], 800		; 00000320H
$LN4@GetPrimary:
	mov	edx, DWORD PTR tv69[ebp]
	mov	DWORD PTR _lResult$[ebp], edx

; 338  : //	if(Handler_)
; 339  : //		return(Handler_->GetW());
; 340  : //	return(800);
; 341  : 	return static_cast<short>(lResult);

	mov	ax, WORD PTR _lResult$[ebp]

; 342  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPrimaryW@C_Window@@QAEFXZ ENDP			; C_Window::GetPrimaryW
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.h
;	COMDAT ?GetH@C_Window@@QAEFXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetH@C_Window@@QAEFXZ PROC				; C_Window::GetH, COMDAT
; _this$ = ecx

; 313  : 		short GetH() { return(h_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+434]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetH@C_Window@@QAEFXZ ENDP				; C_Window::GetH
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.h
;	COMDAT ?GetW@C_Window@@QAEFXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetW@C_Window@@QAEFXZ PROC				; C_Window::GetW, COMDAT
; _this$ = ecx

; 312  : 		short GetW() { return(w_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+432]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetW@C_Window@@QAEFXZ ENDP				; C_Window::GetW
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.h
;	COMDAT ?GetY@C_Window@@QAEFXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetY@C_Window@@QAEFXZ PROC				; C_Window::GetY, COMDAT
; _this$ = ecx

; 311  : 		short GetY() { return(y_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+430]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetY@C_Window@@QAEFXZ ENDP				; C_Window::GetY
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.h
;	COMDAT ?GetX@C_Window@@QAEFXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetX@C_Window@@QAEFXZ PROC				; C_Window::GetX, COMDAT
; _this$ = ecx

; 310  : 		short GetX() { return(x_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+428]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetX@C_Window@@QAEFXZ ENDP				; C_Window::GetX
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.h
;	COMDAT ?SetGroup@C_Window@@QAEXJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_grp$ = 8						; size = 4
?SetGroup@C_Window@@QAEXJ@Z PROC			; C_Window::SetGroup, COMDAT
; _this$ = ecx

; 308  : 		void SetGroup(long grp) { Group_=grp; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _grp$[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetGroup@C_Window@@QAEXJ@Z ENDP			; C_Window::SetGroup
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = -4						; size = 2
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_x2$ = 16						; size = 4
_y2$ = 20						; size = 4
?ClearUpdateRect@C_Window@@QAEXJJJJ@Z PROC		; C_Window::ClearUpdateRect
; _this$ = ecx

; 787  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 788  : 	short i;
; 789  : 
; 790  : 	if(x1 > GetW() || x2 < 0 || y1 > GetH() || y2 < 0 || !rectcount_)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetW@C_Window@@QAEFXZ			; C_Window::GetW
	cwde
	cmp	DWORD PTR _x1$[ebp], eax
	jg	SHORT $LN10@ClearUpdat
	cmp	DWORD PTR _x2$[ebp], 0
	jl	SHORT $LN10@ClearUpdat
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetH@C_Window@@QAEFXZ			; C_Window::GetH
	movsx	ecx, ax
	cmp	DWORD PTR _y1$[ebp], ecx
	jg	SHORT $LN10@ClearUpdat
	cmp	DWORD PTR _y2$[ebp], 0
	jl	SHORT $LN10@ClearUpdat
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+1016]
	test	eax, eax
	jne	SHORT $LN11@ClearUpdat
$LN10@ClearUpdat:

; 791  : 		return;

	jmp	$LN12@ClearUpdat
$LN11@ClearUpdat:

; 792  : 
; 793  : 	if(x1 <= 0 && y1 <= 0 && x2 >= GetW() && y2 >= GetH())

	cmp	DWORD PTR _x1$[ebp], 0
	jg	SHORT $LN9@ClearUpdat
	cmp	DWORD PTR _y1$[ebp], 0
	jg	SHORT $LN9@ClearUpdat
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetW@C_Window@@QAEFXZ			; C_Window::GetW
	movsx	ecx, ax
	cmp	DWORD PTR _x2$[ebp], ecx
	jl	SHORT $LN9@ClearUpdat
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetH@C_Window@@QAEFXZ			; C_Window::GetH
	movsx	edx, ax
	cmp	DWORD PTR _y2$[ebp], edx
	jl	SHORT $LN9@ClearUpdat

; 794  : 	{
; 795  : 		rectcount_=0;

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1016], ax

; 796  : 		return;

	jmp	$LN12@ClearUpdat
$LN9@ClearUpdat:

; 797  : 	}
; 798  : 	if(x1 < 0) x1=0;

	cmp	DWORD PTR _x1$[ebp], 0
	jge	SHORT $LN8@ClearUpdat
	mov	DWORD PTR _x1$[ebp], 0
$LN8@ClearUpdat:

; 799  : 	if(y1 < 0) y1=0;

	cmp	DWORD PTR _y1$[ebp], 0
	jge	SHORT $LN7@ClearUpdat
	mov	DWORD PTR _y1$[ebp], 0
$LN7@ClearUpdat:

; 800  : 	if(x2 > GetW()) x2=GetW();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetW@C_Window@@QAEFXZ			; C_Window::GetW
	movsx	edx, ax
	cmp	DWORD PTR _x2$[ebp], edx
	jle	SHORT $LN6@ClearUpdat
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetW@C_Window@@QAEFXZ			; C_Window::GetW
	cwde
	mov	DWORD PTR _x2$[ebp], eax
$LN6@ClearUpdat:

; 801  : 	if(y2 > GetH()) y2=GetH();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetH@C_Window@@QAEFXZ			; C_Window::GetH
	movsx	ecx, ax
	cmp	DWORD PTR _y2$[ebp], ecx
	jle	SHORT $LN5@ClearUpdat
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetH@C_Window@@QAEFXZ			; C_Window::GetH
	movsx	edx, ax
	mov	DWORD PTR _y2$[ebp], edx
$LN5@ClearUpdat:

; 802  : 
; 803  : 	ClearCheckedUpdateRect(x1,y1,x2,y2);

	mov	eax, DWORD PTR _y2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y1$[ebp]
	push	edx
	mov	eax, DWORD PTR _x1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCheckedUpdateRect@C_Window@@QAEXJJJJ@Z ; C_Window::ClearCheckedUpdateRect

; 804  : 	for(i=0;i<rectcount_;i++)

	xor	ecx, ecx
	mov	WORD PTR _i$[ebp], cx
	jmp	SHORT $LN4@ClearUpdat
$LN3@ClearUpdat:
	mov	dx, WORD PTR _i$[ebp]
	add	dx, 1
	mov	WORD PTR _i$[ebp], dx
$LN4@ClearUpdat:
	movsx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+1016]
	cmp	eax, edx
	jge	SHORT $LN2@ClearUpdat

; 805  : 		if(rectflag_[i])

	movsx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+616]
	test	edx, edx
	je	SHORT $LN1@ClearUpdat

; 806  : 			return;

	jmp	SHORT $LN12@ClearUpdat
$LN1@ClearUpdat:

; 807  : 	update_=0;

	jmp	SHORT $LN3@ClearUpdat
$LN2@ClearUpdat:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+104], 0

; 808  : 	rectcount_=0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1016], cx
$LN12@ClearUpdat:

; 809  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?ClearUpdateRect@C_Window@@QAEXJJJJ@Z ENDP		; C_Window::ClearUpdateRect
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_clipflag$ = -32					; size = 2
_this$ = -28						; size = 4
_i$ = -24						; size = 2
_oldrect$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_x2$ = 16						; size = 4
_y2$ = 20						; size = 4
?ClearCheckedUpdateRect@C_Window@@QAEXJJJJ@Z PROC	; C_Window::ClearCheckedUpdateRect
; _this$ = ecx

; 661  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 662  : 	short i,clipflag;
; 663  : 	UI95_RECT oldrect;
; 664  : 
; 665  : 	if(rectcount_ < WIN_MAX_RECTS)

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+1016]
	cmp	ecx, 200				; 000000c8H
	jge	$LN46@ClearCheck

; 666  : 	{
; 667  : 		for(i=0;(i<rectcount_) && (x1 < x2) && (y1 < y2);i++)

	xor	edx, edx
	mov	WORD PTR _i$[ebp], dx
	jmp	SHORT $LN45@ClearCheck
$LN44@ClearCheck:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN45@ClearCheck:
	movsx	ecx, WORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+1016]
	cmp	ecx, eax
	jge	$LN43@ClearCheck
	mov	ecx, DWORD PTR _x1$[ebp]
	cmp	ecx, DWORD PTR _x2$[ebp]
	jge	$LN43@ClearCheck
	mov	edx, DWORD PTR _y1$[ebp]
	cmp	edx, DWORD PTR _y2$[ebp]
	jge	$LN43@ClearCheck

; 668  : 		{
; 669  : 			if(rectflag_[i])

	movsx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+616]
	test	edx, edx
	je	$LN42@ClearCheck

; 670  : 			{
; 671  : 				if(x1 >= rectlist_[i].right || x2 <= rectlist_[i].left || y1 >= rectlist_[i].bottom || y2 <= rectlist_[i].top)

	movsx	eax, WORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _x1$[ebp]
	cmp	edx, DWORD PTR [ecx+eax+1028]
	jge	SHORT $LN40@ClearCheck
	movsx	eax, WORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _x2$[ebp]
	cmp	edx, DWORD PTR [ecx+eax+1020]
	jle	SHORT $LN40@ClearCheck
	movsx	eax, WORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _y1$[ebp]
	cmp	edx, DWORD PTR [ecx+eax+1032]
	jge	SHORT $LN40@ClearCheck
	movsx	eax, WORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _y2$[ebp]
	cmp	edx, DWORD PTR [ecx+eax+1024]
	jg	SHORT $LN41@ClearCheck
$LN40@ClearCheck:

; 672  : 				{ // rects don't intersect
; 673  : 					continue;

	jmp	$LN44@ClearCheck

; 674  : 				}
; 675  : 				else

	jmp	$LN42@ClearCheck
$LN41@ClearCheck:

; 676  : 				{
; 677  : 					clipflag=0;

	xor	eax, eax
	mov	WORD PTR _clipflag$[ebp], ax

; 678  : 					if(x1 >= rectlist_[i].left)

	movsx	ecx, WORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _x1$[ebp]
	cmp	eax, DWORD PTR [edx+ecx+1020]
	jl	SHORT $LN38@ClearCheck

; 679  : 						clipflag |= _CHR_CLIP_LEFT;

	movsx	ecx, WORD PTR _clipflag$[ebp]
	or	ecx, 1
	mov	WORD PTR _clipflag$[ebp], cx
$LN38@ClearCheck:

; 680  : 					if(y1 >= rectlist_[i].top)

	movsx	edx, WORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _y1$[ebp]
	cmp	ecx, DWORD PTR [eax+edx+1024]
	jl	SHORT $LN37@ClearCheck

; 681  : 						clipflag |= _CHR_CLIP_TOP;

	movsx	edx, WORD PTR _clipflag$[ebp]
	or	edx, 4
	mov	WORD PTR _clipflag$[ebp], dx
$LN37@ClearCheck:

; 682  : 					if(x2 <= rectlist_[i].right)

	movsx	eax, WORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _x2$[ebp]
	cmp	edx, DWORD PTR [ecx+eax+1028]
	jg	SHORT $LN36@ClearCheck

; 683  : 						clipflag |= _CHR_CLIP_RIGHT;

	movsx	eax, WORD PTR _clipflag$[ebp]
	or	eax, 2
	mov	WORD PTR _clipflag$[ebp], ax
$LN36@ClearCheck:

; 684  : 					if(y2 <= rectlist_[i].bottom)

	movsx	ecx, WORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _y2$[ebp]
	cmp	eax, DWORD PTR [edx+ecx+1032]
	jg	SHORT $LN35@ClearCheck

; 685  : 						clipflag |= _CHR_CLIP_BOTTOM;

	movsx	ecx, WORD PTR _clipflag$[ebp]
	or	ecx, 8
	mov	WORD PTR _clipflag$[ebp], cx
$LN35@ClearCheck:

; 686  : 
; 687  : 					oldrect=rectlist_[i];

	movsx	edx, WORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+1020]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _oldrect$[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _oldrect$[ebp+4], eax
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _oldrect$[ebp+8], edx
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR _oldrect$[ebp+12], eax

; 688  : 					if(!clipflag)

	movsx	ecx, WORD PTR _clipflag$[ebp]
	test	ecx, ecx
	jne	SHORT $LN34@ClearCheck

; 689  : 					{ // clear rect contains rect... remove cur
; 690  : 						rectflag_[i]=0;

	movsx	edx, WORD PTR _i$[ebp]
	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+edx*2+616], ax
$LN34@ClearCheck:

; 691  : 					}
; 692  : 					if(clipflag == (_CHR_CLIP_LEFT|_CHR_CLIP_TOP|_CHR_CLIP_RIGHT|_CHR_CLIP_BOTTOM))

	movsx	edx, WORD PTR _clipflag$[ebp]
	cmp	edx, 15					; 0000000fH
	jne	SHORT $LN33@ClearCheck

; 693  : 					{ // clear rect is totally inside current rect... break into 4
; 694  : 						rectflag_[i]=0;

	movsx	eax, WORD PTR _i$[ebp]
	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+eax*2+616], cx

; 695  : 						SetCheckedUpdateRect(oldrect.left,oldrect.top,oldrect.right,y1);

	mov	eax, DWORD PTR _y1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _oldrect$[ebp+8]
	push	ecx
	mov	edx, DWORD PTR _oldrect$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _oldrect$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCheckedUpdateRect@C_Window@@AAEJJJJJ@Z ; C_Window::SetCheckedUpdateRect

; 696  : 						SetCheckedUpdateRect(oldrect.left,y1,x1,y2);

	mov	ecx, DWORD PTR _y2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x1$[ebp]
	push	edx
	mov	eax, DWORD PTR _y1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _oldrect$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCheckedUpdateRect@C_Window@@AAEJJJJJ@Z ; C_Window::SetCheckedUpdateRect

; 697  : 						SetCheckedUpdateRect(x2,y1,oldrect.right,y2);

	mov	edx, DWORD PTR _y2$[ebp]
	push	edx
	mov	eax, DWORD PTR _oldrect$[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _y1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x2$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCheckedUpdateRect@C_Window@@AAEJJJJJ@Z ; C_Window::SetCheckedUpdateRect

; 698  : 						SetCheckedUpdateRect(oldrect.left,y2,oldrect.right,oldrect.bottom);

	mov	eax, DWORD PTR _oldrect$[ebp+12]
	push	eax
	mov	ecx, DWORD PTR _oldrect$[ebp+8]
	push	ecx
	mov	edx, DWORD PTR _y2$[ebp]
	push	edx
	mov	eax, DWORD PTR _oldrect$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCheckedUpdateRect@C_Window@@AAEJJJJJ@Z ; C_Window::SetCheckedUpdateRect
	jmp	$LN42@ClearCheck
$LN33@ClearCheck:

; 699  : 					}
; 700  : 					else if(clipflag == (_CHR_CLIP_RIGHT|_CHR_CLIP_BOTTOM))

	movsx	ecx, WORD PTR _clipflag$[ebp]
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN31@ClearCheck

; 701  : 					{ // case 1
; 702  : 						rectlist_[i].top=y2;

	movsx	edx, WORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _y2$[ebp]
	mov	DWORD PTR [eax+edx+1024], ecx

; 703  : 						SetCheckedUpdateRect(x2,oldrect.top,oldrect.right,y2);

	mov	edx, DWORD PTR _y2$[ebp]
	push	edx
	mov	eax, DWORD PTR _oldrect$[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _oldrect$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _x2$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCheckedUpdateRect@C_Window@@AAEJJJJJ@Z ; C_Window::SetCheckedUpdateRect
	jmp	$LN42@ClearCheck
$LN31@ClearCheck:

; 704  : 					}
; 705  : 					else if(clipflag == (_CHR_CLIP_LEFT|_CHR_CLIP_BOTTOM))

	movsx	eax, WORD PTR _clipflag$[ebp]
	cmp	eax, 9
	jne	SHORT $LN29@ClearCheck

; 706  : 					{ // case 2
; 707  : 						rectlist_[i].top=y2;

	movsx	ecx, WORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _y2$[ebp]
	mov	DWORD PTR [edx+ecx+1024], eax

; 708  : 						SetCheckedUpdateRect(oldrect.left,oldrect.top,x1,y2);

	mov	ecx, DWORD PTR _y2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x1$[ebp]
	push	edx
	mov	eax, DWORD PTR _oldrect$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _oldrect$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCheckedUpdateRect@C_Window@@AAEJJJJJ@Z ; C_Window::SetCheckedUpdateRect
	jmp	$LN42@ClearCheck
$LN29@ClearCheck:

; 709  : 					}
; 710  : 					else if(clipflag == (_CHR_CLIP_RIGHT|_CHR_CLIP_TOP))

	movsx	edx, WORD PTR _clipflag$[ebp]
	cmp	edx, 6
	jne	SHORT $LN27@ClearCheck

; 711  : 					{ // case 3
; 712  : 						rectlist_[i].bottom=y1;

	movsx	eax, WORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _y1$[ebp]
	mov	DWORD PTR [ecx+eax+1032], edx

; 713  : 						SetCheckedUpdateRect(x2,y1,oldrect.right,oldrect.bottom);

	mov	eax, DWORD PTR _oldrect$[ebp+12]
	push	eax
	mov	ecx, DWORD PTR _oldrect$[ebp+8]
	push	ecx
	mov	edx, DWORD PTR _y1$[ebp]
	push	edx
	mov	eax, DWORD PTR _x2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCheckedUpdateRect@C_Window@@AAEJJJJJ@Z ; C_Window::SetCheckedUpdateRect
	jmp	$LN42@ClearCheck
$LN27@ClearCheck:

; 714  : 					}
; 715  : 					else if(clipflag == (_CHR_CLIP_LEFT|_CHR_CLIP_TOP))

	movsx	ecx, WORD PTR _clipflag$[ebp]
	cmp	ecx, 5
	jne	SHORT $LN25@ClearCheck

; 716  : 					{ // case 4
; 717  : 						rectlist_[i].bottom=y1;

	movsx	edx, WORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _y1$[ebp]
	mov	DWORD PTR [eax+edx+1032], ecx

; 718  : 						SetCheckedUpdateRect(oldrect.left,y1,x1,oldrect.bottom);

	mov	edx, DWORD PTR _oldrect$[ebp+12]
	push	edx
	mov	eax, DWORD PTR _x1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _oldrect$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCheckedUpdateRect@C_Window@@AAEJJJJJ@Z ; C_Window::SetCheckedUpdateRect
	jmp	$LN42@ClearCheck
$LN25@ClearCheck:

; 719  : 					}
; 720  : 					else if(clipflag == _CHR_CLIP_BOTTOM)

	movsx	eax, WORD PTR _clipflag$[ebp]
	cmp	eax, 8
	jne	SHORT $LN23@ClearCheck

; 721  : 					{ // case 5
; 722  : 						rectlist_[i].top=y2;

	movsx	ecx, WORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _y2$[ebp]
	mov	DWORD PTR [edx+ecx+1024], eax
	jmp	$LN42@ClearCheck
$LN23@ClearCheck:

; 723  : 					}
; 724  : 					else if(clipflag == _CHR_CLIP_RIGHT)

	movsx	ecx, WORD PTR _clipflag$[ebp]
	cmp	ecx, 2
	jne	SHORT $LN21@ClearCheck

; 725  : 					{ // case 6
; 726  : 						rectlist_[i].left=x2;

	movsx	edx, WORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _x2$[ebp]
	mov	DWORD PTR [eax+edx+1020], ecx
	jmp	$LN42@ClearCheck
$LN21@ClearCheck:

; 727  : 					}
; 728  : 					else if(clipflag == _CHR_CLIP_TOP)

	movsx	edx, WORD PTR _clipflag$[ebp]
	cmp	edx, 4
	jne	SHORT $LN19@ClearCheck

; 729  : 					{ // case 7
; 730  : 						rectlist_[i].bottom=y1;

	movsx	eax, WORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _y1$[ebp]
	mov	DWORD PTR [ecx+eax+1032], edx
	jmp	$LN42@ClearCheck
$LN19@ClearCheck:

; 731  : 					}
; 732  : 					else if(clipflag == _CHR_CLIP_LEFT)

	movsx	eax, WORD PTR _clipflag$[ebp]
	cmp	eax, 1
	jne	SHORT $LN17@ClearCheck

; 733  : 					{ // case 8
; 734  : 						rectlist_[i].right=x1;

	movsx	ecx, WORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _x1$[ebp]
	mov	DWORD PTR [edx+ecx+1028], eax
	jmp	$LN42@ClearCheck
$LN17@ClearCheck:

; 735  : 					}
; 736  : 					else if(clipflag == (_CHR_CLIP_LEFT|_CHR_CLIP_RIGHT|_CHR_CLIP_BOTTOM))

	movsx	ecx, WORD PTR _clipflag$[ebp]
	cmp	ecx, 11					; 0000000bH
	jne	SHORT $LN15@ClearCheck

; 737  : 					{ // case 9
; 738  : 						rectlist_[i].top=y2;

	movsx	edx, WORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _y2$[ebp]
	mov	DWORD PTR [eax+edx+1024], ecx

; 739  : 						SetCheckedUpdateRect(oldrect.left,oldrect.top,x1,y2);

	mov	edx, DWORD PTR _y2$[ebp]
	push	edx
	mov	eax, DWORD PTR _x1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _oldrect$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _oldrect$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCheckedUpdateRect@C_Window@@AAEJJJJJ@Z ; C_Window::SetCheckedUpdateRect

; 740  : 						SetCheckedUpdateRect(x2,oldrect.top,oldrect.right,y2);

	mov	eax, DWORD PTR _y2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _oldrect$[ebp+8]
	push	ecx
	mov	edx, DWORD PTR _oldrect$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _x2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCheckedUpdateRect@C_Window@@AAEJJJJJ@Z ; C_Window::SetCheckedUpdateRect
	jmp	$LN42@ClearCheck
$LN15@ClearCheck:

; 741  : 					}
; 742  : 					else if(clipflag == (_CHR_CLIP_TOP|_CHR_CLIP_RIGHT|_CHR_CLIP_BOTTOM))

	movsx	ecx, WORD PTR _clipflag$[ebp]
	cmp	ecx, 14					; 0000000eH
	jne	SHORT $LN13@ClearCheck

; 743  : 					{ // case 10
; 744  : 						rectlist_[i].left=x2;

	movsx	edx, WORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _x2$[ebp]
	mov	DWORD PTR [eax+edx+1020], ecx

; 745  : 						SetCheckedUpdateRect(oldrect.left,oldrect.top,x2,y1);

	mov	edx, DWORD PTR _y1$[ebp]
	push	edx
	mov	eax, DWORD PTR _x2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _oldrect$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _oldrect$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCheckedUpdateRect@C_Window@@AAEJJJJJ@Z ; C_Window::SetCheckedUpdateRect

; 746  : 						SetCheckedUpdateRect(oldrect.left,y2,x2,oldrect.bottom);

	mov	eax, DWORD PTR _oldrect$[ebp+12]
	push	eax
	mov	ecx, DWORD PTR _x2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y2$[ebp]
	push	edx
	mov	eax, DWORD PTR _oldrect$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCheckedUpdateRect@C_Window@@AAEJJJJJ@Z ; C_Window::SetCheckedUpdateRect
	jmp	$LN42@ClearCheck
$LN13@ClearCheck:

; 747  : 					}
; 748  : 					else if(clipflag == (_CHR_CLIP_TOP|_CHR_CLIP_LEFT|_CHR_CLIP_RIGHT))

	movsx	ecx, WORD PTR _clipflag$[ebp]
	cmp	ecx, 7
	jne	SHORT $LN11@ClearCheck

; 749  : 					{ // case 11
; 750  : 						rectlist_[i].bottom=y1;

	movsx	edx, WORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _y1$[ebp]
	mov	DWORD PTR [eax+edx+1032], ecx

; 751  : 						SetCheckedUpdateRect(oldrect.left,y1,x1,oldrect.bottom);

	mov	edx, DWORD PTR _oldrect$[ebp+12]
	push	edx
	mov	eax, DWORD PTR _x1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _oldrect$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCheckedUpdateRect@C_Window@@AAEJJJJJ@Z ; C_Window::SetCheckedUpdateRect

; 752  : 						SetCheckedUpdateRect(x2,y1,oldrect.right,oldrect.bottom);

	mov	eax, DWORD PTR _oldrect$[ebp+12]
	push	eax
	mov	ecx, DWORD PTR _oldrect$[ebp+8]
	push	ecx
	mov	edx, DWORD PTR _y1$[ebp]
	push	edx
	mov	eax, DWORD PTR _x2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCheckedUpdateRect@C_Window@@AAEJJJJJ@Z ; C_Window::SetCheckedUpdateRect
	jmp	$LN42@ClearCheck
$LN11@ClearCheck:

; 753  : 					}
; 754  : 					else if(clipflag == (_CHR_CLIP_LEFT|_CHR_CLIP_TOP|_CHR_CLIP_BOTTOM))

	movsx	ecx, WORD PTR _clipflag$[ebp]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN9@ClearCheck

; 755  : 					{ // case 12
; 756  : 						rectlist_[i].right=x1;

	movsx	edx, WORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _x1$[ebp]
	mov	DWORD PTR [eax+edx+1028], ecx

; 757  : 						SetCheckedUpdateRect(x1,oldrect.top,oldrect.right,y1);

	mov	edx, DWORD PTR _y1$[ebp]
	push	edx
	mov	eax, DWORD PTR _oldrect$[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _oldrect$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _x1$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCheckedUpdateRect@C_Window@@AAEJJJJJ@Z ; C_Window::SetCheckedUpdateRect

; 758  : 						SetCheckedUpdateRect(x1,y2,oldrect.right,oldrect.bottom);

	mov	eax, DWORD PTR _oldrect$[ebp+12]
	push	eax
	mov	ecx, DWORD PTR _oldrect$[ebp+8]
	push	ecx
	mov	edx, DWORD PTR _y2$[ebp]
	push	edx
	mov	eax, DWORD PTR _x1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCheckedUpdateRect@C_Window@@AAEJJJJJ@Z ; C_Window::SetCheckedUpdateRect
	jmp	$LN42@ClearCheck
$LN9@ClearCheck:

; 759  : 					}
; 760  : 					else if(clipflag == (_CHR_CLIP_TOP|_CHR_CLIP_BOTTOM))

	movsx	ecx, WORD PTR _clipflag$[ebp]
	cmp	ecx, 12					; 0000000cH
	jne	SHORT $LN7@ClearCheck

; 761  : 					{ // case 15
; 762  : 						rectflag_[i]=0;

	movsx	edx, WORD PTR _i$[ebp]
	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+edx*2+616], ax

; 763  : 						SetCheckedUpdateRect(oldrect.left,oldrect.top,oldrect.right,y1);

	mov	edx, DWORD PTR _y1$[ebp]
	push	edx
	mov	eax, DWORD PTR _oldrect$[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _oldrect$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _oldrect$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCheckedUpdateRect@C_Window@@AAEJJJJJ@Z ; C_Window::SetCheckedUpdateRect

; 764  : 						SetCheckedUpdateRect(oldrect.left,y2,oldrect.right,oldrect.bottom);

	mov	eax, DWORD PTR _oldrect$[ebp+12]
	push	eax
	mov	ecx, DWORD PTR _oldrect$[ebp+8]
	push	ecx
	mov	edx, DWORD PTR _y2$[ebp]
	push	edx
	mov	eax, DWORD PTR _oldrect$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCheckedUpdateRect@C_Window@@AAEJJJJJ@Z ; C_Window::SetCheckedUpdateRect
	jmp	SHORT $LN42@ClearCheck
$LN7@ClearCheck:

; 765  : 					}
; 766  : 					else if(clipflag == (_CHR_CLIP_LEFT|_CHR_CLIP_RIGHT))

	movsx	ecx, WORD PTR _clipflag$[ebp]
	cmp	ecx, 3
	jne	SHORT $LN42@ClearCheck

; 767  : 					{ // case 16
; 768  : 						rectflag_[i]=0;

	movsx	edx, WORD PTR _i$[ebp]
	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+edx*2+616], ax

; 769  : 						SetCheckedUpdateRect(oldrect.left,oldrect.top,x1,oldrect.bottom);

	mov	edx, DWORD PTR _oldrect$[ebp+12]
	push	edx
	mov	eax, DWORD PTR _x1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _oldrect$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _oldrect$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCheckedUpdateRect@C_Window@@AAEJJJJJ@Z ; C_Window::SetCheckedUpdateRect

; 770  : 						SetCheckedUpdateRect(x2,oldrect.top,oldrect.right,oldrect.bottom);

	mov	eax, DWORD PTR _oldrect$[ebp+12]
	push	eax
	mov	ecx, DWORD PTR _oldrect$[ebp+8]
	push	ecx
	mov	edx, DWORD PTR _oldrect$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _x2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCheckedUpdateRect@C_Window@@AAEJJJJJ@Z ; C_Window::SetCheckedUpdateRect
$LN42@ClearCheck:

; 771  : 					}
; 772  : 				}
; 773  : 			}
; 774  : 		}

	jmp	$LN44@ClearCheck
$LN43@ClearCheck:

; 775  : 	}
; 776  : 	else

	jmp	SHORT $LN47@ClearCheck
$LN46@ClearCheck:

; 777  : 	{
; 778  : 		for(i=0;i<WIN_MAX_RECTS;i++)

	xor	ecx, ecx
	mov	WORD PTR _i$[ebp], cx
	jmp	SHORT $LN3@ClearCheck
$LN2@ClearCheck:
	mov	dx, WORD PTR _i$[ebp]
	add	dx, 1
	mov	WORD PTR _i$[ebp], dx
$LN3@ClearCheck:
	movsx	eax, WORD PTR _i$[ebp]
	cmp	eax, 200				; 000000c8H
	jge	SHORT $LN1@ClearCheck

; 779  : 			rectflag_[i]=0;

	movsx	ecx, WORD PTR _i$[ebp]
	xor	edx, edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+ecx*2+616], dx
	jmp	SHORT $LN2@ClearCheck
$LN1@ClearCheck:

; 780  : 		rectcount_=0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1016], cx

; 781  : 		AddUpdateRect(0,0,w_,h_);

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+434]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+432]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddUpdateRect@C_Window@@QAEXJJJJ@Z	; C_Window::AddUpdateRect

; 782  : 		ClearCheckedUpdateRect(x1,y1,x2,y2);

	mov	ecx, DWORD PTR _y2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x2$[ebp]
	push	edx
	mov	eax, DWORD PTR _y1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x1$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearCheckedUpdateRect@C_Window@@QAEXJJJJ@Z ; C_Window::ClearCheckedUpdateRect
$LN47@ClearCheck:

; 783  : 	}
; 784  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?ClearCheckedUpdateRect@C_Window@@QAEXJJJJ@Z ENDP	; C_Window::ClearCheckedUpdateRect
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_Leave$ = -12						; size = 4
_this$ = -8						; size = 4
_i$ = -4						; size = 2
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_x2$ = 16						; size = 4
_y2$ = 20						; size = 4
_flags$ = 24						; size = 4
_client$ = 28						; size = 4
?SetUpdateRect@C_Window@@QAEXJJJJJJ@Z PROC		; C_Window::SetUpdateRect
; _this$ = ecx

; 609  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 610  : 	short i;
; 611  : 	F4CSECTIONHANDLE* Leave;
; 612  : 
; 613  : 	if(Handler_ == NULL) return;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4328], 0
	jne	SHORT $LN21@SetUpdateR
	jmp	$LN22@SetUpdateR
$LN21@SetUpdateR:

; 614  : 
; 615  : 	if(!(flags & C_BIT_ABSOLUTE))

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 262144				; 00040000H
	jne	$LN20@SetUpdateR

; 616  : 	{
; 617  : 		x1+=VX_[client];

	mov	edx, DWORD PTR _client$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _x1$[ebp]
	add	ecx, DWORD PTR [eax+edx*4+480]
	mov	DWORD PTR _x1$[ebp], ecx

; 618  : 		y1+=VY_[client];

	mov	edx, DWORD PTR _client$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _y1$[ebp]
	add	ecx, DWORD PTR [eax+edx*4+512]
	mov	DWORD PTR _y1$[ebp], ecx

; 619  : 		x2+=VX_[client];

	mov	edx, DWORD PTR _client$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _x2$[ebp]
	add	ecx, DWORD PTR [eax+edx*4+480]
	mov	DWORD PTR _x2$[ebp], ecx

; 620  : 		y2+=VY_[client];

	mov	edx, DWORD PTR _client$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _y2$[ebp]
	add	ecx, DWORD PTR [eax+edx*4+512]
	mov	DWORD PTR _y2$[ebp], ecx

; 621  : 		if(x1 > ClientArea_[client].right || y1 > ClientArea_[client].bottom || x2 < ClientArea_[client].left || y2 < ClientArea_[client].top)

	mov	edx, DWORD PTR _client$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _x1$[ebp]
	cmp	ecx, DWORD PTR [eax+edx+176]
	jg	SHORT $LN18@SetUpdateR
	mov	edx, DWORD PTR _client$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _y1$[ebp]
	cmp	ecx, DWORD PTR [eax+edx+180]
	jg	SHORT $LN18@SetUpdateR
	mov	edx, DWORD PTR _client$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _x2$[ebp]
	cmp	ecx, DWORD PTR [eax+edx+168]
	jl	SHORT $LN18@SetUpdateR
	mov	edx, DWORD PTR _client$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _y2$[ebp]
	cmp	ecx, DWORD PTR [eax+edx+172]
	jge	SHORT $LN19@SetUpdateR
$LN18@SetUpdateR:

; 622  : 			return;

	jmp	$LN22@SetUpdateR
$LN19@SetUpdateR:

; 623  : 		// original code
; 624  : 		if(x1 < ClientArea_[client].left) x1=ClientArea_[client].left;

	mov	edx, DWORD PTR _client$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _x1$[ebp]
	cmp	ecx, DWORD PTR [eax+edx+168]
	jge	SHORT $LN17@SetUpdateR
	mov	edx, DWORD PTR _client$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+168]
	mov	DWORD PTR _x1$[ebp], ecx
$LN17@SetUpdateR:

; 625  : 		if(y1 < ClientArea_[client].top) y1=ClientArea_[client].top;

	mov	edx, DWORD PTR _client$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _y1$[ebp]
	cmp	ecx, DWORD PTR [eax+edx+172]
	jge	SHORT $LN16@SetUpdateR
	mov	edx, DWORD PTR _client$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+172]
	mov	DWORD PTR _y1$[ebp], ecx
$LN16@SetUpdateR:

; 626  : 		if(x2 > ClientArea_[client].right) x2=ClientArea_[client].right;

	mov	edx, DWORD PTR _client$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _x2$[ebp]
	cmp	ecx, DWORD PTR [eax+edx+176]
	jle	SHORT $LN15@SetUpdateR
	mov	edx, DWORD PTR _client$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+176]
	mov	DWORD PTR _x2$[ebp], ecx
$LN15@SetUpdateR:

; 627  : 		if(y2 > ClientArea_[client].bottom) y2=ClientArea_[client].bottom;

	mov	edx, DWORD PTR _client$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _y2$[ebp]
	cmp	ecx, DWORD PTR [eax+edx+180]
	jle	SHORT $LN14@SetUpdateR
	mov	edx, DWORD PTR _client$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+180]
	mov	DWORD PTR _y2$[ebp], ecx
$LN14@SetUpdateR:

; 628  : 	}
; 629  : 	else

	jmp	$LN13@SetUpdateR
$LN20@SetUpdateR:

; 630  : 	{
; 631  : 		if(x1 > GetW() || y1 > GetH() || x2 < 0 || y2 < 0)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetW@C_Window@@QAEFXZ			; C_Window::GetW
	movsx	edx, ax
	cmp	DWORD PTR _x1$[ebp], edx
	jg	SHORT $LN11@SetUpdateR
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetH@C_Window@@QAEFXZ			; C_Window::GetH
	cwde
	cmp	DWORD PTR _y1$[ebp], eax
	jg	SHORT $LN11@SetUpdateR
	cmp	DWORD PTR _x2$[ebp], 0
	jl	SHORT $LN11@SetUpdateR
	cmp	DWORD PTR _y2$[ebp], 0
	jge	SHORT $LN12@SetUpdateR
$LN11@SetUpdateR:

; 632  : 			return;

	jmp	$LN22@SetUpdateR
$LN12@SetUpdateR:

; 633  : 
; 634  : 		if(x1 < 0) x1=0;

	cmp	DWORD PTR _x1$[ebp], 0
	jge	SHORT $LN10@SetUpdateR
	mov	DWORD PTR _x1$[ebp], 0
$LN10@SetUpdateR:

; 635  : 		if(y1 < 0) y1=0;

	cmp	DWORD PTR _y1$[ebp], 0
	jge	SHORT $LN9@SetUpdateR
	mov	DWORD PTR _y1$[ebp], 0
$LN9@SetUpdateR:

; 636  : 		if(x2 > GetW()) x2=GetW();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetW@C_Window@@QAEFXZ			; C_Window::GetW
	movsx	ecx, ax
	cmp	DWORD PTR _x2$[ebp], ecx
	jle	SHORT $LN8@SetUpdateR
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetW@C_Window@@QAEFXZ			; C_Window::GetW
	movsx	edx, ax
	mov	DWORD PTR _x2$[ebp], edx
$LN8@SetUpdateR:

; 637  : 		if(y2 > GetH()) y2=GetH();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetH@C_Window@@QAEFXZ			; C_Window::GetH
	cwde
	cmp	DWORD PTR _y2$[ebp], eax
	jle	SHORT $LN13@SetUpdateR
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetH@C_Window@@QAEFXZ			; C_Window::GetH
	movsx	ecx, ax
	mov	DWORD PTR _y2$[ebp], ecx
$LN13@SetUpdateR:

; 638  : 	}
; 639  : 	Leave=UI_Enter(this);

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 640  : 
; 641  : 	if(rectcount_)

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+1016]
	test	ecx, ecx
	je	SHORT $LN6@SetUpdateR

; 642  : 	{
; 643  : 		if(SetCheckedUpdateRect(x1,y1,x2,y2) < 0)

	mov	edx, DWORD PTR _y2$[ebp]
	push	edx
	mov	eax, DWORD PTR _x2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _y1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x1$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCheckedUpdateRect@C_Window@@AAEJJJJJ@Z ; C_Window::SetCheckedUpdateRect
	test	eax, eax
	jge	SHORT $LN5@SetUpdateR

; 644  : 		{
; 645  : 			for(i=0;i<WIN_MAX_RECTS;i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN4@SetUpdateR
$LN3@SetUpdateR:
	mov	cx, WORD PTR _i$[ebp]
	add	cx, 1
	mov	WORD PTR _i$[ebp], cx
$LN4@SetUpdateR:
	movsx	edx, WORD PTR _i$[ebp]
	cmp	edx, 200				; 000000c8H
	jge	SHORT $LN2@SetUpdateR

; 646  : 				rectflag_[i]=0;

	movsx	eax, WORD PTR _i$[ebp]
	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+eax*2+616], cx
	jmp	SHORT $LN3@SetUpdateR
$LN2@SetUpdateR:

; 647  : 			rectcount_=0;

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1016], ax

; 648  : 			AddUpdateRect(0,0,w_,h_);

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+434]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+432]
	push	edx
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddUpdateRect@C_Window@@QAEXJJJJ@Z	; C_Window::AddUpdateRect
$LN5@SetUpdateR:

; 649  : 		}
; 650  : 	}
; 651  : 	else

	jmp	SHORT $LN1@SetUpdateR
$LN6@SetUpdateR:

; 652  : 		AddUpdateRect(x1,y1,x2,y2);

	mov	eax, DWORD PTR _y2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _y1$[ebp]
	push	edx
	mov	eax, DWORD PTR _x1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddUpdateRect@C_Window@@QAEXJJJJ@Z	; C_Window::AddUpdateRect
$LN1@SetUpdateR:

; 653  : 
; 654  : 	update_ |= C_DRAW_COPYWINDOW | C_DRAW_REFRESH;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	or	edx, 268435457				; 10000001H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+104], edx

; 655  : 	Handler_->UpdateFlag |= C_DRAW_REFRESH;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4328]
	mov	eax, DWORD PTR [edx+3472]
	or	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4328]
	mov	DWORD PTR [edx+3472], eax

; 656  : 
; 657  : 	UI_Leave(Leave);

	mov	eax, DWORD PTR _Leave$[ebp]
	push	eax
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4
$LN22@SetUpdateR:

; 658  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?SetUpdateRect@C_Window@@QAEXJJJJJJ@Z ENDP		; C_Window::SetUpdateRect
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_i$ = -12						; size = 4
_use$ = -8						; size = 4
_this$ = -4						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_x2$ = 16						; size = 4
_y2$ = 20						; size = 4
?AddUpdateRect@C_Window@@QAEXJJJJ@Z PROC		; C_Window::AddUpdateRect
; _this$ = ecx

; 458  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 459  : 	long i,use;
; 460  : 
; 461  : 	if(x1 >= x2 || y1 >= y2)

	mov	eax, DWORD PTR _x1$[ebp]
	cmp	eax, DWORD PTR _x2$[ebp]
	jge	SHORT $LN8@AddUpdateR
	mov	ecx, DWORD PTR _y1$[ebp]
	cmp	ecx, DWORD PTR _y2$[ebp]
	jl	SHORT $LN9@AddUpdateR
$LN8@AddUpdateR:

; 462  : 		return;

	jmp	$LN10@AddUpdateR
$LN9@AddUpdateR:

; 463  : 
; 464  : 	use=-1;

	mov	DWORD PTR _use$[ebp], -1

; 465  : 	for(i=0;i<rectcount_;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@AddUpdateR
$LN6@AddUpdateR:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN7@AddUpdateR:
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+1016]
	cmp	DWORD PTR _i$[ebp], ecx
	jge	SHORT $LN5@AddUpdateR

; 466  : 		if(!rectflag_[i])

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+edx*2+616]
	test	ecx, ecx
	jne	SHORT $LN4@AddUpdateR

; 467  : 		{
; 468  : 			use=i;

	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _use$[ebp], edx

; 469  : 			i=rectcount_+1;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+1016]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@AddUpdateR:

; 470  : 		}

	jmp	SHORT $LN6@AddUpdateR
$LN5@AddUpdateR:

; 471  : 
; 472  : 	if(use == -1)

	cmp	DWORD PTR _use$[ebp], -1
	jne	SHORT $LN3@AddUpdateR

; 473  : 	{
; 474  : 		use=rectcount_;

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+1016]
	mov	DWORD PTR _use$[ebp], eax

; 475  : 		rectcount_++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1016]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+1016], dx
$LN3@AddUpdateR:

; 476  : 	}
; 477  : 	if(use < WIN_MAX_RECTS)

	cmp	DWORD PTR _use$[ebp], 200		; 000000c8H
	jge	SHORT $LN2@AddUpdateR

; 478  : 	{
; 479  : 		rectflag_[use]=1;

	mov	ecx, 1
	mov	edx, DWORD PTR _use$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+edx*2+616], cx

; 480  : 		rectlist_[use].left=x1;

	mov	ecx, DWORD PTR _use$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _x1$[ebp]
	mov	DWORD PTR [edx+ecx+1020], eax

; 481  : 		rectlist_[use].top=y1;

	mov	ecx, DWORD PTR _use$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _y1$[ebp]
	mov	DWORD PTR [edx+ecx+1024], eax

; 482  : 		rectlist_[use].right=x2;

	mov	ecx, DWORD PTR _use$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _x2$[ebp]
	mov	DWORD PTR [edx+ecx+1028], eax

; 483  : 		rectlist_[use].bottom=y2;

	mov	ecx, DWORD PTR _use$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _y2$[ebp]
	mov	DWORD PTR [edx+ecx+1032], eax

; 484  : 	}
; 485  : 	else

	jmp	$LN10@AddUpdateR
$LN2@AddUpdateR:

; 486  : 	{
; 487  : 		rectcount_=1;

	mov	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1016], cx

; 488  : 		memset(rectflag_,0,sizeof(rectflag_));

	push	400					; 00000190H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 616				; 00000268H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 489  : 		rectflag_[0]=1;

	mov	ecx, 2
	imul	ecx, 0
	mov	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+ecx+616], dx

; 490  : 		rectlist_[0].left=0;

	mov	ecx, 16					; 00000010H
	imul	ecx, 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx+1020], 0

; 491  : 		rectlist_[0].top=0;

	mov	eax, 16					; 00000010H
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+1024], 0

; 492  : 		rectlist_[0].right=GetW();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetW@C_Window@@QAEFXZ			; C_Window::GetW
	movsx	edx, ax
	mov	eax, 16					; 00000010H
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+1028], edx

; 493  : 		rectlist_[0].bottom=GetH();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetH@C_Window@@QAEFXZ			; C_Window::GetH
	movsx	edx, ax
	mov	eax, 16					; 00000010H
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax+1032], edx
$LN10@AddUpdateR:

; 494  : 		//MonoPrint("AddUpdateRect: [use] index >= WIN_MAX_RECTS");
; 495  : 	}
; 496  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?AddUpdateRect@C_Window@@QAEXJJJJ@Z ENDP		; C_Window::AddUpdateRect
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.h
;	COMDAT ?SetDefaultFlags@C_Window@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetDefaultFlags@C_Window@@QAEXXZ PROC			; C_Window::SetDefaultFlags, COMDAT
; _this$ = ecx

; 298  : 		void SetDefaultFlags() { SetFlags(DefaultFlags_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFlags@C_Window@@QAEXJ@Z		; C_Window::SetFlags
	mov	esp, ebp
	pop	ebp
	ret	0
?SetDefaultFlags@C_Window@@QAEXXZ ENDP			; C_Window::SetDefaultFlags
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
tv135 = -40						; size = 4
$T1 = -36						; size = 4
$T2 = -32						; size = 4
tv91 = -28						; size = 4
$T3 = -24						; size = 4
$T4 = -20						; size = 4
$T5 = -16						; size = 4
_cur$ = -12						; size = 4
_last$ = -8						; size = 4
_this$ = -4						; size = 4
?Cleanup@C_Window@@QAEXXZ PROC				; C_Window::Cleanup
; _this$ = ecx

; 248  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 249  : 	CONTROLLIST *cur,*last;
; 250  : 
; 251  : 	if(Controls_ && !(Flags_ & C_BIT_NOCLEANUP))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4304], 0
	je	$LN5@Cleanup
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, 134217728				; 08000000H
	jne	$LN5@Cleanup

; 252  : 	{
; 253  : 		cur=Controls_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4304]
	mov	DWORD PTR _cur$[ebp], ecx
$LN4@Cleanup:

; 254  : 		while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN3@Cleanup

; 255  : 		{
; 256  : 			last=cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _last$[ebp], edx

; 257  : 			cur=cur->Next;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _cur$[ebp], ecx

; 258  : 			if(last->Control_->GetFlags() & C_BIT_REMOVE)

	mov	edx, DWORD PTR _last$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetFlags@C_Base@@QAEJXZ		; C_Base::GetFlags
	and	eax, 67108864				; 04000000H
	je	SHORT $LN2@Cleanup

; 259  : 			{
; 260  : 				last->Control_->Cleanup();

	mov	eax, DWORD PTR _last$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _last$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax+176]
	call	edx

; 261  : 				delete last->Control_;

	mov	eax, DWORD PTR _last$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T3[ebp], ecx
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR $T5[ebp], edx
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN8@Cleanup
	push	1
	mov	eax, DWORD PTR $T5[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T5[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv91[ebp], eax
	jmp	SHORT $LN2@Cleanup
$LN8@Cleanup:
	mov	DWORD PTR tv91[ebp], 0
$LN2@Cleanup:

; 262  : 			}
; 263  : 			delete last;

	mov	ecx, DWORD PTR _last$[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 264  : 		}

	jmp	SHORT $LN4@Cleanup
$LN3@Cleanup:

; 265  : 		Controls_=NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4304], 0
$LN5@Cleanup:

; 266  : 	}
; 267  : 
; 268  : 	if(Hash_)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4300], 0
	je	SHORT $LN1@Cleanup

; 269  : 	{
; 270  : 		Hash_->Cleanup();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4300]
	call	?Cleanup@C_Hash@@QAEXXZ			; C_Hash::Cleanup

; 271  : 		delete Hash_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4300]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T4[ebp], edx
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN10@Cleanup
	push	1
	mov	ecx, DWORD PTR $T4[ebp]
	call	??_GC_Hash@@QAEPAXI@Z
	mov	DWORD PTR tv135[ebp], eax
	jmp	SHORT $LN11@Cleanup
$LN10@Cleanup:
	mov	DWORD PTR tv135[ebp], 0
$LN11@Cleanup:

; 272  : 		Hash_=NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4300], 0
$LN1@Cleanup:

; 273  : 	}
; 274  : 	imgBuf_=NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4292], 0

; 275  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Cleanup@C_Window@@QAEXXZ ENDP				; C_Window::Cleanup
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_cur$ = -4						; size = 4
?SetNextControl@C_Window@@QAEXXZ PROC			; C_Window::SetNextControl
; _this$ = ecx

; 2481 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2482 : 	CONTROLLIST *cur;
; 2483 : 
; 2484 : 	if(CurControl_)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4312], 0
	je	SHORT $LN13@SetNextCon

; 2485 : 		CurControl_->Deactivate();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4312]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4312]
	mov	eax, DWORD PTR [edx+188]
	call	eax
$LN13@SetNextCon:

; 2486 : 
; 2487 : 	if(CurControl_ == NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4312], 0
	jne	$LN12@SetNextCon

; 2488 : 	{
; 2489 : 		cur=Controls_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4304]
	mov	DWORD PTR _cur$[ebp], eax
$LN11@SetNextCon:

; 2490 : 		while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN10@SetNextCon

; 2491 : 		{
; 2492 : 			if(cur->Control_->GetFlags() & C_BIT_SELECTABLE && cur->Control_->GetFlags() & C_BIT_ENABLED && !(cur->Control_->GetFlags() & C_BIT_INVISIBLE))

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetFlags@C_Base@@QAEJXZ		; C_Base::GetFlags
	and	eax, 524288				; 00080000H
	je	SHORT $LN9@SetNextCon
	mov	edx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetFlags@C_Base@@QAEJXZ		; C_Base::GetFlags
	and	eax, 2048				; 00000800H
	je	SHORT $LN9@SetNextCon
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetFlags@C_Base@@QAEJXZ		; C_Base::GetFlags
	and	eax, 8192				; 00002000H
	jne	SHORT $LN9@SetNextCon

; 2493 : 			{
; 2494 : 				CurControl_=cur->Control_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+4312], eax

; 2495 : 				CurControl_->Activate();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4312]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4312]
	mov	eax, DWORD PTR [edx+184]
	call	eax

; 2496 : 				return;

	jmp	$LN14@SetNextCon
$LN9@SetNextCon:

; 2497 : 			}
; 2498 : 			cur=cur->Next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _cur$[ebp], edx

; 2499 : 		}

	jmp	SHORT $LN11@SetNextCon
$LN10@SetNextCon:

; 2500 : 	}
; 2501 : 	else

	jmp	$LN14@SetNextCon
$LN12@SetNextCon:

; 2502 : 	{
; 2503 : 		cur=FindControlInList(CurControl_);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4312]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindControlInList@C_Window@@AAEPAUControlListStr@@PAVC_Base@@@Z ; C_Window::FindControlInList
	mov	DWORD PTR _cur$[ebp], eax

; 2504 : 		if(cur == NULL)

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN7@SetNextCon

; 2505 : 			return;

	jmp	$LN14@SetNextCon
$LN7@SetNextCon:

; 2506 : 
; 2507 : 		if(cur->Next == NULL)

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	SHORT $LN6@SetNextCon

; 2508 : 			cur=Controls_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4304]
	mov	DWORD PTR _cur$[ebp], ecx

; 2509 : 		else

	jmp	SHORT $LN4@SetNextCon
$LN6@SetNextCon:

; 2510 : 			cur=cur->Next;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _cur$[ebp], eax
$LN4@SetNextCon:

; 2511 : 
; 2512 : 		while(cur->Control_ != CurControl_)

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx+4312]
	je	SHORT $LN14@SetNextCon

; 2513 : 		{
; 2514 : 			if(cur->Control_->GetFlags() & C_BIT_SELECTABLE && cur->Control_->GetFlags() & C_BIT_ENABLED && !(cur->Control_->GetFlags() & C_BIT_INVISIBLE))

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetFlags@C_Base@@QAEJXZ		; C_Base::GetFlags
	and	eax, 524288				; 00080000H
	je	SHORT $LN2@SetNextCon
	mov	edx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetFlags@C_Base@@QAEJXZ		; C_Base::GetFlags
	and	eax, 2048				; 00000800H
	je	SHORT $LN2@SetNextCon
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetFlags@C_Base@@QAEJXZ		; C_Base::GetFlags
	and	eax, 8192				; 00002000H
	jne	SHORT $LN2@SetNextCon

; 2515 : 			{
; 2516 : 				CurControl_=cur->Control_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+4312], eax

; 2517 : 				CurControl_->Activate();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4312]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4312]
	mov	eax, DWORD PTR [edx+184]
	call	eax

; 2518 : 				return;

	jmp	SHORT $LN14@SetNextCon
$LN2@SetNextCon:

; 2519 : 			}
; 2520 : 			cur=cur->Next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _cur$[ebp], edx

; 2521 : 			if(cur == NULL)

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN1@SetNextCon

; 2522 : 				cur=Controls_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4304]
	mov	DWORD PTR _cur$[ebp], ecx
$LN1@SetNextCon:

; 2523 : 		}

	jmp	$LN4@SetNextCon
$LN14@SetNextCon:

; 2524 : 	}
; 2525 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetNextControl@C_Window@@QAEXXZ ENDP			; C_Window::SetNextControl
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_cur$ = -4						; size = 4
?SetPrevControl@C_Window@@QAEXXZ PROC			; C_Window::SetPrevControl
; _this$ = ecx

; 2434 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2435 : 	CONTROLLIST *cur;
; 2436 : 
; 2437 : 	if(CurControl_)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4312], 0
	je	SHORT $LN13@SetPrevCon

; 2438 : 		CurControl_->Deactivate();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4312]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4312]
	mov	eax, DWORD PTR [edx+188]
	call	eax
$LN13@SetPrevCon:

; 2439 : 
; 2440 : 	if(CurControl_ == NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4312], 0
	jne	$LN12@SetPrevCon

; 2441 : 	{
; 2442 : 		cur=Last_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4308]
	mov	DWORD PTR _cur$[ebp], eax
$LN11@SetPrevCon:

; 2443 : 		while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN10@SetPrevCon

; 2444 : 		{
; 2445 : 			if(cur->Control_->GetFlags() & C_BIT_SELECTABLE && cur->Control_->GetFlags() & C_BIT_ENABLED && !(cur->Control_->GetFlags() & C_BIT_INVISIBLE))

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetFlags@C_Base@@QAEJXZ		; C_Base::GetFlags
	and	eax, 524288				; 00080000H
	je	SHORT $LN9@SetPrevCon
	mov	edx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetFlags@C_Base@@QAEJXZ		; C_Base::GetFlags
	and	eax, 2048				; 00000800H
	je	SHORT $LN9@SetPrevCon
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetFlags@C_Base@@QAEJXZ		; C_Base::GetFlags
	and	eax, 8192				; 00002000H
	jne	SHORT $LN9@SetPrevCon

; 2446 : 			{
; 2447 : 				CurControl_=cur->Control_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+4312], eax

; 2448 : 				CurControl_->Activate();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4312]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4312]
	mov	eax, DWORD PTR [edx+184]
	call	eax

; 2449 : 				return;

	jmp	$LN14@SetPrevCon
$LN9@SetPrevCon:

; 2450 : 			}
; 2451 : 			cur=cur->Prev;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _cur$[ebp], edx

; 2452 : 		}

	jmp	SHORT $LN11@SetPrevCon
$LN10@SetPrevCon:

; 2453 : 	}
; 2454 : 	else

	jmp	$LN14@SetPrevCon
$LN12@SetPrevCon:

; 2455 : 	{
; 2456 : 		cur=FindControlInList(CurControl_);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4312]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindControlInList@C_Window@@AAEPAUControlListStr@@PAVC_Base@@@Z ; C_Window::FindControlInList
	mov	DWORD PTR _cur$[ebp], eax

; 2457 : 		if(cur == NULL)

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN7@SetPrevCon

; 2458 : 			return;

	jmp	$LN14@SetPrevCon
$LN7@SetPrevCon:

; 2459 : 
; 2460 : 		if(cur->Prev == NULL)

	mov	edx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN6@SetPrevCon

; 2461 : 			cur=Last_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4308]
	mov	DWORD PTR _cur$[ebp], ecx

; 2462 : 		else

	jmp	SHORT $LN4@SetPrevCon
$LN6@SetPrevCon:

; 2463 : 			cur=cur->Prev;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _cur$[ebp], eax
$LN4@SetPrevCon:

; 2464 : 
; 2465 : 		while(cur->Control_ != CurControl_)

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx+4312]
	je	SHORT $LN14@SetPrevCon

; 2466 : 		{
; 2467 : 			if(cur->Control_->GetFlags() & C_BIT_SELECTABLE && cur->Control_->GetFlags() & C_BIT_ENABLED && !(cur->Control_->GetFlags() & C_BIT_INVISIBLE))

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetFlags@C_Base@@QAEJXZ		; C_Base::GetFlags
	and	eax, 524288				; 00080000H
	je	SHORT $LN2@SetPrevCon
	mov	edx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetFlags@C_Base@@QAEJXZ		; C_Base::GetFlags
	and	eax, 2048				; 00000800H
	je	SHORT $LN2@SetPrevCon
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetFlags@C_Base@@QAEJXZ		; C_Base::GetFlags
	and	eax, 8192				; 00002000H
	jne	SHORT $LN2@SetPrevCon

; 2468 : 			{
; 2469 : 				CurControl_=cur->Control_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+4312], eax

; 2470 : 				CurControl_->Activate();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4312]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4312]
	mov	eax, DWORD PTR [edx+184]
	call	eax

; 2471 : 				return;

	jmp	SHORT $LN14@SetPrevCon
$LN2@SetPrevCon:

; 2472 : 			}
; 2473 : 			cur=cur->Prev;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _cur$[ebp], edx

; 2474 : 			if(cur == NULL)

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $LN1@SetPrevCon

; 2475 : 				cur=Last_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4308]
	mov	DWORD PTR _cur$[ebp], ecx
$LN1@SetPrevCon:

; 2476 : 		}

	jmp	$LN4@SetPrevCon
$LN14@SetPrevCon:

; 2477 : 	}
; 2478 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetPrevControl@C_Window@@QAEXXZ ENDP			; C_Window::SetPrevControl
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_cur$ = -8						; size = 4
_this$ = -4						; size = 4
_ID$ = 8						; size = 4
?SetControl@C_Window@@QAEXJ@Z PROC			; C_Window::SetControl
; _this$ = ecx

; 2391 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2392 : 	C_Base *cur;
; 2393 : 
; 2394 : 	cur=FindControl(ID);

	mov	eax, DWORD PTR _ID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _cur$[ebp], eax

; 2395 : 	if(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN9@SetControl

; 2396 : 	{
; 2397 : 		if(cur->GetFlags() & C_BIT_SELECTABLE)

	mov	ecx, DWORD PTR _cur$[ebp]
	call	?GetFlags@C_Base@@QAEJXZ		; C_Base::GetFlags
	and	eax, 524288				; 00080000H
	je	$LN8@SetControl

; 2398 : 		{
; 2399 : 			if(CurControl_)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4312], 0
	je	SHORT $LN7@SetControl

; 2400 : 			{
; 2401 : 				if(cur != CurControl_)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	cmp	eax, DWORD PTR [edx+4312]
	je	SHORT $LN6@SetControl

; 2402 : 				{
; 2403 : 					CurControl_->Deactivate();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4312]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4312]
	mov	eax, DWORD PTR [edx+188]
	call	eax

; 2404 : 					CurControl_=cur;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx+4312], edx

; 2405 : 					CurControl_->Activate();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4312]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+4312]
	mov	edx, DWORD PTR [eax+184]
	call	edx
$LN6@SetControl:

; 2406 : 				}
; 2407 : 			}
; 2408 : 			else

	jmp	SHORT $LN5@SetControl
$LN7@SetControl:

; 2409 : 			{
; 2410 : 				CurControl_=cur;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax+4312], ecx

; 2411 : 				CurControl_->Activate();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4312]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4312]
	mov	eax, DWORD PTR [edx+184]
	call	eax
$LN5@SetControl:

; 2412 : 			}
; 2413 : 		}
; 2414 : 		else

	jmp	SHORT $LN4@SetControl
$LN8@SetControl:

; 2415 : 		{
; 2416 : 			if(CurControl_)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4312], 0
	je	SHORT $LN4@SetControl

; 2417 : 			{
; 2418 : 				CurControl_->Deactivate();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4312]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4312]
	mov	eax, DWORD PTR [edx+188]
	call	eax

; 2419 : 				CurControl_=NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4312], 0
$LN4@SetControl:

; 2420 : 			}
; 2421 : 		}
; 2422 : 	}
; 2423 : 	else

	jmp	SHORT $LN10@SetControl
$LN9@SetControl:

; 2424 : 	{
; 2425 : 		if(CurControl_)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4312], 0
	je	SHORT $LN10@SetControl

; 2426 : 		{
; 2427 : 			CurControl_->Deactivate();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4312]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+4312]
	mov	edx, DWORD PTR [eax+188]
	call	edx

; 2428 : 			CurControl_=NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4312], 0
$LN10@SetControl:

; 2429 : 		}
; 2430 : 	}
; 2431 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetControl@C_Window@@QAEXJ@Z ENDP			; C_Window::SetControl
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_cur$ = -4						; size = 4
_DKScanCode$ = 8					; size = 1
___formal$ = 12						; size = 1
_ShiftStates$ = 16					; size = 1
___formal$ = 20						; size = 4
?CheckHotKeys@C_Window@@QAEHEEEJ@Z PROC			; C_Window::CheckHotKeys
; _this$ = ecx

; 2600 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2601 : 	CONTROLLIST *cur;
; 2602 : 
; 2603 : 	cur=Controls_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4304]
	mov	DWORD PTR _cur$[ebp], ecx
$LN3@CheckHotKe:

; 2604 : 
; 2605 : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN2@CheckHotKe

; 2606 : 	{
; 2607 : 		if(cur->Control_->GetHotKey() == (DKScanCode | (ShiftStates << 8)))

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+116]
	call	eax
	movsx	ecx, ax
	movzx	edx, BYTE PTR _DKScanCode$[ebp]
	movzx	eax, BYTE PTR _ShiftStates$[ebp]
	shl	eax, 8
	or	edx, eax
	cmp	ecx, edx
	jne	SHORT $LN1@CheckHotKe

; 2608 : 		{
; 2609 : 			cur->Control_->Process(cur->Control_->GetID(),C_TYPE_LMOUSEDOWN);

	push	51					; 00000033H
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	push	eax
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+200]
	call	eax

; 2610 : 			cur->Control_->Process(cur->Control_->GetID(),C_TYPE_LMOUSEUP);

	push	52					; 00000034H
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	push	eax
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+200]
	call	eax

; 2611 : 			return(TRUE);

	mov	eax, 1
	jmp	SHORT $LN4@CheckHotKe
$LN1@CheckHotKe:

; 2612 : 		}
; 2613 : 		cur=cur->Next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _cur$[ebp], edx

; 2614 : 	}

	jmp	SHORT $LN3@CheckHotKe
$LN2@CheckHotKe:

; 2615 : 	return(FALSE);

	xor	eax, eax
$LN4@CheckHotKe:

; 2616 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?CheckHotKeys@C_Window@@QAEHEEEJ@Z ENDP			; C_Window::CheckHotKeys
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
tv91 = -8						; size = 4
_this$ = -4						; size = 4
_DKScanCode$ = 8					; size = 1
_Ascii$ = 12						; size = 1
_ShiftStates$ = 16					; size = 1
_RepeatCount$ = 20					; size = 4
?CheckKeyboard@C_Window@@QAEHEEEJ@Z PROC		; C_Window::CheckKeyboard
; _this$ = ecx

; 2558 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2559 : 	if(KBCallback_)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4324], 0
	je	SHORT $LN17@CheckKeybo

; 2560 : 		if((*KBCallback_)(DKScanCode,Ascii,ShiftStates,RepeatCount))

	mov	ecx, DWORD PTR _RepeatCount$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _ShiftStates$[ebp]
	push	edx
	movzx	eax, BYTE PTR _Ascii$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _DKScanCode$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4324]
	call	eax
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN17@CheckKeybo

; 2561 : 			return(TRUE);

	mov	eax, 1
	jmp	$LN18@CheckKeybo
$LN17@CheckKeybo:

; 2562 : 
; 2563 : 	if(Ascii)

	movzx	ecx, BYTE PTR _Ascii$[ebp]
	test	ecx, ecx
	je	SHORT $LN15@CheckKeybo

; 2564 : 	{
; 2565 : 		if (CurControl_ && CurControl_->CheckKeyboard(DKScanCode,Ascii,ShiftStates,RepeatCount))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4312], 0
	je	SHORT $LN14@CheckKeybo
	mov	eax, DWORD PTR _RepeatCount$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _ShiftStates$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _Ascii$[ebp]
	push	edx
	movzx	eax, BYTE PTR _DKScanCode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4312]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4312]
	mov	eax, DWORD PTR [edx+196]
	call	eax
	test	eax, eax
	je	SHORT $LN14@CheckKeybo

; 2566 : 			return(TRUE);

	mov	eax, 1
	jmp	$LN18@CheckKeybo
$LN14@CheckKeybo:

; 2567 : 	}
; 2568 : 	else

	jmp	$LN13@CheckKeybo
$LN15@CheckKeybo:

; 2569 : 	{
; 2570 : 		switch(DKScanCode)

	mov	cl, BYTE PTR _DKScanCode$[ebp]
	mov	BYTE PTR tv91[ebp], cl
	cmp	BYTE PTR tv91[ebp], 15			; 0000000fH
	je	SHORT $LN10@CheckKeybo
	cmp	BYTE PTR tv91[ebp], 82			; 00000052H
	je	SHORT $LN6@CheckKeybo
	cmp	BYTE PTR tv91[ebp], 210			; 000000d2H
	je	SHORT $LN6@CheckKeybo
	jmp	SHORT $LN3@CheckKeybo
$LN10@CheckKeybo:

; 2571 : 		{
; 2572 : 			case DIK_TAB:
; 2573 : 				if(ShiftStates == _SHIFT_DOWN_)

	movzx	edx, BYTE PTR _ShiftStates$[ebp]
	cmp	edx, 1
	jne	SHORT $LN9@CheckKeybo

; 2574 : 					SetPrevControl();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPrevControl@C_Window@@QAEXXZ	; C_Window::SetPrevControl
	jmp	SHORT $LN8@CheckKeybo
$LN9@CheckKeybo:

; 2575 : 				else if(!ShiftStates)

	movzx	eax, BYTE PTR _ShiftStates$[ebp]
	test	eax, eax
	jne	SHORT $LN8@CheckKeybo

; 2576 : 					SetNextControl();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetNextControl@C_Window@@QAEXXZ	; C_Window::SetNextControl
$LN8@CheckKeybo:

; 2577 : 				return(TRUE);

	mov	eax, 1
	jmp	$LN18@CheckKeybo

; 2578 : 				break;

	jmp	$LN13@CheckKeybo
$LN6@CheckKeybo:

; 2579 : 			case DIK_NUMPAD0:
; 2580 : 			case DIK_INSERT:
; 2581 : 				if(Handler_->KeyboardMode())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4328]
	call	?KeyboardMode@C_Handler@@QAEHXZ		; C_Handler::KeyboardMode
	test	eax, eax
	je	SHORT $LN5@CheckKeybo

; 2582 : 					Handler_->SetKeyboardMode(FALSE);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4328]
	call	?SetKeyboardMode@C_Handler@@QAEXH@Z	; C_Handler::SetKeyboardMode

; 2583 : 				else

	jmp	SHORT $LN4@CheckKeybo
$LN5@CheckKeybo:

; 2584 : 					Handler_->SetKeyboardMode(TRUE);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4328]
	call	?SetKeyboardMode@C_Handler@@QAEXH@Z	; C_Handler::SetKeyboardMode
$LN4@CheckKeybo:

; 2585 : 				return(TRUE);

	mov	eax, 1
	jmp	SHORT $LN18@CheckKeybo

; 2586 : 				break;

	jmp	SHORT $LN13@CheckKeybo
$LN3@CheckKeybo:

; 2587 : 			default:
; 2588 : 				if(CurControl_ == NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4312], 0
	jne	SHORT $LN2@CheckKeybo

; 2589 : 					break;

	jmp	SHORT $LN13@CheckKeybo
$LN2@CheckKeybo:

; 2590 : 				if(CurControl_->CheckKeyboard(DKScanCode,Ascii,ShiftStates,RepeatCount))

	mov	edx, DWORD PTR _RepeatCount$[ebp]
	push	edx
	movzx	eax, BYTE PTR _ShiftStates$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _Ascii$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _DKScanCode$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4312]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx+4312]
	mov	edx, DWORD PTR [eax+196]
	call	edx
	test	eax, eax
	je	SHORT $LN13@CheckKeybo

; 2591 : 					return(TRUE);

	mov	eax, 1
	jmp	SHORT $LN18@CheckKeybo
$LN13@CheckKeybo:

; 2592 : 				break;
; 2593 : 		}
; 2594 : 	}
; 2595 : 	return(FALSE);

	xor	eax, eax
$LN18@CheckKeybo:

; 2596 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?CheckKeyboard@C_Window@@QAEHEEEJ@Z ENDP		; C_Window::CheckKeyboard
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.h
;	COMDAT ?SetFont@C_Window@@QAEHJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ID$ = 8						; size = 4
?SetFont@C_Window@@QAEHJ@Z PROC				; C_Window::SetFont, COMDAT
; _this$ = ecx

; 282  : 		BOOL SetFont(long ID) { Font_=ID; return(TRUE); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _ID$[ebp]
	mov	DWORD PTR [eax+108], ecx
	mov	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	4
?SetFont@C_Window@@QAEHJ@Z ENDP				; C_Window::SetFont
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_Leave$ = -32						; size = 4
$T1 = -28						; size = 4
tv88 = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
_cur$ = -12						; size = 4
_last$ = -8						; size = 4
_this$ = -4						; size = 4
?RemoveAllControls@C_Window@@QAEXXZ PROC		; C_Window::RemoveAllControls
; _this$ = ecx

; 1039 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1040 : 	CONTROLLIST *cur,*last;
; 1041 : 	F4CSECTIONHANDLE* Leave;
; 1042 : 
; 1043 : 	Leave=UI_Enter(this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 1044 : 	cur=Controls_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4304]
	mov	DWORD PTR _cur$[ebp], edx
$LN3@RemoveAllC:

; 1045 : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN2@RemoveAllC

; 1046 : 	{
; 1047 : 		last=cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _last$[ebp], eax

; 1048 : 		cur=cur->Next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _cur$[ebp], edx

; 1049 : 		if(last->Control_->GetFlags() & C_BIT_REMOVE)

	mov	eax, DWORD PTR _last$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetFlags@C_Base@@QAEJXZ		; C_Base::GetFlags
	and	eax, 67108864				; 04000000H
	je	SHORT $LN1@RemoveAllC

; 1050 : 		{
; 1051 : 			last->Control_->Cleanup();

	mov	ecx, DWORD PTR _last$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _last$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+176]
	call	eax

; 1052 : 			delete last->Control_;

	mov	ecx, DWORD PTR _last$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T3[ebp], eax
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN6@RemoveAllC
	push	1
	mov	ecx, DWORD PTR $T3[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv88[ebp], eax
	jmp	SHORT $LN7@RemoveAllC
$LN6@RemoveAllC:
	mov	DWORD PTR tv88[ebp], 0
$LN7@RemoveAllC:

; 1053 : 			delete last;

	mov	ecx, DWORD PTR _last$[ebp]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@RemoveAllC:

; 1054 : 		}
; 1055 : 	}

	jmp	SHORT $LN3@RemoveAllC
$LN2@RemoveAllC:

; 1056 : 	Controls_=NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4304], 0

; 1057 : 	Hash_->Cleanup();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4300]
	call	?Cleanup@C_Hash@@QAEXXZ			; C_Hash::Cleanup

; 1058 : 	Hash_->Setup(WIN_HASH_SIZE);

	push	50					; 00000032H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4300]
	call	?Setup@C_Hash@@QAEXJ@Z			; C_Hash::Setup

; 1059 : 
; 1060 : 	ScanClientAreas();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ScanClientAreas@C_Window@@QAEXXZ	; C_Window::ScanClientAreas

; 1061 : 	UI_Leave(Leave);

	mov	eax, DWORD PTR _Leave$[ebp]
	push	eax
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4

; 1062 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAllControls@C_Window@@QAEXXZ ENDP		; C_Window::RemoveAllControls
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_retval$ = -28						; size = 4
_Leave$ = -24						; size = 4
$T1 = -20						; size = 4
tv169 = -16						; size = 4
$T2 = -12						; size = 4
$T3 = -8						; size = 4
_this$ = -4						; size = 4
_ctrl$ = 8						; size = 4
?RemoveControl@C_Window@@QAEPAUControlListStr@@PAU2@@Z PROC ; C_Window::RemoveControl
; _this$ = ecx

; 994  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 995  : 	CONTROLLIST *retval;
; 996  : 	F4CSECTIONHANDLE* Leave;
; 997  : 
; 998  : 	if(!Controls_ || !ctrl)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4304], 0
	je	SHORT $LN10@RemoveCont
	cmp	DWORD PTR _ctrl$[ebp], 0
	jne	SHORT $LN11@RemoveCont
$LN10@RemoveCont:

; 999  : 		return(NULL);

	xor	eax, eax
	jmp	$LN12@RemoveCont
$LN11@RemoveCont:

; 1000 : 
; 1001 : 	Leave=UI_Enter(this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 1002 : 
; 1003 : 	if(CurControl_ == ctrl->Control_)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _ctrl$[ebp]
	mov	ecx, DWORD PTR [edx+4312]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN9@RemoveCont

; 1004 : 	{
; 1005 : 		CurControl_->Refresh();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4312]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4312]
	mov	eax, DWORD PTR [edx+160]
	call	eax

; 1006 : 		CurControl_=NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4312], 0

; 1007 : 		Handler_->RemovingControl(ctrl->Control_);

	mov	edx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4328]
	call	?RemovingControl@C_Handler@@QAEXPAVC_Base@@@Z ; C_Handler::RemovingControl
$LN9@RemoveCont:

; 1008 : 	}
; 1009 : 	if(Last_ == ctrl)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4308]
	cmp	eax, DWORD PTR _ctrl$[ebp]
	jne	SHORT $LN8@RemoveCont

; 1010 : 		Last_=Last_->Prev;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4308]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4308], ecx
$LN8@RemoveCont:

; 1011 : 	if(ctrl == Controls_)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _ctrl$[ebp]
	cmp	eax, DWORD PTR [edx+4304]
	jne	SHORT $LN7@RemoveCont

; 1012 : 	{
; 1013 : 		Controls_=Controls_->Next;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4304]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+4304], ecx

; 1014 : 		if(Controls_)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4304], 0
	je	SHORT $LN6@RemoveCont

; 1015 : 			Controls_->Prev=NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4304]
	mov	DWORD PTR [ecx+4], 0
$LN6@RemoveCont:

; 1016 : 	}
; 1017 : 	else

	jmp	SHORT $LN5@RemoveCont
$LN7@RemoveCont:

; 1018 : 	{
; 1019 : 		if(ctrl->Prev)

	mov	edx, DWORD PTR _ctrl$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $LN4@RemoveCont

; 1020 : 			ctrl->Prev->Next=ctrl->Next;

	mov	eax, DWORD PTR _ctrl$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
$LN4@RemoveCont:

; 1021 : 		if(ctrl->Next)

	mov	ecx, DWORD PTR _ctrl$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN5@RemoveCont

; 1022 : 			ctrl->Next->Prev=ctrl->Prev;

	mov	edx, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
$LN5@RemoveCont:

; 1023 : 	}
; 1024 : 	if(ctrl->Control_->GetID() > 0)

	mov	eax, DWORD PTR _ctrl$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	test	eax, eax
	jle	SHORT $LN2@RemoveCont

; 1025 : 		Hash_->Remove(ctrl->Control_->GetID());

	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4300]
	call	?Remove@C_Hash@@QAEXJ@Z			; C_Hash::Remove
$LN2@RemoveCont:

; 1026 : 	if(ctrl->Control_->GetFlags() & C_BIT_REMOVE)

	mov	eax, DWORD PTR _ctrl$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetFlags@C_Base@@QAEJXZ		; C_Base::GetFlags
	and	eax, 67108864				; 04000000H
	je	SHORT $LN1@RemoveCont

; 1027 : 	{
; 1028 : 		ctrl->Control_->Cleanup();

	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+176]
	call	eax

; 1029 : 		delete ctrl->Control_;

	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T3[ebp], eax
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN14@RemoveCont
	push	1
	mov	ecx, DWORD PTR $T3[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv169[ebp], eax
	jmp	SHORT $LN1@RemoveCont
$LN14@RemoveCont:
	mov	DWORD PTR tv169[ebp], 0
$LN1@RemoveCont:

; 1030 : 	}
; 1031 : 	retval=ctrl->Next;

	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _retval$[ebp], edx

; 1032 : 	delete ctrl;

	mov	eax, DWORD PTR _ctrl$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1033 : 
; 1034 : 	UI_Leave(Leave);

	mov	edx, DWORD PTR _Leave$[ebp]
	push	edx
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4

; 1035 : 	return(retval);

	mov	eax, DWORD PTR _retval$[ebp]
$LN12@RemoveCont:

; 1036 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveControl@C_Window@@QAEPAUControlListStr@@PAU2@@Z ENDP ; C_Window::RemoveControl
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_Leave$ = -12						; size = 4
_this$ = -8						; size = 4
_cur$ = -4						; size = 4
_ID$ = 8						; size = 4
?RemoveControl@C_Window@@QAEXJ@Z PROC			; C_Window::RemoveControl
; _this$ = ecx

; 969  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 970  : 	CONTROLLIST *cur;
; 971  : 	F4CSECTIONHANDLE* Leave;
; 972  : 
; 973  : 	if(Controls_ == NULL || ID == C_DONT_CARE)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4304], 0
	je	SHORT $LN5@RemoveCont
	cmp	DWORD PTR _ID$[ebp], -2			; fffffffeH
	jne	SHORT $LN6@RemoveCont
$LN5@RemoveCont:

; 974  : 		return;

	jmp	SHORT $LN7@RemoveCont
$LN6@RemoveCont:

; 975  : 
; 976  : 	Leave=UI_Enter(this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 977  : 	cur=Controls_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4304]
	mov	DWORD PTR _cur$[ebp], eax
$LN4@RemoveCont:

; 978  : 
; 979  : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN3@RemoveCont

; 980  : 	{
; 981  : 		if(cur->Control_->GetID() == ID)

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	cmp	eax, DWORD PTR _ID$[ebp]
	jne	SHORT $LN2@RemoveCont

; 982  : 		{
; 983  : 			RemoveControl(cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveControl@C_Window@@QAEPAUControlListStr@@PAU2@@Z ; C_Window::RemoveControl

; 984  : 			cur=NULL;

	mov	DWORD PTR _cur$[ebp], 0

; 985  : 		}
; 986  : 		else

	jmp	SHORT $LN1@RemoveCont
$LN2@RemoveCont:

; 987  : 			cur=cur->Next;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _cur$[ebp], ecx
$LN1@RemoveCont:

; 988  : 	}

	jmp	SHORT $LN4@RemoveCont
$LN3@RemoveCont:

; 989  : 	ScanClientAreas();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ScanClientAreas@C_Window@@QAEXXZ	; C_Window::ScanClientAreas

; 990  : 	UI_Leave(Leave);

	mov	edx, DWORD PTR _Leave$[ebp]
	push	edx
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4
$LN7@RemoveCont:

; 991  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveControl@C_Window@@QAEXJ@Z ENDP			; C_Window::RemoveControl
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_Leave$ = -16						; size = 4
$T1 = -12						; size = 4
_cnt$ = -8						; size = 4
_this$ = -4						; size = 4
_NewControl$ = 8					; size = 4
?AddControlTop@C_Window@@QAEXPAVC_Base@@@Z PROC		; C_Window::AddControlTop
; _this$ = ecx

; 858  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 859  : 	CONTROLLIST *cnt;
; 860  : 	F4CSECTIONHANDLE* Leave;
; 861  : 
; 862  : 	if(!NewControl)

	cmp	DWORD PTR _NewControl$[ebp], 0
	jne	SHORT $LN9@AddControl

; 863  : 		return;

	jmp	$LN10@AddControl
$LN9@AddControl:

; 864  : 
; 865  : 	if(NewControl->GetID() > 0)

	mov	ecx, DWORD PTR _NewControl$[ebp]
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	test	eax, eax
	jle	SHORT $LN8@AddControl

; 866  : 		if(Hash_->Find(NewControl->GetID()))

	mov	ecx, DWORD PTR _NewControl$[ebp]
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4300]
	call	?Find@C_Hash@@QAEPAXJ@Z			; C_Hash::Find
	test	eax, eax
	je	SHORT $LN8@AddControl

; 867  : 			return;

	jmp	$LN10@AddControl
$LN8@AddControl:

; 868  : 
; 869  : 	#ifdef USE_SH_POOLS
; 870  : 	cnt = (CONTROLLIST *)MemAllocPtr(UI_Pools[UI_CONTROL_POOL],sizeof( CONTROLLIST ),FALSE);
; 871  : 	#else
; 872  : 	cnt=new CONTROLLIST;

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR _cnt$[ebp], ecx

; 873  : 	#endif
; 874  : 	cnt->Control_=NewControl;

	mov	edx, DWORD PTR _cnt$[ebp]
	mov	eax, DWORD PTR _NewControl$[ebp]
	mov	DWORD PTR [edx], eax

; 875  : 	cnt->Prev=NULL;

	mov	ecx, DWORD PTR _cnt$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 876  : 	cnt->Next=NULL;

	mov	edx, DWORD PTR _cnt$[ebp]
	mov	DWORD PTR [edx+8], 0

; 877  : 
; 878  : 	Leave=UI_Enter(this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 879  : 	if(!Controls_)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4304], 0
	jne	SHORT $LN6@AddControl

; 880  : 		Controls_=cnt;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _cnt$[ebp]
	mov	DWORD PTR [edx+4304], eax

; 881  : 	else

	jmp	SHORT $LN5@AddControl
$LN6@AddControl:

; 882  : 	{
; 883  : 		cnt->Next=Controls_;

	mov	ecx, DWORD PTR _cnt$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4304]
	mov	DWORD PTR [ecx+8], eax

; 884  : 		Controls_=cnt;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _cnt$[ebp]
	mov	DWORD PTR [ecx+4304], edx
$LN5@AddControl:

; 885  : 	}
; 886  : 	NewControl->SetParent(this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _NewControl$[ebp]
	call	?SetParent@C_Base@@QAEXPAVC_Window@@@Z	; C_Base::SetParent

; 887  : 	NewControl->SetSubParents(this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _NewControl$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _NewControl$[ebp]
	mov	edx, DWORD PTR [eax+172]
	call	edx

; 888  : 
; 889  : 	if(!(NewControl->GetFlags() & C_BIT_ABSOLUTE))

	mov	ecx, DWORD PTR _NewControl$[ebp]
	call	?GetFlags@C_Base@@QAEJXZ		; C_Base::GetFlags
	and	eax, 262144				; 00040000H
	jne	$LN4@AddControl

; 890  : 	{
; 891  : 		if(VScroll_[NewControl->GetClient()])

	mov	ecx, DWORD PTR _NewControl$[ebp]
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	cwde
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4+4228], 0
	je	SHORT $LN3@AddControl

; 892  : 		{
; 893  : 			VScroll_[NewControl->GetClient()]->SetVirtualH(NewControl->GetY()+NewControl->GetH());//+ClientArea_[NewControl->GetClient()].top);

	mov	ecx, DWORD PTR _NewControl$[ebp]
	call	?GetY@C_Base@@QAEJXZ			; C_Base::GetY
	mov	esi, eax
	mov	ecx, DWORD PTR _NewControl$[ebp]
	call	?GetH@C_Base@@QAEJXZ			; C_Base::GetH
	add	esi, eax
	push	esi
	mov	ecx, DWORD PTR _NewControl$[ebp]
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	movsx	edx, ax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+4228]
	call	?SetVirtualH@C_ScrollBar@@QAEXJ@Z	; C_ScrollBar::SetVirtualH
$LN3@AddControl:

; 894  : 		}
; 895  : 		if(HScroll_[NewControl->GetClient()])

	mov	ecx, DWORD PTR _NewControl$[ebp]
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	movsx	ecx, ax
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx*4+4260], 0
	je	SHORT $LN4@AddControl

; 896  : 		{
; 897  : 			HScroll_[NewControl->GetClient()]->SetVirtualW(NewControl->GetX()+NewControl->GetW());//+ClientArea_[NewControl->GetClient()].left);

	mov	ecx, DWORD PTR _NewControl$[ebp]
	call	?GetX@C_Base@@QAEJXZ			; C_Base::GetX
	mov	esi, eax
	mov	ecx, DWORD PTR _NewControl$[ebp]
	call	?GetW@C_Base@@QAEJXZ			; C_Base::GetW
	add	esi, eax
	push	esi
	mov	ecx, DWORD PTR _NewControl$[ebp]
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	cwde
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+4260]
	call	?SetVirtualW@C_ScrollBar@@QAEXJ@Z	; C_ScrollBar::SetVirtualW
$LN4@AddControl:

; 898  : 		}
; 899  : 	}
; 900  : 	if(NewControl->GetID() > 0)

	mov	ecx, DWORD PTR _NewControl$[ebp]
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	test	eax, eax
	jle	SHORT $LN1@AddControl

; 901  : 		Hash_->Add(NewControl->GetID(),cnt);

	mov	edx, DWORD PTR _cnt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _NewControl$[ebp]
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4300]
	call	?Add@C_Hash@@QAEXJPAX@Z			; C_Hash::Add
$LN1@AddControl:

; 902  : 
; 903  : 	UI_Leave(Leave);

	mov	ecx, DWORD PTR _Leave$[ebp]
	push	ecx
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4
$LN10@AddControl:

; 904  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?AddControlTop@C_Window@@QAEXPAVC_Base@@@Z ENDP		; C_Window::AddControlTop
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_Leave$ = -28						; size = 4
$T1 = -24						; size = 4
tv81 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_cnt$ = -8						; size = 4
_this$ = -4						; size = 4
_NewControl$ = 8					; size = 4
?AddControl@C_Window@@QAEXPAVC_Base@@@Z PROC		; C_Window::AddControl
; _this$ = ecx

; 907  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 	CONTROLLIST *cnt;
; 909  : 	F4CSECTIONHANDLE* Leave;
; 910  : 
; 911  : 	if(!NewControl)

	cmp	DWORD PTR _NewControl$[ebp], 0
	jne	SHORT $LN9@AddControl

; 912  : 		return;

	jmp	$LN10@AddControl
$LN9@AddControl:

; 913  : 
; 914  : 	//F4Assert(NewControl->GetID() >0 || NewControl->GetID() == C_DONT_CARE);
; 915  : 
; 916  : 	if(NewControl->GetID() > 0){

	mov	ecx, DWORD PTR _NewControl$[ebp]
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	test	eax, eax
	jle	SHORT $LN8@AddControl

; 917  : 	    if(Hash_->Find(NewControl->GetID())) {

	mov	ecx, DWORD PTR _NewControl$[ebp]
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4300]
	call	?Find@C_Hash@@QAEPAXJ@Z			; C_Hash::Find
	test	eax, eax
	je	SHORT $LN8@AddControl

; 918  : 			//MonoPrint ("Duplicate control ID %d\n", NewControl->GetID());
; 919  : 			delete NewControl;

	mov	ecx, DWORD PTR _NewControl$[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T3[ebp], edx
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN12@AddControl
	push	1
	mov	eax, DWORD PTR $T3[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv81[ebp], eax
	jmp	SHORT $LN13@AddControl
$LN12@AddControl:
	mov	DWORD PTR tv81[ebp], 0
$LN13@AddControl:

; 920  : 			return;

	jmp	$LN10@AddControl
$LN8@AddControl:

; 921  : 	    }
; 922  : 	}
; 923  : 
; 924  : 	#ifdef USE_SH_POOLS
; 925  : 	cnt = (CONTROLLIST *)MemAllocPtr(UI_Pools[UI_CONTROL_POOL],sizeof( CONTROLLIST ),FALSE);
; 926  : 	#else
; 927  : 	cnt=new CONTROLLIST;

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR _cnt$[ebp], ecx

; 928  : 	#endif
; 929  : 	cnt->Control_=NewControl;

	mov	edx, DWORD PTR _cnt$[ebp]
	mov	eax, DWORD PTR _NewControl$[ebp]
	mov	DWORD PTR [edx], eax

; 930  : 	cnt->Next=NULL;

	mov	ecx, DWORD PTR _cnt$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 931  : 
; 932  : 	Leave=UI_Enter(this);

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 933  : 	if(!Controls_)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4304], 0
	jne	SHORT $LN6@AddControl

; 934  : 	{
; 935  : 		Controls_=cnt;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _cnt$[ebp]
	mov	DWORD PTR [ecx+4304], edx

; 936  : 		Controls_->Prev=NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4304]
	mov	DWORD PTR [ecx+4], 0

; 937  : 		Last_=Controls_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4304]
	mov	DWORD PTR [edx+4308], ecx

; 938  : 	}
; 939  : 	else

	jmp	SHORT $LN5@AddControl
$LN6@AddControl:

; 940  : 	{
; 941  : 		Last_->Next=cnt;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4308]
	mov	ecx, DWORD PTR _cnt$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 942  : 		cnt->Prev=Last_;

	mov	edx, DWORD PTR _cnt$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4308]
	mov	DWORD PTR [edx+4], ecx

; 943  : 		Last_=cnt;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _cnt$[ebp]
	mov	DWORD PTR [edx+4308], eax
$LN5@AddControl:

; 944  : 	}
; 945  : 
; 946  : 	NewControl->SetParent(this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _NewControl$[ebp]
	call	?SetParent@C_Base@@QAEXPAVC_Window@@@Z	; C_Base::SetParent

; 947  : 	NewControl->SetSubParents(this);

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _NewControl$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _NewControl$[ebp]
	mov	eax, DWORD PTR [edx+172]
	call	eax

; 948  : 	ControlCount_++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+614]
	add	dx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+614], dx

; 949  : 
; 950  : 	if(!(NewControl->GetFlags() & C_BIT_ABSOLUTE))

	mov	ecx, DWORD PTR _NewControl$[ebp]
	call	?GetFlags@C_Base@@QAEJXZ		; C_Base::GetFlags
	and	eax, 262144				; 00040000H
	jne	$LN4@AddControl

; 951  : 	{
; 952  : 		if(VScroll_[NewControl->GetClient()])

	mov	ecx, DWORD PTR _NewControl$[ebp]
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	movsx	ecx, ax
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx*4+4228], 0
	je	SHORT $LN3@AddControl

; 953  : 		{
; 954  : 			VScroll_[NewControl->GetClient()]->SetVirtualH(NewControl->GetY()+NewControl->GetH());//+ClientArea_[NewControl->GetClient()].top);

	mov	ecx, DWORD PTR _NewControl$[ebp]
	call	?GetY@C_Base@@QAEJXZ			; C_Base::GetY
	mov	esi, eax
	mov	ecx, DWORD PTR _NewControl$[ebp]
	call	?GetH@C_Base@@QAEJXZ			; C_Base::GetH
	add	esi, eax
	push	esi
	mov	ecx, DWORD PTR _NewControl$[ebp]
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	cwde
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+4228]
	call	?SetVirtualH@C_ScrollBar@@QAEXJ@Z	; C_ScrollBar::SetVirtualH
$LN3@AddControl:

; 955  : 		}
; 956  : 		if(HScroll_[NewControl->GetClient()])

	mov	ecx, DWORD PTR _NewControl$[ebp]
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	movsx	edx, ax
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+edx*4+4260], 0
	je	SHORT $LN4@AddControl

; 957  : 		{
; 958  : 			HScroll_[NewControl->GetClient()]->SetVirtualW(NewControl->GetX()+NewControl->GetW());//+ClientArea_[NewControl->GetClient()].left);

	mov	ecx, DWORD PTR _NewControl$[ebp]
	call	?GetX@C_Base@@QAEJXZ			; C_Base::GetX
	mov	esi, eax
	mov	ecx, DWORD PTR _NewControl$[ebp]
	call	?GetW@C_Base@@QAEJXZ			; C_Base::GetW
	add	esi, eax
	push	esi
	mov	ecx, DWORD PTR _NewControl$[ebp]
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	movsx	ecx, ax
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+4260]
	call	?SetVirtualW@C_ScrollBar@@QAEXJ@Z	; C_ScrollBar::SetVirtualW
$LN4@AddControl:

; 959  : 		}
; 960  : 	}
; 961  : 	NewControl->Refresh();

	mov	eax, DWORD PTR _NewControl$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _NewControl$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax

; 962  : 	if(NewControl->GetID() > 0)

	mov	ecx, DWORD PTR _NewControl$[ebp]
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	test	eax, eax
	jle	SHORT $LN1@AddControl

; 963  : 		Hash_->Add(NewControl->GetID(),cnt);

	mov	ecx, DWORD PTR _cnt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _NewControl$[ebp]
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4300]
	call	?Add@C_Hash@@QAEXJPAX@Z			; C_Hash::Add
$LN1@AddControl:

; 964  : 
; 965  : 	UI_Leave(Leave);

	mov	eax, DWORD PTR _Leave$[ebp]
	push	eax
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4
$LN10@AddControl:

; 966  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?AddControl@C_Window@@QAEXPAVC_Base@@@Z ENDP		; C_Window::AddControl
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
tv71 = -8						; size = 4
_this$ = -4						; size = 4
_scroll$ = 8						; size = 4
?AddScrollBar@C_Window@@QAEXPAVC_ScrollBar@@@Z PROC	; C_Window::AddScrollBar
; _this$ = ecx

; 827  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 828  : 	switch(scroll->GetType())

	mov	ecx, DWORD PTR _scroll$[ebp]
	call	?GetType@C_Base@@QAEFXZ			; C_Base::GetType
	cwde
	mov	DWORD PTR tv71[ebp], eax
	cmp	DWORD PTR tv71[ebp], 62			; 0000003eH
	je	SHORT $LN2@AddScrollB
	cmp	DWORD PTR tv71[ebp], 63			; 0000003fH
	je	SHORT $LN1@AddScrollB
	jmp	SHORT $LN3@AddScrollB
$LN2@AddScrollB:

; 829  : 	{
; 830  : 		case C_TYPE_VERTICAL:
; 831  : 			VScroll_[scroll->GetClient()]=scroll;

	mov	ecx, DWORD PTR _scroll$[ebp]
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	movsx	ecx, ax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _scroll$[ebp]
	mov	DWORD PTR [edx+ecx*4+4228], eax

; 832  : 			break;

	jmp	SHORT $LN3@AddScrollB
$LN1@AddScrollB:

; 833  : 		case C_TYPE_HORIZONTAL:
; 834  : 			HScroll_[scroll->GetClient()]=scroll;

	mov	ecx, DWORD PTR _scroll$[ebp]
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	movsx	ecx, ax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _scroll$[ebp]
	mov	DWORD PTR [edx+ecx*4+4260], eax
$LN3@AddScrollB:

; 835  : 			break;
; 836  : 	}
; 837  : 	AddControl(scroll);

	mov	ecx, DWORD PTR _scroll$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddControl@C_Window@@QAEXPAVC_Base@@@Z	; C_Window::AddControl

; 838  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?AddScrollBar@C_Window@@QAEXPAVC_ScrollBar@@@Z ENDP	; C_Window::AddScrollBar
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_client$ = 8						; size = 4
?AdjustScrollbar@C_Window@@QAEXJ@Z PROC			; C_Window::AdjustScrollbar
; _this$ = ecx

; 841  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 842  : 	if(client < WIN_MAX_CLIENTS)

	cmp	DWORD PTR _client$[ebp], 8
	jge	$LN4@AdjustScro

; 843  : 	{
; 844  : 		if(HScroll_[client])

	mov	eax, DWORD PTR _client$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4+4260], 0
	je	SHORT $LN2@AdjustScro

; 845  : 		{
; 846  : 			HScroll_[client]->UpdatePosition();

	mov	edx, DWORD PTR _client$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+4260]
	call	?UpdatePosition@C_ScrollBar@@QAEXXZ	; C_ScrollBar::UpdatePosition

; 847  : 			HScroll_[client]->Refresh();

	mov	ecx, DWORD PTR _client$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+4260]
	mov	ecx, DWORD PTR _client$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4+4260]
	mov	edx, DWORD PTR [eax+160]
	call	edx
$LN2@AdjustScro:

; 848  : 		}
; 849  : 		if(VScroll_[client])

	mov	eax, DWORD PTR _client$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4+4228], 0
	je	SHORT $LN4@AdjustScro

; 850  : 		{
; 851  : 			VScroll_[client]->UpdatePosition();

	mov	edx, DWORD PTR _client$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+4228]
	call	?UpdatePosition@C_ScrollBar@@QAEXXZ	; C_ScrollBar::UpdatePosition

; 852  : 			VScroll_[client]->Refresh();

	mov	ecx, DWORD PTR _client$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+4228]
	mov	ecx, DWORD PTR _client$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4+4228]
	mov	edx, DWORD PTR [eax+160]
	call	edx
$LN4@AdjustScro:

; 853  : 		}
; 854  : 	}
; 855  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?AdjustScrollbar@C_Window@@QAEXJ@Z ENDP			; C_Window::AdjustScrollbar
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.h
;	COMDAT ?SetClientFlags@C_Window@@QAEXJJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_Client$ = 8						; size = 4
_flags$ = 12						; size = 4
?SetClientFlags@C_Window@@QAEXJJ@Z PROC			; C_Window::SetClientFlags, COMDAT
; _this$ = ecx

; 273  : 		void SetClientFlags(long Client,long flags) {  if(Client < WIN_MAX_CLIENTS) ClientFlags_[Client]=flags; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _Client$[ebp], 8
	jge	SHORT $LN2@SetClientF
	mov	eax, DWORD PTR _Client$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _flags$[ebp]
	mov	DWORD PTR [ecx+eax*4+72], edx
$LN2@SetClientF:
	mov	esp, ebp
	pop	ebp
	ret	8
?SetClientFlags@C_Window@@QAEXJJ@Z ENDP			; C_Window::SetClientFlags
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.h
;	COMDAT ?SetClientMenu@C_Window@@QAEXJJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_Client$ = 8						; size = 4
_ID$ = 12						; size = 4
?SetClientMenu@C_Window@@QAEXJJ@Z PROC			; C_Window::SetClientMenu, COMDAT
; _this$ = ecx

; 269  : 		void SetClientMenu(long Client,long ID) { if(Client < WIN_MAX_CLIENTS) ClientMenuID_[Client]=ID; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _Client$[ebp], 8
	jge	SHORT $LN2@SetClientM
	mov	eax, DWORD PTR _Client$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _ID$[ebp]
	mov	DWORD PTR [ecx+eax*4+40], edx
$LN2@SetClientM:
	mov	esp, ebp
	pop	ebp
	ret	8
?SetClientMenu@C_Window@@QAEXJJ@Z ENDP			; C_Window::SetClientMenu
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.h
;	COMDAT ?SetMenu@C_Window@@QAEXJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ID$ = 8						; size = 4
?SetMenu@C_Window@@QAEXJ@Z PROC				; C_Window::SetMenu, COMDAT
; _this$ = ecx

; 268  : 		void SetMenu(long ID) { MenuID_=ID; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _ID$[ebp]
	mov	DWORD PTR [eax+24], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetMenu@C_Window@@QAEXJ@Z ENDP				; C_Window::SetMenu
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flag$ = 8						; size = 4
?SetFlagBitOff@C_Window@@QAEXJ@Z PROC			; C_Window::SetFlagBitOff
; _this$ = ecx

; 243  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 244  : 	Flags_ &= (0xffffffff ^ flag);

	mov	eax, DWORD PTR _flag$[ebp]
	xor	eax, -1
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 245  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetFlagBitOff@C_Window@@QAEXJ@Z ENDP			; C_Window::SetFlagBitOff
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flag$ = 8						; size = 4
?SetFlagBitOn@C_Window@@QAEXJ@Z PROC			; C_Window::SetFlagBitOn
; _this$ = ecx

; 238  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 239  : 	Flags_ |= flag;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	or	ecx, DWORD PTR _flag$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 240  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetFlagBitOn@C_Window@@QAEXJ@Z ENDP			; C_Window::SetFlagBitOn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.h
;	COMDAT ?SetCursorID@C_Window@@QAEXJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ID$ = 8						; size = 4
?SetCursorID@C_Window@@QAEXJ@Z PROC			; C_Window::SetCursorID, COMDAT
; _this$ = ecx

; 262  : 		void SetCursorID(long ID) { if(ID < MAX_CURSORS) CursorID_=ID; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _ID$[ebp], 30			; 0000001eH
	jge	SHORT $LN2@SetCursorI
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _ID$[ebp]
	mov	DWORD PTR [eax+32], ecx
$LN2@SetCursorI:
	mov	esp, ebp
	pop	ebp
	ret	4
?SetCursorID@C_Window@@QAEXJ@Z ENDP			; C_Window::SetCursorID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_wintitle$ = -4						; size = 4
?Deactivate@C_Window@@QAEXXZ PROC			; C_Window::Deactivate
; _this$ = ecx

; 2543 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2544 : 	C_Base *wintitle;
; 2545 : 
; 2546 : 	wintitle=FindControl(WINDOW_TITLE_BAR);

	push	67676767				; 0408aa5fH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _wintitle$[ebp], eax

; 2547 : 	if(wintitle)

	cmp	DWORD PTR _wintitle$[ebp], 0
	je	SHORT $LN2@Deactivate

; 2548 : 	{
; 2549 : 		wintitle->SetState(0);

	push	0
	mov	eax, DWORD PTR _wintitle$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _wintitle$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 2550 : 		wintitle->Refresh();

	mov	ecx, DWORD PTR _wintitle$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _wintitle$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN2@Deactivate:

; 2551 : 	}
; 2552 : 
; 2553 : 	if(CurControl_)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4312], 0
	je	SHORT $LN3@Deactivate

; 2554 : 		CurControl_->Deactivate();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4312]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4312]
	mov	eax, DWORD PTR [edx+188]
	call	eax
$LN3@Deactivate:

; 2555 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Deactivate@C_Window@@QAEXXZ ENDP			; C_Window::Deactivate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_wintitle$ = -4						; size = 4
?Activate@C_Window@@QAEXXZ PROC				; C_Window::Activate
; _this$ = ecx

; 2528 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2529 : 	C_Base *wintitle;
; 2530 : 
; 2531 : 	wintitle=FindControl(WINDOW_TITLE_BAR);

	push	67676767				; 0408aa5fH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindControl@C_Window@@QAEPAVC_Base@@J@Z ; C_Window::FindControl
	mov	DWORD PTR _wintitle$[ebp], eax

; 2532 : 	if(wintitle)

	cmp	DWORD PTR _wintitle$[ebp], 0
	je	SHORT $LN2@Activate

; 2533 : 	{
; 2534 : 		wintitle->SetState(1);

	push	1
	mov	eax, DWORD PTR _wintitle$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _wintitle$[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax

; 2535 : 		wintitle->Refresh();

	mov	ecx, DWORD PTR _wintitle$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _wintitle$[ebp]
	mov	eax, DWORD PTR [edx+160]
	call	eax
$LN2@Activate:

; 2536 : 	}
; 2537 : 
; 2538 : 	if(CurControl_)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4312], 0
	je	SHORT $LN3@Activate

; 2539 : 		CurControl_->Activate();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4312]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4312]
	mov	eax, DWORD PTR [edx+184]
	call	eax
$LN3@Activate:

; 2540 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Activate@C_Window@@QAEXXZ ENDP				; C_Window::Activate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DeactivateControl@C_Window@@QAEXXZ PROC		; C_Window::DeactivateControl
; _this$ = ecx

; 2375 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2376 : 	if(CurControl_)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4312], 0
	je	SHORT $LN2@Deactivate

; 2377 : 	{
; 2378 : 		CurControl_->Deactivate();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4312]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4312]
	mov	eax, DWORD PTR [edx+188]
	call	eax

; 2379 : 		CurControl_=NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4312], 0
$LN2@Deactivate:

; 2380 : 	}
; 2381 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DeactivateControl@C_Window@@QAEXXZ ENDP		; C_Window::DeactivateControl
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flag$ = 8						; size = 4
?SetFlags@C_Window@@QAEXJ@Z PROC			; C_Window::SetFlags
; _this$ = ecx

; 233  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 234  : 	Flags_=flag;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _flag$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 235  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetFlags@C_Window@@QAEXJ@Z ENDP			; C_Window::SetFlags
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.h
;	COMDAT ?SetVirtual@C_Window@@QAEXJJJJF@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_w$ = 16						; size = 4
_h$ = 20						; size = 4
_ID$ = 24						; size = 2
?SetVirtual@C_Window@@QAEXJJJJF@Z PROC			; C_Window::SetVirtual, COMDAT
; _this$ = ecx

; 253  : 		void SetVirtual(long x,long y,long w,long h,short ID) { if(ID >= WIN_MAX_CLIENTS) return; VX_[ID]=-x;VY_[ID]=-y;VW_[ID]=w;VH_[ID]=h;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	movsx	eax, WORD PTR _ID$[ebp]
	cmp	eax, 8
	jl	SHORT $LN1@SetVirtual
	jmp	SHORT $LN2@SetVirtual
$LN1@SetVirtual:
	mov	ecx, DWORD PTR _x$[ebp]
	neg	ecx
	movsx	edx, WORD PTR _ID$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx*4+480], ecx
	mov	ecx, DWORD PTR _y$[ebp]
	neg	ecx
	movsx	edx, WORD PTR _ID$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx*4+512], ecx
	movsx	ecx, WORD PTR _ID$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _w$[ebp]
	mov	DWORD PTR [edx+ecx*4+544], eax
	movsx	ecx, WORD PTR _ID$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _h$[ebp]
	mov	DWORD PTR [edx+ecx*4+576], eax
$LN2@SetVirtual:
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?SetVirtual@C_Window@@QAEXJJJJF@Z ENDP			; C_Window::SetVirtual
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.h
;	COMDAT ?SetClientArea@C_Window@@QAEXJJJJF@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_w$ = 16						; size = 4
_h$ = 20						; size = 4
_ID$ = 24						; size = 2
?SetClientArea@C_Window@@QAEXJJJJF@Z PROC		; C_Window::SetClientArea, COMDAT
; _this$ = ecx

; 252  : 		void SetClientArea(long x,long y,long w,long h,short ID) { if(ID >= WIN_MAX_CLIENTS) return; ClientArea_[ID].left=x; ClientArea_[ID].top=y; ClientArea_[ID].right=x+w; ClientArea_[ID].bottom=y+h; VX_[ID]=x; VY_[ID]=y; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	movsx	eax, WORD PTR _ID$[ebp]
	cmp	eax, 8
	jl	SHORT $LN1@SetClientA
	jmp	SHORT $LN2@SetClientA
$LN1@SetClientA:
	movsx	ecx, WORD PTR _ID$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR [edx+ecx+168], eax
	movsx	ecx, WORD PTR _ID$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _y$[ebp]
	mov	DWORD PTR [edx+ecx+172], eax
	mov	ecx, DWORD PTR _x$[ebp]
	add	ecx, DWORD PTR _w$[ebp]
	movsx	edx, WORD PTR _ID$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+176], ecx
	mov	ecx, DWORD PTR _y$[ebp]
	add	ecx, DWORD PTR _h$[ebp]
	movsx	edx, WORD PTR _ID$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx+180], ecx
	movsx	ecx, WORD PTR _ID$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR [edx+ecx*4+480], eax
	movsx	ecx, WORD PTR _ID$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _y$[ebp]
	mov	DWORD PTR [edx+ecx*4+512], eax
$LN2@SetClientA:
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?SetClientArea@C_Window@@QAEXJJJJF@Z ENDP		; C_Window::SetClientArea
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = -4						; size = 2
?ScanClientAreas@C_Window@@QAEXXZ PROC			; C_Window::ScanClientAreas
; _this$ = ecx

; 429  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 430  : 	short i;
; 431  : 
; 432  : 	for(i=0;i<WIN_MAX_CLIENTS;i++)

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN3@ScanClient
$LN2@ScanClient:
	mov	cx, WORD PTR _i$[ebp]
	add	cx, 1
	mov	WORD PTR _i$[ebp], cx
$LN3@ScanClient:
	movsx	edx, WORD PTR _i$[ebp]
	cmp	edx, 8
	jge	SHORT $LN4@ScanClient

; 433  : 		ScanClientArea(i);

	movsx	eax, WORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ScanClientArea@C_Window@@QAEXJ@Z	; C_Window::ScanClientArea
	jmp	SHORT $LN2@ScanClient
$LN4@ScanClient:

; 434  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ScanClientAreas@C_Window@@QAEXXZ ENDP			; C_Window::ScanClientAreas
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_cur$ = -8						; size = 4
_this$ = -4						; size = 4
_client$ = 8						; size = 4
?ScanClientArea@C_Window@@QAEXJ@Z PROC			; C_Window::ScanClientArea
; _this$ = ecx

; 355  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 356  : 	CONTROLLIST *cur;
; 357  : 
; 358  : 	if(client >= WIN_MAX_CLIENTS)

	cmp	DWORD PTR _client$[ebp], 8
	jl	SHORT $LN19@ScanClient

; 359  : 		return;

	jmp	$LN20@ScanClient
$LN19@ScanClient:

; 360  : 
; 361  : 	if(!VScroll_[client] && !HScroll_[client])

	mov	eax, DWORD PTR _client$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4+4228], 0
	jne	SHORT $LN18@ScanClient
	mov	edx, DWORD PTR _client$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+edx*4+4260], 0
	jne	SHORT $LN18@ScanClient

; 362  : 		return;

	jmp	$LN20@ScanClient
$LN18@ScanClient:

; 363  : 
; 364  : 	VW_[client]=0;

	mov	ecx, DWORD PTR _client$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+544], 0

; 365  : 	VH_[client]=0;

	mov	eax, DWORD PTR _client$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+576], 0

; 366  : 
; 367  : 	cur=Controls_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4304]
	mov	DWORD PTR _cur$[ebp], eax
$LN17@ScanClient:

; 368  : 
; 369  : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	$LN16@ScanClient

; 370  : 	{
; 371  : 		if(cur->Control_ && !(cur->Control_->GetFlags() & C_BIT_ABSOLUTE) && !(cur->Control_->GetFlags() & C_BIT_INVISIBLE) && cur->Control_->GetClient() == client)

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	$LN15@ScanClient
	mov	edx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetFlags@C_Base@@QAEJXZ		; C_Base::GetFlags
	and	eax, 262144				; 00040000H
	jne	$LN15@ScanClient
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetFlags@C_Base@@QAEJXZ		; C_Base::GetFlags
	and	eax, 8192				; 00002000H
	jne	$LN15@ScanClient
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetClient@C_Base@@QAEFXZ		; C_Base::GetClient
	movsx	edx, ax
	cmp	edx, DWORD PTR _client$[ebp]
	jne	$LN15@ScanClient

; 372  : 		{
; 373  : 			if((cur->Control_->GetX()+cur->Control_->GetW()) > VW_[client])

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetX@C_Base@@QAEJXZ			; C_Base::GetX
	mov	esi, eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetW@C_Base@@QAEJXZ			; C_Base::GetW
	add	esi, eax
	mov	edx, DWORD PTR _client$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	esi, DWORD PTR [eax+edx*4+544]
	jle	SHORT $LN14@ScanClient

; 374  : 				VW_[client]=cur->Control_->GetX()+cur->Control_->GetW();

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetX@C_Base@@QAEJXZ			; C_Base::GetX
	mov	esi, eax
	mov	edx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetW@C_Base@@QAEJXZ			; C_Base::GetW
	add	esi, eax
	mov	eax, DWORD PTR _client$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+544], esi
$LN14@ScanClient:

; 375  : 			if((cur->Control_->GetY()+cur->Control_->GetH()) > VH_[client])

	mov	edx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetY@C_Base@@QAEJXZ			; C_Base::GetY
	mov	esi, eax
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetH@C_Base@@QAEJXZ			; C_Base::GetH
	add	esi, eax
	mov	ecx, DWORD PTR _client$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	cmp	esi, DWORD PTR [edx+ecx*4+576]
	jle	SHORT $LN15@ScanClient

; 376  : 				VH_[client]=cur->Control_->GetY()+cur->Control_->GetH();

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetY@C_Base@@QAEJXZ			; C_Base::GetY
	mov	esi, eax
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetH@C_Base@@QAEJXZ			; C_Base::GetH
	add	esi, eax
	mov	edx, DWORD PTR _client$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx*4+576], esi
$LN15@ScanClient:

; 377  : 		}
; 378  : 		cur=cur->Next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _cur$[ebp], edx

; 379  : 	}

	jmp	$LN17@ScanClient
$LN16@ScanClient:

; 380  : 	if(HScroll_[client])

	mov	eax, DWORD PTR _client$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4+4260], 0
	je	$LN12@ScanClient

; 381  : 	{
; 382  : 		HScroll_[client]->ClearVW();

	mov	edx, DWORD PTR _client$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+4260]
	call	?ClearVW@C_ScrollBar@@QAEXXZ		; C_ScrollBar::ClearVW

; 383  : 		HScroll_[client]->SetVirtualW(VW_[client]);

	mov	ecx, DWORD PTR _client$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+544]
	push	eax
	mov	ecx, DWORD PTR _client$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+4260]
	call	?SetVirtualW@C_ScrollBar@@QAEXJ@Z	; C_ScrollBar::SetVirtualW

; 384  : 		if(VW_[client] > (ClientArea_[client].right - ClientArea_[client].left))

	mov	eax, DWORD PTR _client$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _client$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+eax+176]
	sub	eax, DWORD PTR [esi+ecx+168]
	mov	ecx, DWORD PTR _client$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx*4+544], eax
	jle	SHORT $LN11@ScanClient

; 385  : 		{
; 386  : 			if(VX_[client] < -(VW_[client]-ClientArea_[client].right))

	mov	eax, DWORD PTR _client$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _client$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+544]
	sub	ecx, DWORD PTR [esi+eax+176]
	neg	ecx
	mov	edx, DWORD PTR _client$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+edx*4+480], ecx
	jge	SHORT $LN10@ScanClient

; 387  : 				VX_[client]=-(VW_[client]-ClientArea_[client].right);

	mov	ecx, DWORD PTR _client$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _client$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+edx*4+544]
	sub	edx, DWORD PTR [esi+ecx+176]
	neg	edx
	mov	eax, DWORD PTR _client$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+480], edx
$LN10@ScanClient:

; 388  : 		}
; 389  : 		else

	jmp	SHORT $LN9@ScanClient
$LN11@ScanClient:

; 390  : 			VX_[client]=ClientArea_[client].left;

	mov	edx, DWORD PTR _client$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _client$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [esi+edx+168]
	mov	DWORD PTR [ecx+eax*4+480], edx
$LN9@ScanClient:

; 391  : 		HScroll_[client]->UpdatePosition();

	mov	eax, DWORD PTR _client$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+4260]
	call	?UpdatePosition@C_ScrollBar@@QAEXXZ	; C_ScrollBar::UpdatePosition

; 392  : 		if(VW_[client] > (ClientArea_[client].right - ClientArea_[client].left))

	mov	edx, DWORD PTR _client$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _client$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+edx+176]
	sub	edx, DWORD PTR [esi+eax+168]
	mov	eax, DWORD PTR _client$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4+544], edx
	jle	SHORT $LN8@ScanClient

; 393  : 		{
; 394  : 			HScroll_[client]->SetFlagBitOff(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	mov	edx, DWORD PTR _client$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+4260]
	mov	edx, DWORD PTR _client$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+edx*4+4260]
	mov	edx, DWORD PTR [esi+12]
	call	edx

; 395  : 			HScroll_[client]->Refresh();

	mov	eax, DWORD PTR _client$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+4260]
	mov	eax, DWORD PTR _client$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4+4260]
	mov	eax, DWORD PTR [edx+160]
	call	eax

; 396  : 		}
; 397  : 		else

	jmp	SHORT $LN12@ScanClient
$LN8@ScanClient:

; 398  : 		{
; 399  : 			HScroll_[client]->Refresh();

	mov	ecx, DWORD PTR _client$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+4260]
	mov	ecx, DWORD PTR _client$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4+4260]
	mov	edx, DWORD PTR [eax+160]
	call	edx

; 400  : 			HScroll_[client]->SetFlagBitOn(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	mov	eax, DWORD PTR _client$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+4260]
	mov	eax, DWORD PTR _client$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4+4260]
	mov	eax, DWORD PTR [edx+8]
	call	eax
$LN12@ScanClient:

; 401  : 		}
; 402  : 	}
; 403  : 	if(VScroll_[client])

	mov	ecx, DWORD PTR _client$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx*4+4228], 0
	je	$LN20@ScanClient

; 404  : 	{
; 405  : 		VScroll_[client]->ClearVH();

	mov	eax, DWORD PTR _client$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4+4228]
	call	?ClearVH@C_ScrollBar@@QAEXXZ		; C_ScrollBar::ClearVH

; 406  : 		VScroll_[client]->SetVirtualH(VH_[client]);

	mov	edx, DWORD PTR _client$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+576]
	push	ecx
	mov	edx, DWORD PTR _client$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+4228]
	call	?SetVirtualH@C_ScrollBar@@QAEXJ@Z	; C_ScrollBar::SetVirtualH

; 407  : 		if(VH_[client] > (ClientArea_[client].bottom - ClientArea_[client].top))

	mov	ecx, DWORD PTR _client$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _client$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+180]
	sub	ecx, DWORD PTR [esi+edx+172]
	mov	edx, DWORD PTR _client$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+edx*4+576], ecx
	jle	SHORT $LN5@ScanClient

; 408  : 		{
; 409  : 			if(VY_[client] < -(VH_[client]-ClientArea_[client].bottom))

	mov	ecx, DWORD PTR _client$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _client$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+edx*4+576]
	sub	edx, DWORD PTR [esi+ecx+180]
	neg	edx
	mov	eax, DWORD PTR _client$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4+512], edx
	jge	SHORT $LN4@ScanClient

; 410  : 				VY_[client]=-(VH_[client]-ClientArea_[client].bottom);

	mov	edx, DWORD PTR _client$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _client$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+576]
	sub	eax, DWORD PTR [esi+edx+180]
	neg	eax
	mov	ecx, DWORD PTR _client$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+512], eax
$LN4@ScanClient:

; 411  : 		}
; 412  : 		else

	jmp	SHORT $LN3@ScanClient
$LN5@ScanClient:

; 413  : 			VY_[client]=ClientArea_[client].top;

	mov	eax, DWORD PTR _client$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _client$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [esi+eax+172]
	mov	DWORD PTR [edx+ecx*4+512], eax
$LN3@ScanClient:

; 414  : 		VScroll_[client]->UpdatePosition();

	mov	ecx, DWORD PTR _client$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+4228]
	call	?UpdatePosition@C_ScrollBar@@QAEXXZ	; C_ScrollBar::UpdatePosition

; 415  : 		if(VH_[client] > (ClientArea_[client].bottom - ClientArea_[client].top))

	mov	eax, DWORD PTR _client$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _client$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+eax+180]
	sub	eax, DWORD PTR [esi+ecx+172]
	mov	ecx, DWORD PTR _client$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx*4+576], eax
	jle	SHORT $LN2@ScanClient

; 416  : 		{
; 417  : 			VScroll_[client]->SetFlagBitOff(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	mov	eax, DWORD PTR _client$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+4228]
	mov	eax, DWORD PTR _client$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4+4228]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 418  : 			VScroll_[client]->Refresh();

	mov	ecx, DWORD PTR _client$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+4228]
	mov	ecx, DWORD PTR _client$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4+4228]
	mov	edx, DWORD PTR [eax+160]
	call	edx

; 419  : 		}
; 420  : 		else

	jmp	SHORT $LN20@ScanClient
$LN2@ScanClient:

; 421  : 		{
; 422  : 			VScroll_[client]->Refresh();

	mov	eax, DWORD PTR _client$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+4228]
	mov	eax, DWORD PTR _client$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+eax*4+4228]
	mov	eax, DWORD PTR [edx+160]
	call	eax

; 423  : 			VScroll_[client]->SetFlagBitOn(C_BIT_INVISIBLE);

	push	8192					; 00002000H
	mov	ecx, DWORD PTR _client$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+4228]
	mov	ecx, DWORD PTR _client$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4+4228]
	mov	edx, DWORD PTR [eax+8]
	call	edx
$LN20@ScanClient:

; 424  : 		}
; 425  : 	}
; 426  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?ScanClientArea@C_Window@@QAEXJ@Z ENDP			; C_Window::ScanClientArea
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.h
;	COMDAT ?SetDragH@C_Window@@QAEXF@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_h$ = 8							; size = 2
?SetDragH@C_Window@@QAEXF@Z PROC			; C_Window::SetDragH, COMDAT
; _this$ = ecx

; 246  : 		void SetDragH(short h) { DragH_=h; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _h$[ebp]
	mov	WORD PTR [eax+452], cx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetDragH@C_Window@@QAEXF@Z ENDP			; C_Window::SetDragH
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.h
;	COMDAT ?SetDepth@C_Window@@QAEXF@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newdepth$ = 8						; size = 2
?SetDepth@C_Window@@QAEXF@Z PROC			; C_Window::SetDepth, COMDAT
; _this$ = ecx

; 245  : 		void SetDepth(short newdepth) { Depth_=newdepth; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _newdepth$[ebp]
	mov	WORD PTR [eax+426], cx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetDepth@C_Window@@QAEXF@Z ENDP			; C_Window::SetDepth
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x1$ = 8						; size = 2
_y1$ = 12						; size = 2
_x2$ = 16						; size = 2
_y2$ = 20						; size = 2
_w$ = 24						; size = 2
_h$ = 28						; size = 2
?SetRanges@C_Window@@QAEXFFFFFF@Z PROC			; C_Window::SetRanges
; _this$ = ecx

; 345  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 346  : 	MinX_=x1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _x1$[ebp]
	mov	WORD PTR [eax+436], cx

; 347  : 	MinY_=y1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR _y1$[ebp]
	mov	WORD PTR [edx+438], ax

; 348  : 	MaxX_=x2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR _x2$[ebp]
	mov	WORD PTR [ecx+440], dx

; 349  : 	MaxY_=y2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _y2$[ebp]
	mov	WORD PTR [eax+442], cx

; 350  : 	MinW_=w;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR _w$[ebp]
	mov	WORD PTR [edx+444], ax

; 351  : 	MinH_=h;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR _h$[ebp]
	mov	WORD PTR [ecx+446], dx

; 352  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?SetRanges@C_Window@@QAEXFFFFFF@Z ENDP			; C_Window::SetRanges
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_Leave$ = -8						; size = 4
_this$ = -4						; size = 4
_NewH$ = 8						; size = 2
?SetH@C_Window@@QAEXF@Z PROC				; C_Window::SetH
; _this$ = ecx

; 310  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 311  : 	F4CSECTIONHANDLE* Leave;
; 312  : 	if(NewH < MinH_)

	movsx	eax, WORD PTR _NewH$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+446]
	cmp	eax, edx
	jge	SHORT $LN2@SetH

; 313  : 		NewH=MinH_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+446]
	mov	WORD PTR _NewH$[ebp], cx
$LN2@SetH:

; 314  : 	if(NewH > MaxH_)

	movsx	edx, WORD PTR _NewH$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+450]
	cmp	edx, ecx
	jle	SHORT $LN1@SetH

; 315  : 		NewH=MaxH_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+450]
	mov	WORD PTR _NewH$[ebp], ax
$LN1@SetH:

; 316  : 
; 317  : 	Leave=UI_Enter(this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 318  : 	h_=NewH;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR _NewH$[ebp]
	mov	WORD PTR [edx+434], ax

; 319  : 	UI_Leave(Leave);

	mov	ecx, DWORD PTR _Leave$[ebp]
	push	ecx
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4

; 320  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetH@C_Window@@QAEXF@Z ENDP				; C_Window::SetH
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_Leave$ = -8						; size = 4
_this$ = -4						; size = 4
_NewW$ = 8						; size = 2
?SetW@C_Window@@QAEXF@Z PROC				; C_Window::SetW
; _this$ = ecx

; 297  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 298  : 	F4CSECTIONHANDLE* Leave;
; 299  : 	if(NewW < MinW_)

	movsx	eax, WORD PTR _NewW$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+444]
	cmp	eax, edx
	jge	SHORT $LN2@SetW

; 300  : 		NewW=MinW_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+444]
	mov	WORD PTR _NewW$[ebp], cx
$LN2@SetW:

; 301  : 	if(NewW > MaxW_)

	movsx	edx, WORD PTR _NewW$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+448]
	cmp	edx, ecx
	jle	SHORT $LN1@SetW

; 302  : 		NewW=MaxW_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+448]
	mov	WORD PTR _NewW$[ebp], ax
$LN1@SetW:

; 303  : 
; 304  : 	Leave=UI_Enter(this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 305  : 	w_=NewW;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR _NewW$[ebp]
	mov	WORD PTR [edx+432], ax

; 306  : 	UI_Leave(Leave);

	mov	ecx, DWORD PTR _Leave$[ebp]
	push	ecx
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4

; 307  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetW@C_Window@@QAEXF@Z ENDP				; C_Window::SetW
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_NewX$ = 8						; size = 2
_NewY$ = 12						; size = 2
?SetXY@C_Window@@QAEXFF@Z PROC				; C_Window::SetXY
; _this$ = ecx

; 278  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 279  : 	SetX(NewX);

	movzx	eax, WORD PTR _NewX$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetX@C_Window@@QAEXF@Z			; C_Window::SetX

; 280  : 	SetY(NewY);

	movzx	ecx, WORD PTR _NewY$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetY@C_Window@@QAEXF@Z			; C_Window::SetY

; 281  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetXY@C_Window@@QAEXFF@Z ENDP				; C_Window::SetXY
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_Leave$ = -8						; size = 4
_this$ = -4						; size = 4
_NewY$ = 8						; size = 2
?SetY@C_Window@@QAEXF@Z PROC				; C_Window::SetY
; _this$ = ecx

; 323  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 324  : 	F4CSECTIONHANDLE* Leave;
; 325  : 	if(NewY < MinY_)

	movsx	eax, WORD PTR _NewY$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+438]
	cmp	eax, edx
	jge	SHORT $LN2@SetY

; 326  : 		NewY=MinY_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+438]
	mov	WORD PTR _NewY$[ebp], cx
$LN2@SetY:

; 327  : 	if(NewY > MaxY_)

	movsx	edx, WORD PTR _NewY$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+442]
	cmp	edx, ecx
	jle	SHORT $LN1@SetY

; 328  : 		NewY=MaxY_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+442]
	mov	WORD PTR _NewY$[ebp], ax
$LN1@SetY:

; 329  : 
; 330  : 	Leave=UI_Enter(this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 331  : 	y_=NewY;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR _NewY$[ebp]
	mov	WORD PTR [edx+430], ax

; 332  : 	UI_Leave(Leave);

	mov	ecx, DWORD PTR _Leave$[ebp]
	push	ecx
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4

; 333  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetY@C_Window@@QAEXF@Z ENDP				; C_Window::SetY
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_Leave$ = -8						; size = 4
_this$ = -4						; size = 4
_NewX$ = 8						; size = 2
?SetX@C_Window@@QAEXF@Z PROC				; C_Window::SetX
; _this$ = ecx

; 284  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 285  : 	F4CSECTIONHANDLE* Leave;
; 286  : 	if(NewX < MinX_)

	movsx	eax, WORD PTR _NewX$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+436]
	cmp	eax, edx
	jge	SHORT $LN2@SetX

; 287  : 		NewX=MinX_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+436]
	mov	WORD PTR _NewX$[ebp], cx
$LN2@SetX:

; 288  : 	if(NewX > MaxX_)

	movsx	edx, WORD PTR _NewX$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+440]
	cmp	edx, ecx
	jle	SHORT $LN1@SetX

; 289  : 		NewX=MaxX_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+440]
	mov	WORD PTR _NewX$[ebp], ax
$LN1@SetX:

; 290  : 
; 291  : 	Leave=UI_Enter(this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ; UI_Enter
	add	esp, 4
	mov	DWORD PTR _Leave$[ebp], eax

; 292  : 	x_=NewX;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR _NewX$[ebp]
	mov	WORD PTR [edx+428], ax

; 293  : 	UI_Leave(Leave);

	mov	ecx, DWORD PTR _Leave$[ebp]
	push	ecx
	call	?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z	; UI_Leave
	add	esp, 4

; 294  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetX@C_Window@@QAEXF@Z ENDP				; C_Window::SetX
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_w$ = 8							; size = 2
_h$ = 12						; size = 2
?ResizeSurface@C_Window@@QAEXFF@Z PROC			; C_Window::ResizeSurface
; _this$ = ecx

; 223  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 224  : 	Width_=w;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _w$[ebp]
	mov	WORD PTR [eax+608], cx

; 225  : 	Height_=h;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR _h$[ebp]
	mov	WORD PTR [edx+610], ax

; 226  : 	MaxW_=w;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR _w$[ebp]
	mov	WORD PTR [ecx+448], dx

; 227  : 	MaxH_=h;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _h$[ebp]
	mov	WORD PTR [eax+450], cx

; 228  : 	w_=w;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR _w$[ebp]
	mov	WORD PTR [edx+432], ax

; 229  : 	h_=h;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR _h$[ebp]
	mov	WORD PTR [ecx+434], dx

; 230  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ResizeSurface@C_Window@@QAEXFF@Z ENDP			; C_Window::ResizeSurface
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
$T2 = -44						; size = 4
tv152 = -40						; size = 4
$T3 = -36						; size = 4
tv161 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
_this$ = -20						; size = 4
_i$ = -16						; size = 2
__$EHRec$ = -12						; size = 12
_wID$ = 8						; size = 4
_Type$ = 12						; size = 2
_w$ = 16						; size = 2
_h$ = 20						; size = 2
?Setup@C_Window@@QAEXJFFF@Z PROC			; C_Window::Setup
; _this$ = ecx

; 163  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Setup@C_Window@@QAEXJFFF@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 164  : 	short i;
; 165  : 
; 166  : 	if(w < 1)

	movsx	eax, WORD PTR _w$[ebp]
	cmp	eax, 1
	jge	SHORT $LN6@Setup

; 167  : 		w=1;

	mov	ecx, 1
	mov	WORD PTR _w$[ebp], cx
$LN6@Setup:

; 168  : 	if(h < 1)

	movsx	edx, WORD PTR _h$[ebp]
	cmp	edx, 1
	jge	SHORT $LN5@Setup

; 169  : 		h=1;

	mov	eax, 1
	mov	WORD PTR _h$[ebp], ax
$LN5@Setup:

; 170  : 
; 171  : 	imgBuf_=gMainHandler->GetFront();

	mov	ecx, DWORD PTR ?gMainHandler@@3PAVC_Handler@@A ; gMainHandler
	call	?GetFront@C_Handler@@QAEPAVImageBuffer@@XZ ; C_Handler::GetFront
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4292], eax

; 172  : 
; 173  : 	SetDefaultFlags();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDefaultFlags@C_Window@@QAEXXZ	; C_Window::SetDefaultFlags

; 174  : 	Type_=Type;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR _Type$[ebp]
	mov	WORD PTR [edx+424], ax

; 175  : 	ID_=wID;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _wID$[ebp]
	mov	DWORD PTR [ecx], edx

; 176  : 	Width_=w;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _w$[ebp]
	mov	WORD PTR [eax+608], cx

; 177  : 	Height_=h;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR _h$[ebp]
	mov	WORD PTR [edx+610], ax

; 178  : 	x_=0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+428], cx

; 179  : 	y_=0;

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+430], ax

; 180  : 	w_=Width_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+608]
	mov	WORD PTR [edx+432], cx

; 181  : 	h_=Height_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+610]
	mov	WORD PTR [edx+434], cx

; 182  : 	MinX_=0;

	xor	edx, edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+436], dx

; 183  : 	MaxX_=800;

	mov	ecx, 800				; 00000320H
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+440], cx

; 184  : 	MinY_=0;

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+438], ax

; 185  : 	MaxY_=600;

	mov	edx, 600				; 00000258H
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+442], dx

; 186  : 	MinW_=w_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+432]
	mov	WORD PTR [ecx+444], ax

; 187  : 	MinH_=h_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+434]
	mov	WORD PTR [ecx+446], ax

; 188  : 	MaxW_=w_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+432]
	mov	WORD PTR [ecx+448], ax

; 189  : 	MaxH_=h_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+434]
	mov	WORD PTR [ecx+450], ax

; 190  : 	Area_.left=0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+112], 0

; 191  : 	Area_.top=0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+116], 0

; 192  : 	Area_.right=w_;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+432]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+120], ecx

; 193  : 	Area_.bottom=h_;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+434]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+124], ecx

; 194  : 	Handler_=NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4328], 0

; 195  : 	DragCallback_=NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4316], 0

; 196  : 	SetXY(0,0);

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetXY@C_Window@@QAEXFF@Z		; C_Window::SetXY

; 197  : 
; 198  : 	if(Hash_)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4300], 0
	je	SHORT $LN4@Setup

; 199  : 	{
; 200  : 		Hash_->Cleanup();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4300]
	call	?Cleanup@C_Hash@@QAEXXZ			; C_Hash::Cleanup

; 201  : 		delete Hash_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4300]
	mov	DWORD PTR $T3[ebp], edx
	mov	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR $T5[ebp], eax
	cmp	DWORD PTR $T5[ebp], 0
	je	SHORT $LN9@Setup
	push	1
	mov	ecx, DWORD PTR $T5[ebp]
	call	??_GC_Hash@@QAEPAXI@Z
	mov	DWORD PTR tv152[ebp], eax
	jmp	SHORT $LN4@Setup
$LN9@Setup:
	mov	DWORD PTR tv152[ebp], 0
$LN4@Setup:

; 202  : 	}
; 203  : 	Hash_=new C_Hash;

	push	20					; 00000014H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN11@Setup
	mov	ecx, DWORD PTR $T4[ebp]
	call	??0C_Hash@@QAE@XZ			; C_Hash::C_Hash
	mov	DWORD PTR tv161[ebp], eax
	jmp	SHORT $LN12@Setup
$LN11@Setup:
	mov	DWORD PTR tv161[ebp], 0
$LN12@Setup:
	mov	ecx, DWORD PTR tv161[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR [edx+4300], eax

; 204  : 	Hash_->Setup(WIN_HASH_SIZE);

	push	50					; 00000032H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4300]
	call	?Setup@C_Hash@@QAEXJ@Z			; C_Hash::Setup

; 205  : 
; 206  : 	for(i=0;i<WIN_MAX_CLIENTS;i++)

	xor	edx, edx
	mov	WORD PTR _i$[ebp], dx
	jmp	SHORT $LN3@Setup
$LN2@Setup:
	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN3@Setup:
	movsx	ecx, WORD PTR _i$[ebp]
	cmp	ecx, 8
	jge	$LN1@Setup

; 207  : 	{
; 208  : 		VScroll_[i]=NULL;

	movsx	edx, WORD PTR _i$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx*4+4228], 0

; 209  : 		HScroll_[i]=NULL;

	movsx	ecx, WORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+4260], 0

; 210  : 		FullClientArea_[i]=Area_;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 112				; 00000070H
	movsx	ecx, WORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+296]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 211  : 		ClientArea_[i]=Area_;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	movsx	edx, WORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [eax+edx+168]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx

; 212  : 		SetVirtual(ClientArea_[i].left,ClientArea_[i].top,ClientArea_[i].right-ClientArea_[i].left,ClientArea_[i].bottom-ClientArea_[i].top,i);

	movzx	edx, WORD PTR _i$[ebp]
	push	edx
	movsx	eax, WORD PTR _i$[ebp]
	shl	eax, 4
	movsx	ecx, WORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+eax+180]
	sub	eax, DWORD PTR [esi+ecx+172]
	push	eax
	movsx	ecx, WORD PTR _i$[ebp]
	shl	ecx, 4
	movsx	edx, WORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+176]
	sub	ecx, DWORD PTR [esi+edx+168]
	push	ecx
	movsx	edx, WORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+172]
	push	ecx
	movsx	edx, WORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+168]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetVirtual@C_Window@@QAEXJJJJF@Z	; C_Window::SetVirtual

; 213  : 	}

	jmp	$LN2@Setup
$LN1@Setup:

; 214  : 	CurControl_=NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4312], 0

; 215  : 	Font_=1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+108], 1

; 216  : 
; 217  : 	GetScreenFormat();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetScreenFormat@C_Window@@AAEXXZ	; C_Window::GetScreenFormat

; 218  : 
; 219  : 	rectcount_=0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+1016], cx

; 220  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?Setup@C_Window@@QAEXJFFF@Z$0:
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?Setup@C_Window@@QAEXJFFF@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Setup@C_Window@@QAEXJFFF@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Setup@C_Window@@QAEXJFFF@Z ENDP			; C_Window::Setup
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.h
;	COMDAT ?GetCritical@C_Window@@QAEPAUF4CSECTIONHANDLE@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCritical@C_Window@@QAEPAUF4CSECTIONHANDLE@@XZ PROC	; C_Window::GetCritical, COMDAT
; _this$ = ecx

; 233  : 		F4CSECTIONHANDLE* GetCritical() { return(Critical); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4320]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCritical@C_Window@@QAEPAUF4CSECTIONHANDLE@@XZ ENDP	; C_Window::GetCritical
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0C_Window@@QAE@XZ PROC				; C_Window::C_Window
; _this$ = ecx

; 124  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 125  : 	Critical=NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4320], 0

; 126  : 	Handler_=NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4328], 0

; 127  : 	ControlCount_=0;

	xor	edx, edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+614], dx

; 128  : 	Controls_=NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4304], 0

; 129  : 	CurControl_=NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4312], 0

; 130  : 	BgColor_=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+164], 0

; 131  : 	MinX_=0;MinY_=0;MaxX_=0;MaxY_=0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+436], cx
	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+438], ax
	xor	edx, edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+440], dx
	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+442], cx

; 132  : 	DragH_=0;

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+452], ax

; 133  : 	update_ = C_DRAW_NOTHING;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+104], 0

; 134  : 	Flags_=C_BIT_NOTHING;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 135  : 	Group_=0; // Nothing

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 136  : 	DefaultFlags_=C_BIT_REMOVE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 67108864		; 04000000H

; 137  : 	memset(ClientMenuID_,0,sizeof(long)*WIN_MAX_CLIENTS);

	push	32					; 00000020H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 138  : 	memset(ClientFlags_,C_BIT_ENABLED,sizeof(long)*WIN_MAX_CLIENTS);

	push	32					; 00000020H
	push	2048					; 00000800H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 139  : 	Depth_=10;

	mov	edx, 10					; 0000000aH
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+426], dx

; 140  : 	Font_=1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+108], 1

; 141  : 	CursorID_=0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], 0

; 142  : 	MenuID_=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0

; 143  : 	MenuFlags_=0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+36], 0

; 144  : 	BorderLite=0xeeeeee;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+128], 15658734		; 00eeeeeeH

; 145  : 	BorderMedium=0x777777;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+132], 7829367		; 00777777H

; 146  : 	BorderDark=0x222222;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+136], 2236962		; 00222222H

; 147  : 	BGColor=0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+140], 0

; 148  : 	SelectBG=0xbbbbbb;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+144], 12303291		; 00bbbbbbH

; 149  : 	NormalText=0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+148], 0

; 150  : 	ReverseText=0xcccccc;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+152], 13421772		; 00ccccccH

; 151  : 	DisabledText=0x888888;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+156], 8947848		; 00888888H

; 152  : 	TextColor_=0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+160], 0

; 153  : 	BgColor_=0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+164], 0

; 154  : 	DragCallback_=NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4316], 0

; 155  : 	KBCallback_=NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4324], 0

; 156  : 	Owner_=NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4296], 0

; 157  : 	Hash_=NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4300], 0

; 158  : 	Section_ = 0; // JPO initialise

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 159  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0C_Window@@QAE@XZ ENDP				; C_Window::C_Window
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -44						; size = 4
_dest$ = -40						; size = 4
_c$1 = -36						; size = 4
tv93 = -32						; size = 4
tv90 = -28						; size = 4
_addpos$ = -24						; size = 4
_w$ = -20						; size = 4
_startpos$ = -16					; size = 4
_i$ = -12						; size = 4
_h$ = -8						; size = 4
_dptr$2 = -4						; size = 4
_surface$ = 8						; size = 4
_Color$ = 12						; size = 2
_rect$ = 16						; size = 4
?Fill@C_Window@@AAEXPAVSCREEN@@GPAUUI95_RECT@@@Z PROC	; C_Window::Fill
; _this$ = ecx

; 1762 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1763 : 	long startpos;
; 1764 : 	long w,h,addpos;
; 1765 : 	WORD *dest;
; 1766 : 	int i;
; 1767 : 
; 1768 : 	dest=surface->mem;

	mov	eax, DWORD PTR _surface$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _dest$[ebp], ecx

; 1769 : 	startpos=(rect->top * surface->width + rect->left);// << 1;

	mov	edx, DWORD PTR _surface$[ebp]
	movsx	eax, WORD PTR [edx+4]
	mov	ecx, DWORD PTR _rect$[ebp]
	imul	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _rect$[ebp]
	add	eax, DWORD PTR [edx]
	mov	DWORD PTR _startpos$[ebp], eax

; 1770 : 	w=rect->right - rect->left;

	mov	eax, DWORD PTR _rect$[ebp]
	mov	ecx, DWORD PTR _rect$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx]
	mov	DWORD PTR _w$[ebp], edx

; 1771 : 	h=rect->bottom-rect->top;

	mov	eax, DWORD PTR _rect$[ebp]
	mov	ecx, DWORD PTR _rect$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _h$[ebp], edx

; 1772 : 	addpos=(surface->width - w);// << 1;

	mov	eax, DWORD PTR _surface$[ebp]
	movsx	ecx, WORD PTR [eax+4]
	sub	ecx, DWORD PTR _w$[ebp]
	mov	DWORD PTR _addpos$[ebp], ecx

; 1773 : 
; 1774 : 	if(surface->bpp == 32 )//XX

	mov	edx, DWORD PTR _surface$[ebp]
	movzx	eax, BYTE PTR [edx+8]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN6@Fill

; 1775 : 	{
; 1776 : 		DWORD c = RGB565toRGB8( Color );

	movzx	ecx, WORD PTR _Color$[ebp]
	push	ecx
	call	?RGB565toRGB8@@YAKG@Z			; RGB565toRGB8
	add	esp, 4
	mov	DWORD PTR _c$1[ebp], eax

; 1777 : 		DWORD* dptr = ((DWORD*)surface->mem) + startpos;

	mov	edx, DWORD PTR _surface$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _startpos$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _dptr$2[ebp], edx
$LN5@Fill:

; 1778 : 		while(h--)

	mov	eax, DWORD PTR _h$[ebp]
	mov	DWORD PTR tv90[ebp], eax
	mov	ecx, DWORD PTR _h$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _h$[ebp], ecx
	cmp	DWORD PTR tv90[ebp], 0
	je	SHORT $LN4@Fill

; 1779 : {
; 1780 : 			i = w;

	mov	edx, DWORD PTR _w$[ebp]
	mov	DWORD PTR _i$[ebp], edx
$LN3@Fill:

; 1781 : 			while(i--)

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR tv93[ebp], eax
	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	cmp	DWORD PTR tv93[ebp], 0
	je	SHORT $LN2@Fill

; 1782 : 				*dptr++ = c;

	mov	edx, DWORD PTR _dptr$2[ebp]
	mov	eax, DWORD PTR _c$1[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _dptr$2[ebp]
	add	ecx, 4
	mov	DWORD PTR _dptr$2[ebp], ecx
	jmp	SHORT $LN3@Fill
$LN2@Fill:

; 1783 : 
; 1784 : 			dptr += addpos;

	mov	edx, DWORD PTR _addpos$[ebp]
	mov	eax, DWORD PTR _dptr$2[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dptr$2[ebp], ecx

; 1785 : 		}

	jmp	SHORT $LN5@Fill
$LN4@Fill:

; 1786 : 	}
; 1787 : 	else

	jmp	SHORT $LN7@Fill
$LN6@Fill:

; 1788 : 	{//WORD
; 1789 : 
; 1790 : 	__asm
; 1791 : 	{
; 1792 : 		mov ecx, h

	mov	ecx, DWORD PTR _h$[ebp]

; 1793 : 		mov edi, dest

	mov	edi, DWORD PTR _dest$[ebp]

; 1794 : 		add edi, startpos

	add	edi, DWORD PTR _startpos$[ebp]

; 1795 : 			add edi, startpos

	add	edi, DWORD PTR _startpos$[ebp]
$Loop1$9:

; 1796 : 	};
; 1797 : Loop1:
; 1798 : 	__asm
; 1799 : 	{
; 1800 : 		push ecx

	push	ecx

; 1801 : 		mov ecx, w

	mov	ecx, DWORD PTR _w$[ebp]

; 1802 : 			mov ax, Color

	mov	ax, WORD PTR _Color$[ebp]

; 1803 : 			rep stosw

	rep	 stosw

; 1804 : 			add edi, addpos

	add	edi, DWORD PTR _addpos$[ebp]

; 1805 : 		add edi, addpos

	add	edi, DWORD PTR _addpos$[ebp]

; 1806 : 		pop ecx

	pop	ecx

; 1807 : 		loop Loop1

	loop	$Loop1$9
$LN7@Fill:

; 1808 : 	};
; 1809 : }
; 1810 : }

	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Fill@C_Window@@AAEXPAVSCREEN@@GPAUUI95_RECT@@@Z ENDP	; C_Window::Fill
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_clipflag$ = -12					; size = 4
_i$ = -8						; size = 4
_this$ = -4						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_x2$ = 16						; size = 4
_y2$ = 20						; size = 4
?SetCheckedUpdateRect@C_Window@@AAEJJJJJ@Z PROC		; C_Window::SetCheckedUpdateRect
; _this$ = ecx

; 499  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 500  : 	long i,clipflag;
; 501  : 
; 502  : 	if(rectcount_ < WIN_MAX_RECTS)

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+1016]
	cmp	ecx, 200				; 000000c8H
	jge	$LN43@SetChecked

; 503  : 	{
; 504  : 		for(i=0;(i<rectcount_) && (x1 <= x2) && (y1 <= y2);i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN42@SetChecked
$LN41@SetChecked:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN42@SetChecked:
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+1016]
	cmp	DWORD PTR _i$[ebp], ecx
	jge	$LN40@SetChecked
	mov	edx, DWORD PTR _x1$[ebp]
	cmp	edx, DWORD PTR _x2$[ebp]
	jg	$LN40@SetChecked
	mov	eax, DWORD PTR _y1$[ebp]
	cmp	eax, DWORD PTR _y2$[ebp]
	jg	$LN40@SetChecked

; 505  : 		{
; 506  : 			if(rectflag_[i])

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+ecx*2+616]
	test	eax, eax
	je	$LN39@SetChecked

; 507  : 			{
; 508  : 				if(x1 >= rectlist_[i].right || x2 <= rectlist_[i].left || y1 >= rectlist_[i].bottom || y2 <= rectlist_[i].top)

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _x1$[ebp]
	cmp	eax, DWORD PTR [edx+ecx+1028]
	jge	SHORT $LN37@SetChecked
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _x2$[ebp]
	cmp	eax, DWORD PTR [edx+ecx+1020]
	jle	SHORT $LN37@SetChecked
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _y1$[ebp]
	cmp	eax, DWORD PTR [edx+ecx+1032]
	jge	SHORT $LN37@SetChecked
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _y2$[ebp]
	cmp	eax, DWORD PTR [edx+ecx+1024]
	jg	SHORT $LN38@SetChecked
$LN37@SetChecked:

; 509  : 				{ // rects don't intersect
; 510  : 					continue;

	jmp	$LN41@SetChecked

; 511  : 				}
; 512  : 				else

	jmp	$LN39@SetChecked
$LN38@SetChecked:

; 513  : 				{
; 514  : 					clipflag=0;

	mov	DWORD PTR _clipflag$[ebp], 0

; 515  : 					if(x1 >= rectlist_[i].left)

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _x1$[ebp]
	cmp	eax, DWORD PTR [edx+ecx+1020]
	jl	SHORT $LN35@SetChecked

; 516  : 						clipflag |= _CHR_CLIP_LEFT;

	mov	ecx, DWORD PTR _clipflag$[ebp]
	or	ecx, 1
	mov	DWORD PTR _clipflag$[ebp], ecx
$LN35@SetChecked:

; 517  : 					if(y1 >= rectlist_[i].top)

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _y1$[ebp]
	cmp	ecx, DWORD PTR [eax+edx+1024]
	jl	SHORT $LN34@SetChecked

; 518  : 						clipflag |= _CHR_CLIP_TOP;

	mov	edx, DWORD PTR _clipflag$[ebp]
	or	edx, 4
	mov	DWORD PTR _clipflag$[ebp], edx
$LN34@SetChecked:

; 519  : 					if(x2 <= rectlist_[i].right)

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _x2$[ebp]
	cmp	edx, DWORD PTR [ecx+eax+1028]
	jg	SHORT $LN33@SetChecked

; 520  : 						clipflag |= _CHR_CLIP_RIGHT;

	mov	eax, DWORD PTR _clipflag$[ebp]
	or	eax, 2
	mov	DWORD PTR _clipflag$[ebp], eax
$LN33@SetChecked:

; 521  : 					if(y2 <= rectlist_[i].bottom)

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _y2$[ebp]
	cmp	eax, DWORD PTR [edx+ecx+1032]
	jg	SHORT $LN32@SetChecked

; 522  : 						clipflag |= _CHR_CLIP_BOTTOM;

	mov	ecx, DWORD PTR _clipflag$[ebp]
	or	ecx, 8
	mov	DWORD PTR _clipflag$[ebp], ecx
$LN32@SetChecked:

; 523  : 					if(clipflag == (_CHR_CLIP_LEFT|_CHR_CLIP_TOP|_CHR_CLIP_RIGHT|_CHR_CLIP_BOTTOM))

	cmp	DWORD PTR _clipflag$[ebp], 15		; 0000000fH
	jne	SHORT $LN31@SetChecked

; 524  : 						return(0); // new rect is inside another rect

	xor	eax, eax
	jmp	$LN44@SetChecked
$LN31@SetChecked:

; 525  : 					if(!clipflag)

	cmp	DWORD PTR _clipflag$[ebp], 0
	jne	SHORT $LN30@SetChecked

; 526  : 						continue;

	jmp	$LN41@SetChecked
$LN30@SetChecked:

; 527  : 
; 528  : 					if(clipflag == (_CHR_CLIP_RIGHT|_CHR_CLIP_BOTTOM))

	cmp	DWORD PTR _clipflag$[ebp], 10		; 0000000aH
	jne	SHORT $LN29@SetChecked

; 529  : 					{ // case 1
; 530  : 						SetCheckedUpdateRect(x1,y1,rectlist_[i].left,y2);

	mov	edx, DWORD PTR _y2$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+1020]
	push	edx
	mov	eax, DWORD PTR _y1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x1$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCheckedUpdateRect@C_Window@@AAEJJJJJ@Z ; C_Window::SetCheckedUpdateRect

; 531  : 						x1=rectlist_[i].left;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+1020]
	mov	DWORD PTR _x1$[ebp], ecx

; 532  : 						y2=rectlist_[i].top;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+1024]
	mov	DWORD PTR _y2$[ebp], ecx
	jmp	$LN39@SetChecked
$LN29@SetChecked:

; 533  : 					}
; 534  : 					else if(clipflag == (_CHR_CLIP_LEFT|_CHR_CLIP_BOTTOM))

	cmp	DWORD PTR _clipflag$[ebp], 9
	jne	SHORT $LN27@SetChecked

; 535  : 					{ // case 2
; 536  : 						SetCheckedUpdateRect(x1,y1,x2,rectlist_[i].top);

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+1024]
	push	ecx
	mov	edx, DWORD PTR _x2$[ebp]
	push	edx
	mov	eax, DWORD PTR _y1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x1$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCheckedUpdateRect@C_Window@@AAEJJJJJ@Z ; C_Window::SetCheckedUpdateRect

; 537  : 						x1=rectlist_[i].right;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+1028]
	mov	DWORD PTR _x1$[ebp], ecx

; 538  : 						y1=rectlist_[i].top;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+1024]
	mov	DWORD PTR _y1$[ebp], ecx
	jmp	$LN39@SetChecked
$LN27@SetChecked:

; 539  : 					}
; 540  : 					else if(clipflag == (_CHR_CLIP_RIGHT|_CHR_CLIP_TOP))

	cmp	DWORD PTR _clipflag$[ebp], 6
	jne	SHORT $LN25@SetChecked

; 541  : 					{ // case 3
; 542  : 						SetCheckedUpdateRect(x1,y1,rectlist_[i].left,y2);

	mov	edx, DWORD PTR _y2$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+1020]
	push	edx
	mov	eax, DWORD PTR _y1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x1$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCheckedUpdateRect@C_Window@@AAEJJJJJ@Z ; C_Window::SetCheckedUpdateRect

; 543  : 						x1=rectlist_[i].left;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+1020]
	mov	DWORD PTR _x1$[ebp], ecx

; 544  : 						y1=rectlist_[i].bottom;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+1032]
	mov	DWORD PTR _y1$[ebp], ecx
	jmp	$LN39@SetChecked
$LN25@SetChecked:

; 545  : 					}
; 546  : 					else if(clipflag == (_CHR_CLIP_LEFT|_CHR_CLIP_TOP))

	cmp	DWORD PTR _clipflag$[ebp], 5
	jne	SHORT $LN23@SetChecked

; 547  : 					{ // case 4
; 548  : 						SetCheckedUpdateRect(x1,rectlist_[i].bottom,x2,y2);

	mov	edx, DWORD PTR _y2$[ebp]
	push	edx
	mov	eax, DWORD PTR _x2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx+1032]
	push	eax
	mov	ecx, DWORD PTR _x1$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCheckedUpdateRect@C_Window@@AAEJJJJJ@Z ; C_Window::SetCheckedUpdateRect

; 549  : 						x1=rectlist_[i].right;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+1028]
	mov	DWORD PTR _x1$[ebp], ecx

; 550  : 						y2=rectlist_[i].bottom;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+1032]
	mov	DWORD PTR _y2$[ebp], ecx
	jmp	$LN39@SetChecked
$LN23@SetChecked:

; 551  : 					}
; 552  : 					else if(clipflag == _CHR_CLIP_BOTTOM)

	cmp	DWORD PTR _clipflag$[ebp], 8
	jne	SHORT $LN21@SetChecked

; 553  : 					{ // case 5
; 554  : 						rectlist_[i].top=y2;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _y2$[ebp]
	mov	DWORD PTR [eax+edx+1024], ecx
	jmp	$LN39@SetChecked
$LN21@SetChecked:

; 555  : 					}
; 556  : 					else if(clipflag == _CHR_CLIP_RIGHT)

	cmp	DWORD PTR _clipflag$[ebp], 2
	jne	SHORT $LN19@SetChecked

; 557  : 					{ // case 6
; 558  : 						rectlist_[i].left=x2;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _x2$[ebp]
	mov	DWORD PTR [eax+edx+1020], ecx
	jmp	$LN39@SetChecked
$LN19@SetChecked:

; 559  : 					}
; 560  : 					else if(clipflag == _CHR_CLIP_TOP)

	cmp	DWORD PTR _clipflag$[ebp], 4
	jne	SHORT $LN17@SetChecked

; 561  : 					{ // case 7
; 562  : 						rectlist_[i].bottom=y1;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _y1$[ebp]
	mov	DWORD PTR [eax+edx+1032], ecx
	jmp	$LN39@SetChecked
$LN17@SetChecked:

; 563  : 					}
; 564  : 					else if(clipflag == _CHR_CLIP_LEFT)

	cmp	DWORD PTR _clipflag$[ebp], 1
	jne	SHORT $LN15@SetChecked

; 565  : 					{ // case 8
; 566  : 						rectlist_[i].right=x1;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _x1$[ebp]
	mov	DWORD PTR [eax+edx+1028], ecx
	jmp	$LN39@SetChecked
$LN15@SetChecked:

; 567  : 					}
; 568  : 					else if(clipflag == (_CHR_CLIP_LEFT|_CHR_CLIP_RIGHT|_CHR_CLIP_BOTTOM))

	cmp	DWORD PTR _clipflag$[ebp], 11		; 0000000bH
	jne	SHORT $LN13@SetChecked

; 569  : 					{ // case 9
; 570  : 						y2=rectlist_[i].top;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+1024]
	mov	DWORD PTR _y2$[ebp], ecx
	jmp	$LN39@SetChecked
$LN13@SetChecked:

; 571  : 					}
; 572  : 					else if(clipflag == (_CHR_CLIP_TOP|_CHR_CLIP_RIGHT|_CHR_CLIP_BOTTOM))

	cmp	DWORD PTR _clipflag$[ebp], 14		; 0000000eH
	jne	SHORT $LN11@SetChecked

; 573  : 					{ // case 10
; 574  : 						x2=rectlist_[i].left;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+1020]
	mov	DWORD PTR _x2$[ebp], ecx
	jmp	$LN39@SetChecked
$LN11@SetChecked:

; 575  : 					}
; 576  : 					else if(clipflag == (_CHR_CLIP_TOP|_CHR_CLIP_LEFT|_CHR_CLIP_RIGHT))

	cmp	DWORD PTR _clipflag$[ebp], 7
	jne	SHORT $LN9@SetChecked

; 577  : 					{ // case 11
; 578  : 						y1=rectlist_[i].bottom;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+1032]
	mov	DWORD PTR _y1$[ebp], ecx
	jmp	$LN39@SetChecked
$LN9@SetChecked:

; 579  : 					}
; 580  : 					else if(clipflag == (_CHR_CLIP_LEFT|_CHR_CLIP_TOP|_CHR_CLIP_BOTTOM))

	cmp	DWORD PTR _clipflag$[ebp], 13		; 0000000dH
	jne	SHORT $LN7@SetChecked

; 581  : 					{ // case 12
; 582  : 						x1=rectlist_[i].right;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+1028]
	mov	DWORD PTR _x1$[ebp], ecx
	jmp	SHORT $LN39@SetChecked
$LN7@SetChecked:

; 583  : 					}
; 584  : 					else if(clipflag == (_CHR_CLIP_TOP|_CHR_CLIP_BOTTOM))

	cmp	DWORD PTR _clipflag$[ebp], 12		; 0000000cH
	jne	SHORT $LN5@SetChecked

; 585  : 					{ // case 15
; 586  : 						SetCheckedUpdateRect(x1,y1,rectlist_[i].left,y2);

	mov	edx, DWORD PTR _y2$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax+1020]
	push	edx
	mov	eax, DWORD PTR _y1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x1$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCheckedUpdateRect@C_Window@@AAEJJJJJ@Z ; C_Window::SetCheckedUpdateRect

; 587  : 						x1=rectlist_[i].right;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+1028]
	mov	DWORD PTR _x1$[ebp], ecx
	jmp	SHORT $LN39@SetChecked
$LN5@SetChecked:

; 588  : 					}
; 589  : 					else if(clipflag == (_CHR_CLIP_LEFT|_CHR_CLIP_RIGHT))

	cmp	DWORD PTR _clipflag$[ebp], 3
	jne	SHORT $LN39@SetChecked

; 590  : 					{ // case 16
; 591  : 						SetCheckedUpdateRect(x1,y1,x2,rectlist_[i].top);

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+1024]
	push	ecx
	mov	edx, DWORD PTR _x2$[ebp]
	push	edx
	mov	eax, DWORD PTR _y1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x1$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCheckedUpdateRect@C_Window@@AAEJJJJJ@Z ; C_Window::SetCheckedUpdateRect

; 592  : 						y1=rectlist_[i].bottom;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx+1032]
	mov	DWORD PTR _y1$[ebp], ecx
$LN39@SetChecked:

; 593  : 					}
; 594  : 				}
; 595  : 			}
; 596  : 		}

	jmp	$LN41@SetChecked
$LN40@SetChecked:

; 597  : 		if(x1 < x2 && y1 < y2)

	mov	edx, DWORD PTR _x1$[ebp]
	cmp	edx, DWORD PTR _x2$[ebp]
	jge	SHORT $LN2@SetChecked
	mov	eax, DWORD PTR _y1$[ebp]
	cmp	eax, DWORD PTR _y2$[ebp]
	jge	SHORT $LN2@SetChecked

; 598  : 		{
; 599  : 			AddUpdateRect(x1,y1,x2,y2);

	mov	ecx, DWORD PTR _y2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _x2$[ebp]
	push	edx
	mov	eax, DWORD PTR _y1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x1$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddUpdateRect@C_Window@@QAEXJJJJ@Z	; C_Window::AddUpdateRect

; 600  : 			return(1);

	mov	eax, 1
	jmp	SHORT $LN44@SetChecked
$LN2@SetChecked:

; 601  : 		}
; 602  : 	}
; 603  : 	else

	jmp	SHORT $LN1@SetChecked
$LN43@SetChecked:

; 604  : 		return(-1);

	or	eax, -1
	jmp	SHORT $LN44@SetChecked
$LN1@SetChecked:

; 605  : 	return(0);

	xor	eax, eax
$LN44@SetChecked:

; 606  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?SetCheckedUpdateRect@C_Window@@AAEJJJJJ@Z ENDP		; C_Window::SetCheckedUpdateRect
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetScreenFormat@C_Window@@AAEXXZ PROC			; C_Window::GetScreenFormat
; _this$ = ecx

; 1367 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1368 : 	UI95_GetScreenColorInfo(r_mask_, r_shift_, g_mask_, g_shift_, b_mask_, b_shift_);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 476				; 000001dcH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 472				; 000001d8H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 468				; 000001d4H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 464				; 000001d0H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 460				; 000001ccH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 456				; 000001c8H
	push	edx
	call	?UI95_GetScreenColorInfo@@YAXAAKAAG0101@Z ; UI95_GetScreenColorInfo
	add	esp, 24					; 00000018H

; 1369 : //!	UI95_GetScreenColorInfo(&r_mask_,&r_shift_,&g_mask_,&g_shift_,&b_mask_,&b_shift_);
; 1370 : 	r_max_=static_cast<WORD>(r_mask_ >> r_shift_);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+460]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+456]
	shr	eax, cl
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+462], ax

; 1371 : 	g_max_=static_cast<WORD>(g_mask_ >> g_shift_);

	mov	edx, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [edx+468]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+464]
	shr	edx, cl
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+470], dx

; 1372 : 	b_max_=static_cast<WORD>(b_mask_ >> b_shift_);

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [ecx+476]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+472]
	shr	eax, cl
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+478], ax

; 1373 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetScreenFormat@C_Window@@AAEXXZ ENDP			; C_Window::GetScreenFormat
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_cur$ = -4						; size = 4
_cntrl$ = 8						; size = 4
?FindControlInList@C_Window@@AAEPAUControlListStr@@PAVC_Base@@@Z PROC ; C_Window::FindControlInList
; _this$ = ecx

; 1315 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1316 : 	CONTROLLIST *cur;
; 1317 : 
; 1318 : 	if(!cntrl) return(NULL);

	cmp	DWORD PTR _cntrl$[ebp], 0
	jne	SHORT $LN5@FindContro
	xor	eax, eax
	jmp	SHORT $LN6@FindContro
$LN5@FindContro:

; 1319 : 
; 1320 : 	if(cntrl->GetID() > 0)

	mov	ecx, DWORD PTR _cntrl$[ebp]
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	test	eax, eax
	jle	SHORT $LN4@FindContro

; 1321 : 		return((CONTROLLIST*)Hash_->Find(cntrl->GetID()));

	mov	ecx, DWORD PTR _cntrl$[ebp]
	call	?GetID@C_Base@@QAEJXZ			; C_Base::GetID
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4300]
	call	?Find@C_Hash@@QAEPAXJ@Z			; C_Hash::Find
	jmp	SHORT $LN6@FindContro
$LN4@FindContro:

; 1322 : 
; 1323 : 	cur=Controls_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4304]
	mov	DWORD PTR _cur$[ebp], edx
$LN3@FindContro:

; 1324 : 	while(cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $LN2@FindContro

; 1325 : 	{
; 1326 : 		if(cur->Control_ == cntrl)

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _cntrl$[ebp]
	jne	SHORT $LN1@FindContro

; 1327 : 			return(cur);

	mov	eax, DWORD PTR _cur$[ebp]
	jmp	SHORT $LN6@FindContro
$LN1@FindContro:

; 1328 : 		cur=cur->Next;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _cur$[ebp], eax

; 1329 : 	}

	jmp	SHORT $LN3@FindContro
$LN2@FindContro:

; 1330 : 	return(NULL);

	xor	eax, eax
$LN6@FindContro:

; 1331 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?FindControlInList@C_Window@@AAEPAUControlListStr@@PAVC_Base@@@Z ENDP ; C_Window::FindControlInList
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cscroll.h
;	COMDAT ?SetVirtualH@C_ScrollBar@@QAEXJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_h$ = 8							; size = 4
?SetVirtualH@C_ScrollBar@@QAEXJ@Z PROC			; C_ScrollBar::SetVirtualH, COMDAT
; _this$ = ecx

; 67   : 		void SetVirtualH(long h) { if(-h < VirtualH_) VirtualH_=-h; CalcRanges(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _h$[ebp]
	neg	eax
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [ecx+124]
	jge	SHORT $LN1@SetVirtual
	mov	edx, DWORD PTR _h$[ebp]
	neg	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+124], edx
$LN1@SetVirtual:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcRanges@C_ScrollBar@@AAEXXZ		; C_ScrollBar::CalcRanges
	mov	esp, ebp
	pop	ebp
	ret	4
?SetVirtualH@C_ScrollBar@@QAEXJ@Z ENDP			; C_ScrollBar::SetVirtualH
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cscroll.h
;	COMDAT ?SetVirtualW@C_ScrollBar@@QAEXJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_w$ = 8							; size = 4
?SetVirtualW@C_ScrollBar@@QAEXJ@Z PROC			; C_ScrollBar::SetVirtualW, COMDAT
; _this$ = ecx

; 66   : 		void SetVirtualW(long w) { if(-w < VirtualW_) VirtualW_=-w; CalcRanges(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _w$[ebp]
	neg	eax
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [ecx+120]
	jge	SHORT $LN1@SetVirtual
	mov	edx, DWORD PTR _w$[ebp]
	neg	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+120], edx
$LN1@SetVirtual:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcRanges@C_ScrollBar@@AAEXXZ		; C_ScrollBar::CalcRanges
	mov	esp, ebp
	pop	ebp
	ret	4
?SetVirtualW@C_ScrollBar@@QAEXJ@Z ENDP			; C_ScrollBar::SetVirtualW
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cscroll.h
;	COMDAT ?ClearVH@C_ScrollBar@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearVH@C_ScrollBar@@QAEXXZ PROC			; C_ScrollBar::ClearVH, COMDAT
; _this$ = ecx

; 64   : 		void ClearVH() { VirtualH_=-1; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+124], -1
	mov	esp, ebp
	pop	ebp
	ret	0
?ClearVH@C_ScrollBar@@QAEXXZ ENDP			; C_ScrollBar::ClearVH
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cscroll.h
;	COMDAT ?ClearVW@C_ScrollBar@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearVW@C_ScrollBar@@QAEXXZ PROC			; C_ScrollBar::ClearVW, COMDAT
; _this$ = ecx

; 63   : 		void ClearVW() { VirtualW_=-1; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+120], -1
	mov	esp, ebp
	pop	ebp
	ret	0
?ClearVW@C_ScrollBar@@QAEXXZ ENDP			; C_ScrollBar::ClearVW
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?GetH@C_Base@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetH@C_Base@@QAEJXZ PROC				; C_Base::GetH, COMDAT
; _this$ = ecx

; 144  : 		long GetH()					{ return(h_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+36]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetH@C_Base@@QAEJXZ ENDP				; C_Base::GetH
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?GetW@C_Base@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetW@C_Base@@QAEJXZ PROC				; C_Base::GetW, COMDAT
; _this$ = ecx

; 143  : 		long GetW()					{ return(w_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+32]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetW@C_Base@@QAEJXZ ENDP				; C_Base::GetW
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?GetY@C_Base@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetY@C_Base@@QAEJXZ PROC				; C_Base::GetY, COMDAT
; _this$ = ecx

; 142  : 		long GetY()					{ return(y_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+28]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetY@C_Base@@QAEJXZ ENDP				; C_Base::GetY
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?GetX@C_Base@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetX@C_Base@@QAEJXZ PROC				; C_Base::GetX, COMDAT
; _this$ = ecx

; 141  : 		long GetX()					{ return(x_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetX@C_Base@@QAEJXZ ENDP				; C_Base::GetX
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?GetClient@C_Base@@QAEFXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetClient@C_Base@@QAEFXZ PROC				; C_Base::GetClient, COMDAT
; _this$ = ecx

; 140  : 		short GetClient()			{ return(Client_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetClient@C_Base@@QAEFXZ ENDP				; C_Base::GetClient
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?GetFlags@C_Base@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFlags@C_Base@@QAEJXZ PROC				; C_Base::GetFlags, COMDAT
; _this$ = ecx

; 139  : 		long  GetFlags()			{ return(Flags_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetFlags@C_Base@@QAEJXZ ENDP				; C_Base::GetFlags
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?GetCluster@C_Base@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCluster@C_Base@@QAEJXZ PROC				; C_Base::GetCluster, COMDAT
; _this$ = ecx

; 138  : 		long  GetCluster()			{ return(Section_[_CLUSTER_]); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCluster@C_Base@@QAEJXZ ENDP				; C_Base::GetCluster
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?GetGroup@C_Base@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGroup@C_Base@@QAEJXZ PROC				; C_Base::GetGroup, COMDAT
; _this$ = ecx

; 137  : 		long  GetGroup()			{ return(Section_[_GROUP_]); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetGroup@C_Base@@QAEJXZ ENDP				; C_Base::GetGroup
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?GetType@C_Base@@QAEFXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetType@C_Base@@QAEFXZ PROC				; C_Base::GetType, COMDAT
; _this$ = ecx

; 135  : 		short GetType()				{ return(Type_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+22]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetType@C_Base@@QAEFXZ ENDP				; C_Base::GetType
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?GetID@C_Base@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetID@C_Base@@QAEJXZ PROC				; C_Base::GetID, COMDAT
; _this$ = ecx

; 134  : 		long  GetID()				{ return(ID_); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetID@C_Base@@QAEJXZ ENDP				; C_Base::GetID
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?SetParent@C_Base@@QAEXPAVC_Window@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_win$ = 8						; size = 4
?SetParent@C_Base@@QAEXPAVC_Window@@@Z PROC		; C_Base::SetParent, COMDAT
; _this$ = ecx

; 115  : 		void SetParent(C_Window *win)							{ Parent_=win; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _win$[ebp]
	mov	DWORD PTR [eax+48], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetParent@C_Base@@QAEXPAVC_Window@@@Z ENDP		; C_Base::SetParent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?DisableGroup@C_Base@@QAEXJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ID$ = 8						; size = 4
?DisableGroup@C_Base@@QAEXJ@Z PROC			; C_Base::DisableGroup, COMDAT
; _this$ = ecx

; 114  : 		void DisableGroup(long ID)								{ SetFlags(Flags_ | C_BIT_INVISIBLE); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	or	ecx, 8192				; 00002000H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	call	edx
	mov	esp, ebp
	pop	ebp
	ret	4
?DisableGroup@C_Base@@QAEXJ@Z ENDP			; C_Base::DisableGroup
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cbase.h
;	COMDAT ?EnableGroup@C_Base@@QAEXJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ID$ = 8						; size = 4
?EnableGroup@C_Base@@QAEXJ@Z PROC			; C_Base::EnableGroup, COMDAT
; _this$ = ecx

; 113  : 		void EnableGroup(long ID)								{ SetFlags(Flags_ & ~C_BIT_INVISIBLE); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, -8193				; ffffdfffH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	call	edx
	mov	esp, ebp
	pop	ebp
	ret	4
?EnableGroup@C_Base@@QAEXJ@Z ENDP			; C_Base::EnableGroup
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_Section$ = 8						; size = 4
?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z PROC		; UI_Leave

; 100  : {

	push	ebp
	mov	ebp, esp

; 101  : 	if(Section)

	cmp	DWORD PTR _Section$[ebp], 0
	je	SHORT $LN2@UI_Leave

; 102  : 		F4LeaveCriticalSection(Section);

	mov	eax, DWORD PTR _Section$[ebp]
	push	eax
	call	_F4LeaveCriticalSection
	add	esp, 4
$LN2@UI_Leave:

; 103  : }

	pop	ebp
	ret	0
?UI_Leave@@YAXPAUF4CSECTIONHANDLE@@@Z ENDP		; UI_Leave
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\ui95\cwindow.cpp
_TEXT	SEGMENT
_Parent$ = 8						; size = 4
?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z PROC	; UI_Enter

; 90   : {

	push	ebp
	mov	ebp, esp

; 91   : 	if(Parent && Parent->GetCritical())

	cmp	DWORD PTR _Parent$[ebp], 0
	je	SHORT $LN1@UI_Enter
	mov	ecx, DWORD PTR _Parent$[ebp]
	call	?GetCritical@C_Window@@QAEPAUF4CSECTIONHANDLE@@XZ ; C_Window::GetCritical
	test	eax, eax
	je	SHORT $LN1@UI_Enter

; 92   : 	{
; 93   : 		F4EnterCriticalSection(Parent->GetCritical());

	mov	ecx, DWORD PTR _Parent$[ebp]
	call	?GetCritical@C_Window@@QAEPAUF4CSECTIONHANDLE@@XZ ; C_Window::GetCritical
	push	eax
	call	_F4EnterCriticalSection
	add	esp, 4

; 94   : 		return(Parent->GetCritical());

	mov	ecx, DWORD PTR _Parent$[ebp]
	call	?GetCritical@C_Window@@QAEPAUF4CSECTIONHANDLE@@XZ ; C_Window::GetCritical
	jmp	SHORT $LN2@UI_Enter
$LN1@UI_Enter:

; 95   : 	}
; 96   : 	return(NULL);

	xor	eax, eax
$LN2@UI_Enter:

; 97   : }

	pop	ebp
	ret	0
?UI_Enter@@YAPAUF4CSECTIONHANDLE@@PAVC_Window@@@Z ENDP	; UI_Enter
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GC_Hash@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GC_Hash@@QAEPAXI@Z PROC				; C_Hash::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1C_Hash@@QAE@XZ			; C_Hash::~C_Hash
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GC_Hash@@QAEPAXI@Z ENDP				; C_Hash::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?FloatToInt32@@YAHM@Z PROC				; FloatToInt32

; 179  : {

	push	ebp
	mov	ebp, esp

; 180  : #if WIN32
; 181  :   __asm {
; 182  :     fld dword ptr [x];

	fld	DWORD PTR _x$[ebp]

; 183  :     fistp dword ptr [x];

	fistp	DWORD PTR _x$[ebp]

; 184  :     mov eax,dword ptr [x];

	mov	eax, DWORD PTR _x$[ebp]

; 185  :   }
; 186  : #else 
; 187  : 	return static_cast<int>(x);	
; 188  : #endif
; 189  : }

	pop	ebp
	ret	0
?FloatToInt32@@YAHM@Z ENDP				; FloatToInt32
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\mathlib\math.h
_TEXT	SEGMENT
_x$ = 8							; size = 4
?SqrtSSE@@YAMM@Z PROC					; SqrtSSE

; 91   : static inline float SqrtSSE(float x){ 

	push	ebp
	mov	ebp, esp

; 92   :     __asm 
; 93   :     { 
; 94   :         sqrtss xmm0,x 

	sqrtss	xmm0, DWORD PTR _x$[ebp]

; 95   :         movss x,xmm0 

	movss	XMMWORD PTR _x$[ebp], xmm0

; 96   :     } 
; 97   : 
; 98   :     return x; 

	fld	DWORD PTR _x$[ebp]

; 99   : } 

	pop	ebp
	ret	0
?SqrtSSE@@YAMM@Z ENDP					; SqrtSSE
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_System_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 641  : 		{	// make error_condition for error code (generic if possible)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 642  : 		if (_Syserror_map(_Errval))

	mov	eax, DWORD PTR __Errval$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@default_er

; 643  : 			return (error_condition(_Errval, generic_category()));

	call	?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@default_er

; 644  : 		else

	jmp	SHORT $LN3@default_er
$LN2@default_er:

; 645  : 			return (error_condition(_Errval, system_category()));

	call	?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
	push	eax
	mov	edx, DWORD PTR __Errval$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@default_er:

; 646  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 634  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 635  : 		const char *_Name = _Winerror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Winerror_map@std@@YAPBDH@Z		; std::_Winerror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 636  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 637  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 629  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 630  : 		return ("system");

	mov	eax, OFFSET ??_C@_06FHFOAHML@system?$AA@

; 631  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_System_error_category@std@@QAE@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT
; _this$ = ecx

; 624  : 	_System_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_System_error_category@std@@6B@

; 625  : 		{	// default constructor
; 626  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_System_error_category@std@@QAE@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iostream_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Iostream_error_category@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category@std@@UAE@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Iostream_error_category@std@@UAE@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT
; _this$ = ecx

; 611  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 612  : 		if (_Errcode == (int)io_errc::stream)

	cmp	DWORD PTR __Errcode$[ebp], 1
	jne	SHORT $LN2@message

; 613  : 			return ("iostream stream error");

	push	OFFSET ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@message

; 614  : 		else

	jmp	SHORT $LN3@message
$LN2@message:

; 615  : 			return (_Generic_error_category::message(_Errcode));

	mov	ecx, DWORD PTR __Errcode$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 616  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category@std@@UBEPBDXZ PROC	; std::_Iostream_error_category::name, COMDAT
; _this$ = ecx

; 606  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 607  : 		return ("iostream");

	mov	eax, OFFSET ??_C@_08LLGCOLLL@iostream?$AA@

; 608  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Iostream_error_category@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iostream_error_category@std@@QAE@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT
; _this$ = ecx

; 601  : 	_Iostream_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Generic_error_category@std@@QAE@XZ	; std::_Generic_error_category::_Generic_error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Iostream_error_category@std@@6B@

; 602  : 		{	// default constructor
; 603  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iostream_error_category@std@@QAE@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Generic_error_category@std@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv69 = -8						; size = 4
__Name$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 590  : 		{	// convert to name of error

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T1[ebp], 0

; 591  : 		const char *_Name = _Syserror_map(_Errcode);

	mov	eax, DWORD PTR __Errcode$[ebp]
	push	eax
	call	?_Syserror_map@std@@YAPBDH@Z		; std::_Syserror_map
	add	esp, 4
	mov	DWORD PTR __Name$[ebp], eax

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

	cmp	DWORD PTR __Name$[ebp], 0
	je	SHORT $LN3@message
	mov	ecx, DWORD PTR __Name$[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@message
$LN3@message:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
$LN4@message:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T1[ebp]
	or	eax, 1
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 593  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 585  : 		{	// get name of category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		return ("generic");

	mov	eax, OFFSET ??_C@_07DCLBNMLN@generic?$AA@

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Generic_error_category@std@@QAE@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT
; _this$ = ecx

; 580  : 	_Generic_error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0error_category@std@@QAE@XZ		; std::error_category::error_category
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7_Generic_error_category@std@@6B@

; 581  : 		{	// default constructor
; 582  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Generic_error_category@std@@QAE@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8error_condition@std@@QBE_NABV01@@Z PROC		; std::error_condition::operator==, COMDAT
; _this$ = ecx

; 376  : 		{	// test if *this == _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
	mov	ecx, eax
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?value@error_condition@std@@QBEHXZ	; std::error_condition::value
	cmp	esi, eax
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv78[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv78[ebp]

; 379  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??8error_condition@std@@QBE_NABV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 354  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 356  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 349  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 350  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 351  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 316  : 		{	// construct from error code and category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Cat$[ebp]
	mov	DWORD PTR [edx+4], eax

; 317  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 256  : 		{	// get category

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 257  : 		return (*_Mycat);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 258  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 251  : 		{	// get error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 		return (_Myval);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gerror_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gerror_category@std@@UAEPAXI@Z PROC			; std::error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1error_category@std@@UAE@XZ		; std::error_category::~error_category
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gerror_category@std@@UAEPAXI@Z ENDP			; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 184  : 		{	// compare categories for equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (this == &_Right);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv65[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv65[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv65[ebp]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 415  : 	{	// test if conditions same for this category

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

	mov	ecx, DWORD PTR __Code$[ebp]
	call	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8error_category@std@@QBE_NABV01@@Z	; std::error_category::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@equivalent
	mov	ecx, DWORD PTR __Code$[ebp]
	call	?value@error_code@std@@QBEHXZ		; std::error_code::value
	cmp	eax, DWORD PTR __Errval$[ebp]
	jne	SHORT $LN3@equivalent
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@equivalent
$LN3@equivalent:
	mov	DWORD PTR tv74[ebp], 0
$LN4@equivalent:
	mov	al, BYTE PTR tv74[ebp]

; 417  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 408  : 	{	// test if error code same condition

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 	return (default_error_condition(_Errval) == _Cond);

	mov	eax, DWORD PTR __Cond$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, eax
	call	??8error_condition@std@@QBE_NABV01@@Z	; std::error_condition::operator==

; 410  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 401  : 	{	// make error_condition for error code

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 	return (error_condition(_Errval, *this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Errval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 403  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 167  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0error_category@std@@QAE@XZ PROC			; std::error_category::error_category, COMDAT
; _this$ = ecx

; 162  : 	error_category()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7error_category@std@@6B@

; 163  : 		{	// default constructor
; 164  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0error_category@std@@QAE@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 679  : 	{	// get system_category

	push	ebp
	mov	ebp, esp

; 680  : 	return (_Error_objects<int>::_System_object);

	mov	eax, OFFSET ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 681  : 	}

	pop	ebp
	ret	0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 669  : 	{	// get generic_category

	push	ebp
	mov	ebp, esp

; 670  : 	return (_Error_objects<int>::_Generic_object);

	mov	eax, OFFSET ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 671  : 	}

	pop	ebp
	ret	0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 74   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 75   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2275 : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2276 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN2@Xran:

; 2277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2270 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2271 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 2272 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Ptr$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2253 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2254 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $LN4@Tidy
	jmp	SHORT $LN3@Tidy
$LN4@Tidy:

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Ptr$1[ebp], eax

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2260 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN1@Tidy

; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$1[ebp]
	push	ecx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Tidy:

; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __Ptr$1[ebp]
	push	edx
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN3@Tidy:

; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2266 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2267 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2237 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $LN2@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $LN4@Inside

; 2241 : 		else

	jmp	SHORT $LN4@Inside
$LN3@Inside:

; 2242 : 			return (true);

	mov	al, 1
$LN4@Inside:

; 2243 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2224 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN6@Grow

; 2225 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN6@Grow:

; 2226 : 		if (this->_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	jmp	SHORT $LN4@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $LN3@Grow
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN9@Grow
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Grow
$LN9@Grow:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR tv129[ebp], ecx
$LN10@Grow:
	mov	edx, DWORD PTR tv129[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	jmp	SHORT $LN4@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $LN4@Grow

; 2232 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN4@Grow:

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $LN11@Grow
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN12@Grow
$LN11@Grow:
	mov	DWORD PTR tv136[ebp], 0
$LN12@Grow:
	mov	al, BYTE PTR tv136[ebp]
$LN8@Grow:

; 2234 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T1[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+16], ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 2219 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
tv205 = -48						; size = 4
tv204 = -44						; size = 4
tv203 = -40						; size = 4
tv202 = -36						; size = 4
__Ptr$ = -32						; size = 4
__Newres$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 2184 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx
	jmp	SHORT $LN8@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	shr	ecx, 1
	cmp	ecx, eax
	ja	SHORT $LN7@Copy
	jmp	SHORT $LN8@Copy
$LN7@Copy:

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+20]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN5@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Newres$[ebp], eax

; 2191 : 		else

	jmp	SHORT $LN8@Copy
$LN5@Copy:

; 2192 : 			_Newres = max_size();	// settle for max_size()

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	DWORD PTR __Newres$[ebp], eax
$LN8@Copy:

; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	edx, DWORD PTR $T4[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv202[ebp], eax
	mov	eax, DWORD PTR __Newres$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR tv202[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv203[ebp], eax
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx
	jmp	SHORT $LN12@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2197 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], edx

; 2199 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR __Newres$[ebp]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR tv204[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR tv205[ebp], eax
	mov	edx, DWORD PTR tv205[ebp]
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $LN14@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2203 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 2204 : 			_CATCH_END

	mov	eax, $LN17@Copy
	ret	0
$LN14@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2
$LN17@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$2:

; 2205 : 		_CATCH_END

	mov	eax, $LN19@Copy
	ret	0
$LN12@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3
$LN19@Copy:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$3:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $LN1@Copy

; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements

	mov	eax, DWORD PTR __Oldlen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$LN1@Copy:

; 2210 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);

	lea	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>

; 2212 : 		this->_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2213 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN11@Copy:

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv75 = -12						; size = 4
__Num$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1737 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1738 : 		size_type _Num = this->_Getal().max_size();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $LN3@max_size
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv75[ebp], ecx
$LN4@max_size:
	mov	eax, DWORD PTR tv75[ebp]

; 1740 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1732 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1733 : 		return (this->_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 1734 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$1 = -12					; size = 4
__Ptr$2 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN4@erase

; 1319 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN4@erase:

; 1320 : 		if (this->_Mysize - _Off <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@erase

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	jmp	SHORT $LN2@erase
$LN3@erase:

; 1322 : 		else if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN2@erase

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Ptr$2[ebp], eax

; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$1[ebp], eax

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$2[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$2[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 1327 : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@erase:

; 1328 : 			}
; 1329 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@erase:

; 1330 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1309 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1310 : 		if (this->_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN1@erase

; 1311 : 			_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN1@erase:

; 1312 : 		_Eos(_Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1313 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@erase:

; 1314 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1142 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@assign

; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN3@assign
$LN2@assign:

; 1132 : 
; 1133 : 		if (_Grow(_Count))

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@assign

; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1136 : 			_Eos(_Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN1@assign:

; 1137 : 			}
; 1138 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN3@assign:

; 1139 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN5@assign

; 1106 : 			_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN5@assign:

; 1107 : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 1108 : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $LN4@assign

; 1109 : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$LN4@assign:

; 1110 : 
; 1111 : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	jmp	SHORT $LN2@assign
$LN3@assign:

; 1113 : 		else if (_Grow(_Num))

	push	0
	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 1117 : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$LN2@assign:

; 1118 : 			}
; 1119 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN7@assign:

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >

; 792  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 793  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 794  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 688  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 690  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 635  : 	_String_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >

; 636  : 		{	// construct allocator from _Al
; 637  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 525  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$addressof@D@std@@YAPADAAD@Z		; std::addressof<char>
	add	esp, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@Myptr
$LN3@Myptr:
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv72[ebp], eax
$LN4@Myptr:
	mov	eax, DWORD PTR tv72[ebp]

; 518  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 	_String_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 499  : 		_Myres = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 500  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 563  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 564  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 565  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 551  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@move
$LN3@move:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@move:
	mov	eax, DWORD PTR tv69[ebp]

; 554  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@copy
$LN3@copy:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
$LN4@copy:
	mov	eax, DWORD PTR tv69[ebp]

; 531  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 521  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp
	push	ecx

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@length
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@length
$LN3@length:
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv68[ebp], eax
$LN4@length:
	mov	eax, DWORD PTR tv68[ebp]

; 524  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Estringdispid@CComTypeInfoHolder@ATL@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Estringdispid@CComTypeInfoHolder@ATL@@QAEPAXI@Z PROC	; ATL::CComTypeInfoHolder::stringdispid::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector
	push	OFFSET ??1stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector
$LN3@vector:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector:
	mov	esp, ebp
	pop	ebp
	ret	4
??_Estringdispid@CComTypeInfoHolder@ATL@@QAEPAXI@Z ENDP	; ATL::CComTypeInfoHolder::stringdispid::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ PROC	; ATL::CComTypeInfoHolder::stringdispid::~stringdispid, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	esp, ebp
	pop	ebp
	ret	0
??1stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ ENDP	; ATL::CComTypeInfoHolder::stringdispid::~stringdispid
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\atlmfc\include\atlcomcli.h
;	COMDAT ??1CComBSTR@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CComBSTR@ATL@@QAE@XZ PROC				; ATL::CComBSTR::~CComBSTR, COMDAT
; _this$ = ecx

; 1656 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1657 :     ::SysFreeString(m_str);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4

; 1658 : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1CComBSTR@ATL@@QAE@XZ ENDP				; ATL::CComBSTR::~CComBSTR
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new.h
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 83   :         {return; }

	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 81   :         {return (_Where); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Where$[ebp]
	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
END
