; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\crashhandler\DiagAssert.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?value@?$integral_constant@I$0A@@std@@2IB	; std::integral_constant<unsigned int,0>::value
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?value@?$integral_constant@_N$0A@@std@@2_NB	; std::integral_constant<bool,0>::value
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?value@?$integral_constant@_N$00@std@@2_NB	; std::integral_constant<bool,1>::value
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
_BSS	SEGMENT
_g_bSymIsInit DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@HU_Nil@std@@U12@U12@U12@U12@U12@U12@@std@@2IB DD 01H ; std::_Sizeof<int,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB
CONST	SEGMENT
?value@?$_Sizeof@U_Nil@std@@U12@U12@U12@U12@U12@U12@U12@@std@@2IB DD 00H ; std::_Sizeof<std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil,std::_Nil>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@std@@2_NB DB 01H	; std::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@std@@2_NB DB 00H	; std::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 09H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@std@@2IB DD 00H	; std::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 00H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
_DATA	SEGMENT
_g_DiagAssertOptions DD 03H
_DATA	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
PUBLIC	?strrchr@@YAPADPADH@Z				; strrchr
PUBLIC	?SetDiagAssertOptions@@YGKK@Z			; SetDiagAssertOptions
PUBLIC	?AddDiagAssertModule@@YGHPAUHINSTANCE__@@@Z	; AddDiagAssertModule
PUBLIC	?DiagAssert@@YGHKPBD0K@Z			; DiagAssert
PUBLIC	?DiagOutput@@YAXPBDZZ				; DiagOutput
PUBLIC	??0CSymbolEngine@@QAE@XZ			; CSymbolEngine::CSymbolEngine
PUBLIC	??1CSymbolEngine@@UAE@XZ			; CSymbolEngine::~CSymbolEngine
PUBLIC	?SymInitialize@CSymbolEngine@@QAEHPAXPADH@Z	; CSymbolEngine::SymInitialize
PUBLIC	?SymLoadModule@CSymbolEngine@@QAEHPAXPAD1KK@Z	; CSymbolEngine::SymLoadModule
PUBLIC	?SymGetModuleInfo@CSymbolEngine@@QAEHKPAU_IMAGEHLP_MODULE@@@Z ; CSymbolEngine::SymGetModuleInfo
PUBLIC	?SymGetSymFromAddr@CSymbolEngine@@QAEHKPAKPAU_IMAGEHLP_SYMBOL@@@Z ; CSymbolEngine::SymGetSymFromAddr
PUBLIC	?SymGetLineFromAddr@CSymbolEngine@@QAEHKPAKPAU_IMAGEHLP_LINE@@@Z ; CSymbolEngine::SymGetLineFromAddr
PUBLIC	??_GCSymbolEngine@@UAEPAXI@Z			; CSymbolEngine::`scalar deleting destructor'
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	??0?$allocator@PAUHINSTANCE__@@@std@@QAE@XZ	; std::allocator<HINSTANCE__ *>::allocator<HINSTANCE__ *>
PUBLIC	?deallocate@?$allocator@PAUHINSTANCE__@@@std@@QAEXPAPAUHINSTANCE__@@I@Z ; std::allocator<HINSTANCE__ *>::deallocate
PUBLIC	?allocate@?$allocator@PAUHINSTANCE__@@@std@@QAEPAPAUHINSTANCE__@@I@Z ; std::allocator<HINSTANCE__ *>::allocate
PUBLIC	?construct@?$allocator@PAUHINSTANCE__@@@std@@QAEXPAPAUHINSTANCE__@@ABQAU3@@Z ; std::allocator<HINSTANCE__ *>::construct
PUBLIC	?max_size@?$allocator@PAUHINSTANCE__@@@std@@QBEIXZ ; std::allocator<HINSTANCE__ *>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@PAUHINSTANCE__@@@std@@@std@@SAIABV?$allocator@PAUHINSTANCE__@@@2@@Z ; std::allocator_traits<std::allocator<HINSTANCE__ *> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<HINSTANCE__ *> >::_Wrap_alloc<std::allocator<HINSTANCE__ *> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAEPAPAUHINSTANCE__@@I@Z ; std::_Wrap_alloc<std::allocator<HINSTANCE__ *> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAEXPAPAUHINSTANCE__@@I@Z ; std::_Wrap_alloc<std::allocator<HINSTANCE__ *> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<HINSTANCE__ *> >::max_size
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<HINSTANCE__ *> >::_Vector_val<std::_Simple_types<HINSTANCE__ *> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUHINSTANCE__@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<HINSTANCE__ *,std::allocator<HINSTANCE__ *> > >::_Vector_alloc<0,std::_Vec_base_types<HINSTANCE__ *,std::allocator<HINSTANCE__ *> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<HINSTANCE__ *,std::allocator<HINSTANCE__ *> > >::_Getal
PUBLIC	??0?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAE@XZ ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >
PUBLIC	??1?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAE@XZ ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::~vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >
PUBLIC	?capacity@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QBEIXZ ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::capacity
PUBLIC	?_Unused_capacity@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QBEIXZ ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Unused_capacity
PUBLIC	?begin@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@2@XZ ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::begin
PUBLIC	?end@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@2@XZ ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::end
PUBLIC	?size@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QBEIXZ ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::size
PUBLIC	?max_size@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QBEIXZ ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::max_size
PUBLIC	?push_back@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAEXABQAUHINSTANCE__@@@Z ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::push_back
PUBLIC	?_Destroy@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IAEXPAPAUHINSTANCE__@@0@Z ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Destroy
PUBLIC	?_Grow_to@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IBEII@Z ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Grow_to
PUBLIC	?_Inside@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IBE_NPBQAUHINSTANCE__@@@Z ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Inside
PUBLIC	?_Reallocate@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IAEXI@Z ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Reallocate
PUBLIC	?_Reserve@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IAEXI@Z ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Reserve
PUBLIC	?_Tidy@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IAEXXZ ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Tidy
PUBLIC	?_Xlen@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IBEXXZ ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Xlen
PUBLIC	?_Orphan_range@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IBEXPAPAUHINSTANCE__@@0@Z ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Orphan_range
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QAE@PAPAUHINSTANCE__@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QBEABQAUHINSTANCE__@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::operator!=
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::_Compat
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QAE@PAPAUHINSTANCE__@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QBEAAPAUHINSTANCE__@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::operator*
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::operator++
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::operator++
PUBLIC	??0?$allocator@K@std@@QAE@XZ			; std::allocator<unsigned long>::allocator<unsigned long>
PUBLIC	?deallocate@?$allocator@K@std@@QAEXPAKI@Z	; std::allocator<unsigned long>::deallocate
PUBLIC	?allocate@?$allocator@K@std@@QAEPAKI@Z		; std::allocator<unsigned long>::allocate
PUBLIC	?construct@?$allocator@K@std@@QAEXPAKABK@Z	; std::allocator<unsigned long>::construct
PUBLIC	?max_size@?$allocator@K@std@@QBEIXZ		; std::allocator<unsigned long>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@K@std@@@std@@SAIABV?$allocator@K@2@@Z ; std::allocator_traits<std::allocator<unsigned long> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<unsigned long> >::_Wrap_alloc<std::allocator<unsigned long> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEPAKI@Z ; std::_Wrap_alloc<std::allocator<unsigned long> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKI@Z ; std::_Wrap_alloc<std::allocator<unsigned long> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<unsigned long> >::max_size
PUBLIC	??0?$_Vector_val@U?$_Simple_types@K@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<unsigned long> >::_Vector_val<std::_Simple_types<unsigned long> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAE@ABV?$allocator@K@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Vector_alloc<0,std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Getal
PUBLIC	??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ	; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >
PUBLIC	??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ	; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
PUBLIC	?capacity@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::capacity
PUBLIC	?_Unused_capacity@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Unused_capacity
PUBLIC	?begin@?$vector@KV?$allocator@K@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@2@XZ ; std::vector<unsigned long,std::allocator<unsigned long> >::begin
PUBLIC	?end@?$vector@KV?$allocator@K@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@2@XZ ; std::vector<unsigned long,std::allocator<unsigned long> >::end
PUBLIC	?size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::size
PUBLIC	?max_size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::max_size
PUBLIC	?push_back@?$vector@KV?$allocator@K@std@@@std@@QAEXABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::push_back
PUBLIC	?_Destroy@?$vector@KV?$allocator@K@std@@@std@@IAEXPAK0@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Destroy
PUBLIC	?_Grow_to@?$vector@KV?$allocator@K@std@@@std@@IBEII@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Grow_to
PUBLIC	?_Inside@?$vector@KV?$allocator@K@std@@@std@@IBE_NPBK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Inside
PUBLIC	?_Reallocate@?$vector@KV?$allocator@K@std@@@std@@IAEXI@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Reallocate
PUBLIC	?_Reserve@?$vector@KV?$allocator@K@std@@@std@@IAEXI@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Reserve
PUBLIC	?_Tidy@?$vector@KV?$allocator@K@std@@@std@@IAEXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Tidy
PUBLIC	?_Xlen@?$vector@KV?$allocator@K@std@@@std@@IBEXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlen
PUBLIC	?_Orphan_range@?$vector@KV?$allocator@K@std@@@std@@IBEXPAK0@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Orphan_range
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAE@PAKPBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBEABKXZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::operator!=
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::_Compat
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAE@PAKPBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBEAAKXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::operator*
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::operator++
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::operator++
PUBLIC	??$addressof@QAUHINSTANCE__@@@std@@YAPBQAUHINSTANCE__@@ABQAU1@@Z ; std::addressof<HINSTANCE__ * const>
PUBLIC	??$construct@PAUHINSTANCE__@@AAPAU1@@?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAEXPAPAUHINSTANCE__@@AAPAU2@@Z ; std::_Wrap_alloc<std::allocator<HINSTANCE__ *> >::construct<HINSTANCE__ *,HINSTANCE__ * &>
PUBLIC	??$construct@PAUHINSTANCE__@@ABQAU1@@?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAEXPAPAUHINSTANCE__@@ABQAU2@@Z ; std::_Wrap_alloc<std::allocator<HINSTANCE__ *> >::construct<HINSTANCE__ *,HINSTANCE__ * const &>
PUBLIC	??$addressof@$$CBK@std@@YAPBKABK@Z		; std::addressof<unsigned long const >
PUBLIC	??$construct@KAAK@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKAAK@Z ; std::_Wrap_alloc<std::allocator<unsigned long> >::construct<unsigned long,unsigned long &>
PUBLIC	??$construct@KABK@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKABK@Z ; std::_Wrap_alloc<std::allocator<unsigned long> >::construct<unsigned long,unsigned long const &>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@@std@@YAXPAPAUHINSTANCE__@@0AAU?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<HINSTANCE__ *> > >
PUBLIC	??$_Umove@PAPAUHINSTANCE__@@@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IAEPAPAUHINSTANCE__@@PAPAU2@00@Z ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Umove<HINSTANCE__ * *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@@std@@YAXPAK0AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<unsigned long> > >
PUBLIC	??$_Umove@PAK@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAK00@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Umove<unsigned long *>
PUBLIC	??$_Allocate@PAUHINSTANCE__@@@std@@YAPAPAUHINSTANCE__@@IPAPAU1@@Z ; std::_Allocate<HINSTANCE__ *>
PUBLIC	??$_Allocate@K@std@@YAPAKIPAK@Z			; std::_Allocate<unsigned long>
PUBLIC	??$forward@AAPAUHINSTANCE__@@@std@@YAAAPAUHINSTANCE__@@AAPAU1@@Z ; std::forward<HINSTANCE__ * &>
PUBLIC	??$construct@PAUHINSTANCE__@@AAPAU1@@?$allocator_traits@V?$allocator@PAUHINSTANCE__@@@std@@@std@@SAXAAV?$allocator@PAUHINSTANCE__@@@1@PAPAUHINSTANCE__@@AAPAU3@@Z ; std::allocator_traits<std::allocator<HINSTANCE__ *> >::construct<HINSTANCE__ *,HINSTANCE__ * &>
PUBLIC	??$forward@ABQAUHINSTANCE__@@@std@@YAABQAUHINSTANCE__@@ABQAU1@@Z ; std::forward<HINSTANCE__ * const &>
PUBLIC	??$construct@PAUHINSTANCE__@@ABQAU1@@?$allocator_traits@V?$allocator@PAUHINSTANCE__@@@std@@@std@@SAXAAV?$allocator@PAUHINSTANCE__@@@1@PAPAUHINSTANCE__@@ABQAU3@@Z ; std::allocator_traits<std::allocator<HINSTANCE__ *> >::construct<HINSTANCE__ *,HINSTANCE__ * const &>
PUBLIC	??$forward@AAK@std@@YAAAKAAK@Z			; std::forward<unsigned long &>
PUBLIC	??$construct@KAAK@?$allocator_traits@V?$allocator@K@std@@@std@@SAXAAV?$allocator@K@1@PAKAAK@Z ; std::allocator_traits<std::allocator<unsigned long> >::construct<unsigned long,unsigned long &>
PUBLIC	??$forward@ABK@std@@YAABKABK@Z			; std::forward<unsigned long const &>
PUBLIC	??$construct@KABK@?$allocator_traits@V?$allocator@K@std@@@std@@SAXAAV?$allocator@K@1@PAKABK@Z ; std::allocator_traits<std::allocator<unsigned long> >::construct<unsigned long,unsigned long const &>
PUBLIC	??$_Ptr_cat@PAUHINSTANCE__@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUHINSTANCE__@@0@Z ; std::_Ptr_cat<HINSTANCE__ *,HINSTANCE__ *>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@@std@@YAXPAPAUHINSTANCE__@@0AAU?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<HINSTANCE__ *> > >
PUBLIC	??$_Uninitialized_move@PAPAUHINSTANCE__@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@@std@@YAPAPAUHINSTANCE__@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@0@@Z ; std::_Uninitialized_move<HINSTANCE__ * *,HINSTANCE__ * *,std::_Wrap_alloc<std::allocator<HINSTANCE__ *> > >
PUBLIC	??$_Ptr_cat@KK@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAK0@Z ; std::_Ptr_cat<unsigned long,unsigned long>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@@std@@YAXPAK0AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<unsigned long> > >
PUBLIC	??$_Uninitialized_move@PAKPAKU?$_Wrap_alloc@V?$allocator@K@std@@@std@@@std@@YAPAKPAK00AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@@Z ; std::_Uninitialized_move<unsigned long *,unsigned long *,std::_Wrap_alloc<std::allocator<unsigned long> > >
PUBLIC	??$construct@PAUHINSTANCE__@@AAPAU1@@?$allocator@PAUHINSTANCE__@@@std@@QAEXPAPAUHINSTANCE__@@AAPAU2@@Z ; std::allocator<HINSTANCE__ *>::construct<HINSTANCE__ *,HINSTANCE__ * &>
PUBLIC	??$construct@KAAK@?$allocator@K@std@@QAEXPAKAAK@Z ; std::allocator<unsigned long>::construct<unsigned long,unsigned long &>
PUBLIC	??$_Val_type@PAPAUHINSTANCE__@@@std@@YAPAPAUHINSTANCE__@@PAPAU1@@Z ; std::_Val_type<HINSTANCE__ * *>
PUBLIC	??$_Uninit_move@PAUHINSTANCE__@@PAU1@PAU1@@std@@YAPAPAUHINSTANCE__@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<HINSTANCE__ *,HINSTANCE__ *,HINSTANCE__ *>
PUBLIC	??$_Val_type@PAK@std@@YAPAKPAK@Z		; std::_Val_type<unsigned long *>
PUBLIC	??$_Uninit_move@KKK@std@@YAPAKPAK00AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<unsigned long,unsigned long,unsigned long>
PUBLIC	??_7CSymbolEngine@@6B@				; CSymbolEngine::`vftable'
PUBLIC	??_C@_0CF@NNHOJLK@?$CK?$CKLast?5error?5code?5does?5not?5exist@ ; `string'
PUBLIC	??_C@_0BG@OPOJBHAK@?$DMunknown?5application?$DO?$AA@ ; `string'
PUBLIC	??_C@_0GF@FMBDCGE@Debug?5Assertion?5Failed?$CB?6?6Program@ ; `string'
PUBLIC	??_C@_0BF@OAIGKMGH@ASSERTION?5FAILURE?4?4?4?$AA@ ; `string'
PUBLIC	??_C@_07PEGDEKEA@0x?$CF08X?5?$AA@		; `string'
PUBLIC	??_C@_04PFAOODAA@?$CFs?3?5?$AA@			; `string'
PUBLIC	??_C@_0BD@LGBHNHKC@?$DMunknown?5module?$DO?3?5?$AA@ ; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	??_C@_0O@NOLLDIJH@?$CFs?5?$CL?5?$CFd?5bytes?$AA@ ; `string'
PUBLIC	??_C@_0P@MKDHEAFE@?6?7?7?$CFs?0?5Line?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0M@DKCMIBMA@?5?$CL?5?$CFd?5bytes?$AA@	; `string'
PUBLIC	??_C@_0BB@IICGLAA@?$DMunknown?5symbol?$DO?$AA@	; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_R4CSymbolEngine@@6B@				; CSymbolEngine::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCSymbolEngine@@@8			; CSymbolEngine `RTTI Type Descriptor'
PUBLIC	??_R3CSymbolEngine@@8				; CSymbolEngine::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CSymbolEngine@@8				; CSymbolEngine::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CSymbolEngine@@8			; CSymbolEngine::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	_memset:PROC
EXTRN	_strcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_strrchr:PROC
EXTRN	__imp__CreateFileA@28:PROC
EXTRN	__imp__OutputDebugStringA@4:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__SetLastError@4:PROC
EXTRN	__imp__GetCurrentProcess@0:PROC
EXTRN	__imp__ExitProcess@4:PROC
EXTRN	__imp__GetCurrentThread@0:PROC
EXTRN	__imp__GetThreadContext@8:PROC
EXTRN	__imp__VirtualQueryEx@16:PROC
EXTRN	__imp__GetModuleFileNameA@12:PROC
EXTRN	__imp__LocalFree@4:PROC
EXTRN	__imp__FormatMessageA@28:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	__imp__GetActiveWindow@0:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	__imp__GetLastActivePopup@4:PROC
EXTRN	__imp__StackWalk@36:PROC
EXTRN	__imp__SymSetOptions@4:PROC
EXTRN	__imp__SymGetOptions@0:PROC
EXTRN	__imp__SymFunctionTableAccess@8:PROC
EXTRN	__imp__SymGetModuleInfo@12:PROC
EXTRN	__imp__SymGetLineFromAddr@16:PROC
EXTRN	__imp__SymInitialize@12:PROC
EXTRN	__imp__SymGetSymFromAddr@16:PROC
EXTRN	__imp__SymLoadModule@24:PROC
EXTRN	??_ECSymbolEngine@@UAEPAXI@Z:PROC		; CSymbolEngine::`vector deleting destructor'
EXTRN	_vsprintf:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
_piecewise_construct DB 01H DUP (?)
	ALIGN	4

_allocator_arg DB 01H DUP (?)
	ALIGN	4

_g_HMODVector DB 0cH DUP (?)
_g_cSym	DQ	01H DUP (?)
_BSS	ENDS
;	COMDAT ?szBuff@?1??DiagAssert@@YGHKPBD0K@Z@4PADA
_BSS	SEGMENT
?szBuff@?1??DiagAssert@@YGHKPBD0K@Z@4PADA DB 01000H DUP (?) ; `DiagAssert'::`2'::szBuff
_BSS	ENDS
;	COMDAT ?szOutBuff@?1??DiagOutput@@YAXPBDZZ@4PADA
_BSS	SEGMENT
?szOutBuff@?1??DiagOutput@@YAXPBDZZ@4PADA DB 0400H DUP (?) ; `DiagOutput'::`2'::szOutBuff
_BSS	ENDS
CRT$XCU	SEGMENT
_piecewise_construct$initializer$ DD FLAT:??__Epiecewise_construct@std@@YAXXZ
CRT$XCU	ENDS
;	COMDAT ??_R1A@?0A@EA@CSymbolEngine@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CSymbolEngine@@8 DD FLAT:??_R0?AVCSymbolEngine@@@8 ; CSymbolEngine::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CSymbolEngine@@8
rdata$r	ENDS
;	COMDAT ??_R2CSymbolEngine@@8
rdata$r	SEGMENT
??_R2CSymbolEngine@@8 DD FLAT:??_R1A@?0A@EA@CSymbolEngine@@8 ; CSymbolEngine::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CSymbolEngine@@8
rdata$r	SEGMENT
??_R3CSymbolEngine@@8 DD 00H				; CSymbolEngine::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CSymbolEngine@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCSymbolEngine@@@8
_DATA	SEGMENT
??_R0?AVCSymbolEngine@@@8 DD FLAT:??_7type_info@@6B@	; CSymbolEngine `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCSymbolEngine@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CSymbolEngine@@6B@
rdata$r	SEGMENT
??_R4CSymbolEngine@@6B@ DD 00H				; CSymbolEngine::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCSymbolEngine@@@8
	DD	FLAT:??_R3CSymbolEngine@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IICGLAA@?$DMunknown?5symbol?$DO?$AA@
CONST	SEGMENT
??_C@_0BB@IICGLAA@?$DMunknown?5symbol?$DO?$AA@ DB '<unknown symbol>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DKCMIBMA@?5?$CL?5?$CFd?5bytes?$AA@
CONST	SEGMENT
??_C@_0M@DKCMIBMA@?5?$CL?5?$CFd?5bytes?$AA@ DB ' + %d bytes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MKDHEAFE@?6?7?7?$CFs?0?5Line?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0P@MKDHEAFE@?6?7?7?$CFs?0?5Line?5?$CFd?$AA@ DB 0aH, 09H, 09H, '%s, '
	DB	'Line %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NOLLDIJH@?$CFs?5?$CL?5?$CFd?5bytes?$AA@
CONST	SEGMENT
??_C@_0O@NOLLDIJH@?$CFs?5?$CL?5?$CFd?5bytes?$AA@ DB '%s + %d bytes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LGBHNHKC@?$DMunknown?5module?$DO?3?5?$AA@
CONST	SEGMENT
??_C@_0BD@LGBHNHKC@?$DMunknown?5module?$DO?3?5?$AA@ DB '<unknown module>:'
	DB	' ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_04PFAOODAA@?$CFs?3?5?$AA@
CONST	SEGMENT
??_C@_04PFAOODAA@?$CFs?3?5?$AA@ DB '%s: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PEGDEKEA@0x?$CF08X?5?$AA@
CONST	SEGMENT
??_C@_07PEGDEKEA@0x?$CF08X?5?$AA@ DB '0x%08X ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OAIGKMGH@ASSERTION?5FAILURE?4?4?4?$AA@
CONST	SEGMENT
??_C@_0BF@OAIGKMGH@ASSERTION?5FAILURE?4?4?4?$AA@ DB 'ASSERTION FAILURE...'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0GF@FMBDCGE@Debug?5Assertion?5Failed?$CB?6?6Program@
CONST	SEGMENT
??_C@_0GF@FMBDCGE@Debug?5Assertion?5Failed?$CB?6?6Program@ DB 'Debug Asse'
	DB	'rtion Failed!', 0aH, 0aH, 'Program : %s', 0aH, 'File : %s', 0aH
	DB	'Line : %d', 0aH, 'Expression : %s', 0aH, 'Last Error (0x%08X)'
	DB	' : %s', 0aH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@OPOJBHAK@?$DMunknown?5application?$DO?$AA@
CONST	SEGMENT
??_C@_0BG@OPOJBHAK@?$DMunknown?5application?$DO?$AA@ DB '<unknown applica'
	DB	'tion>', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@NNHOJLK@?$CK?$CKLast?5error?5code?5does?5not?5exist@
CONST	SEGMENT
??_C@_0CF@NNHOJLK@?$CK?$CKLast?5error?5code?5does?5not?5exist@ DB '**Last'
	DB	' error code does not exist!!!!', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7CSymbolEngine@@6B@
CONST	SEGMENT
??_7CSymbolEngine@@6B@ DD FLAT:??_R4CSymbolEngine@@6B@	; CSymbolEngine::`vftable'
	DD	FLAT:??_ECSymbolEngine@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@KAAK@?$allocator@K@std@@QAEXPAKAAK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@KAAK@?$allocator@K@std@@QAEXPAKAAK@Z$0
__ehfuncinfo$??$construct@KAAK@?$allocator@K@std@@QAEXPAKAAK@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@KAAK@?$allocator@K@std@@QAEXPAKAAK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct@PAUHINSTANCE__@@AAPAU1@@?$allocator@PAUHINSTANCE__@@@std@@QAEXPAPAUHINSTANCE__@@AAPAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@PAUHINSTANCE__@@AAPAU1@@?$allocator@PAUHINSTANCE__@@@std@@QAEXPAPAUHINSTANCE__@@AAPAU2@@Z$0
__ehfuncinfo$??$construct@PAUHINSTANCE__@@AAPAU1@@?$allocator@PAUHINSTANCE__@@@std@@QAEXPAPAUHINSTANCE__@@AAPAU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@PAUHINSTANCE__@@AAPAU1@@?$allocator@PAUHINSTANCE__@@@std@@QAEXPAPAUHINSTANCE__@@AAPAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Reallocate@?$vector@KV?$allocator@K@std@@@std@@IAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate@?$vector@KV?$allocator@K@std@@@std@@IAEXI@Z$0
__unwindtable$?_Reallocate@?$vector@KV?$allocator@K@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate@?$vector@KV?$allocator@K@std@@@std@@IAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate@?$vector@KV?$allocator@K@std@@@std@@IAEXI@Z$2
__ehfuncinfo$?_Reallocate@?$vector@KV?$allocator@K@std@@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate@?$vector@KV?$allocator@K@std@@@std@@IAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate@?$vector@KV?$allocator@K@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?DoStackTrace@@YAXPADKK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoStackTrace@@YAXPADKK@Z$0
__ehfuncinfo$?DoStackTrace@@YAXPADKK@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DoStackTrace@@YAXPADKK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Reallocate@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IAEXI@Z$0
__unwindtable$?_Reallocate@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IAEXI@Z$2
__ehfuncinfo$?_Reallocate@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CRT$XCU	SEGMENT
_allocator_arg$initializer$ DD FLAT:??__Eallocator_arg@std@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_g_HMODVector$initializer$ DD FLAT:??__Eg_HMODVector@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	SEGMENT
_g_cSym$initializer$ DD FLAT:??__Eg_cSym@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@KKK@std@@YAPAKPAK00AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@KKK@std@@YAPAKPAK00AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<unsigned long,unsigned long,unsigned long>, COMDAT

; 458  : 	{	// move [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	push	ecx

; 459  : 	_DEBUG_RANGE(_First, _Last);
; 460  : 	_DEBUG_POINTER(_Dest);
; 461  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 462  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 463  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [eax+ecx*4]

; 464  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_move@KKK@std@@YAPAKPAK00AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<unsigned long,unsigned long,unsigned long>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAK@std@@YAPAKPAK@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAK@std@@YAPAKPAK@Z PROC			; std::_Val_type<unsigned long *>, COMDAT

; 710  : 	{	// return value type from arbitrary argument

	push	ebp
	mov	ebp, esp

; 711  : 	return (0);

	xor	eax, eax

; 712  : 	}

	pop	ebp
	ret	0
??$_Val_type@PAK@std@@YAPAKPAK@Z ENDP			; std::_Val_type<unsigned long *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PAUHINSTANCE__@@PAU1@PAU1@@std@@YAPAPAUHINSTANCE__@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUHINSTANCE__@@PAU1@PAU1@@std@@YAPAPAUHINSTANCE__@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<HINSTANCE__ *,HINSTANCE__ *,HINSTANCE__ *>, COMDAT

; 458  : 	{	// move [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	push	ecx

; 459  : 	_DEBUG_RANGE(_First, _Last);
; 460  : 	_DEBUG_POINTER(_Dest);
; 461  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 462  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 463  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [eax+ecx*4]

; 464  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_move@PAUHINSTANCE__@@PAU1@PAU1@@std@@YAPAPAUHINSTANCE__@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<HINSTANCE__ *,HINSTANCE__ *,HINSTANCE__ *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAPAUHINSTANCE__@@@std@@YAPAPAUHINSTANCE__@@PAPAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAPAUHINSTANCE__@@@std@@YAPAPAUHINSTANCE__@@PAPAU1@@Z PROC ; std::_Val_type<HINSTANCE__ * *>, COMDAT

; 710  : 	{	// return value type from arbitrary argument

	push	ebp
	mov	ebp, esp

; 711  : 	return (0);

	xor	eax, eax

; 712  : 	}

	pop	ebp
	ret	0
??$_Val_type@PAPAUHINSTANCE__@@@std@@YAPAPAUHINSTANCE__@@PAPAU1@@Z ENDP ; std::_Val_type<HINSTANCE__ * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@KAAK@?$allocator@K@std@@QAEXPAKAAK@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@KAAK@?$allocator@K@std@@QAEXPAKAAK@Z PROC	; std::allocator<unsigned long>::construct<unsigned long,unsigned long &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@KAAK@?$allocator@K@std@@QAEXPAKAAK@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAK@std@@YAAAKAAK@Z		; std::forward<unsigned long &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@KAAK@?$allocator@K@std@@QAEXPAKAAK@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@KAAK@?$allocator@K@std@@QAEXPAKAAK@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@KAAK@?$allocator@K@std@@QAEXPAKAAK@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@KAAK@?$allocator@K@std@@QAEXPAKAAK@Z ENDP	; std::allocator<unsigned long>::construct<unsigned long,unsigned long &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PAUHINSTANCE__@@AAPAU1@@?$allocator@PAUHINSTANCE__@@@std@@QAEXPAPAUHINSTANCE__@@AAPAU2@@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PAUHINSTANCE__@@AAPAU1@@?$allocator@PAUHINSTANCE__@@@std@@QAEXPAPAUHINSTANCE__@@AAPAU2@@Z PROC ; std::allocator<HINSTANCE__ *>::construct<HINSTANCE__ *,HINSTANCE__ * &>, COMDAT
; _this$ = ecx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@PAUHINSTANCE__@@AAPAU1@@?$allocator@PAUHINSTANCE__@@@std@@QAEXPAPAUHINSTANCE__@@AAPAU2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __V0$[ebp]
	push	ecx
	call	??$forward@AAPAUHINSTANCE__@@@std@@YAAAPAUHINSTANCE__@@AAPAU1@@Z ; std::forward<HINSTANCE__ * &>
	add	esp, 4
	mov	edx, DWORD PTR $T3[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN4@construct
$LN3@construct:
	mov	DWORD PTR tv73[ebp], 0
$LN4@construct:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@PAUHINSTANCE__@@AAPAU1@@?$allocator@PAUHINSTANCE__@@@std@@QAEXPAPAUHINSTANCE__@@AAPAU2@@Z$0:
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$construct@PAUHINSTANCE__@@AAPAU1@@?$allocator@PAUHINSTANCE__@@@std@@QAEXPAPAUHINSTANCE__@@AAPAU2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@PAUHINSTANCE__@@AAPAU1@@?$allocator@PAUHINSTANCE__@@@std@@QAEXPAPAUHINSTANCE__@@AAPAU2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@PAUHINSTANCE__@@AAPAU1@@?$allocator@PAUHINSTANCE__@@@std@@QAEXPAPAUHINSTANCE__@@AAPAU2@@Z ENDP ; std::allocator<HINSTANCE__ *>::construct<HINSTANCE__ *,HINSTANCE__ * &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAKPAKU?$_Wrap_alloc@V?$allocator@K@std@@@std@@@std@@YAPAKPAK00AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAKPAKU?$_Wrap_alloc@V?$allocator@K@std@@@std@@@std@@YAPAKPAK00AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@@Z PROC ; std::_Uninitialized_move<unsigned long *,unsigned long *,std::_Wrap_alloc<std::allocator<unsigned long> > >, COMDAT

; 471  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 472  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 473  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@KK@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAK0@Z ; std::_Ptr_cat<unsigned long,unsigned long>
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Val_type@PAK@std@@YAPAKPAK@Z	; std::_Val_type<unsigned long *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_move@KKK@std@@YAPAKPAK00AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<unsigned long,unsigned long,unsigned long>
	add	esp, 24					; 00000018H

; 474  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_move@PAKPAKU?$_Wrap_alloc@V?$allocator@K@std@@@std@@@std@@YAPAKPAK00AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@@Z ENDP ; std::_Uninitialized_move<unsigned long *,unsigned long *,std::_Wrap_alloc<std::allocator<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@@std@@YAXPAK0AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@@std@@YAXPAK0AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<unsigned long> > >, COMDAT

; 96   : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 97   : 	}

	pop	ebp
	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@@std@@YAXPAK0AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@KK@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAK0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@KK@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAK0@Z PROC ; std::_Ptr_cat<unsigned long,unsigned long>, COMDAT

; 437  : 	{	// return pointer category from pointers

	push	ebp
	mov	ebp, esp
	push	ecx

; 438  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 439  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 440  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@KK@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAK0@Z ENDP ; std::_Ptr_cat<unsigned long,unsigned long>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAUHINSTANCE__@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@@std@@YAPAPAUHINSTANCE__@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAUHINSTANCE__@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@@std@@YAPAPAUHINSTANCE__@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@0@@Z PROC ; std::_Uninitialized_move<HINSTANCE__ * *,HINSTANCE__ * *,std::_Wrap_alloc<std::allocator<HINSTANCE__ *> > >, COMDAT

; 471  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 472  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 473  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAUHINSTANCE__@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUHINSTANCE__@@0@Z ; std::_Ptr_cat<HINSTANCE__ *,HINSTANCE__ *>
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Val_type@PAPAUHINSTANCE__@@@std@@YAPAPAUHINSTANCE__@@PAPAU1@@Z ; std::_Val_type<HINSTANCE__ * *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_move@PAUHINSTANCE__@@PAU1@PAU1@@std@@YAPAPAUHINSTANCE__@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<HINSTANCE__ *,HINSTANCE__ *,HINSTANCE__ *>
	add	esp, 24					; 00000018H

; 474  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_move@PAPAUHINSTANCE__@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@@std@@YAPAPAUHINSTANCE__@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<HINSTANCE__ * *,HINSTANCE__ * *,std::_Wrap_alloc<std::allocator<HINSTANCE__ *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@@std@@YAXPAPAUHINSTANCE__@@0AAU?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@@std@@YAXPAPAUHINSTANCE__@@0AAU?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<HINSTANCE__ *> > >, COMDAT

; 96   : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 97   : 	}

	pop	ebp
	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@@std@@YAXPAPAUHINSTANCE__@@0AAU?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<HINSTANCE__ *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAUHINSTANCE__@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUHINSTANCE__@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUHINSTANCE__@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUHINSTANCE__@@0@Z PROC ; std::_Ptr_cat<HINSTANCE__ *,HINSTANCE__ *>, COMDAT

; 437  : 	{	// return pointer category from pointers

	push	ebp
	mov	ebp, esp
	push	ecx

; 438  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 439  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 440  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAUHINSTANCE__@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUHINSTANCE__@@0@Z ENDP ; std::_Ptr_cat<HINSTANCE__ *,HINSTANCE__ *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@KABK@?$allocator_traits@V?$allocator@K@std@@@std@@SAXAAV?$allocator@K@1@PAKABK@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@KABK@?$allocator_traits@V?$allocator@K@std@@@std@@SAXAAV?$allocator@K@1@PAKABK@Z PROC ; std::allocator_traits<std::allocator<unsigned long> >::construct<unsigned long,unsigned long const &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@ABK@std@@YAABKABK@Z		; std::forward<unsigned long const &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@K@std@@QAEXPAKABK@Z ; std::allocator<unsigned long>::construct
	pop	ebp
	ret	0
??$construct@KABK@?$allocator_traits@V?$allocator@K@std@@@std@@SAXAAV?$allocator@K@1@PAKABK@Z ENDP ; std::allocator_traits<std::allocator<unsigned long> >::construct<unsigned long,unsigned long const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@ABK@std@@YAABKABK@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABK@std@@YAABKABK@Z PROC			; std::forward<unsigned long const &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@ABK@std@@YAABKABK@Z ENDP			; std::forward<unsigned long const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@KAAK@?$allocator_traits@V?$allocator@K@std@@@std@@SAXAAV?$allocator@K@1@PAKAAK@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@KAAK@?$allocator_traits@V?$allocator@K@std@@@std@@SAXAAV?$allocator@K@1@PAKAAK@Z PROC ; std::allocator_traits<std::allocator<unsigned long> >::construct<unsigned long,unsigned long &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAK@std@@YAAAKAAK@Z		; std::forward<unsigned long &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@KAAK@?$allocator@K@std@@QAEXPAKAAK@Z ; std::allocator<unsigned long>::construct<unsigned long,unsigned long &>
	pop	ebp
	ret	0
??$construct@KAAK@?$allocator_traits@V?$allocator@K@std@@@std@@SAXAAV?$allocator@K@1@PAKAAK@Z ENDP ; std::allocator_traits<std::allocator<unsigned long> >::construct<unsigned long,unsigned long &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAK@std@@YAAAKAAK@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAK@std@@YAAAKAAK@Z PROC			; std::forward<unsigned long &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAK@std@@YAAAKAAK@Z ENDP			; std::forward<unsigned long &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PAUHINSTANCE__@@ABQAU1@@?$allocator_traits@V?$allocator@PAUHINSTANCE__@@@std@@@std@@SAXAAV?$allocator@PAUHINSTANCE__@@@1@PAPAUHINSTANCE__@@ABQAU3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PAUHINSTANCE__@@ABQAU1@@?$allocator_traits@V?$allocator@PAUHINSTANCE__@@@std@@@std@@SAXAAV?$allocator@PAUHINSTANCE__@@@1@PAPAUHINSTANCE__@@ABQAU3@@Z PROC ; std::allocator_traits<std::allocator<HINSTANCE__ *> >::construct<HINSTANCE__ *,HINSTANCE__ * const &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@ABQAUHINSTANCE__@@@std@@YAABQAUHINSTANCE__@@ABQAU1@@Z ; std::forward<HINSTANCE__ * const &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@PAUHINSTANCE__@@@std@@QAEXPAPAUHINSTANCE__@@ABQAU3@@Z ; std::allocator<HINSTANCE__ *>::construct
	pop	ebp
	ret	0
??$construct@PAUHINSTANCE__@@ABQAU1@@?$allocator_traits@V?$allocator@PAUHINSTANCE__@@@std@@@std@@SAXAAV?$allocator@PAUHINSTANCE__@@@1@PAPAUHINSTANCE__@@ABQAU3@@Z ENDP ; std::allocator_traits<std::allocator<HINSTANCE__ *> >::construct<HINSTANCE__ *,HINSTANCE__ * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@ABQAUHINSTANCE__@@@std@@YAABQAUHINSTANCE__@@ABQAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAUHINSTANCE__@@@std@@YAABQAUHINSTANCE__@@ABQAU1@@Z PROC ; std::forward<HINSTANCE__ * const &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@ABQAUHINSTANCE__@@@std@@YAABQAUHINSTANCE__@@ABQAU1@@Z ENDP ; std::forward<HINSTANCE__ * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PAUHINSTANCE__@@AAPAU1@@?$allocator_traits@V?$allocator@PAUHINSTANCE__@@@std@@@std@@SAXAAV?$allocator@PAUHINSTANCE__@@@1@PAPAUHINSTANCE__@@AAPAU3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__V0$ = 16						; size = 4
??$construct@PAUHINSTANCE__@@AAPAU1@@?$allocator_traits@V?$allocator@PAUHINSTANCE__@@@std@@@std@@SAXAAV?$allocator@PAUHINSTANCE__@@@1@PAPAUHINSTANCE__@@AAPAU3@@Z PROC ; std::allocator_traits<std::allocator<HINSTANCE__ *> >::construct<HINSTANCE__ *,HINSTANCE__ * &>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAUHINSTANCE__@@@std@@YAAAPAUHINSTANCE__@@AAPAU1@@Z ; std::forward<HINSTANCE__ * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@PAUHINSTANCE__@@AAPAU1@@?$allocator@PAUHINSTANCE__@@@std@@QAEXPAPAUHINSTANCE__@@AAPAU2@@Z ; std::allocator<HINSTANCE__ *>::construct<HINSTANCE__ *,HINSTANCE__ * &>
	pop	ebp
	ret	0
??$construct@PAUHINSTANCE__@@AAPAU1@@?$allocator_traits@V?$allocator@PAUHINSTANCE__@@@std@@@std@@SAXAAV?$allocator@PAUHINSTANCE__@@@1@PAPAUHINSTANCE__@@AAPAU3@@Z ENDP ; std::allocator_traits<std::allocator<HINSTANCE__ *> >::construct<HINSTANCE__ *,HINSTANCE__ * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAUHINSTANCE__@@@std@@YAAAPAUHINSTANCE__@@AAPAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAUHINSTANCE__@@@std@@YAAAPAUHINSTANCE__@@AAPAU1@@Z PROC ; std::forward<HINSTANCE__ * &>, COMDAT

; 1775 : 	{	// forward an lvalue

	push	ebp
	mov	ebp, esp

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1777 : 	}

	pop	ebp
	ret	0
??$forward@AAPAUHINSTANCE__@@@std@@YAAAPAUHINSTANCE__@@AAPAU1@@Z ENDP ; std::forward<HINSTANCE__ * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@K@std@@YAPAKIPAK@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@K@std@@YAPAKIPAK@Z PROC			; std::_Allocate<unsigned long>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@K@std@@YAPAKIPAK@Z ENDP			; std::_Allocate<unsigned long>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@PAUHINSTANCE__@@@std@@YAPAPAUHINSTANCE__@@IPAPAU1@@Z
_TEXT	SEGMENT
__Ptr$ = -4						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAUHINSTANCE__@@@std@@YAPAPAUHINSTANCE__@@IPAPAU1@@Z PROC ; std::_Allocate<HINSTANCE__ *>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 24   : 
; 25   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN4@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)

	jmp	SHORT $LN3@Allocate
$LN4@Allocate:

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

	cmp	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH
	ja	SHORT $LN1@Allocate
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN3@Allocate
$LN1@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN3@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN6@Allocate:

; 32   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAUHINSTANCE__@@@std@@YAPAPAUHINSTANCE__@@IPAPAU1@@Z ENDP ; std::_Allocate<HINSTANCE__ *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??$_Umove@PAK@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAK00@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Alval$ = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAK@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAK00@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Umove<unsigned long *>, COMDAT
; _this$ = ecx

; 1557 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1558 : 		{	// move initializing [_First, _Last), using allocator
; 1559 : 		_Alty _Alval(this->_Getal());

	lea	eax, DWORD PTR __Alval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Getal

; 1560 : 		return (_Uninitialized_move(_First, _Last,
; 1561 : 			_Ptr, _Alval));

	lea	ecx, DWORD PTR __Alval$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninitialized_move@PAKPAKU?$_Wrap_alloc@V?$allocator@K@std@@@std@@@std@@YAPAKPAK00AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@@Z ; std::_Uninitialized_move<unsigned long *,unsigned long *,std::_Wrap_alloc<std::allocator<unsigned long> > >
	add	esp, 16					; 00000010H

; 1562 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAK@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAK00@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Umove<unsigned long *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@@std@@YAXPAK0AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@@std@@YAXPAK0AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<unsigned long> > >, COMDAT

; 79   : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 80   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@KK@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAK0@Z ; std::_Ptr_cat<unsigned long,unsigned long>
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@@std@@YAXPAK0AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<unsigned long> > >
	add	esp, 16					; 00000010H

; 81   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@@std@@YAXPAK0AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??$_Umove@PAPAUHINSTANCE__@@@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IAEPAPAUHINSTANCE__@@PAPAU2@00@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Alval$ = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAUHINSTANCE__@@@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IAEPAPAUHINSTANCE__@@PAPAU2@00@Z PROC ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Umove<HINSTANCE__ * *>, COMDAT
; _this$ = ecx

; 1557 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1558 : 		{	// move initializing [_First, _Last), using allocator
; 1559 : 		_Alty _Alval(this->_Getal());

	lea	eax, DWORD PTR __Alval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<HINSTANCE__ *,std::allocator<HINSTANCE__ *> > >::_Getal

; 1560 : 		return (_Uninitialized_move(_First, _Last,
; 1561 : 			_Ptr, _Alval));

	lea	ecx, DWORD PTR __Alval$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninitialized_move@PAPAUHINSTANCE__@@PAPAU1@U?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@@std@@YAPAPAUHINSTANCE__@@PAPAU1@00AAU?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@0@@Z ; std::_Uninitialized_move<HINSTANCE__ * *,HINSTANCE__ * *,std::_Wrap_alloc<std::allocator<HINSTANCE__ *> > >
	add	esp, 16					; 00000010H

; 1562 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAPAUHINSTANCE__@@@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IAEPAPAUHINSTANCE__@@PAPAU2@00@Z ENDP ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Umove<HINSTANCE__ * *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@@std@@YAXPAPAUHINSTANCE__@@0AAU?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@@std@@YAXPAPAUHINSTANCE__@@0AAU?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<HINSTANCE__ *> > >, COMDAT

; 79   : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 80   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAUHINSTANCE__@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUHINSTANCE__@@0@Z ; std::_Ptr_cat<HINSTANCE__ *,HINSTANCE__ *>
	add	esp, 8
	mov	BYTE PTR $T1[ebp], al
	movzx	edx, BYTE PTR $T1[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@@std@@YAXPAPAUHINSTANCE__@@0AAU?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<HINSTANCE__ *> > >
	add	esp, 16					; 00000010H

; 81   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@@std@@YAXPAPAUHINSTANCE__@@0AAU?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<HINSTANCE__ *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@KABK@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKABK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@KABK@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKABK@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned long> >::construct<unsigned long,unsigned long const &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@ABK@std@@YAABKABK@Z		; std::forward<unsigned long const &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@KABK@?$allocator_traits@V?$allocator@K@std@@@std@@SAXAAV?$allocator@K@1@PAKABK@Z ; std::allocator_traits<std::allocator<unsigned long> >::construct<unsigned long,unsigned long const &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@KABK@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKABK@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned long> >::construct<unsigned long,unsigned long const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@KAAK@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKAAK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@KAAK@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKAAK@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned long> >::construct<unsigned long,unsigned long &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAK@std@@YAAAKAAK@Z		; std::forward<unsigned long &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@KAAK@?$allocator_traits@V?$allocator@K@std@@@std@@SAXAAV?$allocator@K@1@PAKAAK@Z ; std::allocator_traits<std::allocator<unsigned long> >::construct<unsigned long,unsigned long &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@KAAK@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKAAK@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned long> >::construct<unsigned long,unsigned long &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@$$CBK@std@@YAPBKABK@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBK@std@@YAPBKABK@Z PROC			; std::addressof<unsigned long const >, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@$$CBK@std@@YAPBKABK@Z ENDP			; std::addressof<unsigned long const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PAUHINSTANCE__@@ABQAU1@@?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAEXPAPAUHINSTANCE__@@ABQAU2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PAUHINSTANCE__@@ABQAU1@@?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAEXPAPAUHINSTANCE__@@ABQAU2@@Z PROC ; std::_Wrap_alloc<std::allocator<HINSTANCE__ *> >::construct<HINSTANCE__ *,HINSTANCE__ * const &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@ABQAUHINSTANCE__@@@std@@YAABQAUHINSTANCE__@@ABQAU1@@Z ; std::forward<HINSTANCE__ * const &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PAUHINSTANCE__@@ABQAU1@@?$allocator_traits@V?$allocator@PAUHINSTANCE__@@@std@@@std@@SAXAAV?$allocator@PAUHINSTANCE__@@@1@PAPAUHINSTANCE__@@ABQAU3@@Z ; std::allocator_traits<std::allocator<HINSTANCE__ *> >::construct<HINSTANCE__ *,HINSTANCE__ * const &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PAUHINSTANCE__@@ABQAU1@@?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAEXPAPAUHINSTANCE__@@ABQAU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<HINSTANCE__ *> >::construct<HINSTANCE__ *,HINSTANCE__ * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PAUHINSTANCE__@@AAPAU1@@?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAEXPAPAUHINSTANCE__@@AAPAU2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__V0$ = 12						; size = 4
??$construct@PAUHINSTANCE__@@AAPAU1@@?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAEXPAPAUHINSTANCE__@@AAPAU2@@Z PROC ; std::_Wrap_alloc<std::allocator<HINSTANCE__ *> >::construct<HINSTANCE__ *,HINSTANCE__ * &>, COMDAT
; _this$ = ecx

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __V0$[ebp]
	push	eax
	call	??$forward@AAPAUHINSTANCE__@@@std@@YAAAPAUHINSTANCE__@@AAPAU1@@Z ; std::forward<HINSTANCE__ * &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@PAUHINSTANCE__@@AAPAU1@@?$allocator_traits@V?$allocator@PAUHINSTANCE__@@@std@@@std@@SAXAAV?$allocator@PAUHINSTANCE__@@@1@PAPAUHINSTANCE__@@AAPAU3@@Z ; std::allocator_traits<std::allocator<HINSTANCE__ *> >::construct<HINSTANCE__ *,HINSTANCE__ * &>
	add	esp, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@PAUHINSTANCE__@@AAPAU1@@?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAEXPAPAUHINSTANCE__@@AAPAU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<HINSTANCE__ *> >::construct<HINSTANCE__ *,HINSTANCE__ * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@QAUHINSTANCE__@@@std@@YAPBQAUHINSTANCE__@@ABQAU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@QAUHINSTANCE__@@@std@@YAPBQAUHINSTANCE__@@ABQAU1@@Z PROC ; std::addressof<HINSTANCE__ * const>, COMDAT

; 85   : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	eax, DWORD PTR __Val$[ebp]

; 89   : 	}

	pop	ebp
	ret	0
??$addressof@QAUHINSTANCE__@@@std@@YAPBQAUHINSTANCE__@@ABQAU1@@Z ENDP ; std::addressof<HINSTANCE__ * const>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::operator++, COMDAT
; _this$ = ecx

; 339  : 		{	// postincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 340  : 		_Myiter _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$[ebp], ecx

; 341  : 		++*this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::operator++

; 342  : 		return (_Tmp);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Tmp$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 343  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::operator++, COMDAT
; _this$ = ecx

; 333  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 334  : 		++*(_Mybase *)this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::operator++

; 335  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 336  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBEAAKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBEAAKXZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::operator*, COMDAT
; _this$ = ecx

; 323  : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 324  : 		return ((reference)**(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBEABKXZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::operator*

; 325  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBEAAKXZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAE@PAKPBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAE@PAKPBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAE@PAKPBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >

; 307  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAE@PAKPBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >, COMDAT
; _this$ = ecx

; 300  : 	_Vector_iterator()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >

; 301  : 		{	// construct with null vector pointer
; 302  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::_Compat, COMDAT
; _this$ = ecx

; 254  : 		{	// test for compatible iterator pair

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 255  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv69 = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::operator!=, COMDAT
; _this$ = ecx

; 209  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 210  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::operator==
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 211  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 		_Compat(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::_Compat

; 205  : 		return (this->_Ptr == _Right._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 206  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::operator++, COMDAT
; _this$ = ecx

; 95   : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 113  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 114  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBEABKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBEABKXZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::operator*, COMDAT
; _this$ = ecx

; 65   : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 87   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBEABKXZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAE@PAKPBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAE@PAKPBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [eax], ecx

; 48   : 		this->_Adopt(_Pvector);

	mov	edx, DWORD PTR __Pvector$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z	; std::_Iterator_base0::_Adopt

; 49   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAE@PAKPBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >, COMDAT
; _this$ = ecx

; 42   : 		{	// construct with null pointer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 43   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@KV?$allocator@K@std@@@std@@IBEXPAK0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@KV?$allocator@K@std@@@std@@IBEXPAK0@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1693 : 		{	// orphan iterators within specified (inclusive) range

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1694 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Orphan_range@?$vector@KV?$allocator@K@std@@@std@@IBEXPAK0@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@KV?$allocator@K@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@KV?$allocator@K@std@@@std@@IBEXXZ PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlen, COMDAT
; _this$ = ecx

; 1666 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1667 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 1668 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$vector@KV?$allocator@K@std@@@std@@IBEXXZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@KV?$allocator@K@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Tidy@?$vector@KV?$allocator@K@std@@@std@@IAEXXZ PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::_Tidy, COMDAT
; _this$ = ecx

; 1535 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1536 : 		if (this->_Myfirst != pointer())

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Tidy

; 1537 : 			{	// something to free, destroy and deallocate it
; 1538 : 			this->_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1539 : 			_Destroy(this->_Myfirst, this->_Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@KV?$allocator@K@std@@@std@@IAEXPAK0@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Destroy

; 1540 : 			this->_Getal().deallocate(this->_Myfirst,
; 1541 : 				this->_Myend - this->_Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax]
	sar	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKI@Z ; std::_Wrap_alloc<std::allocator<unsigned long> >::deallocate

; 1542 : 			this->_Myfirst = pointer();

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0

; 1543 : 			this->_Mylast = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 1544 : 			this->_Myend = pointer();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
$LN2@Tidy:

; 1545 : 			}
; 1546 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@KV?$allocator@K@std@@@std@@IAEXXZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@KV?$allocator@K@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@KV?$allocator@K@std@@@std@@IAEXI@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Reserve, COMDAT
; _this$ = ecx

; 1525 : 		{	// ensure room for _Count new elements, grow exponentially

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1526 : 		if (_Unused_capacity() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Unused_capacity@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Unused_capacity
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN4@Reserve

; 1527 : 			{	// need more room, try to get it
; 1528 : 			if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN1@Reserve

; 1529 : 				_Xlen();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$vector@KV?$allocator@K@std@@@std@@IBEXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlen
$LN1@Reserve:

; 1530 : 			_Reallocate(_Grow_to(size() + _Count));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::size
	add	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow_to@?$vector@KV?$allocator@K@std@@@std@@IBEII@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Grow_to
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reallocate@?$vector@KV?$allocator@K@std@@@std@@IAEXI@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Reallocate
$LN4@Reserve:

; 1531 : 			}
; 1532 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Reserve@?$vector@KV?$allocator@K@std@@@std@@IAEXI@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@KV?$allocator@K@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -32						; size = 4
__Ptr$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?_Reallocate@?$vector@KV?$allocator@K@std@@@std@@IAEXI@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Reallocate, COMDAT
; _this$ = ecx

; 1500 : 		{	// move to array of exactly _Count elements

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Reallocate@?$vector@KV?$allocator@K@std@@@std@@IAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1501 : 		pointer _Ptr = this->_Getal().allocate(_Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Getal
	mov	ecx, eax
	call	?allocate@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEPAKI@Z ; std::_Wrap_alloc<std::allocator<unsigned long> >::allocate
	mov	DWORD PTR __Ptr$[ebp], eax

; 1502 : 
; 1503 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1504 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);

	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAK@?$vector@KV?$allocator@K@std@@@std@@IAEPAKPAK00@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Umove<unsigned long *>
	jmp	SHORT $LN5@Reallocate
__catch$?_Reallocate@?$vector@KV?$allocator@K@std@@@std@@IAEXI@Z$0:

; 1505 : 		_CATCH_ALL
; 1506 : 		this->_Getal().deallocate(_Ptr, _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKI@Z ; std::_Wrap_alloc<std::allocator<unsigned long> >::deallocate

; 1507 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1508 : 		_CATCH_END

	mov	eax, $LN8@Reallocate
	ret	0
$LN5@Reallocate:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Reallocate@?$vector@KV?$allocator@K@std@@@std@@IAEXI@Z$1
$LN8@Reallocate:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Reallocate@?$vector@KV?$allocator@K@std@@@std@@IAEXI@Z$1:

; 1509 : 
; 1510 : 		size_type _Size = size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::size
	mov	DWORD PTR __Size$[ebp], eax

; 1511 : 		if (this->_Myfirst != pointer())

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN1@Reallocate

; 1512 : 			{	// destroy and deallocate old array
; 1513 : 			_Destroy(this->_Myfirst, this->_Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@KV?$allocator@K@std@@@std@@IAEXPAK0@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Destroy

; 1514 : 			this->_Getal().deallocate(this->_Myfirst,
; 1515 : 				this->_Myend - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx]
	sar	edx, 2
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKI@Z ; std::_Wrap_alloc<std::allocator<unsigned long> >::deallocate
$LN1@Reallocate:

; 1516 : 			}
; 1517 : 
; 1518 : 		this->_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1519 : 		this->_Myend = _Ptr + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 1520 : 		this->_Mylast = _Ptr + _Size;

	mov	ecx, DWORD PTR __Size$[ebp]
	mov	edx, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1521 : 		this->_Myfirst = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx], eax
$LN4@Reallocate:

; 1522 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate@?$vector@KV?$allocator@K@std@@@std@@IAEXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Reallocate@?$vector@KV?$allocator@K@std@@@std@@IAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Reallocate@?$vector@KV?$allocator@K@std@@@std@@IAEXI@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Reallocate
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@KV?$allocator@K@std@@@std@@IBE_NPBK@Z
_TEXT	SEGMENT
tv76 = -8						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@KV?$allocator@K@std@@@std@@IBE_NPBK@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Inside, COMDAT
; _this$ = ecx

; 1495 : 		{	// test if _Ptr points inside vector

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1496 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN3@Inside
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN4@Inside
$LN3@Inside:
	mov	DWORD PTR tv76[ebp], 0
$LN4@Inside:
	mov	al, BYTE PTR tv76[ebp]

; 1497 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$vector@KV?$allocator@K@std@@@std@@IBE_NPBK@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@KV?$allocator@K@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -12						; size = 4
_this$ = -8						; size = 4
__Capacity$ = -4					; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@KV?$allocator@K@std@@@std@@IBEII@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Grow_to, COMDAT
; _this$ = ecx

; 1484 : 		{	// grow by 50% or at least to _Count

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1485 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN4@Grow_to
	mov	DWORD PTR tv73[ebp], 0
	jmp	SHORT $LN5@Grow_to
$LN4@Grow_to:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv73[ebp], edx
$LN5@Grow_to:
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1489 : 		if (_Capacity < _Count)

	mov	ecx, DWORD PTR __Capacity$[ebp]
	cmp	ecx, DWORD PTR __Count$[ebp]
	jae	SHORT $LN1@Grow_to

; 1490 : 			_Capacity = _Count;

	mov	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx
$LN1@Grow_to:

; 1491 : 		return (_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]

; 1492 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Grow_to@?$vector@KV?$allocator@K@std@@@std@@IBEII@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@KV?$allocator@K@std@@@std@@IAEXPAK0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Alval$ = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@KV?$allocator@K@std@@@std@@IAEXPAK0@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Destroy, COMDAT
; _this$ = ecx

; 1478 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1479 : 		_Alty _Alval(this->_Getal());

	lea	eax, DWORD PTR __Alval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Getal

; 1480 : 		_Destroy_range(_First, _Last, _Alval);

	lea	ecx, DWORD PTR __Alval$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@@std@@YAXPAK0AAU?$_Wrap_alloc@V?$allocator@K@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<unsigned long> > >
	add	esp, 12					; 0000000cH

; 1481 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@KV?$allocator@K@std@@@std@@IAEXPAK0@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?push_back@?$vector@KV?$allocator@K@std@@@std@@QAEXABK@Z
_TEXT	SEGMENT
__Idx$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Val$ = 8						; size = 4
?push_back@?$vector@KV?$allocator@K@std@@@std@@QAEXABK@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::push_back, COMDAT
; _this$ = ecx

; 1184 : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1185 : 		if (_Inside(_STD addressof(_Val)))

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$addressof@$$CBK@std@@YAPBKABK@Z	; std::addressof<unsigned long const >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$vector@KV?$allocator@K@std@@@std@@IBE_NPBK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@push_back

; 1186 : 			{	// push back an element
; 1187 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	??$addressof@$$CBK@std@@YAPBKABK@Z	; std::addressof<unsigned long const >
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	mov	DWORD PTR __Idx$1[ebp], eax

; 1188 : 			if (this->_Mylast == this->_Myend)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN3@push_back

; 1189 : 				_Reserve(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reserve@?$vector@KV?$allocator@K@std@@@std@@IAEXI@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Reserve
$LN3@push_back:

; 1190 : 			_Orphan_range(this->_Mylast, this->_Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@KV?$allocator@K@std@@@std@@IBEXPAK0@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Orphan_range

; 1191 : 			this->_Getal().construct(this->_Mylast,
; 1192 : 				this->_Myfirst[_Idx]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Idx$1[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Getal
	mov	ecx, eax
	call	??$construct@KAAK@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKAAK@Z ; std::_Wrap_alloc<std::allocator<unsigned long> >::construct<unsigned long,unsigned long &>

; 1193 : 			++this->_Mylast;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 1194 : 			}
; 1195 : 		else

	jmp	SHORT $LN5@push_back
$LN4@push_back:

; 1196 : 			{	// push back a non-element
; 1197 : 			if (this->_Mylast == this->_Myend)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN1@push_back

; 1198 : 				_Reserve(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reserve@?$vector@KV?$allocator@K@std@@@std@@IAEXI@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Reserve
$LN1@push_back:

; 1199 : 			_Orphan_range(this->_Mylast, this->_Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@KV?$allocator@K@std@@@std@@IBEXPAK0@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Orphan_range

; 1200 : 			this->_Getal().construct(this->_Mylast,
; 1201 : 				_Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Getal
	mov	ecx, eax
	call	??$construct@KABK@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKABK@Z ; std::_Wrap_alloc<std::allocator<unsigned long> >::construct<unsigned long,unsigned long const &>

; 1202 : 			++this->_Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
$LN5@push_back:

; 1203 : 			}
; 1204 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@KV?$allocator@K@std@@@std@@QAEXABK@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?max_size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::max_size, COMDAT
; _this$ = ecx

; 1091 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1092 : 		return (this->_Getal().max_size());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<unsigned long> >::max_size

; 1093 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::size, COMDAT
; _this$ = ecx

; 1086 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1087 : 		return (this->_Mylast - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1088 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?end@?$vector@KV?$allocator@K@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@KV?$allocator@K@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@2@XZ PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::end, COMDAT
; _this$ = ecx

; 991  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 992  : 		return (iterator(this->_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAE@PAKPBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 993  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@KV?$allocator@K@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@2@XZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?begin@?$vector@KV?$allocator@K@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@KV?$allocator@K@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@2@XZ PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::begin, COMDAT
; _this$ = ecx

; 981  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 982  : 		return (iterator(this->_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAE@PAKPBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 983  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@KV?$allocator@K@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@2@XZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Unused_capacity@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 971  : 		{	// micro-optimization for capacity() - size()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 972  : 		return (this->_Myend - this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 973  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Unused_capacity@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?capacity@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::capacity, COMDAT
; _this$ = ecx

; 966  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 967  : 		return (this->_Myend - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 968  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@KV?$allocator@K@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >, COMDAT
; _this$ = ecx

; 899  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 900  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@KV?$allocator@K@std@@@std@@IAEXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Tidy

; 901  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >, COMDAT
; _this$ = ecx

; 685  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@K@std@@QAE@XZ		; std::allocator<unsigned long>::allocator<unsigned long>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAE@ABV?$allocator@K@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Vector_alloc<0,std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >

; 686  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Getal, COMDAT
; _this$ = ecx

; 646  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 647  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<unsigned long> >::_Wrap_alloc<std::allocator<unsigned long> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 648  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAE@ABV?$allocator@K@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAE@ABV?$allocator@K@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Vector_alloc<0,std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >, COMDAT
; _this$ = ecx

; 593  : 	_Vector_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@U?$_Simple_types@K@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<unsigned long> >::_Vector_val<std::_Simple_types<unsigned long> >

; 594  : 		{	// construct allocator from _Al
; 595  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@KV?$allocator@K@std@@@std@@@std@@QAE@ABV?$allocator@K@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >::_Vector_alloc<0,std::_Vec_base_types<unsigned long,std::allocator<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_val@U?$_Simple_types@K@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<unsigned long> >::_Vector_val<std::_Simple_types<unsigned long> >, COMDAT
; _this$ = ecx

; 484  : 	_Vector_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 485  : 		{	// initialize values
; 486  : 		_Myfirst = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 487  : 		_Mylast = pointer();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 488  : 		_Myend = pointer();

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 489  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Vector_val@U?$_Simple_types@K@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<unsigned long> >::_Vector_val<std::_Simple_types<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<unsigned long> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@K@std@@@std@@SAIABV?$allocator@K@2@@Z ; std::allocator_traits<std::allocator<unsigned long> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<unsigned long> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKI@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned long> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@K@std@@QAEXPAKI@Z ; std::allocator<unsigned long>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKI@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned long> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEPAKI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEPAKI@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned long> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@K@std@@QAEPAKI@Z	; std::allocator<unsigned long>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEPAKI@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned long> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<unsigned long> >::_Wrap_alloc<std::allocator<unsigned long> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@K@std@@QAE@XZ		; std::allocator<unsigned long>::allocator<unsigned long>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<unsigned long> >::_Wrap_alloc<std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@K@std@@@std@@SAIABV?$allocator@K@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@K@std@@@std@@SAIABV?$allocator@K@2@@Z PROC ; std::allocator_traits<std::allocator<unsigned long> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@K@std@@QBEIXZ	; std::allocator<unsigned long>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@K@std@@@std@@SAIABV?$allocator@K@2@@Z ENDP ; std::allocator_traits<std::allocator<unsigned long> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@K@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@K@std@@QBEIXZ PROC		; std::allocator<unsigned long>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 1073741823				; 3fffffffH

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@K@std@@QBEIXZ ENDP		; std::allocator<unsigned long>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@K@std@@QAEXPAKABK@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv68 = -8						; size = 4
$T1 = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@K@std@@QAEXPAKABK@Z PROC		; std::allocator<unsigned long>::construct, COMDAT
; _this$ = ecx

; 605  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR $T1[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR tv68[ebp], ecx
	jmp	SHORT $LN1@construct
$LN3@construct:
	mov	DWORD PTR tv68[ebp], 0
$LN1@construct:

; 607  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@K@std@@QAEXPAKABK@Z ENDP		; std::allocator<unsigned long>::construct
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@K@std@@QAEPAKI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@K@std@@QAEPAKI@Z PROC		; std::allocator<unsigned long>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@K@std@@YAPAKIPAK@Z		; std::_Allocate<unsigned long>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@K@std@@QAEPAKI@Z ENDP		; std::allocator<unsigned long>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@K@std@@QAEXPAKI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@K@std@@QAEXPAKI@Z PROC		; std::allocator<unsigned long>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@K@std@@QAEXPAKI@Z ENDP		; std::allocator<unsigned long>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@K@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@K@std@@QAE@XZ PROC			; std::allocator<unsigned long>::allocator<unsigned long>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@K@std@@QAE@XZ ENDP			; std::allocator<unsigned long>::allocator<unsigned long>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\diagassert.cpp
_TEXT	SEGMENT
_stIHL$1 = -896						; size = 20
_szName$2 = -876					; size = 4
_dwDisp$ = -872						; size = 4
_pIHS$ = -868						; size = 4
_pCurrPos$ = -864					; size = 4
_stIHM$ = -860						; size = 572
_szTemp$ = -288						; size = 284
__$ArrayPad$ = -4					; size = 4
_dwAddr$ = 8						; size = 4
_szOutBuff$ = 12					; size = 4
?ConvertAddress@@YAKKPAD@Z PROC				; ConvertAddress

; 318  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 896				; 00000380H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 319  :     char szTemp [ MAX_PATH + sizeof ( IMAGEHLP_SYMBOL ) ] ;
; 320  : 
; 321  :     PIMAGEHLP_SYMBOL pIHS = (PIMAGEHLP_SYMBOL)&szTemp ;

	lea	eax, DWORD PTR _szTemp$[ebp]
	mov	DWORD PTR _pIHS$[ebp], eax

; 322  : 
; 323  :     IMAGEHLP_MODULE stIHM ;
; 324  : 
; 325  :     LPTSTR pCurrPos = szOutBuff ;

	mov	ecx, DWORD PTR _szOutBuff$[ebp]
	mov	DWORD PTR _pCurrPos$[ebp], ecx

; 326  : 
; 327  :     ZeroMemory ( pIHS , MAX_PATH + sizeof ( IMAGEHLP_SYMBOL ) ) ;

	push	284					; 0000011cH
	push	0
	mov	edx, DWORD PTR _pIHS$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 328  :     ZeroMemory ( &stIHM , sizeof ( IMAGEHLP_MODULE ) ) ;

	push	572					; 0000023cH
	push	0
	lea	eax, DWORD PTR _stIHM$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 329  : 
; 330  :     pIHS->SizeOfStruct = sizeof ( IMAGEHLP_SYMBOL ) ;

	mov	ecx, DWORD PTR _pIHS$[ebp]
	mov	DWORD PTR [ecx], 24			; 00000018H

; 331  :     pIHS->Address = dwAddr ;

	mov	edx, DWORD PTR _pIHS$[ebp]
	mov	eax, DWORD PTR _dwAddr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 332  :     pIHS->MaxNameLength = MAX_PATH ;

	mov	ecx, DWORD PTR _pIHS$[ebp]
	mov	DWORD PTR [ecx+16], 260			; 00000104H

; 333  : 
; 334  :     stIHM.SizeOfStruct = sizeof ( IMAGEHLP_MODULE ) ;

	mov	DWORD PTR _stIHM$[ebp], 572		; 0000023cH

; 335  : 
; 336  :     // Always stick the address in first.
; 337  :     pCurrPos += wsprintf ( pCurrPos , _T ( "0x%08X " ) , dwAddr ) ;

	mov	edx, DWORD PTR _dwAddr$[ebp]
	push	edx
	push	OFFSET ??_C@_07PEGDEKEA@0x?$CF08X?5?$AA@
	mov	eax, DWORD PTR _pCurrPos$[ebp]
	push	eax
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH
	add	eax, DWORD PTR _pCurrPos$[ebp]
	mov	DWORD PTR _pCurrPos$[ebp], eax

; 338  : 
; 339  :     // Get the module name.
; 340  :     if ( 0 != g_cSym.SymGetModuleInfo ( dwAddr , &stIHM ) )

	lea	ecx, DWORD PTR _stIHM$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwAddr$[ebp]
	push	edx
	mov	ecx, OFFSET _g_cSym
	call	?SymGetModuleInfo@CSymbolEngine@@QAEHKPAU_IMAGEHLP_MODULE@@@Z ; CSymbolEngine::SymGetModuleInfo
	test	eax, eax
	je	SHORT $LN10@ConvertAdd

; 341  :     {
; 342  :         // Strip off the path.
; 343  :         LPTSTR szName = _tcsrchr ( stIHM.ImageName , _T ( '\\' ) ) ;

	push	92					; 0000005cH
	lea	eax, DWORD PTR _stIHM$[ebp+60]
	push	eax
	call	?strrchr@@YAPADPADH@Z			; strrchr
	add	esp, 8
	mov	DWORD PTR _szName$2[ebp], eax

; 344  :         if ( NULL != szName )

	cmp	DWORD PTR _szName$2[ebp], 0
	je	SHORT $LN9@ConvertAdd

; 345  :         {
; 346  :             szName++ ;

	mov	ecx, DWORD PTR _szName$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _szName$2[ebp], ecx

; 347  :         }
; 348  :         else

	jmp	SHORT $LN8@ConvertAdd
$LN9@ConvertAdd:

; 349  :         {
; 350  :             szName = stIHM.ImageName ;

	lea	edx, DWORD PTR _stIHM$[ebp+60]
	mov	DWORD PTR _szName$2[ebp], edx
$LN8@ConvertAdd:

; 351  :         }
; 352  :         pCurrPos += wsprintf ( pCurrPos , _T ( "%s: " ) , szName ) ;

	mov	eax, DWORD PTR _szName$2[ebp]
	push	eax
	push	OFFSET ??_C@_04PFAOODAA@?$CFs?3?5?$AA@
	mov	ecx, DWORD PTR _pCurrPos$[ebp]
	push	ecx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH
	add	eax, DWORD PTR _pCurrPos$[ebp]
	mov	DWORD PTR _pCurrPos$[ebp], eax

; 353  :     }
; 354  :     else

	jmp	SHORT $LN7@ConvertAdd
$LN10@ConvertAdd:

; 355  :     {
; 356  :         pCurrPos += wsprintf ( pCurrPos , _T ( "<unknown module>: " ) );

	push	OFFSET ??_C@_0BD@LGBHNHKC@?$DMunknown?5module?$DO?3?5?$AA@
	mov	edx, DWORD PTR _pCurrPos$[ebp]
	push	edx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 8
	add	eax, DWORD PTR _pCurrPos$[ebp]
	mov	DWORD PTR _pCurrPos$[ebp], eax
$LN7@ConvertAdd:

; 357  :     }
; 358  : 
; 359  :     // Get the function.
; 360  :     DWORD dwDisp ;
; 361  :     if ( 0 != g_cSym.SymGetSymFromAddr ( dwAddr , &dwDisp , pIHS ) )

	mov	eax, DWORD PTR _pIHS$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dwDisp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwAddr$[ebp]
	push	edx
	mov	ecx, OFFSET _g_cSym
	call	?SymGetSymFromAddr@CSymbolEngine@@QAEHKPAKPAU_IMAGEHLP_SYMBOL@@@Z ; CSymbolEngine::SymGetSymFromAddr
	test	eax, eax
	je	$LN6@ConvertAdd

; 362  :     {
; 363  :         if ( 0 == dwDisp )

	cmp	DWORD PTR _dwDisp$[ebp], 0
	jne	SHORT $LN5@ConvertAdd

; 364  :         {
; 365  :             pCurrPos += wsprintf ( pCurrPos , _T ( "%s" ) , pIHS->Name);

	mov	eax, DWORD PTR _pIHS$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	push	OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
	mov	ecx, DWORD PTR _pCurrPos$[ebp]
	push	ecx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH
	add	eax, DWORD PTR _pCurrPos$[ebp]
	mov	DWORD PTR _pCurrPos$[ebp], eax

; 366  :         }
; 367  :         else

	jmp	SHORT $LN4@ConvertAdd
$LN5@ConvertAdd:

; 368  :         {
; 369  :             pCurrPos += wsprintf ( pCurrPos               ,
; 370  :                                    _T ( "%s + %d bytes" ) ,
; 371  :                                    pIHS->Name             ,
; 372  :                                    dwDisp                  ) ;

	mov	edx, DWORD PTR _dwDisp$[ebp]
	push	edx
	mov	eax, DWORD PTR _pIHS$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	push	OFFSET ??_C@_0O@NOLLDIJH@?$CFs?5?$CL?5?$CFd?5bytes?$AA@
	mov	ecx, DWORD PTR _pCurrPos$[ebp]
	push	ecx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _pCurrPos$[ebp]
	mov	DWORD PTR _pCurrPos$[ebp], eax
$LN4@ConvertAdd:

; 373  :         }
; 374  : 
; 375  :         // If I got a symbol, give the source and line a whirl.
; 376  :         IMAGEHLP_LINE stIHL ;
; 377  : 
; 378  :         ZeroMemory ( &stIHL , sizeof ( IMAGEHLP_LINE ) ) ;

	push	20					; 00000014H
	push	0
	lea	edx, DWORD PTR _stIHL$1[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 379  : 
; 380  :         stIHL.SizeOfStruct = sizeof ( IMAGEHLP_LINE ) ;

	mov	DWORD PTR _stIHL$1[ebp], 20		; 00000014H

; 381  : 
; 382  :         if ( 0 != g_cSym.SymGetLineFromAddr ( dwAddr  ,
; 383  :                                               &dwDisp ,
; 384  :                                               &stIHL   ) )

	lea	eax, DWORD PTR _stIHL$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _dwDisp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwAddr$[ebp]
	push	edx
	mov	ecx, OFFSET _g_cSym
	call	?SymGetLineFromAddr@CSymbolEngine@@QAEHKPAKPAU_IMAGEHLP_LINE@@@Z ; CSymbolEngine::SymGetLineFromAddr
	test	eax, eax
	je	SHORT $LN3@ConvertAdd

; 385  :         {
; 386  :             // Put this on the next line and indented a bit.
; 387  :             pCurrPos += wsprintf ( pCurrPos                  ,
; 388  :                                   _T ( "\n\t\t%s, Line %d" ) ,
; 389  :                                   stIHL.FileName             ,
; 390  :                                   stIHL.LineNumber            ) ;

	mov	eax, DWORD PTR _stIHL$1[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _stIHL$1[ebp+12]
	push	ecx
	push	OFFSET ??_C@_0P@MKDHEAFE@?6?7?7?$CFs?0?5Line?5?$CFd?$AA@
	mov	edx, DWORD PTR _pCurrPos$[ebp]
	push	edx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _pCurrPos$[ebp]
	mov	DWORD PTR _pCurrPos$[ebp], eax

; 391  :             if ( 0 != dwDisp )

	cmp	DWORD PTR _dwDisp$[ebp], 0
	je	SHORT $LN3@ConvertAdd

; 392  :             {
; 393  :                 pCurrPos += wsprintf ( pCurrPos             ,
; 394  :                                        _T ( " + %d bytes" ) ,
; 395  :                                        dwDisp                ) ;

	mov	eax, DWORD PTR _dwDisp$[ebp]
	push	eax
	push	OFFSET ??_C@_0M@DKCMIBMA@?5?$CL?5?$CFd?5bytes?$AA@
	mov	ecx, DWORD PTR _pCurrPos$[ebp]
	push	ecx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH
	add	eax, DWORD PTR _pCurrPos$[ebp]
	mov	DWORD PTR _pCurrPos$[ebp], eax
$LN3@ConvertAdd:

; 396  :             }
; 397  :         }
; 398  :     }
; 399  :     else

	jmp	SHORT $LN1@ConvertAdd
$LN6@ConvertAdd:

; 400  :     {
; 401  :         pCurrPos += wsprintf ( pCurrPos , _T ( "<unknown symbol>" ) ) ;

	push	OFFSET ??_C@_0BB@IICGLAA@?$DMunknown?5symbol?$DO?$AA@
	mov	edx, DWORD PTR _pCurrPos$[ebp]
	push	edx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 8
	add	eax, DWORD PTR _pCurrPos$[ebp]
	mov	DWORD PTR _pCurrPos$[ebp], eax
$LN1@ConvertAdd:

; 402  :     }
; 403  : 
; 404  :     // Tack on a CRLF.
; 405  :     pCurrPos += wsprintf ( pCurrPos , _T ( "\n" ) ) ;

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	mov	eax, DWORD PTR _pCurrPos$[ebp]
	push	eax
	call	DWORD PTR __imp__wsprintfA
	add	esp, 8
	add	eax, DWORD PTR _pCurrPos$[ebp]
	mov	DWORD PTR _pCurrPos$[ebp], eax

; 406  : 
; 407  :     return ( pCurrPos - szOutBuff ) ;

	mov	eax, DWORD PTR _pCurrPos$[ebp]
	sub	eax, DWORD PTR _szOutBuff$[ebp]

; 408  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?ConvertAddress@@YAKKPAD@Z ENDP				; ConvertAddress
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\diagassert.cpp
_TEXT	SEGMENT
_stMBI$1 = -876						; size = 28
tv94 = -848						; size = 4
_hFile$2 = -844						; size = 4
_dwNameLen$3 = -840					; size = 4
_stIHM$ = -836						; size = 572
_szFile$4 = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_hProcess$ = 8						; size = 4
_dwAddr$ = 12						; size = 4
?GetModBase@@YGKPAXK@Z PROC				; GetModBase

; 253  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 876				; 0000036cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 254  :     // Check in the symbol engine first.
; 255  :     IMAGEHLP_MODULE stIHM ;
; 256  : 
; 257  :     // This is what the MFC stack trace routines forgot to do so their
; 258  :     //  code will not get the info out of the symbol engine.
; 259  :     stIHM.SizeOfStruct = sizeof ( IMAGEHLP_MODULE ) ;

	mov	DWORD PTR _stIHM$[ebp], 572		; 0000023cH

; 260  : 
; 261  :     if ( g_cSym.SymGetModuleInfo ( dwAddr , &stIHM ) )

	lea	eax, DWORD PTR _stIHM$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwAddr$[ebp]
	push	ecx
	mov	ecx, OFFSET _g_cSym
	call	?SymGetModuleInfo@CSymbolEngine@@QAEHKPAU_IMAGEHLP_MODULE@@@Z ; CSymbolEngine::SymGetModuleInfo
	test	eax, eax
	je	SHORT $LN4@GetModBase

; 262  :     {
; 263  :         return ( stIHM.BaseOfImage ) ;

	mov	eax, DWORD PTR _stIHM$[ebp+4]
	jmp	$LN5@GetModBase

; 264  :     }
; 265  :     else

	jmp	$LN3@GetModBase
$LN4@GetModBase:

; 266  :     {
; 267  :         // Let's go fishing.
; 268  :         MEMORY_BASIC_INFORMATION stMBI ;
; 269  : 
; 270  :         if ( 0 != VirtualQueryEx ( hProcess         ,
; 271  :                                    (LPCVOID)dwAddr  ,
; 272  :                                    &stMBI           ,
; 273  :                                    sizeof ( stMBI )  ) )

	push	28					; 0000001cH
	lea	edx, DWORD PTR _stMBI$1[ebp]
	push	edx
	mov	eax, DWORD PTR _dwAddr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hProcess$[ebp]
	push	ecx
	call	DWORD PTR __imp__VirtualQueryEx@16
	test	eax, eax
	je	$LN3@GetModBase

; 274  :         {
; 275  :             // Try and load it.
; 276  :             DWORD dwNameLen = 0 ;

	mov	DWORD PTR _dwNameLen$3[ebp], 0

; 277  :             TCHAR szFile[ MAX_PATH ] ;
; 278  : 
; 279  :             dwNameLen = GetModuleFileName ( (HINSTANCE)
; 280  :                                                 stMBI.AllocationBase ,
; 281  :                                             szFile                   ,
; 282  :                                             MAX_PATH                  );

	push	260					; 00000104H
	lea	edx, DWORD PTR _szFile$4[ebp]
	push	edx
	mov	eax, DWORD PTR _stMBI$1[ebp+4]
	push	eax
	call	DWORD PTR __imp__GetModuleFileNameA@12
	mov	DWORD PTR _dwNameLen$3[ebp], eax

; 283  : 
; 284  :             HANDLE hFile = NULL ;

	mov	DWORD PTR _hFile$2[ebp], 0

; 285  : 
; 286  :             if ( 0 != dwNameLen )

	cmp	DWORD PTR _dwNameLen$3[ebp], 0
	je	SHORT $LN1@GetModBase

; 287  :             {
; 288  :                 hFile = CreateFile ( szFile       ,
; 289  :                                      GENERIC_READ    ,
; 290  :                                      FILE_SHARE_READ ,
; 291  :                                      NULL            ,
; 292  :                                      OPEN_EXISTING   ,
; 293  :                                      0               ,
; 294  :                                      0                ) ;

	push	0
	push	0
	push	3
	push	0
	push	1
	push	-2147483648				; 80000000H
	lea	ecx, DWORD PTR _szFile$4[ebp]
	push	ecx
	call	DWORD PTR __imp__CreateFileA@28
	mov	DWORD PTR _hFile$2[ebp], eax
$LN1@GetModBase:

; 295  :             }
; 296  : #ifdef _DEBUG
; 297  :             DWORD dwRet =
; 298  : #endif
; 299  :             g_cSym.SymLoadModule ( hFile                            ,
; 300  :                                    ( dwNameLen ? szFile : NULL )    ,
; 301  :                                    NULL                             ,
; 302  :                                    (DWORD)stMBI.AllocationBase      ,
; 303  :                                    0                                 ) ;

	cmp	DWORD PTR _dwNameLen$3[ebp], 0
	je	SHORT $LN7@GetModBase
	lea	edx, DWORD PTR _szFile$4[ebp]
	mov	DWORD PTR tv94[ebp], edx
	jmp	SHORT $LN8@GetModBase
$LN7@GetModBase:
	mov	DWORD PTR tv94[ebp], 0
$LN8@GetModBase:
	push	0
	mov	eax, DWORD PTR _stMBI$1[ebp+4]
	push	eax
	push	0
	mov	ecx, DWORD PTR tv94[ebp]
	push	ecx
	mov	edx, DWORD PTR _hFile$2[ebp]
	push	edx
	mov	ecx, OFFSET _g_cSym
	call	?SymLoadModule@CSymbolEngine@@QAEHPAXPAD1KK@Z ; CSymbolEngine::SymLoadModule

; 304  : #ifdef _DEBUG
; 305  :             if ( 0 == dwRet )
; 306  :             {
; 307  :                 TRACE ( "SymLoadModule failed : 0x%08X\n" ,
; 308  :                         GetLastError ( )                   ) ;
; 309  :             }
; 310  : #endif  // _DEBUG
; 311  :             return ( (DWORD)stMBI.AllocationBase ) ;

	mov	eax, DWORD PTR _stMBI$1[ebp+4]
	jmp	SHORT $LN5@GetModBase
$LN3@GetModBase:

; 312  :         }
; 313  :     }
; 314  :     return ( 0 ) ;

	xor	eax, eax
$LN5@GetModBase:

; 315  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
?GetModBase@@YGKPAXK@Z ENDP				; GetModBase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::operator++, COMDAT
; _this$ = ecx

; 339  : 		{	// postincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 340  : 		_Myiter _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$[ebp], ecx

; 341  : 		++*this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::operator++

; 342  : 		return (_Tmp);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Tmp$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 343  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::operator++, COMDAT
; _this$ = ecx

; 333  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 334  : 		++*(_Mybase *)this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::operator++

; 335  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 336  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QBEAAPAUHINSTANCE__@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QBEAAPAUHINSTANCE__@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::operator*, COMDAT
; _this$ = ecx

; 323  : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 324  : 		return ((reference)**(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QBEABQAUHINSTANCE__@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::operator*

; 325  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QBEAAPAUHINSTANCE__@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QAE@PAPAUHINSTANCE__@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QAE@PAPAUHINSTANCE__@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >, COMDAT
; _this$ = ecx

; 306  : 		{	// construct with pointer _Parg

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QAE@PAPAUHINSTANCE__@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >

; 307  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QAE@PAPAUHINSTANCE__@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >, COMDAT
; _this$ = ecx

; 300  : 	_Vector_iterator()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >

; 301  : 		{	// construct with null vector pointer
; 302  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::_Compat, COMDAT
; _this$ = ecx

; 254  : 		{	// test for compatible iterator pair

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 255  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv69 = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::operator!=, COMDAT
; _this$ = ecx

; 209  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 210  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::operator==
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 211  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 		_Compat(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::_Compat

; 205  : 		return (this->_Ptr == _Right._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 206  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::operator++, COMDAT
; _this$ = ecx

; 95   : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 113  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 114  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QBEABQAUHINSTANCE__@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QBEABQAUHINSTANCE__@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::operator*, COMDAT
; _this$ = ecx

; 65   : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 87   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QBEABQAUHINSTANCE__@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QAE@PAPAUHINSTANCE__@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QAE@PAPAUHINSTANCE__@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [eax], ecx

; 48   : 		this->_Adopt(_Pvector);

	mov	edx, DWORD PTR __Pvector$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z	; std::_Iterator_base0::_Adopt

; 49   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QAE@PAPAUHINSTANCE__@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >, COMDAT
; _this$ = ecx

; 42   : 		{	// construct with null pointer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 43   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\diagassert.cpp
_TEXT	SEGMENT
$T2 = -1472						; size = 4
$T3 = -1468						; size = 4
$T4 = -1464						; size = 4
_vAddrs$ = -1460					; size = 12
_dwOpts$5 = -1448					; size = 4
_dwMachine$6 = -1444					; size = 4
_dwSizeLeft$7 = -1440					; size = 4
_szCurrPos$8 = -1436					; size = 4
_hProcess$ = -1432					; size = 4
_dwSymSize$9 = -1428					; size = 4
_loop$10 = -1424					; size = 4
_i$11 = -1420						; size = 4
_stCtx$ = -1416						; size = 716
_stFrame$12 = -700					; size = 164
_szSym$13 = -536					; size = 520
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_szString$ = 8						; size = 4
_dwSize$ = 12						; size = 4
_dwNumSkip$ = 16					; size = 4
?DoStackTrace@@YAXPADKK@Z PROC				; DoStackTrace

; 413  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DoStackTrace@@YAXPADKK@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1460				; 000005b4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 414  :     HANDLE hProcess = GetCurrentProcess ( ) ;

	call	DWORD PTR __imp__GetCurrentProcess@0
	mov	DWORD PTR _hProcess$[ebp], eax

; 415  : 
; 416  :     // If the symbol engine is not initialized, do it now.
; 417  :     if ( FALSE == g_bSymIsInit )

	cmp	DWORD PTR _g_bSymIsInit, 0
	jne	SHORT $LN14@DoStackTra

; 418  :     {
; 419  :         DWORD dwOpts = SymGetOptions ( ) ;

	call	DWORD PTR __imp__SymGetOptions@0
	mov	DWORD PTR _dwOpts$5[ebp], eax

; 420  : 
; 421  :         // Turn on load lines.
; 422  :         SymSetOptions ( dwOpts                |
; 423  :                         SYMOPT_LOAD_LINES      ) ;

	mov	eax, DWORD PTR _dwOpts$5[ebp]
	or	eax, 16					; 00000010H
	push	eax
	call	DWORD PTR __imp__SymSetOptions@4

; 424  : 
; 425  :         if ( FALSE == g_cSym.SymInitialize ( hProcess ,
; 426  :                                              NULL     ,
; 427  :                                              FALSE     ) )

	push	0
	push	0
	mov	ecx, DWORD PTR _hProcess$[ebp]
	push	ecx
	mov	ecx, OFFSET _g_cSym
	call	?SymInitialize@CSymbolEngine@@QAEHPAXPADH@Z ; CSymbolEngine::SymInitialize
	test	eax, eax
	jne	SHORT $LN13@DoStackTra

; 428  :         {
; 429  : 
; 430  :         }
; 431  :         else

	jmp	SHORT $LN14@DoStackTra
$LN13@DoStackTra:

; 432  :         {
; 433  :             g_bSymIsInit = TRUE ;

	mov	DWORD PTR _g_bSymIsInit, 1
$LN14@DoStackTra:

; 434  :         }
; 435  :     }
; 436  : 
; 437  :     // The symbol engine is initialized so do the stack walk.
; 438  : 
; 439  :     // The array of addresses.
; 440  :     ADDRVECTOR vAddrs ;

	lea	ecx, DWORD PTR _vAddrs$[ebp]
	call	??0?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ; std::vector<unsigned long,std::allocator<unsigned long> >::vector<unsigned long,std::allocator<unsigned long> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 441  : 
; 442  :     // The thread information.
; 443  :     CONTEXT    stCtx  ;
; 444  : 
; 445  :     stCtx.ContextFlags = CONTEXT_FULL ;

	mov	DWORD PTR _stCtx$[ebp], 65543		; 00010007H

; 446  : 
; 447  :     if ( GetThreadContext ( GetCurrentThread ( ) , &stCtx ) )

	lea	edx, DWORD PTR _stCtx$[ebp]
	push	edx
	call	DWORD PTR __imp__GetCurrentThread@0
	push	eax
	call	DWORD PTR __imp__GetThreadContext@8
	test	eax, eax
	je	$LN11@DoStackTra

; 448  :     {
; 449  :         STACKFRAME stFrame ;
; 450  :         DWORD      dwMachine ;
; 451  : 
; 452  :         ZeroMemory ( &stFrame , sizeof ( STACKFRAME ) ) ;

	push	164					; 000000a4H
	push	0
	lea	eax, DWORD PTR _stFrame$12[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 453  : 
; 454  :         stFrame.AddrPC.Mode = AddrModeFlat ;

	mov	DWORD PTR _stFrame$12[ebp+8], 3

; 455  : 
; 456  : #if defined (_M_IX86)
; 457  :         dwMachine                = IMAGE_FILE_MACHINE_I386 ;

	mov	DWORD PTR _dwMachine$6[ebp], 332	; 0000014cH

; 458  :         stFrame.AddrPC.Offset    = stCtx.Eip    ;

	mov	ecx, DWORD PTR _stCtx$[ebp+184]
	mov	DWORD PTR _stFrame$12[ebp], ecx

; 459  :         stFrame.AddrStack.Offset = stCtx.Esp    ;

	mov	edx, DWORD PTR _stCtx$[ebp+196]
	mov	DWORD PTR _stFrame$12[ebp+36], edx

; 460  :         stFrame.AddrStack.Mode   = AddrModeFlat ;

	mov	DWORD PTR _stFrame$12[ebp+44], 3

; 461  :         stFrame.AddrFrame.Offset = stCtx.Ebp    ;

	mov	eax, DWORD PTR _stCtx$[ebp+180]
	mov	DWORD PTR _stFrame$12[ebp+24], eax

; 462  :         stFrame.AddrFrame.Mode   = AddrModeFlat ;

	mov	DWORD PTR _stFrame$12[ebp+32], 3

; 463  : 
; 464  : #elif defined (_M_ALPHA)
; 465  :         dwMachine                = IMAGE_FILE_MACHINE_ALPHA ;
; 466  :         stFrame.AddrPC.Offset    = (unsigned long)stCtx.Fir ;
; 467  : #else
; 468  : #error ( "Unknown machine!" )
; 469  : #endif
; 470  : 
; 471  :         // Loop for the first 512 stack elements.
; 472  :         for ( DWORD i = 0 ; i < 512 ; i++ )

	mov	DWORD PTR _i$11[ebp], 0
	jmp	SHORT $LN10@DoStackTra
$LN9@DoStackTra:
	mov	ecx, DWORD PTR _i$11[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$11[ebp], ecx
$LN10@DoStackTra:
	cmp	DWORD PTR _i$11[ebp], 512		; 00000200H
	jae	SHORT $LN8@DoStackTra

; 473  :         {
; 474  :             if ( FALSE == StackWalk ( dwMachine              ,
; 475  :                                       hProcess               ,
; 476  :                                       hProcess               ,
; 477  :                                       &stFrame               ,
; 478  :                                       &stCtx                 ,
; 479  :                                       NULL                   ,
; 480  :                                       SymFunctionTableAccess ,
; 481  :                                       GetModBase             ,
; 482  :                                       NULL                    ) )

	push	0
	push	OFFSET ?GetModBase@@YGKPAXK@Z		; GetModBase
	mov	edx, DWORD PTR __imp__SymFunctionTableAccess@8
	push	edx
	push	0
	lea	eax, DWORD PTR _stCtx$[ebp]
	push	eax
	lea	ecx, DWORD PTR _stFrame$12[ebp]
	push	ecx
	mov	edx, DWORD PTR _hProcess$[ebp]
	push	edx
	mov	eax, DWORD PTR _hProcess$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwMachine$6[ebp]
	push	ecx
	call	DWORD PTR __imp__StackWalk@36
	test	eax, eax
	jne	SHORT $LN7@DoStackTra

; 483  :             {
; 484  :                 break ;

	jmp	SHORT $LN8@DoStackTra
$LN7@DoStackTra:

; 485  :             }
; 486  :             if ( i > dwNumSkip )

	mov	edx, DWORD PTR _i$11[ebp]
	cmp	edx, DWORD PTR _dwNumSkip$[ebp]
	jbe	SHORT $LN6@DoStackTra

; 487  :             {
; 488  :                 // Also check that the address is not zero.  Sometimes
; 489  :                 //  StackWalk returns TRUE with a frame of zero.
; 490  :                 if ( 0 != stFrame.AddrPC.Offset )

	cmp	DWORD PTR _stFrame$12[ebp], 0
	je	SHORT $LN6@DoStackTra

; 491  :                 {
; 492  :                     vAddrs.push_back ( stFrame.AddrPC.Offset ) ;

	lea	eax, DWORD PTR _stFrame$12[ebp]
	push	eax
	lea	ecx, DWORD PTR _vAddrs$[ebp]
	call	?push_back@?$vector@KV?$allocator@K@std@@@std@@QAEXABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::push_back
$LN6@DoStackTra:

; 493  :                 }
; 494  :             }
; 495  :         }

	jmp	$LN9@DoStackTra
$LN8@DoStackTra:

; 496  : 
; 497  :         // Now start converting the addresses.
; 498  :         DWORD dwSizeLeft = dwSize ;

	mov	ecx, DWORD PTR _dwSize$[ebp]
	mov	DWORD PTR _dwSizeLeft$7[ebp], ecx

; 499  :         DWORD dwSymSize ;
; 500  : 
; 501  :         TCHAR szSym [ MAX_PATH * 2 ] ;
; 502  :         LPTSTR szCurrPos = szString ;

	mov	edx, DWORD PTR _szString$[ebp]
	mov	DWORD PTR _szCurrPos$8[ebp], edx

; 503  : 
; 504  :         ADDRVECTOR::iterator loop ;

	lea	ecx, DWORD PTR _loop$10[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >

; 505  :         for ( loop =  vAddrs.begin ( ) ;

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	lea	ecx, DWORD PTR _vAddrs$[ebp]
	call	?begin@?$vector@KV?$allocator@K@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@2@XZ ; std::vector<unsigned long,std::allocator<unsigned long> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _loop$10[ebp], ecx

; 506  :               loop != vAddrs.end ( )   ;

	jmp	SHORT $LN4@DoStackTra
$LN3@DoStackTra:

; 507  :               loop++                     )

	push	0
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	ecx, DWORD PTR _loop$10[ebp]
	call	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::operator++
$LN4@DoStackTra:
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	lea	ecx, DWORD PTR _vAddrs$[ebp]
	call	?end@?$vector@KV?$allocator@K@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@2@XZ ; std::vector<unsigned long,std::allocator<unsigned long> >::end
	push	eax
	lea	ecx, DWORD PTR _loop$10[ebp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN11@DoStackTra

; 508  :         {
; 509  : 
; 510  :             dwSymSize = ConvertAddress ( *loop , szSym ) ;

	lea	edx, DWORD PTR _szSym$13[ebp]
	push	edx
	lea	ecx, DWORD PTR _loop$10[ebp]
	call	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@K@std@@@std@@@std@@QBEAAKXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned long> > >::operator*
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?ConvertAddress@@YAKKPAD@Z		; ConvertAddress
	add	esp, 8
	mov	DWORD PTR _dwSymSize$9[ebp], eax

; 511  :             if ( dwSizeLeft < dwSymSize )

	mov	ecx, DWORD PTR _dwSizeLeft$7[ebp]
	cmp	ecx, DWORD PTR _dwSymSize$9[ebp]
	jae	SHORT $LN1@DoStackTra

; 512  :             {
; 513  :                 break ;

	jmp	SHORT $LN11@DoStackTra
$LN1@DoStackTra:

; 514  :             }
; 515  :             _tcscpy ( szCurrPos , szSym ) ;

	lea	edx, DWORD PTR _szSym$13[ebp]
	push	edx
	mov	eax, DWORD PTR _szCurrPos$8[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 516  :             szCurrPos += dwSymSize ;

	mov	ecx, DWORD PTR _szCurrPos$8[ebp]
	add	ecx, DWORD PTR _dwSymSize$9[ebp]
	mov	DWORD PTR _szCurrPos$8[ebp], ecx

; 517  :             dwSizeLeft -= dwSymSize ;

	mov	edx, DWORD PTR _dwSizeLeft$7[ebp]
	sub	edx, DWORD PTR _dwSymSize$9[ebp]
	mov	DWORD PTR _dwSizeLeft$7[ebp], edx

; 518  :         }

	jmp	$LN3@DoStackTra
$LN11@DoStackTra:

; 519  :     }
; 520  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _vAddrs$[ebp]
	call	??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?DoStackTrace@@YAXPADKK@Z$0:
	lea	ecx, DWORD PTR _vAddrs$[ebp]
	jmp	??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
__ehhandler$?DoStackTrace@@YAXPADKK@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1464]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DoStackTrace@@YAXPADKK@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoStackTrace@@YAXPADKK@Z ENDP				; DoStackTrace
; Function compile flags: /Odtp
;	COMDAT ??__Fg_cSym@@YAXXZ
text$yd	SEGMENT
??__Fg_cSym@@YAXXZ PROC					; `dynamic atexit destructor for 'g_cSym'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _g_cSym
	call	??1CSymbolEngine@@UAE@XZ		; CSymbolEngine::~CSymbolEngine
	pop	ebp
	ret	0
??__Fg_cSym@@YAXXZ ENDP					; `dynamic atexit destructor for 'g_cSym''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\diagassert.cpp
;	COMDAT ??__Eg_cSym@@YAXXZ
text$yc	SEGMENT
??__Eg_cSym@@YAXXZ PROC					; `dynamic initializer for 'g_cSym'', COMDAT

; 48   : static CSymbolEngine g_cSym ;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _g_cSym
	call	??0CSymbolEngine@@QAE@XZ		; CSymbolEngine::CSymbolEngine
	push	OFFSET ??__Fg_cSym@@YAXXZ		; `dynamic atexit destructor for 'g_cSym''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__Eg_cSym@@YAXXZ ENDP					; `dynamic initializer for 'g_cSym''
text$yc	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__Fg_HMODVector@@YAXXZ
text$yd	SEGMENT
??__Fg_HMODVector@@YAXXZ PROC				; `dynamic atexit destructor for 'g_HMODVector'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _g_HMODVector
	call	??1?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAE@XZ ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::~vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >
	pop	ebp
	ret	0
??__Fg_HMODVector@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_HMODVector''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\diagassert.cpp
;	COMDAT ??__Eg_HMODVector@@YAXXZ
text$yc	SEGMENT
??__Eg_HMODVector@@YAXXZ PROC				; `dynamic initializer for 'g_HMODVector'', COMDAT

; 42   : static HINSTVECTOR g_HMODVector ;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _g_HMODVector
	call	??0?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAE@XZ ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >
	push	OFFSET ??__Fg_HMODVector@@YAXXZ		; `dynamic atexit destructor for 'g_HMODVector''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__Eg_HMODVector@@YAXXZ ENDP				; `dynamic initializer for 'g_HMODVector''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IBEXPAPAUHINSTANCE__@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IBEXPAPAUHINSTANCE__@@0@Z PROC ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1693 : 		{	// orphan iterators within specified (inclusive) range

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1694 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Orphan_range@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IBEXPAPAUHINSTANCE__@@0@Z ENDP ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IBEXXZ PROC ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Xlen, COMDAT
; _this$ = ecx

; 1666 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1667 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN2@Xlen:

; 1668 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IBEXXZ ENDP ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Tidy@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IAEXXZ PROC ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Tidy, COMDAT
; _this$ = ecx

; 1535 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1536 : 		if (this->_Myfirst != pointer())

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@Tidy

; 1537 : 			{	// something to free, destroy and deallocate it
; 1538 : 			this->_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1539 : 			_Destroy(this->_Myfirst, this->_Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IAEXPAPAUHINSTANCE__@@0@Z ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Destroy

; 1540 : 			this->_Getal().deallocate(this->_Myfirst,
; 1541 : 				this->_Myend - this->_Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax]
	sar	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<HINSTANCE__ *,std::allocator<HINSTANCE__ *> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAEXPAPAUHINSTANCE__@@I@Z ; std::_Wrap_alloc<std::allocator<HINSTANCE__ *> >::deallocate

; 1542 : 			this->_Myfirst = pointer();

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0

; 1543 : 			this->_Mylast = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 1544 : 			this->_Myend = pointer();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
$LN2@Tidy:

; 1545 : 			}
; 1546 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IAEXXZ ENDP ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IAEXI@Z PROC ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Reserve, COMDAT
; _this$ = ecx

; 1525 : 		{	// ensure room for _Count new elements, grow exponentially

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1526 : 		if (_Unused_capacity() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Unused_capacity@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QBEIXZ ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Unused_capacity
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN4@Reserve

; 1527 : 			{	// need more room, try to get it
; 1528 : 			if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QBEIXZ ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QBEIXZ ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN1@Reserve

; 1529 : 				_Xlen();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IBEXXZ ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Xlen
$LN1@Reserve:

; 1530 : 			_Reallocate(_Grow_to(size() + _Count));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QBEIXZ ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow_to@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IBEII@Z ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Grow_to
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reallocate@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IAEXI@Z ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Reallocate
$LN4@Reserve:

; 1531 : 			}
; 1532 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Reserve@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IAEXI@Z ENDP ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -32						; size = 4
__Ptr$ = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?_Reallocate@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IAEXI@Z PROC ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Reallocate, COMDAT
; _this$ = ecx

; 1500 : 		{	// move to array of exactly _Count elements

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Reallocate@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1501 : 		pointer _Ptr = this->_Getal().allocate(_Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<HINSTANCE__ *,std::allocator<HINSTANCE__ *> > >::_Getal
	mov	ecx, eax
	call	?allocate@?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAEPAPAUHINSTANCE__@@I@Z ; std::_Wrap_alloc<std::allocator<HINSTANCE__ *> >::allocate
	mov	DWORD PTR __Ptr$[ebp], eax

; 1502 : 
; 1503 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1504 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);

	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAUHINSTANCE__@@@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IAEPAPAUHINSTANCE__@@PAPAU2@00@Z ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Umove<HINSTANCE__ * *>
	jmp	SHORT $LN5@Reallocate
__catch$?_Reallocate@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IAEXI@Z$0:

; 1505 : 		_CATCH_ALL
; 1506 : 		this->_Getal().deallocate(_Ptr, _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<HINSTANCE__ *,std::allocator<HINSTANCE__ *> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAEXPAPAUHINSTANCE__@@I@Z ; std::_Wrap_alloc<std::allocator<HINSTANCE__ *> >::deallocate

; 1507 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1508 : 		_CATCH_END

	mov	eax, $LN8@Reallocate
	ret	0
$LN5@Reallocate:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Reallocate@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IAEXI@Z$1
$LN8@Reallocate:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Reallocate@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IAEXI@Z$1:

; 1509 : 
; 1510 : 		size_type _Size = size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QBEIXZ ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::size
	mov	DWORD PTR __Size$[ebp], eax

; 1511 : 		if (this->_Myfirst != pointer())

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN1@Reallocate

; 1512 : 			{	// destroy and deallocate old array
; 1513 : 			_Destroy(this->_Myfirst, this->_Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IAEXPAPAUHINSTANCE__@@0@Z ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Destroy

; 1514 : 			this->_Getal().deallocate(this->_Myfirst,
; 1515 : 				this->_Myend - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx]
	sar	edx, 2
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<HINSTANCE__ *,std::allocator<HINSTANCE__ *> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAEXPAPAUHINSTANCE__@@I@Z ; std::_Wrap_alloc<std::allocator<HINSTANCE__ *> >::deallocate
$LN1@Reallocate:

; 1516 : 			}
; 1517 : 
; 1518 : 		this->_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1519 : 		this->_Myend = _Ptr + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 1520 : 		this->_Mylast = _Ptr + _Size;

	mov	ecx, DWORD PTR __Size$[ebp]
	mov	edx, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1521 : 		this->_Myfirst = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx], eax
$LN4@Reallocate:

; 1522 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IAEXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Reallocate@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Reallocate@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IAEXI@Z ENDP ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Reallocate
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IBE_NPBQAUHINSTANCE__@@@Z
_TEXT	SEGMENT
tv76 = -8						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IBE_NPBQAUHINSTANCE__@@@Z PROC ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Inside, COMDAT
; _this$ = ecx

; 1495 : 		{	// test if _Ptr points inside vector

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1496 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN3@Inside
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN4@Inside
$LN3@Inside:
	mov	DWORD PTR tv76[ebp], 0
$LN4@Inside:
	mov	al, BYTE PTR tv76[ebp]

; 1497 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IBE_NPBQAUHINSTANCE__@@@Z ENDP ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -12						; size = 4
_this$ = -8						; size = 4
__Capacity$ = -4					; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IBEII@Z PROC ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Grow_to, COMDAT
; _this$ = ecx

; 1484 : 		{	// grow by 50% or at least to _Count

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1485 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QBEIXZ ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QBEIXZ ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN4@Grow_to
	mov	DWORD PTR tv73[ebp], 0
	jmp	SHORT $LN5@Grow_to
$LN4@Grow_to:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv73[ebp], edx
$LN5@Grow_to:
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1489 : 		if (_Capacity < _Count)

	mov	ecx, DWORD PTR __Capacity$[ebp]
	cmp	ecx, DWORD PTR __Count$[ebp]
	jae	SHORT $LN1@Grow_to

; 1490 : 			_Capacity = _Count;

	mov	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx
$LN1@Grow_to:

; 1491 : 		return (_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]

; 1492 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Grow_to@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IBEII@Z ENDP ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IAEXPAPAUHINSTANCE__@@0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Alval$ = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IAEXPAPAUHINSTANCE__@@0@Z PROC ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Destroy, COMDAT
; _this$ = ecx

; 1478 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1479 : 		_Alty _Alval(this->_Getal());

	lea	eax, DWORD PTR __Alval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<HINSTANCE__ *,std::allocator<HINSTANCE__ *> > >::_Getal

; 1480 : 		_Destroy_range(_First, _Last, _Alval);

	lea	ecx, DWORD PTR __Alval$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@@std@@YAXPAPAUHINSTANCE__@@0AAU?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<HINSTANCE__ *> > >
	add	esp, 12					; 0000000cH

; 1481 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IAEXPAPAUHINSTANCE__@@0@Z ENDP ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?push_back@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAEXABQAUHINSTANCE__@@@Z
_TEXT	SEGMENT
__Idx$1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Val$ = 8						; size = 4
?push_back@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAEXABQAUHINSTANCE__@@@Z PROC ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::push_back, COMDAT
; _this$ = ecx

; 1184 : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1185 : 		if (_Inside(_STD addressof(_Val)))

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$addressof@QAUHINSTANCE__@@@std@@YAPBQAUHINSTANCE__@@ABQAU1@@Z ; std::addressof<HINSTANCE__ * const>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IBE_NPBQAUHINSTANCE__@@@Z ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@push_back

; 1186 : 			{	// push back an element
; 1187 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	??$addressof@QAUHINSTANCE__@@@std@@YAPBQAUHINSTANCE__@@ABQAU1@@Z ; std::addressof<HINSTANCE__ * const>
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
	mov	DWORD PTR __Idx$1[ebp], eax

; 1188 : 			if (this->_Mylast == this->_Myend)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN3@push_back

; 1189 : 				_Reserve(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reserve@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IAEXI@Z ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Reserve
$LN3@push_back:

; 1190 : 			_Orphan_range(this->_Mylast, this->_Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IBEXPAPAUHINSTANCE__@@0@Z ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Orphan_range

; 1191 : 			this->_Getal().construct(this->_Mylast,
; 1192 : 				this->_Myfirst[_Idx]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Idx$1[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<HINSTANCE__ *,std::allocator<HINSTANCE__ *> > >::_Getal
	mov	ecx, eax
	call	??$construct@PAUHINSTANCE__@@AAPAU1@@?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAEXPAPAUHINSTANCE__@@AAPAU2@@Z ; std::_Wrap_alloc<std::allocator<HINSTANCE__ *> >::construct<HINSTANCE__ *,HINSTANCE__ * &>

; 1193 : 			++this->_Mylast;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 1194 : 			}
; 1195 : 		else

	jmp	SHORT $LN5@push_back
$LN4@push_back:

; 1196 : 			{	// push back a non-element
; 1197 : 			if (this->_Mylast == this->_Myend)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN1@push_back

; 1198 : 				_Reserve(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reserve@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IAEXI@Z ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Reserve
$LN1@push_back:

; 1199 : 			_Orphan_range(this->_Mylast, this->_Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IBEXPAPAUHINSTANCE__@@0@Z ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Orphan_range

; 1200 : 			this->_Getal().construct(this->_Mylast,
; 1201 : 				_Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<HINSTANCE__ *,std::allocator<HINSTANCE__ *> > >::_Getal
	mov	ecx, eax
	call	??$construct@PAUHINSTANCE__@@ABQAU1@@?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAEXPAPAUHINSTANCE__@@ABQAU2@@Z ; std::_Wrap_alloc<std::allocator<HINSTANCE__ *> >::construct<HINSTANCE__ *,HINSTANCE__ * const &>

; 1202 : 			++this->_Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
$LN5@push_back:

; 1203 : 			}
; 1204 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAEXABQAUHINSTANCE__@@@Z ENDP ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?max_size@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QBEIXZ PROC ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::max_size, COMDAT
; _this$ = ecx

; 1091 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1092 : 		return (this->_Getal().max_size());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<HINSTANCE__ *,std::allocator<HINSTANCE__ *> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<HINSTANCE__ *> >::max_size

; 1093 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QBEIXZ ENDP ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?size@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QBEIXZ PROC ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::size, COMDAT
; _this$ = ecx

; 1086 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1087 : 		return (this->_Mylast - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1088 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QBEIXZ ENDP ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?end@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@2@XZ PROC ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::end, COMDAT
; _this$ = ecx

; 991  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 992  : 		return (iterator(this->_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QAE@PAPAUHINSTANCE__@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 993  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@2@XZ ENDP ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@2@XZ PROC ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::begin, COMDAT
; _this$ = ecx

; 981  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 982  : 		return (iterator(this->_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QAE@PAPAUHINSTANCE__@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 983  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@2@XZ ENDP ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Unused_capacity@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QBEIXZ PROC ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 971  : 		{	// micro-optimization for capacity() - size()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 972  : 		return (this->_Myend - this->_Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 973  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Unused_capacity@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QBEIXZ ENDP ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?capacity@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?capacity@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QBEIXZ PROC ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::capacity, COMDAT
; _this$ = ecx

; 966  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 967  : 		return (this->_Myend - this->_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 968  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QBEIXZ ENDP ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??1?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAE@XZ PROC ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::~vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >, COMDAT
; _this$ = ecx

; 899  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 900  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@IAEXXZ ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::_Tidy

; 901  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAE@XZ ENDP ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::~vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
??0?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAE@XZ PROC ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >, COMDAT
; _this$ = ecx

; 685  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$allocator@PAUHINSTANCE__@@@std@@QAE@XZ ; std::allocator<HINSTANCE__ *>::allocator<HINSTANCE__ *>
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUHINSTANCE__@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<HINSTANCE__ *,std::allocator<HINSTANCE__ *> > >::_Vector_alloc<0,std::_Vec_base_types<HINSTANCE__ *,std::allocator<HINSTANCE__ *> > >

; 686  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAE@XZ ENDP ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<HINSTANCE__ *,std::allocator<HINSTANCE__ *> > >::_Getal, COMDAT
; _this$ = ecx

; 646  : 		{	// get reference to allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 647  : 		return (_Alty());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<HINSTANCE__ *> >::_Wrap_alloc<std::allocator<HINSTANCE__ *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 648  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<HINSTANCE__ *,std::allocator<HINSTANCE__ *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUHINSTANCE__@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUHINSTANCE__@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<HINSTANCE__ *,std::allocator<HINSTANCE__ *> > >::_Vector_alloc<0,std::_Vec_base_types<HINSTANCE__ *,std::allocator<HINSTANCE__ *> > >, COMDAT
; _this$ = ecx

; 593  : 	_Vector_alloc(const _Alloc& = _Alloc())

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<HINSTANCE__ *> >::_Vector_val<std::_Simple_types<HINSTANCE__ *> >

; 594  : 		{	// construct allocator from _Al
; 595  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUHINSTANCE__@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<HINSTANCE__ *,std::allocator<HINSTANCE__ *> > >::_Vector_alloc<0,std::_Vec_base_types<HINSTANCE__ *,std::allocator<HINSTANCE__ *> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<HINSTANCE__ *> >::_Vector_val<std::_Simple_types<HINSTANCE__ *> >, COMDAT
; _this$ = ecx

; 484  : 	_Vector_val()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 485  : 		{	// initialize values
; 486  : 		_Myfirst = pointer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 487  : 		_Mylast = pointer();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 488  : 		_Myend = pointer();

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 489  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<HINSTANCE__ *> >::_Vector_val<std::_Simple_types<HINSTANCE__ *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QBEIXZ PROC ; std::_Wrap_alloc<std::allocator<HINSTANCE__ *> >::max_size, COMDAT
; _this$ = ecx

; 913  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@PAUHINSTANCE__@@@std@@@std@@SAIABV?$allocator@PAUHINSTANCE__@@@2@@Z ; std::allocator_traits<std::allocator<HINSTANCE__ *> >::max_size
	add	esp, 4

; 915  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QBEIXZ ENDP ; std::_Wrap_alloc<std::allocator<HINSTANCE__ *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAEXPAPAUHINSTANCE__@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAEXPAPAUHINSTANCE__@@I@Z PROC ; std::_Wrap_alloc<std::allocator<HINSTANCE__ *> >::deallocate, COMDAT
; _this$ = ecx

; 886  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 887  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@PAUHINSTANCE__@@@std@@QAEXPAPAUHINSTANCE__@@I@Z ; std::allocator<HINSTANCE__ *>::deallocate

; 888  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAEXPAPAUHINSTANCE__@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<HINSTANCE__ *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAEPAPAUHINSTANCE__@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAEPAPAUHINSTANCE__@@I@Z PROC ; std::_Wrap_alloc<std::allocator<HINSTANCE__ *> >::allocate, COMDAT
; _this$ = ecx

; 875  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@PAUHINSTANCE__@@@std@@QAEPAPAUHINSTANCE__@@I@Z ; std::allocator<HINSTANCE__ *>::allocate

; 877  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAEPAPAUHINSTANCE__@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<HINSTANCE__ *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<HINSTANCE__ *> >::_Wrap_alloc<std::allocator<HINSTANCE__ *> >, COMDAT
; _this$ = ecx

; 830  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@PAUHINSTANCE__@@@std@@QAE@XZ ; std::allocator<HINSTANCE__ *>::allocator<HINSTANCE__ *>

; 831  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<HINSTANCE__ *> >::_Wrap_alloc<std::allocator<HINSTANCE__ *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@PAUHINSTANCE__@@@std@@@std@@SAIABV?$allocator@PAUHINSTANCE__@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@PAUHINSTANCE__@@@std@@@std@@SAIABV?$allocator@PAUHINSTANCE__@@@2@@Z PROC ; std::allocator_traits<std::allocator<HINSTANCE__ *> >::max_size, COMDAT

; 761  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp

; 762  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@PAUHINSTANCE__@@@std@@QBEIXZ ; std::allocator<HINSTANCE__ *>::max_size

; 763  : 		}

	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@PAUHINSTANCE__@@@std@@@std@@SAIABV?$allocator@PAUHINSTANCE__@@@2@@Z ENDP ; std::allocator_traits<std::allocator<HINSTANCE__ *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@PAUHINSTANCE__@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$allocator@PAUHINSTANCE__@@@std@@QBEIXZ PROC	; std::allocator<HINSTANCE__ *>::max_size, COMDAT
; _this$ = ecx

; 627  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 1073741823				; 3fffffffH

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAUHINSTANCE__@@@std@@QBEIXZ ENDP	; std::allocator<HINSTANCE__ *>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@PAUHINSTANCE__@@@std@@QAEXPAPAUHINSTANCE__@@ABQAU3@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv68 = -8						; size = 4
$T1 = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAUHINSTANCE__@@@std@@QAEXPAPAUHINSTANCE__@@ABQAU3@@Z PROC ; std::allocator<HINSTANCE__ *>::construct, COMDAT
; _this$ = ecx

; 605  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR $T1[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR tv68[ebp], ecx
	jmp	SHORT $LN1@construct
$LN3@construct:
	mov	DWORD PTR tv68[ebp], 0
$LN1@construct:

; 607  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@PAUHINSTANCE__@@@std@@QAEXPAPAUHINSTANCE__@@ABQAU3@@Z ENDP ; std::allocator<HINSTANCE__ *>::construct
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAUHINSTANCE__@@@std@@QAEPAPAUHINSTANCE__@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAUHINSTANCE__@@@std@@QAEPAPAUHINSTANCE__@@I@Z PROC ; std::allocator<HINSTANCE__ *>::allocate, COMDAT
; _this$ = ecx

; 590  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAUHINSTANCE__@@@std@@YAPAPAUHINSTANCE__@@IPAPAU1@@Z ; std::_Allocate<HINSTANCE__ *>
	add	esp, 8

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAUHINSTANCE__@@@std@@QAEPAPAUHINSTANCE__@@I@Z ENDP ; std::allocator<HINSTANCE__ *>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAUHINSTANCE__@@@std@@QAEXPAPAUHINSTANCE__@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAUHINSTANCE__@@@std@@QAEXPAPAUHINSTANCE__@@I@Z PROC ; std::allocator<HINSTANCE__ *>::deallocate, COMDAT
; _this$ = ecx

; 585  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 586  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 587  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAUHINSTANCE__@@@std@@QAEXPAPAUHINSTANCE__@@I@Z ENDP ; std::allocator<HINSTANCE__ *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAUHINSTANCE__@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@PAUHINSTANCE__@@@std@@QAE@XZ PROC	; std::allocator<HINSTANCE__ *>::allocator<HINSTANCE__ *>, COMDAT
; _this$ = ecx

; 565  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@PAUHINSTANCE__@@@std@@QAE@XZ ENDP	; std::allocator<HINSTANCE__ *>::allocator<HINSTANCE__ *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??__Eallocator_arg@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Eallocator_arg@std@@YAXXZ PROC			; std::`dynamic initializer for 'allocator_arg'', COMDAT

; 3644 : const allocator_arg_t allocator_arg = allocator_arg_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eallocator_arg@std@@YAXXZ ENDP			; std::`dynamic initializer for 'allocator_arg''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 50   : 		{	// adopt this iterator by parent

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 51   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 39   : 		{	// orphan all iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 40   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??__Epiecewise_construct@std@@YAXXZ
text$yc	SEGMENT
$T1 = -1						; size = 1
??__Epiecewise_construct@std@@YAXXZ PROC		; std::`dynamic initializer for 'piecewise_construct'', COMDAT

; 65   : 	piecewise_construct_t();

	push	ebp
	mov	ebp, esp
	push	ecx
	xor	eax, eax
	mov	BYTE PTR $T1[ebp], al
	mov	esp, ebp
	pop	ebp
	ret	0
??__Epiecewise_construct@std@@YAXXZ ENDP		; std::`dynamic initializer for 'piecewise_construct''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 65   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GCSymbolEngine@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCSymbolEngine@@UAEPAXI@Z PROC			; CSymbolEngine::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CSymbolEngine@@UAE@XZ		; CSymbolEngine::~CSymbolEngine
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCSymbolEngine@@UAEPAXI@Z ENDP			; CSymbolEngine::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\symbolengine.h
;	COMDAT ?SymGetLineFromAddr@CSymbolEngine@@QAEHKPAKPAU_IMAGEHLP_LINE@@@Z
_TEXT	SEGMENT
_pfnSGLFA$ = -12					; size = 4
_this$ = -8						; size = 4
_dwTempDis$ = -4					; size = 4
_dwAddr$ = 8						; size = 4
_pdwDisplacement$ = 12					; size = 4
_Line$ = 16						; size = 4
?SymGetLineFromAddr@CSymbolEngine@@QAEHKPAKPAU_IMAGEHLP_LINE@@@Z PROC ; CSymbolEngine::SymGetLineFromAddr, COMDAT
; _this$ = ecx

; 492  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 493  :         // Holds the function pointer.
; 494  :         PFNSYMGETLINEFROMADDR pfnSGLFA ;
; 495  : 
; 496  : #ifdef SYMENG_EXTRAWORK
; 497  :         if ( NULL == m_pfnSymGetLineFromAddr )
; 498  :         {
; 499  :             return ( FALSE ) ;
; 500  :         }
; 501  :         else
; 502  :         {
; 503  :             pfnSGLFA = m_pfnSymGetLineFromAddr ;
; 504  :         }
; 505  : #else
; 506  :         // Just grab it directly.
; 507  :         pfnSGLFA = ::SymGetLineFromAddr ;

	mov	eax, DWORD PTR __imp__SymGetLineFromAddr@16
	mov	DWORD PTR _pfnSGLFA$[ebp], eax

; 508  : #endif  // SYMENG_EXTRAWORK
; 509  : 
; 510  : #ifdef DO_NOT_WORK_AROUND_SRCLINE_BUG
; 511  :         // Just return whatever the main function returned.
; 512  :         return ( pfnSGLFA ( m_hProcess      ,
; 513  :                             dwAddr          ,
; 514  :                             pdwDisplacement ,
; 515  :                             Line             ) ) ;
; 516  : 
; 517  : #else
; 518  :         // The problem is that the symbol engine only finds those source
; 519  :         //  line addresses (after the first lookup) that fall exactly on
; 520  :         //  a zero displacement.  I will walk backwards 100 bytes to
; 521  :         //  find the line and return the proper displacement.
; 522  :         DWORD dwTempDis = 0 ;

	mov	DWORD PTR _dwTempDis$[ebp], 0
$LN4@SymGetLine:

; 523  :         while ( FALSE == pfnSGLFA ( m_hProcess          ,
; 524  :                                     dwAddr - dwTempDis  ,
; 525  :                                     pdwDisplacement     ,
; 526  :                                     Line                 ) )

	mov	ecx, DWORD PTR _Line$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pdwDisplacement$[ebp]
	push	edx
	mov	eax, DWORD PTR _dwAddr$[ebp]
	sub	eax, DWORD PTR _dwTempDis$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR _pfnSGLFA$[ebp]
	test	eax, eax
	jne	SHORT $LN3@SymGetLine

; 527  :         {
; 528  :             dwTempDis += 1 ;

	mov	eax, DWORD PTR _dwTempDis$[ebp]
	add	eax, 1
	mov	DWORD PTR _dwTempDis$[ebp], eax

; 529  :             if ( 100 == dwTempDis )

	cmp	DWORD PTR _dwTempDis$[ebp], 100		; 00000064H
	jne	SHORT $LN2@SymGetLine

; 530  :             {
; 531  :                 return ( FALSE ) ;

	xor	eax, eax
	jmp	SHORT $LN5@SymGetLine
$LN2@SymGetLine:

; 532  :             }
; 533  :         }

	jmp	SHORT $LN4@SymGetLine
$LN3@SymGetLine:

; 534  :         // It was found and the source line information is correct so
; 535  :         //  change the displacement if it was looked up multiple times.
; 536  :         if ( 0 != dwTempDis )

	cmp	DWORD PTR _dwTempDis$[ebp], 0
	je	SHORT $LN1@SymGetLine

; 537  :         {
; 538  :             *pdwDisplacement = dwTempDis ;

	mov	ecx, DWORD PTR _pdwDisplacement$[ebp]
	mov	edx, DWORD PTR _dwTempDis$[ebp]
	mov	DWORD PTR [ecx], edx
$LN1@SymGetLine:

; 539  :         }
; 540  :         return ( TRUE ) ;

	mov	eax, 1
$LN5@SymGetLine:

; 541  : #endif // DO_NOT_WORK_AROUND_SRCLINE_BUG
; 542  :     }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SymGetLineFromAddr@CSymbolEngine@@QAEHKPAKPAU_IMAGEHLP_LINE@@@Z ENDP ; CSymbolEngine::SymGetLineFromAddr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\symbolengine.h
;	COMDAT ?SymGetSymFromAddr@CSymbolEngine@@QAEHKPAKPAU_IMAGEHLP_SYMBOL@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dwAddr$ = 8						; size = 4
_pdwDisplacement$ = 12					; size = 4
_Symbol$ = 16						; size = 4
?SymGetSymFromAddr@CSymbolEngine@@QAEHKPAKPAU_IMAGEHLP_SYMBOL@@@Z PROC ; CSymbolEngine::SymGetSymFromAddr, COMDAT
; _this$ = ecx

; 459  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 460  :         return ( ::SymGetSymFromAddr ( m_hProcess       ,
; 461  :                                        dwAddr           ,
; 462  :                                        pdwDisplacement  ,
; 463  :                                        Symbol            ) ) ;

	mov	eax, DWORD PTR _Symbol$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pdwDisplacement$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwAddr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp__SymGetSymFromAddr@16

; 464  :     }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SymGetSymFromAddr@CSymbolEngine@@QAEHKPAKPAU_IMAGEHLP_SYMBOL@@@Z ENDP ; CSymbolEngine::SymGetSymFromAddr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\symbolengine.h
;	COMDAT ?SymGetModuleInfo@CSymbolEngine@@QAEHKPAU_IMAGEHLP_MODULE@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dwAddr$ = 8						; size = 4
_ModuleInfo$ = 12					; size = 4
?SymGetModuleInfo@CSymbolEngine@@QAEHKPAU_IMAGEHLP_MODULE@@@Z PROC ; CSymbolEngine::SymGetModuleInfo, COMDAT
; _this$ = ecx

; 429  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 430  :         return ( ::SymGetModuleInfo ( m_hProcess    ,
; 431  :                                       dwAddr        ,
; 432  :                                       ModuleInfo     ) ) ;

	mov	eax, DWORD PTR _ModuleInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwAddr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR __imp__SymGetModuleInfo@12

; 433  :     }

	mov	esp, ebp
	pop	ebp
	ret	8
?SymGetModuleInfo@CSymbolEngine@@QAEHKPAU_IMAGEHLP_MODULE@@@Z ENDP ; CSymbolEngine::SymGetModuleInfo
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\symbolengine.h
;	COMDAT ?SymLoadModule@CSymbolEngine@@QAEHPAXPAD1KK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_hFile$ = 8						; size = 4
_ImageName$ = 12					; size = 4
_ModuleName$ = 16					; size = 4
_BaseOfDll$ = 20					; size = 4
_SizeOfDll$ = 24					; size = 4
?SymLoadModule@CSymbolEngine@@QAEHPAXPAD1KK@Z PROC	; CSymbolEngine::SymLoadModule, COMDAT
; _this$ = ecx

; 404  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 405  :         return ( ::SymLoadModule ( m_hProcess   ,
; 406  :                                    hFile        ,
; 407  :                                    ImageName    ,
; 408  :                                    ModuleName   ,
; 409  :                                    BaseOfDll    ,
; 410  :                                    SizeOfDll     ) ) ;

	mov	eax, DWORD PTR _SizeOfDll$[ebp]
	push	eax
	mov	ecx, DWORD PTR _BaseOfDll$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ModuleName$[ebp]
	push	edx
	mov	eax, DWORD PTR _ImageName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFile$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR __imp__SymLoadModule@24

; 411  :     }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?SymLoadModule@CSymbolEngine@@QAEHPAXPAD1KK@Z ENDP	; CSymbolEngine::SymLoadModule
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\symbolengine.h
;	COMDAT ?SymInitialize@CSymbolEngine@@QAEHPAXPADH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_hProcess$ = 8						; size = 4
_UserSearchPath$ = 12					; size = 4
_fInvadeProcess$ = 16					; size = 4
?SymInitialize@CSymbolEngine@@QAEHPAXPADH@Z PROC	; CSymbolEngine::SymInitialize, COMDAT
; _this$ = ecx

; 373  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 374  :         m_hProcess = hProcess ;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _hProcess$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 375  :         return ( ::SymInitialize ( hProcess       ,
; 376  :                                    UserSearchPath ,
; 377  :                                    fInvadeProcess  ) ) ;

	mov	edx, DWORD PTR _fInvadeProcess$[ebp]
	push	edx
	mov	eax, DWORD PTR _UserSearchPath$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hProcess$[ebp]
	push	ecx
	call	DWORD PTR __imp__SymInitialize@12

; 378  :     }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SymInitialize@CSymbolEngine@@QAEHPAXPADH@Z ENDP	; CSymbolEngine::SymInitialize
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\symbolengine.h
;	COMDAT ??1CSymbolEngine@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CSymbolEngine@@UAE@XZ PROC				; CSymbolEngine::~CSymbolEngine, COMDAT
; _this$ = ecx

; 267  :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CSymbolEngine@@6B@

; 268  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
??1CSymbolEngine@@UAE@XZ ENDP				; CSymbolEngine::~CSymbolEngine
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\symbolengine.h
;	COMDAT ??0CSymbolEngine@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CSymbolEngine@@QAE@XZ PROC				; CSymbolEngine::CSymbolEngine, COMDAT
; _this$ = ecx

; 233  :     CSymbolEngine ( void )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CSymbolEngine@@6B@

; 234  :     {
; 235  : #ifdef SYMENG_EXTRAWORK
; 236  :         HINSTANCE hInstImageHlp = GetModuleHandleA ( "IMAGEHLP.DLL" ) ;
; 237  : 
; 238  :         m_pfnSymGetLineFromAddr =
; 239  :             (PFNSYMGETLINEFROMADDR)GetProcAddress(hInstImageHlp ,
; 240  :                                                   "SymGetLineFromAddr");
; 241  :         if ( NULL == m_pfnSymGetLineFromAddr )
; 242  :         {
; 243  :             m_pfnSymGetLineFromName = NULL ;
; 244  :             m_pfnSymGetLineNext     = NULL ;
; 245  :             m_pfnSymGetLinePrev     = NULL ;
; 246  :             m_pfnSymMatchFileName   = NULL ;
; 247  :         }
; 248  :         else
; 249  :         {
; 250  :             m_pfnSymGetLineFromName =
; 251  :                (PFNSYMGETLINEFROMNAME)GetProcAddress(hInstImageHlp ,
; 252  :                                                   "SymGetLineFromName");
; 253  :             m_pfnSymGetLineNext     =
; 254  :                (PFNSYMGETLINENEXT)GetProcAddress ( hInstImageHlp  ,
; 255  :                                                    "SymGetLineNext" ) ;
; 256  :             m_pfnSymGetLinePrev     =
; 257  :                (PFNSYMGETLINEPREV)GetProcAddress ( hInstImageHlp  ,
; 258  :                                                    "SymGetLinePrev"  ) ;
; 259  :             m_pfnSymMatchFileName   =
; 260  :                (PFNSYMMATCHFILENAME)GetProcAddress (hInstImageHlp ,
; 261  :                                                     "SymMatchFileName");
; 262  :         }
; 263  : #endif  // SYMENG_EXTRAWORK
; 264  :     }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CSymbolEngine@@QAE@XZ ENDP				; CSymbolEngine::CSymbolEngine
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\diagassert.cpp
_TEXT	SEGMENT
_dwLastError$ = -8					; size = 4
_args$ = -4						; size = 4
_szFmt$ = 8						; size = 4
?DiagOutput@@YAXPBDZZ PROC				; DiagOutput

; 236  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 237  :     // Never corrupt the last error value.
; 238  :     DWORD dwLastError = GetLastError ( ) ;

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _dwLastError$[ebp], eax

; 239  : 
; 240  :     static TCHAR szOutBuff [ 1024 ] ;
; 241  : 
; 242  :     va_list  args ;
; 243  : 
; 244  :     va_start ( args , szFmt ) ;

	lea	eax, DWORD PTR _szFmt$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 245  :     _vstprintf ( szOutBuff , szFmt , args ) ;

	mov	ecx, DWORD PTR _args$[ebp]
	push	ecx
	mov	edx, DWORD PTR _szFmt$[ebp]
	push	edx
	push	OFFSET ?szOutBuff@?1??DiagOutput@@YAXPBDZZ@4PADA
	call	_vsprintf
	add	esp, 12					; 0000000cH

; 246  :     OutputDebugString ( szOutBuff ) ;

	push	OFFSET ?szOutBuff@?1??DiagOutput@@YAXPBDZZ@4PADA
	call	DWORD PTR __imp__OutputDebugStringA@4

; 247  :     va_end ( args ) ;

	mov	DWORD PTR _args$[ebp], 0

; 248  : 
; 249  :     SetLastError ( dwLastError ) ;

	mov	eax, DWORD PTR _dwLastError$[ebp]
	push	eax
	call	DWORD PTR __imp__SetLastError@4

; 250  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DiagOutput@@YAXPBDZZ ENDP				; DiagOutput
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\diagassert.cpp
_TEXT	SEGMENT
$T1 = -312						; size = 4
$T2 = -308						; size = 4
$T3 = -304						; size = 4
_szRealLastErr$ = -300					; size = 4
_iRet$ = -296						; size = 4
_hWndParent$4 = -292					; size = 4
_dwOpts$ = -288						; size = 4
_pCurrPos$ = -284					; size = 4
_loop$ = -280						; size = 4
_dwLastErr$ = -276					; size = 4
_szFmtMsg$ = -272					; size = 4
_szModName$ = -268					; size = 261
__$ArrayPad$ = -4					; size = 4
_dwOverrideOpts$ = 8					; size = 4
_szMsg$ = 12						; size = 4
_szFile$ = 16						; size = 4
_dwLine$ = 20						; size = 4
?DiagAssert@@YGHKPBD0K@Z PROC				; DiagAssert

; 88   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 312				; 00000138H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 89   :     // The buffer used for the final message text.
; 90   :     static TCHAR  szBuff [ DIAGASSERT_BUFFSIZE ] ;
; 91   :     // The current position in szBuff ;
; 92   :     LPTSTR pCurrPos = szBuff ;

	mov	DWORD PTR _pCurrPos$[ebp], OFFSET ?szBuff@?1??DiagAssert@@YGHKPBD0K@Z@4PADA

; 93   :     // The module name.
; 94   :     TCHAR  szModName[ MAX_PATH + 1 ] ;
; 95   :     // The decoded message from FormatMessage
; 96   :     LPTSTR szFmtMsg = NULL ;

	mov	DWORD PTR _szFmtMsg$[ebp], 0

; 97   :     // The options.
; 98   :     DWORD  dwOpts = dwOverrideOpts ;

	mov	eax, DWORD PTR _dwOverrideOpts$[ebp]
	mov	DWORD PTR _dwOpts$[ebp], eax

; 99   :     // The last error value.  (Which is preserved across the call).
; 100  :     DWORD  dwLastErr = GetLastError ( ) ;

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _dwLastErr$[ebp], eax

; 101  : 
; 102  : 
; 103  :     if ( DA_USEDEFAULTS == dwOverrideOpts )

	cmp	DWORD PTR _dwOverrideOpts$[ebp], 0
	jne	SHORT $LN16@DiagAssert

; 104  :     {
; 105  :         dwOpts = g_DiagAssertOptions ;

	mov	ecx, DWORD PTR _g_DiagAssertOptions
	mov	DWORD PTR _dwOpts$[ebp], ecx
$LN16@DiagAssert:

; 106  :     }
; 107  : 
; 108  :     // Look in any specified modules for the code.
; 109  :     HINSTVECTOR::iterator loop ;

	lea	ecx, DWORD PTR _loop$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >

; 110  :     for ( loop =  g_HMODVector.begin ( ) ;

	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	mov	ecx, OFFSET _g_HMODVector
	call	?begin@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@2@XZ ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::begin
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _loop$[ebp], eax

; 111  :           loop != g_HMODVector.end ( )   ;

	jmp	SHORT $LN15@DiagAssert
$LN14@DiagAssert:

; 112  :           loop++                          )

	push	0
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _loop$[ebp]
	call	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::operator++
$LN15@DiagAssert:
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, OFFSET _g_HMODVector
	call	?end@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@2@XZ ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::end
	push	eax
	lea	ecx, DWORD PTR _loop$[ebp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN13@DiagAssert

; 113  :     {
; 114  :         if ( 0 != FormatMessage ( FORMAT_MESSAGE_ALLOCATE_BUFFER    |
; 115  :                                     FORMAT_MESSAGE_IGNORE_INSERTS   |
; 116  :                                     FORMAT_MESSAGE_FROM_HMODULE      ,
; 117  :                                   *loop                              ,
; 118  :                                   dwLastErr                          ,
; 119  :                                   0                                  ,
; 120  :                                   (LPTSTR)&szFmtMsg                  ,
; 121  :                                   0                                  ,
; 122  :                                   NULL                                ))

	push	0
	push	0
	lea	ecx, DWORD PTR _szFmtMsg$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _dwLastErr$[ebp]
	push	edx
	lea	ecx, DWORD PTR _loop$[ebp]
	call	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUHINSTANCE__@@@std@@@std@@@std@@QBEAAPAUHINSTANCE__@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<HINSTANCE__ *> > >::operator*
	mov	eax, DWORD PTR [eax]
	push	eax
	push	2816					; 00000b00H
	call	DWORD PTR __imp__FormatMessageA@28
	test	eax, eax
	je	SHORT $LN12@DiagAssert

; 123  :         {
; 124  :             break ;

	jmp	SHORT $LN13@DiagAssert
$LN12@DiagAssert:

; 125  :         }
; 126  :     }

	jmp	SHORT $LN14@DiagAssert
$LN13@DiagAssert:

; 127  : 
; 128  :     // If the message was not translated, just look in the system.
; 129  :     if ( NULL == szFmtMsg )

	cmp	DWORD PTR _szFmtMsg$[ebp], 0
	jne	SHORT $LN11@DiagAssert

; 130  :     {
; 131  :         FormatMessage ( FORMAT_MESSAGE_ALLOCATE_BUFFER    |
; 132  :                           FORMAT_MESSAGE_IGNORE_INSERTS   |
; 133  :                           FORMAT_MESSAGE_FROM_SYSTEM        ,
; 134  :                         NULL                                ,
; 135  :                         dwLastErr                           ,
; 136  :                         0                                   ,
; 137  :                         (LPTSTR)&szFmtMsg                   ,
; 138  :                         0                                   ,
; 139  :                         NULL                                 ) ;

	push	0
	push	0
	lea	ecx, DWORD PTR _szFmtMsg$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _dwLastErr$[ebp]
	push	edx
	push	0
	push	4864					; 00001300H
	call	DWORD PTR __imp__FormatMessageA@28
$LN11@DiagAssert:

; 140  :     }
; 141  : 
; 142  :     // Make sure the message got translated into something.
; 143  :     LPTSTR szRealLastErr ;
; 144  :     if ( NULL != szFmtMsg )

	cmp	DWORD PTR _szFmtMsg$[ebp], 0
	je	SHORT $LN10@DiagAssert

; 145  :     {
; 146  :         szRealLastErr = szFmtMsg ;

	mov	eax, DWORD PTR _szFmtMsg$[ebp]
	mov	DWORD PTR _szRealLastErr$[ebp], eax

; 147  :     }
; 148  :     else

	jmp	SHORT $LN9@DiagAssert
$LN10@DiagAssert:

; 149  :     {
; 150  :         szRealLastErr = _T ( "**Last error code does not exist!!!!" ) ;

	mov	DWORD PTR _szRealLastErr$[ebp], OFFSET ??_C@_0CF@NNHOJLK@?$CK?$CKLast?5error?5code?5does?5not?5exist@
$LN9@DiagAssert:

; 151  :     }
; 152  : 
; 153  :     // Get the module name.
; 154  :     if ( 0 == GetModuleFileName ( NULL , szModName , MAX_PATH ) )

	push	260					; 00000104H
	lea	ecx, DWORD PTR _szModName$[ebp]
	push	ecx
	push	0
	call	DWORD PTR __imp__GetModuleFileNameA@12
	test	eax, eax
	jne	SHORT $LN8@DiagAssert

; 155  :     {
; 156  :         _tcscpy ( szModName , _T ( "<unknown application>" ) ) ;

	push	OFFSET ??_C@_0BG@OPOJBHAK@?$DMunknown?5application?$DO?$AA@
	lea	edx, DWORD PTR _szModName$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
$LN8@DiagAssert:

; 157  :     }
; 158  : 
; 159  :     // Build the message.
; 160  :     pCurrPos += (wsprintf ( szBuff                                 ,
; 161  :                             _T ( "Debug Assertion Failed!\n\n"  \
; 162  :                                  "Program : %s\n"               \
; 163  :                                  "File : %s\n"                  \
; 164  :                                  "Line : %d\n"                  \
; 165  :                                  "Expression : %s\n"            \
; 166  :                                  "Last Error (0x%08X) : %s\n\n"   ) ,
; 167  :                             szModName                               ,
; 168  :                             szFile                                  ,
; 169  :                             dwLine                                  ,
; 170  :                             szMsg                                   ,
; 171  :                             dwLastErr                               ,
; 172  :                             szRealLastErr                            )
; 173  :                  * sizeof ( TCHAR ) ) ;

	mov	eax, DWORD PTR _szRealLastErr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwLastErr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	mov	eax, DWORD PTR _dwLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szFile$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szModName$[ebp]
	push	edx
	push	OFFSET ??_C@_0GF@FMBDCGE@Debug?5Assertion?5Failed?$CB?6?6Program@
	push	OFFSET ?szBuff@?1??DiagAssert@@YGHKPBD0K@Z@4PADA
	call	DWORD PTR __imp__wsprintfA
	add	esp, 32					; 00000020H
	add	eax, DWORD PTR _pCurrPos$[ebp]
	mov	DWORD PTR _pCurrPos$[ebp], eax

; 174  : 
; 175  :     // Get rid of the allocated memory from FormatMessage.
; 176  :     if ( NULL != szFmtMsg )

	cmp	DWORD PTR _szFmtMsg$[ebp], 0
	je	SHORT $LN7@DiagAssert

; 177  :     {
; 178  :         LocalFree ( (LPVOID)szFmtMsg ) ;

	mov	eax, DWORD PTR _szFmtMsg$[ebp]
	push	eax
	call	DWORD PTR __imp__LocalFree@4
$LN7@DiagAssert:

; 179  :     }
; 180  : 
; 181  :     // Am I supposed to show the stack trace too?
; 182  :     if ( DA_SHOWSTACKTRACE == ( DA_SHOWSTACKTRACE & dwOpts ) )

	mov	ecx, DWORD PTR _dwOpts$[ebp]
	and	ecx, 4
	je	SHORT $LN6@DiagAssert

; 183  :     {
; 184  :         DoStackTrace ( pCurrPos ,
; 185  :                        sizeof ( szBuff ) -
; 186  :                                        ((DWORD)pCurrPos-(DWORD)szBuff),
; 187  :                        2         ) ;

	push	2
	mov	edx, DWORD PTR _pCurrPos$[ebp]
	sub	edx, OFFSET ?szBuff@?1??DiagAssert@@YGHKPBD0K@Z@4PADA
	mov	eax, 4096				; 00001000H
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _pCurrPos$[ebp]
	push	ecx
	call	?DoStackTrace@@YAXPADKK@Z		; DoStackTrace
	add	esp, 12					; 0000000cH
$LN6@DiagAssert:

; 188  :     }
; 189  : 
; 190  :     // Is this supposed to go to ODS?
; 191  :     if ( DA_SHOWODS == ( DA_SHOWODS & dwOpts ) )

	mov	edx, DWORD PTR _dwOpts$[ebp]
	and	edx, 2
	je	SHORT $LN5@DiagAssert

; 192  :     {
; 193  :         OutputDebugString ( szBuff ) ;

	push	OFFSET ?szBuff@?1??DiagAssert@@YGHKPBD0K@Z@4PADA
	call	DWORD PTR __imp__OutputDebugStringA@4
$LN5@DiagAssert:

; 194  :     }
; 195  : 
; 196  :     // By default, treat the return as an IGNORE.  This works best in
; 197  :     //  the case the user does not want the MessageBox.
; 198  :     int iRet = IDIGNORE ;

	mov	DWORD PTR _iRet$[ebp], 5

; 199  :     if ( DA_SHOWMSGBOX == ( DA_SHOWMSGBOX & dwOpts ) )

	mov	eax, DWORD PTR _dwOpts$[ebp]
	and	eax, 1
	je	SHORT $LN4@DiagAssert

; 200  :     {
; 201  :         HWND hWndParent = GetActiveWindow ( ) ;

	call	DWORD PTR __imp__GetActiveWindow@0
	mov	DWORD PTR _hWndParent$4[ebp], eax

; 202  :         if ( NULL != hWndParent )

	cmp	DWORD PTR _hWndParent$4[ebp], 0
	je	SHORT $LN3@DiagAssert

; 203  :         {
; 204  :             hWndParent = GetLastActivePopup ( hWndParent ) ;

	mov	ecx, DWORD PTR _hWndParent$4[ebp]
	push	ecx
	call	DWORD PTR __imp__GetLastActivePopup@4
	mov	DWORD PTR _hWndParent$4[ebp], eax
$LN3@DiagAssert:

; 205  :         }
; 206  :         iRet = MessageBox ( hWndParent                      ,
; 207  :                             szBuff                          ,
; 208  :                             _T ( "ASSERTION FAILURE..." )   ,
; 209  :                             MB_TASKMODAL            |
; 210  :                                 MB_SETFOREGROUND    |
; 211  :                                 MB_ABORTRETRYIGNORE |
; 212  :                                 MB_ICONERROR                 ) ;

	push	73746					; 00012012H
	push	OFFSET ??_C@_0BF@OAIGKMGH@ASSERTION?5FAILURE?4?4?4?$AA@
	push	OFFSET ?szBuff@?1??DiagAssert@@YGHKPBD0K@Z@4PADA
	mov	edx, DWORD PTR _hWndParent$4[ebp]
	push	edx
	call	DWORD PTR __imp__MessageBoxA@16
	mov	DWORD PTR _iRet$[ebp], eax
$LN4@DiagAssert:

; 213  :     }
; 214  : 
; 215  :     // Put the incoming last error back.
; 216  :     SetLastError ( dwLastErr ) ;

	mov	eax, DWORD PTR _dwLastErr$[ebp]
	push	eax
	call	DWORD PTR __imp__SetLastError@4

; 217  : 
; 218  :     // Figure out what to do on the return.
; 219  :     if ( IDIGNORE == iRet )

	cmp	DWORD PTR _iRet$[ebp], 5
	jne	SHORT $LN2@DiagAssert

; 220  :     {
; 221  :         return ( FALSE ) ;

	xor	eax, eax
	jmp	SHORT $LN18@DiagAssert
$LN2@DiagAssert:

; 222  :     }
; 223  :     if ( IDRETRY == iRet )

	cmp	DWORD PTR _iRet$[ebp], 4
	jne	SHORT $LN1@DiagAssert

; 224  :     {
; 225  :         // This will trigger DebugBreak!!
; 226  :         return ( TRUE ) ;

	mov	eax, 1
	jmp	SHORT $LN18@DiagAssert
$LN1@DiagAssert:

; 227  :     }
; 228  : 
; 229  :     // The return has to be Abort....
; 230  :     ExitProcess ( (UINT)-1 ) ;

	push	-1
	call	DWORD PTR __imp__ExitProcess@4

; 231  :     return ( TRUE ) ;

	mov	eax, 1
$LN18@DiagAssert:

; 232  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?DiagAssert@@YGHKPBD0K@Z ENDP				; DiagAssert
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\diagassert.cpp
_TEXT	SEGMENT
_hMod$ = 8						; size = 4
?AddDiagAssertModule@@YGHPAUHINSTANCE__@@@Z PROC	; AddDiagAssertModule

; 78   : {

	push	ebp
	mov	ebp, esp

; 79   :     g_HMODVector.push_back ( hMod ) ;

	lea	eax, DWORD PTR _hMod$[ebp]
	push	eax
	mov	ecx, OFFSET _g_HMODVector
	call	?push_back@?$vector@PAUHINSTANCE__@@V?$allocator@PAUHINSTANCE__@@@std@@@std@@QAEXABQAUHINSTANCE__@@@Z ; std::vector<HINSTANCE__ *,std::allocator<HINSTANCE__ *> >::push_back

; 80   :     return ( TRUE ) ;

	mov	eax, 1

; 81   : }

	pop	ebp
	ret	4
?AddDiagAssertModule@@YGHPAUHINSTANCE__@@@Z ENDP	; AddDiagAssertModule
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\diagassert.cpp
_TEXT	SEGMENT
_dwOld$ = -4						; size = 4
_dwOpts$ = 8						; size = 4
?SetDiagAssertOptions@@YGKK@Z PROC			; SetDiagAssertOptions

; 66   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 67   :     if ( DA_USEDEFAULTS == dwOpts )

	cmp	DWORD PTR _dwOpts$[ebp], 0
	jne	SHORT $LN1@SetDiagAss

; 68   :     {
; 69   :         return ( DA_USEDEFAULTS ) ;

	xor	eax, eax
	jmp	SHORT $LN2@SetDiagAss
$LN1@SetDiagAss:

; 70   :     }
; 71   :     DWORD dwOld = g_DiagAssertOptions ;

	mov	eax, DWORD PTR _g_DiagAssertOptions
	mov	DWORD PTR _dwOld$[ebp], eax

; 72   :     g_DiagAssertOptions = dwOpts ;

	mov	ecx, DWORD PTR _dwOpts$[ebp]
	mov	DWORD PTR _g_DiagAssertOptions, ecx

; 73   :     return ( dwOld ) ;

	mov	eax, DWORD PTR _dwOld$[ebp]
$LN2@SetDiagAss:

; 74   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetDiagAssertOptions@@YGKK@Z ENDP			; SetDiagAssertOptions
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string.h
;	COMDAT ?strrchr@@YAPADPADH@Z
_TEXT	SEGMENT
__Str$ = 8						; size = 4
__Ch$ = 12						; size = 4
?strrchr@@YAPADPADH@Z PROC				; strrchr, COMDAT

; 222  : 	{ return (char*)strrchr((const char*)_Str, _Ch); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Str$[ebp]
	push	ecx
	call	_strrchr
	add	esp, 8
	pop	ebp
	ret	0
?strrchr@@YAPADPADH@Z ENDP				; strrchr
_TEXT	ENDS
END
