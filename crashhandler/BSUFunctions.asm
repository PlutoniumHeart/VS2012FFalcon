; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\crashhandler\BSUFunctions.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?strrchr@@YAPADPADH@Z				; strrchr
PUBLIC	_BSUGetModuleBaseName@16
EXTRN	_strrchr:PROC
EXTRN	__imp__SetLastError@4:PROC
EXTRN	__imp__GetModuleFileNameA@12:PROC
EXTRN	__imp__lstrcpynA@12:PROC
EXTRN	__imp__lstrlenA@4:PROC
EXTRN	__imp__IsBadWritePtr@8:PROC
EXTRN	_IsNT@0:PROC
EXTRN	?NTGetModuleBaseName@@YGKPAXPAUHINSTANCE__@@PADK@Z:PROC ; NTGetModuleBaseName
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___security_cookie:DWORD
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\bsufunctions.cpp
_TEXT	SEGMENT
_dwRet$ = -288						; size = 4
tv129 = -284						; size = 4
tv86 = -280						; size = 4
_iMin$ = -276						; size = 4
_pStart$ = -272						; size = 4
_szBuff$ = -268						; size = 261
__$ArrayPad$ = -4					; size = 4
___formal$ = 8						; size = 4
_hModule$ = 12						; size = 4
_lpBaseName$ = 16					; size = 4
_nSize$ = 20						; size = 4
?Win95GetModuleBaseName@@YGKPAXPAUHINSTANCE__@@PADK@Z PROC ; Win95GetModuleBaseName

; 47   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 288				; 00000120H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 48   :     ASSERT ( FALSE == IsBadWritePtr ( lpBaseName , nSize ) ) ;
; 49   :     if ( TRUE == IsBadWritePtr ( lpBaseName , nSize ) )

	mov	eax, DWORD PTR _nSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpBaseName$[ebp]
	push	ecx
	call	DWORD PTR __imp__IsBadWritePtr@8
	cmp	eax, 1
	jne	SHORT $LN4@Win95GetMo

; 50   :     {
; 51   :         TRACE0 ( "Win95GetModuleBaseName Invalid string buffer\n" ) ;
; 52   :         SetLastError ( ERROR_INVALID_PARAMETER ) ;

	push	87					; 00000057H
	call	DWORD PTR __imp__SetLastError@4

; 53   :         return ( 0 ) ;

	xor	eax, eax
	jmp	$LN5@Win95GetMo
$LN4@Win95GetMo:

; 54   :     }
; 55   : 
; 56   :     // This could blow the stack...
; 57   :     char szBuff[ MAX_PATH + 1 ] ;
; 58   :     DWORD dwRet = GetModuleFileName ( hModule , szBuff , MAX_PATH ) ;

	push	260					; 00000104H
	lea	edx, DWORD PTR _szBuff$[ebp]
	push	edx
	mov	eax, DWORD PTR _hModule$[ebp]
	push	eax
	call	DWORD PTR __imp__GetModuleFileNameA@12
	mov	DWORD PTR _dwRet$[ebp], eax

; 59   :     ASSERT ( 0 != dwRet ) ;
; 60   :     if ( 0 == dwRet )

	cmp	DWORD PTR _dwRet$[ebp], 0
	jne	SHORT $LN3@Win95GetMo

; 61   :     {
; 62   :         return ( 0 ) ;

	xor	eax, eax
	jmp	$LN5@Win95GetMo
$LN3@Win95GetMo:

; 63   :     }
; 64   : 
; 65   :     // Find the last '\' mark.
; 66   :     char * pStart = strrchr ( szBuff , '\\' ) ;

	push	92					; 0000005cH
	lea	ecx, DWORD PTR _szBuff$[ebp]
	push	ecx
	call	?strrchr@@YAPADPADH@Z			; strrchr
	add	esp, 8
	mov	DWORD PTR _pStart$[ebp], eax

; 67   :     int iMin ;
; 68   :     if ( NULL != pStart )

	cmp	DWORD PTR _pStart$[ebp], 0
	je	SHORT $LN2@Win95GetMo

; 69   :     {
; 70   :         // Move up one character.
; 71   :         pStart++ ;

	mov	edx, DWORD PTR _pStart$[ebp]
	add	edx, 1
	mov	DWORD PTR _pStart$[ebp], edx

; 72   :         //lint -e666
; 73   :         iMin = min ( (int)nSize , (lstrlen ( pStart ) + 1) ) ;

	mov	eax, DWORD PTR _pStart$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrlenA@4
	add	eax, 1
	cmp	DWORD PTR _nSize$[ebp], eax
	jge	SHORT $LN7@Win95GetMo
	mov	ecx, DWORD PTR _nSize$[ebp]
	mov	DWORD PTR tv86[ebp], ecx
	jmp	SHORT $LN8@Win95GetMo
$LN7@Win95GetMo:
	mov	edx, DWORD PTR _pStart$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrlenA@4
	add	eax, 1
	mov	DWORD PTR tv86[ebp], eax
$LN8@Win95GetMo:
	mov	eax, DWORD PTR tv86[ebp]
	mov	DWORD PTR _iMin$[ebp], eax

; 74   :         //lint +e666
; 75   :         lstrcpyn ( lpBaseName , pStart , iMin ) ;

	mov	ecx, DWORD PTR _iMin$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pStart$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpBaseName$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcpynA@12

; 76   :     }
; 77   :     else

	jmp	SHORT $LN1@Win95GetMo
$LN2@Win95GetMo:

; 78   :     {
; 79   :         // Copy the szBuff buffer in.
; 80   :         //lint -e666
; 81   :         iMin = min ( (int)nSize , (lstrlen ( szBuff ) + 1) ) ;

	lea	ecx, DWORD PTR _szBuff$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenA@4
	add	eax, 1
	cmp	DWORD PTR _nSize$[ebp], eax
	jge	SHORT $LN9@Win95GetMo
	mov	edx, DWORD PTR _nSize$[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN10@Win95GetMo
$LN9@Win95GetMo:
	lea	eax, DWORD PTR _szBuff$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrlenA@4
	add	eax, 1
	mov	DWORD PTR tv129[ebp], eax
$LN10@Win95GetMo:
	mov	ecx, DWORD PTR tv129[ebp]
	mov	DWORD PTR _iMin$[ebp], ecx

; 82   :         //lint +e666
; 83   :         lstrcpyn ( lpBaseName , szBuff , iMin ) ;

	mov	edx, DWORD PTR _iMin$[ebp]
	push	edx
	lea	eax, DWORD PTR _szBuff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpBaseName$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcpynA@12
$LN1@Win95GetMo:

; 84   :     }
; 85   :     // Always NULL terminate.
; 86   :     lpBaseName[ iMin ] = '\0' ;

	mov	edx, DWORD PTR _lpBaseName$[ebp]
	add	edx, DWORD PTR _iMin$[ebp]
	mov	BYTE PTR [edx], 0

; 87   :     return ( (DWORD)(iMin - 1) ) ;

	mov	eax, DWORD PTR _iMin$[ebp]
	sub	eax, 1
$LN5@Win95GetMo:

; 88   : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Win95GetModuleBaseName@@YGKPAXPAUHINSTANCE__@@PADK@Z ENDP ; Win95GetModuleBaseName
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\bsufunctions.cpp
_TEXT	SEGMENT
_hProcess$ = 8						; size = 4
_hModule$ = 12						; size = 4
_lpBaseName$ = 16					; size = 4
_nSize$ = 20						; size = 4
_BSUGetModuleBaseName@16 PROC

; 25   : {

	push	ebp
	mov	ebp, esp

; 26   :     if ( TRUE == IsNT ( ) )

	call	_IsNT@0
	cmp	eax, 1
	jne	SHORT $LN1@BSUGetModu

; 27   :     {
; 28   :         // Call the NT version.  It is in NT4ProcessInfo because that is
; 29   :         //  where all the PSAPI wrappers are kept.
; 30   :         return ( NTGetModuleBaseName ( hProcess     ,
; 31   :                                        hModule      ,
; 32   :                                        lpBaseName   ,
; 33   :                                        nSize         ) ) ;

	mov	eax, DWORD PTR _nSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpBaseName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hModule$[ebp]
	push	edx
	mov	eax, DWORD PTR _hProcess$[ebp]
	push	eax
	call	?NTGetModuleBaseName@@YGKPAXPAUHINSTANCE__@@PADK@Z ; NTGetModuleBaseName
	jmp	SHORT $LN2@BSUGetModu
$LN1@BSUGetModu:

; 34   :     }
; 35   :     return ( Win95GetModuleBaseName ( hProcess     ,
; 36   :                                       hModule      ,
; 37   :                                       lpBaseName   ,
; 38   :                                       nSize         ) ) ;

	mov	ecx, DWORD PTR _nSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpBaseName$[ebp]
	push	edx
	mov	eax, DWORD PTR _hModule$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hProcess$[ebp]
	push	ecx
	call	?Win95GetModuleBaseName@@YGKPAXPAUHINSTANCE__@@PADK@Z ; Win95GetModuleBaseName
$LN2@BSUGetModu:

; 39   : 
; 40   : }

	pop	ebp
	ret	16					; 00000010H
_BSUGetModuleBaseName@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string.h
;	COMDAT ?strrchr@@YAPADPADH@Z
_TEXT	SEGMENT
__Str$ = 8						; size = 4
__Ch$ = 12						; size = 4
?strrchr@@YAPADPADH@Z PROC				; strrchr, COMDAT

; 222  : 	{ return (char*)strrchr((const char*)_Str, _Ch); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Str$[ebp]
	push	ecx
	call	_strrchr
	add	esp, 8
	pop	ebp
	ret	0
?strrchr@@YAPADPADH@Z ENDP				; strrchr
_TEXT	ENDS
END
