; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\crashhandler\NT4ProcessInfo.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
_g_bInitialized DD 01H DUP (?)
_g_pEnumProcessModules DD 01H DUP (?)
_g_pGetModuleBaseName DD 01H DUP (?)
_BSS	ENDS
PUBLIC	?NT4GetLoadedModules@@YAHKIPAPAUHINSTANCE__@@PAI@Z ; NT4GetLoadedModules
PUBLIC	?NTGetModuleBaseName@@YGKPAXPAUHINSTANCE__@@PADK@Z ; NTGetModuleBaseName
PUBLIC	??_C@_09EPMADGLA@PSAPI?4DLL?$AA@		; `string'
PUBLIC	??_C@_0BD@FIEJBLME@EnumProcessModules?$AA@	; `string'
PUBLIC	??_C@_0BD@OMILCNII@GetModuleBaseNameA?$AA@	; `string'
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__SetLastError@4:PROC
EXTRN	__imp__OpenProcess@12:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__LoadLibraryA@4:PROC
EXTRN	__imp__IsBadCodePtr@4:PROC
EXTRN	__imp__SetLastErrorEx@8:PROC
;	COMDAT ??_C@_0BD@OMILCNII@GetModuleBaseNameA?$AA@
CONST	SEGMENT
??_C@_0BD@OMILCNII@GetModuleBaseNameA?$AA@ DB 'GetModuleBaseNameA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FIEJBLME@EnumProcessModules?$AA@
CONST	SEGMENT
??_C@_0BD@FIEJBLME@EnumProcessModules?$AA@ DB 'EnumProcessModules', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09EPMADGLA@PSAPI?4DLL?$AA@
CONST	SEGMENT
??_C@_09EPMADGLA@PSAPI?4DLL?$AA@ DB 'PSAPI.DLL', 00H	; `string'
CONST	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\nt4processinfo.cpp
_TEXT	SEGMENT
_hProcess$ = 8						; size = 4
_hModule$ = 12						; size = 4
_lpBaseName$ = 16					; size = 4
_nSize$ = 20						; size = 4
?NTGetModuleBaseName@@YGKPAXPAUHINSTANCE__@@PADK@Z PROC	; NTGetModuleBaseName

; 200  : {

	push	ebp
	mov	ebp, esp

; 201  :     // Initialize PSAPI.DLL, if needed.
; 202  :     if ( FALSE == InitPSAPI ( ) )

	call	?InitPSAPI@@YAHXZ			; InitPSAPI
	test	eax, eax
	jne	SHORT $LN1@NTGetModul

; 203  :     {
; 204  :         ASSERT ( FALSE ) ;
; 205  :         SetLastErrorEx ( ERROR_DLL_INIT_FAILED , SLE_ERROR ) ;

	push	1
	push	1114					; 0000045aH
	call	DWORD PTR __imp__SetLastErrorEx@8

; 206  :         return ( FALSE ) ;

	xor	eax, eax
	jmp	SHORT $LN2@NTGetModul
$LN1@NTGetModul:

; 207  :     }
; 208  :     return ( g_pGetModuleBaseName ( hProcess    ,
; 209  :                                     hModule     ,
; 210  :                                     lpBaseName  ,
; 211  :                                     nSize        ) ) ;

	mov	eax, DWORD PTR _nSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpBaseName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hModule$[ebp]
	push	edx
	mov	eax, DWORD PTR _hProcess$[ebp]
	push	eax
	call	DWORD PTR _g_pGetModuleBaseName
$LN2@NTGetModul:

; 212  : }

	pop	ebp
	ret	16					; 00000010H
?NTGetModuleBaseName@@YGKPAXPAUHINSTANCE__@@PADK@Z ENDP	; NTGetModuleBaseName
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\nt4processinfo.cpp
_TEXT	SEGMENT
_bRet$ = -12						; size = 4
_dwTotal$ = -8						; size = 4
_hProc$ = -4						; size = 4
_dwPID$ = 8						; size = 4
_uiCount$ = 12						; size = 4
_paModArray$ = 16					; size = 4
_puiRealCount$ = 20					; size = 4
?NT4GetLoadedModules@@YAHKIPAPAUHINSTANCE__@@PAI@Z PROC	; NT4GetLoadedModules

; 119  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 120  : 
; 121  :     // Initialize PSAPI.DLL, if needed.
; 122  :     if ( FALSE == InitPSAPI ( ) )

	call	?InitPSAPI@@YAHXZ			; InitPSAPI
	test	eax, eax
	jne	SHORT $LN7@NT4GetLoad

; 123  :     {
; 124  :         ASSERT ( FALSE ) ;
; 125  :         SetLastErrorEx ( ERROR_DLL_INIT_FAILED , SLE_ERROR ) ;

	push	1
	push	1114					; 0000045aH
	call	DWORD PTR __imp__SetLastErrorEx@8

; 126  :         return ( FALSE ) ;

	xor	eax, eax
	jmp	$LN8@NT4GetLoad
$LN7@NT4GetLoad:

; 127  :     }
; 128  : 
; 129  :     // Convert the process ID into a process handle.
; 130  :     HANDLE hProc = OpenProcess ( PROCESS_QUERY_INFORMATION |
; 131  :                                     PROCESS_VM_READ         ,
; 132  :                                  FALSE                      ,
; 133  :                                  dwPID                       ) ;

	mov	eax, DWORD PTR _dwPID$[ebp]
	push	eax
	push	0
	push	1040					; 00000410H
	call	DWORD PTR __imp__OpenProcess@12
	mov	DWORD PTR _hProc$[ebp], eax

; 134  :     ASSERT ( NULL != hProc ) ;
; 135  :     if ( NULL == hProc )

	cmp	DWORD PTR _hProc$[ebp], 0
	jne	SHORT $LN6@NT4GetLoad

; 136  :     {
; 137  :         TRACE1 ( "Unable to OpenProcess on %08X\n" , dwPID ) ;
; 138  :         return ( FALSE ) ;

	xor	eax, eax
	jmp	$LN8@NT4GetLoad
$LN6@NT4GetLoad:

; 139  :     }
; 140  : 
; 141  :     // Now get the modules for the specified process.
; 142  :     ASSERT ( NULL != g_pEnumProcessModules ) ;
; 143  :     // Because of possible DLL unload order differences, make sure that
; 144  :     //  PSAPI.DLL is still loaded in case this function is called during
; 145  :     //  shutdown.
; 146  :     ASSERT ( FALSE == IsBadCodePtr ( (FARPROC)g_pEnumProcessModules ) );
; 147  :     if ( TRUE == IsBadCodePtr ( (FARPROC)g_pEnumProcessModules ) )

	mov	ecx, DWORD PTR _g_pEnumProcessModules
	push	ecx
	call	DWORD PTR __imp__IsBadCodePtr@4
	cmp	eax, 1
	jne	SHORT $LN5@NT4GetLoad

; 148  :     {
; 149  :         TRACE0 ( "PSAPI.DLL has been unloaded on us!\n" ) ;
; 150  : 
; 151  :         // Close the process handle used.
; 152  :         VERIFY ( CloseHandle ( hProc ) ) ;

	mov	edx, DWORD PTR _hProc$[ebp]
	push	edx
	call	DWORD PTR __imp__CloseHandle@4

; 153  : 
; 154  :         SetLastErrorEx ( ERROR_INVALID_DLL , SLE_ERROR ) ;

	push	1
	push	1154					; 00000482H
	call	DWORD PTR __imp__SetLastErrorEx@8

; 155  : 
; 156  :         return ( FALSE ) ;

	xor	eax, eax
	jmp	SHORT $LN8@NT4GetLoad
$LN5@NT4GetLoad:

; 157  :     }
; 158  : 
; 159  :     DWORD dwTotal = 0 ;

	mov	DWORD PTR _dwTotal$[ebp], 0

; 160  :     BOOL bRet = g_pEnumProcessModules ( hProc                        ,
; 161  :                                         paModArray                   ,
; 162  :                                         uiCount * sizeof ( HMODULE ) ,
; 163  :                                         &dwTotal                      );

	lea	eax, DWORD PTR _dwTotal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _uiCount$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _paModArray$[ebp]
	push	edx
	mov	eax, DWORD PTR _hProc$[ebp]
	push	eax
	call	DWORD PTR _g_pEnumProcessModules
	mov	DWORD PTR _bRet$[ebp], eax

; 164  : 
; 165  :     // Close the process handle used.
; 166  :     VERIFY ( CloseHandle ( hProc ) ) ;

	mov	ecx, DWORD PTR _hProc$[ebp]
	push	ecx
	call	DWORD PTR __imp__CloseHandle@4

; 167  : 
; 168  :     // Convert the count from bytes to HMODULE values.
; 169  :     *puiRealCount = dwTotal / sizeof ( HMODULE ) ;

	mov	edx, DWORD PTR _dwTotal$[ebp]
	shr	edx, 2
	mov	eax, DWORD PTR _puiRealCount$[ebp]
	mov	DWORD PTR [eax], edx

; 170  : 
; 171  :     // If bRet was FALSE, and the user was not just asking for the
; 172  :     //  total, there was a problem.
; 173  :     if ( ( ( FALSE == bRet ) && ( uiCount > 0 ) ) || ( 0 == dwTotal ) )

	cmp	DWORD PTR _bRet$[ebp], 0
	jne	SHORT $LN2@NT4GetLoad
	cmp	DWORD PTR _uiCount$[ebp], 0
	ja	SHORT $LN3@NT4GetLoad
$LN2@NT4GetLoad:
	cmp	DWORD PTR _dwTotal$[ebp], 0
	jne	SHORT $LN4@NT4GetLoad
$LN3@NT4GetLoad:

; 174  :     {
; 175  :         ASSERT ( FALSE ) ;
; 176  :         TRACE0 ( "EnumProcessModules failed!\n" ) ;
; 177  :         return ( FALSE ) ;

	xor	eax, eax
	jmp	SHORT $LN8@NT4GetLoad
$LN4@NT4GetLoad:

; 178  :     }
; 179  : 
; 180  :     // If the total returned in puiRealCount is larger than the value in
; 181  :     //  uiCount, then return an error.  If uiCount is zero, then it is
; 182  :     //  not an error.
; 183  :     if ( ( *puiRealCount > uiCount ) && ( uiCount > 0 ) )

	mov	ecx, DWORD PTR _puiRealCount$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _uiCount$[ebp]
	jbe	SHORT $LN1@NT4GetLoad
	cmp	DWORD PTR _uiCount$[ebp], 0
	jbe	SHORT $LN1@NT4GetLoad

; 184  :     {
; 185  :         ASSERT ( FALSE ) ;
; 186  :         TRACE0 ( "Buffer is too small in NT4GetLoadedModules!\n" ) ;
; 187  :         SetLastErrorEx ( ERROR_INSUFFICIENT_BUFFER , SLE_ERROR ) ;

	push	1
	push	122					; 0000007aH
	call	DWORD PTR __imp__SetLastErrorEx@8

; 188  :         return ( FALSE ) ;

	xor	eax, eax
	jmp	SHORT $LN8@NT4GetLoad
$LN1@NT4GetLoad:

; 189  :     }
; 190  : 
; 191  :     // All OK, Jumpmaster!
; 192  :     SetLastError ( ERROR_SUCCESS ) ;

	push	0
	call	DWORD PTR __imp__SetLastError@4

; 193  :     return ( TRUE ) ;

	mov	eax, 1
$LN8@NT4GetLoad:

; 194  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?NT4GetLoadedModules@@YAHKIPAPAUHINSTANCE__@@PAI@Z ENDP	; NT4GetLoadedModules
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\nt4processinfo.cpp
_TEXT	SEGMENT
_hInst$ = -4						; size = 4
?InitPSAPI@@YAHXZ PROC					; InitPSAPI

; 52   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 53   :     if ( TRUE == g_bInitialized )

	cmp	DWORD PTR _g_bInitialized, 1
	jne	SHORT $LN4@InitPSAPI

; 54   :     {
; 55   :         return ( TRUE ) ;

	mov	eax, 1
	jmp	SHORT $LN5@InitPSAPI
$LN4@InitPSAPI:

; 56   :     }
; 57   : 
; 58   :     // Load up PSAPI.DLL.
; 59   :     HINSTANCE hInst = LoadLibraryA ( "PSAPI.DLL" ) ;

	push	OFFSET ??_C@_09EPMADGLA@PSAPI?4DLL?$AA@
	call	DWORD PTR __imp__LoadLibraryA@4
	mov	DWORD PTR _hInst$[ebp], eax

; 60   :     ASSERT ( NULL != hInst ) ;
; 61   :     if ( NULL == hInst )

	cmp	DWORD PTR _hInst$[ebp], 0
	jne	SHORT $LN3@InitPSAPI

; 62   :     {
; 63   :         TRACE0 ( "Unable to load PSAPI.DLL!\n" ) ;
; 64   :         return ( FALSE ) ;

	xor	eax, eax
	jmp	SHORT $LN5@InitPSAPI
$LN3@InitPSAPI:

; 65   :     }
; 66   : 
; 67   :     // Now do the GetProcAddress stuff.
; 68   :     g_pEnumProcessModules =
; 69   :            (ENUMPROCESSMODULES)GetProcAddress ( hInst ,
; 70   :                                                 "EnumProcessModules" ) ;

	push	OFFSET ??_C@_0BD@FIEJBLME@EnumProcessModules?$AA@
	mov	eax, DWORD PTR _hInst$[ebp]
	push	eax
	call	DWORD PTR __imp__GetProcAddress@8
	mov	DWORD PTR _g_pEnumProcessModules, eax

; 71   :     ASSERT ( NULL != g_pEnumProcessModules ) ;
; 72   :     if ( NULL == g_pEnumProcessModules )

	cmp	DWORD PTR _g_pEnumProcessModules, 0
	jne	SHORT $LN2@InitPSAPI

; 73   :     {
; 74   :         TRACE0 ( "GetProcAddress failed on EnumProcessModules!\n" ) ;
; 75   :         return ( FALSE ) ;

	xor	eax, eax
	jmp	SHORT $LN5@InitPSAPI
$LN2@InitPSAPI:

; 76   :     }
; 77   : 
; 78   :     g_pGetModuleBaseName =
; 79   :         (GETMODULEBASENAME)GetProcAddress ( hInst ,
; 80   :                                             "GetModuleBaseNameA" ) ;

	push	OFFSET ??_C@_0BD@OMILCNII@GetModuleBaseNameA?$AA@
	mov	ecx, DWORD PTR _hInst$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetProcAddress@8
	mov	DWORD PTR _g_pGetModuleBaseName, eax

; 81   :     ASSERT ( NULL != g_pGetModuleBaseName ) ;
; 82   :     if ( NULL == g_pGetModuleBaseName )

	cmp	DWORD PTR _g_pGetModuleBaseName, 0
	jne	SHORT $LN1@InitPSAPI

; 83   :     {
; 84   :         TRACE0 ( "GetProcAddress failed on GetModuleBaseNameA!\n" ) ;
; 85   :         return ( FALSE ) ;

	xor	eax, eax
	jmp	SHORT $LN5@InitPSAPI
$LN1@InitPSAPI:

; 86   :     }
; 87   : 
; 88   :     // All OK, Jumpmaster!
; 89   :     g_bInitialized = TRUE ;

	mov	DWORD PTR _g_bInitialized, 1

; 90   :     return ( TRUE ) ;

	mov	eax, 1
$LN5@InitPSAPI:

; 91   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InitPSAPI@@YAHXZ ENDP					; InitPSAPI
_TEXT	ENDS
END
