; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.51106.1 

	TITLE	C:\Users\Zhitao Li\Documents\Visual Studio 2012\Projects\Freefalcon\crashhandler\CrashHandler.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0M@IBNEFJCG@DBGHELP?4DLL?$AA@		; `string'
PUBLIC	??_C@_0BC@MNIKNFKD@MiniDumpWriteDump?$AA@	; `string'
_BSS	SEGMENT
_g_pfnMDWD DD	01H DUP (?)
_g_pfnCallBack DD 01H DUP (?)
_g_pfnOrigFilt DD 01H DUP (?)
_g_ahMod DD	01H DUP (?)
_g_uiModCount DD 01H DUP (?)
_g_pfnSymGetLineFromAddr DD 01H DUP (?)
_g_bLookedForSymFuncs DD 01H DUP (?)
_g_bSymEngInit DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BC@MNIKNFKD@MiniDumpWriteDump?$AA@
CONST	SEGMENT
??_C@_0BC@MNIKNFKD@MiniDumpWriteDump?$AA@ DB 'MiniDumpWriteDump', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IBNEFJCG@DBGHELP?4DLL?$AA@
CONST	SEGMENT
??_C@_0M@IBNEFJCG@DBGHELP?4DLL?$AA@ DB 'DBGHELP.DLL', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
_k_DBGHELPDLLNAME DD FLAT:??_C@_0M@IBNEFJCG@DBGHELP?4DLL?$AA@
_k_MINIDUMPWRITEDUMP DD FLAT:??_C@_0BC@MNIKNFKD@MiniDumpWriteDump?$AA@
_g_eIMDALastError DD 07H
_DATA	ENDS
PUBLIC	?SetCrashHandlerFilter@@YGHP6GJPAU_EXCEPTION_POINTERS@@@Z@Z ; SetCrashHandlerFilter
PUBLIC	?AddCrashHandlerLimitModule@@YGHPAUHINSTANCE__@@@Z ; AddCrashHandlerLimitModule
PUBLIC	?GetLimitModuleCount@@YGIXZ			; GetLimitModuleCount
PUBLIC	?GetLimitModulesArray@@YGHPAPAUHINSTANCE__@@I@Z	; GetLimitModulesArray
PUBLIC	?GetFaultReason@@YGPBDPAU_EXCEPTION_POINTERS@@@Z ; GetFaultReason
PUBLIC	?GetFaultReasonVB@@YGHPAU_EXCEPTION_POINTERS@@PADI@Z ; GetFaultReasonVB
PUBLIC	?GetFirstStackTraceString@@YGPBDKPAU_EXCEPTION_POINTERS@@@Z ; GetFirstStackTraceString
PUBLIC	?GetNextStackTraceString@@YGPBDKPAU_EXCEPTION_POINTERS@@@Z ; GetNextStackTraceString
PUBLIC	?GetFirstStackTraceStringVB@@YGHKPAU_EXCEPTION_POINTERS@@PADI@Z ; GetFirstStackTraceStringVB
PUBLIC	?GetNextStackTraceStringVB@@YGHKPAU_EXCEPTION_POINTERS@@PADI@Z ; GetNextStackTraceStringVB
PUBLIC	?GetRegisterString@@YGPBDPAU_EXCEPTION_POINTERS@@@Z ; GetRegisterString
PUBLIC	?GetRegisterStringVB@@YGHPAU_EXCEPTION_POINTERS@@PADI@Z ; GetRegisterStringVB
PUBLIC	?CrashHandlerExceptionFilter@@YGJPAU_EXCEPTION_POINTERS@@@Z ; CrashHandlerExceptionFilter
PUBLIC	?ConvertSimpleException@@YAPBDK@Z		; ConvertSimpleException
PUBLIC	?InternalGetStackTraceString@@YGPBDKPAU_EXCEPTION_POINTERS@@@Z ; InternalGetStackTraceString
PUBLIC	?InternalSymGetLineFromAddr@@YAHPAXKPAKPAU_IMAGEHLP_LINE@@@Z ; InternalSymGetLineFromAddr
PUBLIC	?InitSymEng@@YAXXZ				; InitSymEng
PUBLIC	?CleanupSymEng@@YAXXZ				; CleanupSymEng
PUBLIC	??0CleanUpCrashHandler@@QAE@XZ			; CleanUpCrashHandler::CleanUpCrashHandler
PUBLIC	??1CleanUpCrashHandler@@QAE@XZ			; CleanUpCrashHandler::~CleanUpCrashHandler
PUBLIC	?CH_ReadProcessMemory@@YGHPAXPBX0KPAK@Z		; CH_ReadProcessMemory
PUBLIC	_IsMiniDumpFunctionAvailable@0
PUBLIC	_CreateCurrentProcessMiniDumpA@16
PUBLIC	_CreateCurrentProcessMiniDumpW@16
PUBLIC	?DumpThread@@YGIPAX@Z				; DumpThread
PUBLIC	??_C@_0N@KBGMOMJO@IMAGEHLP?4DLL?$AA@		; `string'
PUBLIC	??_C@_0L@BCDENLPN@?5caused?5a?5?$AA@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	??_C@_09KKJFIDEP@NTDLL?4DLL?$AA@		; `string'
PUBLIC	??_C@_0M@MEHCDCPC@?5in?5module?5?$AA@		; `string'
PUBLIC	??_C@_09KOIOCIHC@?$DMUNKNOWN?$DO?$AA@		; `string'
PUBLIC	??_C@_0O@DJMCFBM@?5at?5?$CF04X?3?$CF08X?$AA@	; `string'
PUBLIC	??_C@_02KEGNLNML@?0?5?$AA@			; `string'
PUBLIC	??_C@_0BA@DKGILEMK@?$CFs?$CI?$CJ?$CL?$CFd?5byte?$CIs?$CJ?$AA@ ; `string'
PUBLIC	??_C@_03IKGEINEE@?$CFs?5?$AA@			; `string'
PUBLIC	??_C@_0BH@PFFLOFO@?$CFs?0?5line?5?$CFd?$CL?$CFd?5byte?$CIs?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0M@NBILGPDE@?$CFs?0?5line?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_09IOHMHKPC@?$CF04X?3?$CF08X?$AA@		; `string'
PUBLIC	??_C@_0BP@NDGHPOJN@?5?$CI0x?$CF08X?50x?$CF08X?50x?$CF08X?50x?$CF08X?$CJ?$AA@ ; `string'
PUBLIC	??_C@_01CLKCMJKC@?5?$AA@			; `string'
PUBLIC	??_C@_0JL@GMKFMLIN@EAX?$DN?$CF08X?5?5EBX?$DN?$CF08X?5?5ECX?$DN?$CF08X?5?5ED@ ; `string'
PUBLIC	??_C@_0BL@CMOMFGDN@EXCEPTION_ACCESS_VIOLATION?$AA@ ; `string'
PUBLIC	??_C@_0CA@LEJEDDLG@EXCEPTION_DATATYPE_MISALIGNMENT?$AA@ ; `string'
PUBLIC	??_C@_0BF@FLLDOCJP@EXCEPTION_BREAKPOINT?$AA@	; `string'
PUBLIC	??_C@_0BG@HPCFEJHG@EXCEPTION_SINGLE_STEP?$AA@	; `string'
PUBLIC	??_C@_0CA@JNIHFDGO@EXCEPTION_ARRAY_BOUNDS_EXCEEDED?$AA@ ; `string'
PUBLIC	??_C@_0BP@NMNHALMC@EXCEPTION_FLT_DENORMAL_OPERAND?$AA@ ; `string'
PUBLIC	??_C@_0BN@PHPNMCML@EXCEPTION_FLT_DIVIDE_BY_ZERO?$AA@ ; `string'
PUBLIC	??_C@_0BN@KLCBBCKL@EXCEPTION_FLT_INEXACT_RESULT?$AA@ ; `string'
PUBLIC	??_C@_0CA@JJDIIMDB@EXCEPTION_FLT_INVALID_OPERATION?$AA@ ; `string'
PUBLIC	??_C@_0BH@LGFBHAFE@EXCEPTION_FLT_OVERFLOW?$AA@	; `string'
PUBLIC	??_C@_0BK@COBCCPEI@EXCEPTION_FLT_STACK_CHECK?$AA@ ; `string'
PUBLIC	??_C@_0BI@CHKFJJC@EXCEPTION_FLT_UNDERFLOW?$AA@	; `string'
PUBLIC	??_C@_0BN@LBLGDPIG@EXCEPTION_INT_DIVIDE_BY_ZERO?$AA@ ; `string'
PUBLIC	??_C@_0BH@HNBKDLPO@EXCEPTION_INT_OVERFLOW?$AA@	; `string'
PUBLIC	??_C@_0BL@HJPDFKEO@EXCEPTION_PRIV_INSTRUCTION?$AA@ ; `string'
PUBLIC	??_C@_0BI@BNDIILLI@EXCEPTION_IN_PAGE_ERROR?$AA@	; `string'
PUBLIC	??_C@_0BO@DLLOIENN@EXCEPTION_ILLEGAL_INSTRUCTION?$AA@ ; `string'
PUBLIC	??_C@_0CD@JGPJMHJA@EXCEPTION_NONCONTINUABLE_EXCEPTI@ ; `string'
PUBLIC	??_C@_0BJ@FNEOPPMM@EXCEPTION_STACK_OVERFLOW?$AA@ ; `string'
PUBLIC	??_C@_0BO@GJKCLCLP@EXCEPTION_INVALID_DISPOSITION?$AA@ ; `string'
PUBLIC	??_C@_0BF@BLPCMAHP@EXCEPTION_GUARD_PAGE?$AA@	; `string'
PUBLIC	??_C@_0BJ@BKJLBIPE@EXCEPTION_INVALID_HANDLE?$AA@ ; `string'
PUBLIC	??_C@_0BD@HHOPHPBF@SymGetLineFromAddr?$AA@	; `string'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__CreateFileA@28:PROC
EXTRN	__imp__CreateFileW@28:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__SetUnhandledExceptionFilter@4:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__SetLastError@4:PROC
EXTRN	__imp__HeapAlloc@12:PROC
EXTRN	__imp__HeapFree@12:PROC
EXTRN	__imp__GetProcessHeap@0:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__GetCurrentProcess@0:PROC
EXTRN	__imp__GetCurrentProcessId@0:PROC
EXTRN	__imp__GetCurrentThread@0:PROC
EXTRN	__imp__ReadProcessMemory@20:PROC
EXTRN	__imp__GetModuleFileNameA@12:PROC
EXTRN	__imp__GetModuleHandleA@4:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__FormatMessageA@28:PROC
EXTRN	__imp__lstrcpynA@12:PROC
EXTRN	__imp__lstrlenA@4:PROC
EXTRN	__imp__LoadLibraryA@4:PROC
EXTRN	__imp__IsBadReadPtr@8:PROC
EXTRN	__imp__IsBadWritePtr@8:PROC
EXTRN	__imp__IsBadCodePtr@4:PROC
EXTRN	__imp__IsBadStringPtrA@8:PROC
EXTRN	__imp__IsBadStringPtrW@8:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	__imp__MultiByteToWideChar@24:PROC
EXTRN	_free:PROC
EXTRN	__imp__StackWalk@36:PROC
EXTRN	__imp__SymSetOptions@4:PROC
EXTRN	__imp__SymGetOptions@0:PROC
EXTRN	__imp__SymCleanup@4:PROC
EXTRN	__imp__SymFunctionTableAccess@8:PROC
EXTRN	__imp__SymGetModuleBase@8:PROC
EXTRN	__imp__SymInitialize@12:PROC
EXTRN	__imp__SymGetSymFromAddr@16:PROC
EXTRN	__imp__SymLoadModule@24:PROC
EXTRN	_GetLoadedModules@16:PROC
EXTRN	_BSUGetModuleBaseName@16:PROC
EXTRN	__beginthreadex:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__except_handler4:PROC
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
_g_szBuff DB	0400H DUP (?)
_g_stSymbol DB	0200H DUP (?)
_g_stLine DB	014H DUP (?)
_g_stFrame DB	0a4H DUP (?)
_g_cBeforeAndAfter DB 01H DUP (?)
_BSS	ENDS
CRT$XCL	SEGMENT
_g_cBeforeAndAfter$initializer$ DD FLAT:??__Eg_cBeforeAndAfter@@YAXXZ
CRT$XCL	ENDS
;	COMDAT ??_C@_0BD@HHOPHPBF@SymGetLineFromAddr?$AA@
CONST	SEGMENT
??_C@_0BD@HHOPHPBF@SymGetLineFromAddr?$AA@ DB 'SymGetLineFromAddr', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BKJLBIPE@EXCEPTION_INVALID_HANDLE?$AA@
CONST	SEGMENT
??_C@_0BJ@BKJLBIPE@EXCEPTION_INVALID_HANDLE?$AA@ DB 'EXCEPTION_INVALID_HA'
	DB	'NDLE', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BLPCMAHP@EXCEPTION_GUARD_PAGE?$AA@
CONST	SEGMENT
??_C@_0BF@BLPCMAHP@EXCEPTION_GUARD_PAGE?$AA@ DB 'EXCEPTION_GUARD_PAGE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GJKCLCLP@EXCEPTION_INVALID_DISPOSITION?$AA@
CONST	SEGMENT
??_C@_0BO@GJKCLCLP@EXCEPTION_INVALID_DISPOSITION?$AA@ DB 'EXCEPTION_INVAL'
	DB	'ID_DISPOSITION', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FNEOPPMM@EXCEPTION_STACK_OVERFLOW?$AA@
CONST	SEGMENT
??_C@_0BJ@FNEOPPMM@EXCEPTION_STACK_OVERFLOW?$AA@ DB 'EXCEPTION_STACK_OVER'
	DB	'FLOW', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@JGPJMHJA@EXCEPTION_NONCONTINUABLE_EXCEPTI@
CONST	SEGMENT
??_C@_0CD@JGPJMHJA@EXCEPTION_NONCONTINUABLE_EXCEPTI@ DB 'EXCEPTION_NONCON'
	DB	'TINUABLE_EXCEPTION', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DLLOIENN@EXCEPTION_ILLEGAL_INSTRUCTION?$AA@
CONST	SEGMENT
??_C@_0BO@DLLOIENN@EXCEPTION_ILLEGAL_INSTRUCTION?$AA@ DB 'EXCEPTION_ILLEG'
	DB	'AL_INSTRUCTION', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BNDIILLI@EXCEPTION_IN_PAGE_ERROR?$AA@
CONST	SEGMENT
??_C@_0BI@BNDIILLI@EXCEPTION_IN_PAGE_ERROR?$AA@ DB 'EXCEPTION_IN_PAGE_ERR'
	DB	'OR', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@HJPDFKEO@EXCEPTION_PRIV_INSTRUCTION?$AA@
CONST	SEGMENT
??_C@_0BL@HJPDFKEO@EXCEPTION_PRIV_INSTRUCTION?$AA@ DB 'EXCEPTION_PRIV_INS'
	DB	'TRUCTION', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HNBKDLPO@EXCEPTION_INT_OVERFLOW?$AA@
CONST	SEGMENT
??_C@_0BH@HNBKDLPO@EXCEPTION_INT_OVERFLOW?$AA@ DB 'EXCEPTION_INT_OVERFLOW'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LBLGDPIG@EXCEPTION_INT_DIVIDE_BY_ZERO?$AA@
CONST	SEGMENT
??_C@_0BN@LBLGDPIG@EXCEPTION_INT_DIVIDE_BY_ZERO?$AA@ DB 'EXCEPTION_INT_DI'
	DB	'VIDE_BY_ZERO', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CHKFJJC@EXCEPTION_FLT_UNDERFLOW?$AA@
CONST	SEGMENT
??_C@_0BI@CHKFJJC@EXCEPTION_FLT_UNDERFLOW?$AA@ DB 'EXCEPTION_FLT_UNDERFLO'
	DB	'W', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@COBCCPEI@EXCEPTION_FLT_STACK_CHECK?$AA@
CONST	SEGMENT
??_C@_0BK@COBCCPEI@EXCEPTION_FLT_STACK_CHECK?$AA@ DB 'EXCEPTION_FLT_STACK'
	DB	'_CHECK', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LGFBHAFE@EXCEPTION_FLT_OVERFLOW?$AA@
CONST	SEGMENT
??_C@_0BH@LGFBHAFE@EXCEPTION_FLT_OVERFLOW?$AA@ DB 'EXCEPTION_FLT_OVERFLOW'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JJDIIMDB@EXCEPTION_FLT_INVALID_OPERATION?$AA@
CONST	SEGMENT
??_C@_0CA@JJDIIMDB@EXCEPTION_FLT_INVALID_OPERATION?$AA@ DB 'EXCEPTION_FLT'
	DB	'_INVALID_OPERATION', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@KLCBBCKL@EXCEPTION_FLT_INEXACT_RESULT?$AA@
CONST	SEGMENT
??_C@_0BN@KLCBBCKL@EXCEPTION_FLT_INEXACT_RESULT?$AA@ DB 'EXCEPTION_FLT_IN'
	DB	'EXACT_RESULT', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@PHPNMCML@EXCEPTION_FLT_DIVIDE_BY_ZERO?$AA@
CONST	SEGMENT
??_C@_0BN@PHPNMCML@EXCEPTION_FLT_DIVIDE_BY_ZERO?$AA@ DB 'EXCEPTION_FLT_DI'
	DB	'VIDE_BY_ZERO', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@NMNHALMC@EXCEPTION_FLT_DENORMAL_OPERAND?$AA@
CONST	SEGMENT
??_C@_0BP@NMNHALMC@EXCEPTION_FLT_DENORMAL_OPERAND?$AA@ DB 'EXCEPTION_FLT_'
	DB	'DENORMAL_OPERAND', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JNIHFDGO@EXCEPTION_ARRAY_BOUNDS_EXCEEDED?$AA@
CONST	SEGMENT
??_C@_0CA@JNIHFDGO@EXCEPTION_ARRAY_BOUNDS_EXCEEDED?$AA@ DB 'EXCEPTION_ARR'
	DB	'AY_BOUNDS_EXCEEDED', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HPCFEJHG@EXCEPTION_SINGLE_STEP?$AA@
CONST	SEGMENT
??_C@_0BG@HPCFEJHG@EXCEPTION_SINGLE_STEP?$AA@ DB 'EXCEPTION_SINGLE_STEP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FLLDOCJP@EXCEPTION_BREAKPOINT?$AA@
CONST	SEGMENT
??_C@_0BF@FLLDOCJP@EXCEPTION_BREAKPOINT?$AA@ DB 'EXCEPTION_BREAKPOINT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@LEJEDDLG@EXCEPTION_DATATYPE_MISALIGNMENT?$AA@
CONST	SEGMENT
??_C@_0CA@LEJEDDLG@EXCEPTION_DATATYPE_MISALIGNMENT?$AA@ DB 'EXCEPTION_DAT'
	DB	'ATYPE_MISALIGNMENT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@CMOMFGDN@EXCEPTION_ACCESS_VIOLATION?$AA@
CONST	SEGMENT
??_C@_0BL@CMOMFGDN@EXCEPTION_ACCESS_VIOLATION?$AA@ DB 'EXCEPTION_ACCESS_V'
	DB	'IOLATION', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0JL@GMKFMLIN@EAX?$DN?$CF08X?5?5EBX?$DN?$CF08X?5?5ECX?$DN?$CF08X?5?5ED@
CONST	SEGMENT
??_C@_0JL@GMKFMLIN@EAX?$DN?$CF08X?5?5EBX?$DN?$CF08X?5?5ECX?$DN?$CF08X?5?5ED@ DB 'E'
	DB	'AX=%08X  EBX=%08X  ECX=%08X  EDX=%08X  ESI=%08X', 0dH, 0aH, 'E'
	DB	'DI=%08X  EBP=%08X  ESP=%08X  EIP=%08X  FLG=%08X', 0dH, 0aH, 'C'
	DB	'S=%04X   DS=%04X  SS=%04X  ES=%04X   FS=%04X  GS=%04X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5?$AA@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5?$AA@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@NDGHPOJN@?5?$CI0x?$CF08X?50x?$CF08X?50x?$CF08X?50x?$CF08X?$CJ?$AA@
CONST	SEGMENT
??_C@_0BP@NDGHPOJN@?5?$CI0x?$CF08X?50x?$CF08X?50x?$CF08X?50x?$CF08X?$CJ?$AA@ DB ' '
	DB	'(0x%08X 0x%08X 0x%08X 0x%08X)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09IOHMHKPC@?$CF04X?3?$CF08X?$AA@
CONST	SEGMENT
??_C@_09IOHMHKPC@?$CF04X?3?$CF08X?$AA@ DB '%04X:%08X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NBILGPDE@?$CFs?0?5line?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0M@NBILGPDE@?$CFs?0?5line?5?$CFd?$AA@ DB '%s, line %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PFFLOFO@?$CFs?0?5line?5?$CFd?$CL?$CFd?5byte?$CIs?$CJ?$AA@
CONST	SEGMENT
??_C@_0BH@PFFLOFO@?$CFs?0?5line?5?$CFd?$CL?$CFd?5byte?$CIs?$CJ?$AA@ DB '%'
	DB	's, line %d+%d byte(s)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03IKGEINEE@?$CFs?5?$AA@
CONST	SEGMENT
??_C@_03IKGEINEE@?$CFs?5?$AA@ DB '%s ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DKGILEMK@?$CFs?$CI?$CJ?$CL?$CFd?5byte?$CIs?$CJ?$AA@
CONST	SEGMENT
??_C@_0BA@DKGILEMK@?$CFs?$CI?$CJ?$CL?$CFd?5byte?$CIs?$CJ?$AA@ DB '%s()+%d'
	DB	' byte(s)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02KEGNLNML@?0?5?$AA@
CONST	SEGMENT
??_C@_02KEGNLNML@?0?5?$AA@ DB ', ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DJMCFBM@?5at?5?$CF04X?3?$CF08X?$AA@
CONST	SEGMENT
??_C@_0O@DJMCFBM@?5at?5?$CF04X?3?$CF08X?$AA@ DB ' at %04X:%08X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09KOIOCIHC@?$DMUNKNOWN?$DO?$AA@
CONST	SEGMENT
??_C@_09KOIOCIHC@?$DMUNKNOWN?$DO?$AA@ DB '<UNKNOWN>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MEHCDCPC@?5in?5module?5?$AA@
CONST	SEGMENT
??_C@_0M@MEHCDCPC@?5in?5module?5?$AA@ DB ' in module ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09KKJFIDEP@NTDLL?4DLL?$AA@
CONST	SEGMENT
??_C@_09KKJFIDEP@NTDLL?4DLL?$AA@ DB 'NTDLL.DLL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BCDENLPN@?5caused?5a?5?$AA@
CONST	SEGMENT
??_C@_0L@BCDENLPN@?5caused?5a?5?$AA@ DB ' caused a ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KBGMOMJO@IMAGEHLP?4DLL?$AA@
CONST	SEGMENT
??_C@_0N@KBGMOMJO@IMAGEHLP?4DLL?$AA@ DB 'IMAGEHLP.DLL', 00H ; `string'
CONST	ENDS
xdata$x	SEGMENT
__sehtable$?InternalGetStackTraceString@@YGPBDKPAU_EXCEPTION_POINTERS@@@Z DD 0fffffffeH
	DD	00H
	DD	0ffffffc0H
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN30@InternalGe
	DD	FLAT:$LN26@InternalGe
	ORG $+4
__sehtable$?CrashHandlerExceptionFilter@@YGJPAU_EXCEPTION_POINTERS@@@Z DD 0fffffffeH
	DD	00H
	DD	0ffffffc8H
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN22@CrashHandl
	DD	FLAT:$LN18@CrashHandl
	ORG $+4
__sehtable$?GetRegisterStringVB@@YGHPAU_EXCEPTION_POINTERS@@PADI@Z DD 0fffffffeH
	DD	00H
	DD	0ffffffccH
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN16@GetRegiste
	DD	FLAT:$LN12@GetRegiste
	ORG $+4
__sehtable$?GetNextStackTraceStringVB@@YGHKPAU_EXCEPTION_POINTERS@@PADI@Z DD 0fffffffeH
	DD	00H
	DD	0ffffffccH
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN16@GetNextSta
	DD	FLAT:$LN12@GetNextSta
	ORG $+4
__sehtable$?GetFirstStackTraceStringVB@@YGHKPAU_EXCEPTION_POINTERS@@PADI@Z DD 0fffffffeH
	DD	00H
	DD	0ffffffccH
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN16@GetFirstSt
	DD	FLAT:$LN12@GetFirstSt
	ORG $+4
__sehtable$?GetFaultReasonVB@@YGHPAU_EXCEPTION_POINTERS@@PADI@Z DD 0fffffffeH
	DD	00H
	DD	0ffffffccH
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN16@GetFaultRe
	DD	FLAT:$LN12@GetFaultRe
	ORG $+4
__sehtable$?GetFaultReason@@YGPBDPAU_EXCEPTION_POINTERS@@@Z DD 0fffffffeH
	DD	00H
	DD	0ffffffc4H
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN26@GetFaultRe
	DD	FLAT:$LN22@GetFaultRe
	ORG $+4
__sehtable$?GetLimitModulesArray@@YGHPAPAUHINSTANCE__@@I@Z DD 0fffffffeH
	DD	00H
	DD	0ffffffd4H
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN12@GetLimitMo
	DD	FLAT:$LN8@GetLimitMo
xdata$x	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\crashhandler.cpp
_TEXT	SEGMENT
_stMDEI$1 = -32						; size = 12
_bRet$2 = -20						; size = 4
tv130 = -16						; size = 4
_pMDEI$3 = -12						; size = 4
_hFile$ = -8						; size = 4
_pParams$ = -4						; size = 4
_pData$ = 8						; size = 4
?DumpThread@@YGIPAX@Z PROC				; DumpThread

; 1468 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 1469 :     LPDUMPTHREADPARAMS pParams = (LPDUMPTHREADPARAMS)pData ;

	mov	eax, DWORD PTR _pData$[ebp]
	mov	DWORD PTR _pParams$[ebp], eax

; 1470 : 
; 1471 :     // Create the file first.
; 1472 :     HANDLE hFile = CreateFileW ( pParams->szFileName             ,
; 1473 :                                  GENERIC_READ | GENERIC_WRITE    ,
; 1474 :                                   0                              ,
; 1475 :                                   NULL                           ,
; 1476 :                                   CREATE_ALWAYS                  ,
; 1477 :                                   FILE_ATTRIBUTE_NORMAL          ,
; 1478 :                                   NULL                            ) ;

	push	0
	push	128					; 00000080H
	push	2
	push	0
	push	0
	push	-1073741824				; c0000000H
	mov	ecx, DWORD PTR _pParams$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR __imp__CreateFileW@28
	mov	DWORD PTR _hFile$[ebp], eax

; 1479 :     ASSERT ( INVALID_HANDLE_VALUE != hFile ) ;
; 1480 :     if ( INVALID_HANDLE_VALUE != hFile )

	cmp	DWORD PTR _hFile$[ebp], -1
	je	$LN5@DumpThread

; 1481 :     {
; 1482 :         MINIDUMP_EXCEPTION_INFORMATION   stMDEI ;
; 1483 :         MINIDUMP_EXCEPTION_INFORMATION * pMDEI = NULL ;

	mov	DWORD PTR _pMDEI$3[ebp], 0

; 1484 : 
; 1485 :         if ( NULL != pParams->pExceptInfo )

	mov	eax, DWORD PTR _pParams$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN4@DumpThread

; 1486 :         {
; 1487 :             stMDEI.ThreadId = pParams->dwThreadID ;

	mov	ecx, DWORD PTR _pParams$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _stMDEI$1[ebp], edx

; 1488 :             stMDEI.ExceptionPointers = pParams->pExceptInfo ;

	mov	eax, DWORD PTR _pParams$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _stMDEI$1[ebp+4], ecx

; 1489 :             stMDEI.ClientPointers = TRUE ;

	mov	DWORD PTR _stMDEI$1[ebp+8], 1

; 1490 :             pMDEI = &stMDEI ;

	lea	edx, DWORD PTR _stMDEI$1[ebp]
	mov	DWORD PTR _pMDEI$3[ebp], edx
$LN4@DumpThread:

; 1491 :         }
; 1492 : 
; 1493 :         // Got the file open.  Write it.
; 1494 :         BOOL bRet = g_pfnMDWD ( GetCurrentProcess ( )   ,
; 1495 :                                 GetCurrentProcessId ( ) ,
; 1496 :                                 hFile                   ,
; 1497 :                                 pParams->eType          ,
; 1498 :                                 pMDEI                   ,
; 1499 :                                 NULL                    ,
; 1500 :                                 NULL                     ) ;

	push	0
	push	0
	mov	eax, DWORD PTR _pMDEI$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _pParams$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	call	DWORD PTR __imp__GetCurrentProcessId@0
	push	eax
	call	DWORD PTR __imp__GetCurrentProcess@0
	push	eax
	call	DWORD PTR _g_pfnMDWD
	mov	DWORD PTR _bRet$2[ebp], eax

; 1501 :         ASSERT ( TRUE == bRet ) ;
; 1502 :         if ( TRUE == bRet )

	cmp	DWORD PTR _bRet$2[ebp], 1
	jne	SHORT $LN3@DumpThread

; 1503 :         {
; 1504 :             pParams->eReturnValue = eDUMP_SUCCEEDED ;

	mov	ecx, DWORD PTR _pParams$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 1505 :         }
; 1506 :         else

	jmp	SHORT $LN2@DumpThread
$LN3@DumpThread:

; 1507 :         {
; 1508 :             // Oops.
; 1509 :             pParams->eReturnValue = eMINIDUMPWRITEDUMP_FAILED ;

	mov	edx, DWORD PTR _pParams$[ebp]
	mov	DWORD PTR [edx+16], 5
$LN2@DumpThread:

; 1510 :         }
; 1511 : 
; 1512 :         // Close the open file.
; 1513 :         VERIFY ( CloseHandle ( hFile ) ) ;

	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 1514 :     }
; 1515 :     else

	jmp	SHORT $LN1@DumpThread
$LN5@DumpThread:

; 1516 :     {
; 1517 :         // Could not open the file!
; 1518 :         pParams->eReturnValue = eOPEN_DUMP_FAILED ;

	mov	ecx, DWORD PTR _pParams$[ebp]
	mov	DWORD PTR [ecx+16], 4
$LN1@DumpThread:

; 1519 :     }
; 1520 :     // Always save the last error value so I can set it in the original
; 1521 :     // thread.
; 1522 :     pParams->dwMiniDumpWriteDumpLastError = GetLastError ( ) ;

	call	DWORD PTR __imp__GetLastError@0
	mov	edx, DWORD PTR _pParams$[ebp]
	mov	DWORD PTR [edx+20], eax

; 1523 :     return ( eDUMP_SUCCEEDED == pParams->eReturnValue ) ;

	mov	eax, DWORD PTR _pParams$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN8@DumpThread
	mov	DWORD PTR tv130[ebp], 1
	jmp	SHORT $LN9@DumpThread
$LN8@DumpThread:
	mov	DWORD PTR tv130[ebp], 0
$LN9@DumpThread:
	mov	eax, DWORD PTR tv130[ebp]

; 1524 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?DumpThread@@YGIPAX@Z ENDP				; DumpThread
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\crashhandler.cpp
_TEXT	SEGMENT
_stParams$ = -32					; size = 24
_dwTID$ = -8						; size = 4
_hThread$ = -4						; size = 4
_eType$ = 8						; size = 4
_szFileName$ = 12					; size = 4
_dwThread$ = 16						; size = 4
_pExceptInfo$ = 20					; size = 4
_CreateCurrentProcessMiniDumpW@16 PROC

; 1379 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 1380 :     // Check the string parameter because I am paranoid.  I can't check
; 1381 :     // the eType as that might change in the future.
; 1382 :     ASSERT ( FALSE == IsBadStringPtrW ( szFileName , MAX_PATH ) ) ;
; 1383 :     if ( TRUE == IsBadStringPtrW ( szFileName , MAX_PATH ) )

	push	260					; 00000104H
	mov	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	call	DWORD PTR __imp__IsBadStringPtrW@8
	cmp	eax, 1
	jne	SHORT $LN8@CreateCurr

; 1384 :     {
; 1385 :         return ( eBAD_PARAM ) ;

	mov	eax, 3
	jmp	$LN9@CreateCurr
$LN8@CreateCurr:

; 1386 :     }
; 1387 :     // If an exception pointer blob was passed in.
; 1388 :     if ( NULL != pExceptInfo )

	cmp	DWORD PTR _pExceptInfo$[ebp], 0
	je	SHORT $LN7@CreateCurr

; 1389 :     {
; 1390 :         ASSERT ( FALSE ==
; 1391 :            IsBadReadPtr ( pExceptInfo , sizeof ( EXCEPTION_POINTERS)));
; 1392 :         if ( TRUE ==
; 1393 :             IsBadReadPtr ( pExceptInfo , sizeof ( EXCEPTION_POINTERS)))

	push	8
	mov	ecx, DWORD PTR _pExceptInfo$[ebp]
	push	ecx
	call	DWORD PTR __imp__IsBadReadPtr@8
	cmp	eax, 1
	jne	SHORT $LN7@CreateCurr

; 1394 :         {
; 1395 :             return ( eBAD_PARAM ) ;

	mov	eax, 3
	jmp	$LN9@CreateCurr
$LN7@CreateCurr:

; 1396 :         }
; 1397 :     }
; 1398 : 
; 1399 :     // Have I even tried to get the exported MiniDumpWriteDump function
; 1400 :     // yet?
; 1401 :     if ( ( NULL == g_pfnMDWD ) && ( eINVALID_ERROR == g_eIMDALastError))

	cmp	DWORD PTR _g_pfnMDWD, 0
	jne	SHORT $LN5@CreateCurr
	cmp	DWORD PTR _g_eIMDALastError, 7
	jne	SHORT $LN5@CreateCurr

; 1402 :     {
; 1403 :         if ( FALSE == IsMiniDumpFunctionAvailable ( ) )

	call	_IsMiniDumpFunctionAvailable@0
	test	eax, eax
	jne	SHORT $LN5@CreateCurr

; 1404 :         {
; 1405 :             return ( g_eIMDALastError ) ;

	mov	eax, DWORD PTR _g_eIMDALastError
	jmp	$LN9@CreateCurr
$LN5@CreateCurr:

; 1406 :         }
; 1407 :     }
; 1408 :     // If the MiniDumpWriteDump function pointer is NULL, return
; 1409 :     // whatever was in g_eIMDALastError.
; 1410 :     if ( NULL == g_pfnMDWD )

	cmp	DWORD PTR _g_pfnMDWD, 0
	jne	SHORT $LN3@CreateCurr

; 1411 :     {
; 1412 :         return ( g_eIMDALastError ) ;

	mov	eax, DWORD PTR _g_eIMDALastError
	jmp	SHORT $LN9@CreateCurr
$LN3@CreateCurr:

; 1413 :     }
; 1414 : 
; 1415 :     // Package up the data for the dump writer thread.
; 1416 :     DUMPTHREADPARAMS stParams ;
; 1417 :     stParams.eReturnValue = eINVALID_ERROR  ;

	mov	DWORD PTR _stParams$[ebp+16], 7

; 1418 :     stParams.eType        = eType           ;

	mov	edx, DWORD PTR _eType$[ebp]
	mov	DWORD PTR _stParams$[ebp], edx

; 1419 :     stParams.pExceptInfo  = pExceptInfo     ;

	mov	eax, DWORD PTR _pExceptInfo$[ebp]
	mov	DWORD PTR _stParams$[ebp+12], eax

; 1420 :     stParams.dwThreadID   = dwThread        ;

	mov	ecx, DWORD PTR _dwThread$[ebp]
	mov	DWORD PTR _stParams$[ebp+8], ecx

; 1421 :     stParams.szFileName   = szFileName      ;

	mov	edx, DWORD PTR _szFileName$[ebp]
	mov	DWORD PTR _stParams$[ebp+4], edx

; 1422 :     stParams.dwMiniDumpWriteDumpLastError = ERROR_SUCCESS ;

	mov	DWORD PTR _stParams$[ebp+20], 0

; 1423 : 
; 1424 :     // Crank the writer thread.
; 1425 :     unsigned dwTID ;
; 1426 :     HANDLE hThread = (HANDLE)_beginthreadex ( NULL        ,
; 1427 :                                               0           ,
; 1428 :                                               DumpThread  ,
; 1429 :                                               &stParams   ,
; 1430 :                                               0           ,
; 1431 :                                               &dwTID       ) ;

	lea	eax, DWORD PTR _dwTID$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR _stParams$[ebp]
	push	ecx
	push	OFFSET ?DumpThread@@YGIPAX@Z		; DumpThread
	push	0
	push	0
	call	__beginthreadex
	add	esp, 24					; 00000018H
	mov	DWORD PTR _hThread$[ebp], eax

; 1432 :     ASSERT ( (HANDLE)-1 != hThread ) ;
; 1433 :     if ( (HANDLE)-1 != hThread )

	cmp	DWORD PTR _hThread$[ebp], -1
	je	SHORT $LN2@CreateCurr

; 1434 :     {
; 1435 :         // The thread is running.  Block until the thread ends.
; 1436 :         WaitForSingleObject ( hThread , INFINITE ) ;

	push	-1
	mov	edx, DWORD PTR _hThread$[ebp]
	push	edx
	call	DWORD PTR __imp__WaitForSingleObject@8

; 1437 : 
; 1438 :         // Close the handle.
; 1439 :         VERIFY ( CloseHandle ( hThread ) ) ;

	mov	eax, DWORD PTR _hThread$[ebp]
	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 1440 : 
; 1441 :     }
; 1442 :     else

	jmp	SHORT $LN1@CreateCurr
$LN2@CreateCurr:

; 1443 :     {
; 1444 :         stParams.dwMiniDumpWriteDumpLastError = GetLastError ( ) ;

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _stParams$[ebp+20], eax

; 1445 :         stParams.eReturnValue = eDEATH_ERROR ;

	mov	DWORD PTR _stParams$[ebp+16], 6
$LN1@CreateCurr:

; 1446 :     }
; 1447 : 
; 1448 :     // Set the last error code based so it looks like this thread made
; 1449 :     // the call to MiniDumpWriteDump.
; 1450 :     SetLastError ( stParams.dwMiniDumpWriteDumpLastError ) ;

	mov	ecx, DWORD PTR _stParams$[ebp+20]
	push	ecx
	call	DWORD PTR __imp__SetLastError@4

; 1451 : 
; 1452 :     return ( stParams.eReturnValue ) ;

	mov	eax, DWORD PTR _stParams$[ebp+16]
$LN9@CreateCurr:

; 1453 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_CreateCurrentProcessMiniDumpW@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\crashhandler.cpp
_TEXT	SEGMENT
_iRet$ = -16						; size = 4
_iLen$ = -12						; size = 4
_eRetVal$ = -8						; size = 4
_pWideFileName$ = -4					; size = 4
_eType$ = 8						; size = 4
_szFileName$ = 12					; size = 4
_dwThread$ = 16						; size = 4
_pExceptInfo$ = 20					; size = 4
_CreateCurrentProcessMiniDumpA@16 PROC

; 1326 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1327 :     // Check the string parameter because I am paranoid.
; 1328 :     ASSERT ( FALSE == IsBadStringPtrA ( szFileName , MAX_PATH ) ) ;
; 1329 :     if ( TRUE == IsBadStringPtrA ( szFileName , MAX_PATH ) )

	push	260					; 00000104H
	mov	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	call	DWORD PTR __imp__IsBadStringPtrA@8
	cmp	eax, 1
	jne	SHORT $LN4@CreateCurr

; 1330 :     {
; 1331 :         return ( eBAD_PARAM ) ;

	mov	eax, 3
	jmp	$LN5@CreateCurr
$LN4@CreateCurr:

; 1332 :     }
; 1333 : 
; 1334 :     // The return value.
; 1335 :     BSUMDRET eRetVal = eDUMP_SUCCEEDED ;

	mov	DWORD PTR _eRetVal$[ebp], 0

; 1336 : 
; 1337 :     // Allocate enough space to hold the converted string.
; 1338 :     int iLen = ( lstrlenA ( szFileName ) + 1 ) * sizeof ( wchar_t ) ;

	mov	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenA@4
	lea	edx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR _iLen$[ebp], edx

; 1339 :     wchar_t * pWideFileName = (wchar_t*)
; 1340 :                                HeapAlloc ( GetProcessHeap ( )         ,
; 1341 :                                            HEAP_GENERATE_EXCEPTIONS |
; 1342 :                                              HEAP_ZERO_MEMORY         ,
; 1343 :                                            iLen                       );

	mov	eax, DWORD PTR _iLen$[ebp]
	push	eax
	push	12					; 0000000cH
	call	DWORD PTR __imp__GetProcessHeap@0
	push	eax
	call	DWORD PTR __imp__HeapAlloc@12
	mov	DWORD PTR _pWideFileName$[ebp], eax

; 1344 : 
; 1345 :     int iRet = MultiByteToWideChar ( CP_ACP          ,
; 1346 :                                      MB_PRECOMPOSED  ,
; 1347 :                                      szFileName      ,
; 1348 :                                      -1              ,
; 1349 :                                      pWideFileName   ,
; 1350 :                                      iLen             ) ;

	mov	ecx, DWORD PTR _iLen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pWideFileName$[ebp]
	push	edx
	push	-1
	mov	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	push	1
	push	0
	call	DWORD PTR __imp__MultiByteToWideChar@24
	mov	DWORD PTR _iRet$[ebp], eax

; 1351 :     ASSERT ( iRet != 0 ) ;
; 1352 :     if ( iRet != 0 )

	cmp	DWORD PTR _iRet$[ebp], 0
	je	SHORT $LN3@CreateCurr

; 1353 :     {
; 1354 :         // The conversion worked, call the wide function.
; 1355 :         eRetVal = CreateCurrentProcessMiniDumpW ( eType         ,
; 1356 :                                                   pWideFileName ,
; 1357 :                                                   dwThread      ,
; 1358 :                                                   pExceptInfo    ) ;

	mov	ecx, DWORD PTR _pExceptInfo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwThread$[ebp]
	push	edx
	mov	eax, DWORD PTR _pWideFileName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eType$[ebp]
	push	ecx
	call	_CreateCurrentProcessMiniDumpW@16
	mov	DWORD PTR _eRetVal$[ebp], eax

; 1359 :     }
; 1360 :     else

	jmp	SHORT $LN2@CreateCurr
$LN3@CreateCurr:

; 1361 :     {
; 1362 :         eRetVal = eBAD_PARAM ;

	mov	DWORD PTR _eRetVal$[ebp], 3
$LN2@CreateCurr:

; 1363 :     }
; 1364 : 
; 1365 :     if ( NULL != pWideFileName )

	cmp	DWORD PTR _pWideFileName$[ebp], 0
	je	SHORT $LN1@CreateCurr

; 1366 :     {
; 1367 :         HeapFree ( GetProcessHeap ( ) , 0 , pWideFileName ) ;

	mov	edx, DWORD PTR _pWideFileName$[ebp]
	push	edx
	push	0
	call	DWORD PTR __imp__GetProcessHeap@0
	push	eax
	call	DWORD PTR __imp__HeapFree@12
$LN1@CreateCurr:

; 1368 :     }
; 1369 : 
; 1370 :     return ( eRetVal ) ;

	mov	eax, DWORD PTR _eRetVal$[ebp]
$LN5@CreateCurr:

; 1371 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_CreateCurrentProcessMiniDumpA@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\crashhandler.cpp
_TEXT	SEGMENT
tv76 = -8						; size = 4
_hInstDBGHELP$1 = -4					; size = 4
_IsMiniDumpFunctionAvailable@0 PROC

; 1278 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1279 :     // If this is the first time through, always do it.
; 1280 :     if ( NULL == g_pfnMDWD )

	cmp	DWORD PTR _g_pfnMDWD, 0
	jne	SHORT $LN6@IsMiniDump

; 1281 :     {
; 1282 :         // Find DBGHELP.DLL in memory.
; 1283 :         HINSTANCE hInstDBGHELP = GetModuleHandle ( k_DBGHELPDLLNAME ) ;

	mov	eax, DWORD PTR _k_DBGHELPDLLNAME
	push	eax
	call	DWORD PTR __imp__GetModuleHandleA@4
	mov	DWORD PTR _hInstDBGHELP$1[ebp], eax

; 1284 :         // BugslayerUtil.DLL has it in memory, but someone might excise
; 1285 :         // this file for their own purposes so try and load it.
; 1286 :         if ( NULL == hInstDBGHELP )

	cmp	DWORD PTR _hInstDBGHELP$1[ebp], 0
	jne	SHORT $LN5@IsMiniDump

; 1287 :         {
; 1288 :             hInstDBGHELP = LoadLibrary ( k_DBGHELPDLLNAME ) ;

	mov	ecx, DWORD PTR _k_DBGHELPDLLNAME
	push	ecx
	call	DWORD PTR __imp__LoadLibraryA@4
	mov	DWORD PTR _hInstDBGHELP$1[ebp], eax
$LN5@IsMiniDump:

; 1289 :         }
; 1290 :         if ( NULL != hInstDBGHELP )

	cmp	DWORD PTR _hInstDBGHELP$1[ebp], 0
	je	SHORT $LN4@IsMiniDump

; 1291 :         {
; 1292 :             // At least I have DBGHELP.DLL's handle.  Get the exported
; 1293 :             // function.
; 1294 :             g_pfnMDWD = (PFNMINIDUMPWRITEDUMP)
; 1295 :                  GetProcAddress ( hInstDBGHELP , k_MINIDUMPWRITEDUMP ) ;

	mov	edx, DWORD PTR _k_MINIDUMPWRITEDUMP
	push	edx
	mov	eax, DWORD PTR _hInstDBGHELP$1[ebp]
	push	eax
	call	DWORD PTR __imp__GetProcAddress@8
	mov	DWORD PTR _g_pfnMDWD, eax

; 1296 : 
; 1297 : 
; 1298 :             if ( NULL != g_pfnMDWD )

	cmp	DWORD PTR _g_pfnMDWD, 0
	je	SHORT $LN3@IsMiniDump

; 1299 :             {
; 1300 :                 // It's good so set the last error for this function.
; 1301 :                 g_eIMDALastError = eDUMP_SUCCEEDED ;

	mov	DWORD PTR _g_eIMDALastError, 0

; 1302 :             }
; 1303 :             else

	jmp	SHORT $LN2@IsMiniDump
$LN3@IsMiniDump:

; 1304 :             {
; 1305 :                 // Ain't got the export.
; 1306 :                 g_eIMDALastError = eDBGHELP_MISSING_EXPORTS ;

	mov	DWORD PTR _g_eIMDALastError, 2
$LN2@IsMiniDump:

; 1307 :             }
; 1308 : 
; 1309 :         }
; 1310 :         else

	jmp	SHORT $LN6@IsMiniDump
$LN4@IsMiniDump:

; 1311 :         {
; 1312 :             // Can't find DBGHELP.DLL!  Save this for the
; 1313 :             // CreateCurrentProcessMiniDump function to return.
; 1314 :             g_eIMDALastError = eDBGHELP_NOT_FOUND ;

	mov	DWORD PTR _g_eIMDALastError, 1
$LN6@IsMiniDump:

; 1315 :         }
; 1316 :     }
; 1317 :     // If g_pfnMDWD is not NULL, I found it.
; 1318 :     return ( NULL != g_pfnMDWD ) ;

	cmp	DWORD PTR _g_pfnMDWD, 0
	je	SHORT $LN9@IsMiniDump
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN10@IsMiniDump
$LN9@IsMiniDump:
	mov	DWORD PTR tv76[ebp], 0
$LN10@IsMiniDump:
	mov	eax, DWORD PTR tv76[ebp]

; 1319 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_IsMiniDumpFunctionAvailable@0 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\crashhandler.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_lpBaseAddress$ = 12					; size = 4
_lpBuffer$ = 16						; size = 4
_nSize$ = 20						; size = 4
_lpNumberOfBytesRead$ = 24				; size = 4
?CH_ReadProcessMemory@@YGHPAXPBX0KPAK@Z PROC		; CH_ReadProcessMemory

; 605  : {

	push	ebp
	mov	ebp, esp

; 606  :     return ( ReadProcessMemory ( GetCurrentProcess ( ) ,
; 607  :                                  lpBaseAddress         ,
; 608  :                                  lpBuffer              ,
; 609  :                                  nSize                 ,
; 610  :                                  lpNumberOfBytesRead    ) ) ;

	mov	eax, DWORD PTR _lpNumberOfBytesRead$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpBuffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpBaseAddress$[ebp]
	push	eax
	call	DWORD PTR __imp__GetCurrentProcess@0
	push	eax
	call	DWORD PTR __imp__ReadProcessMemory@20

; 611  : }

	pop	ebp
	ret	20					; 00000014H
?CH_ReadProcessMemory@@YGHPAXPBX0KPAK@Z ENDP		; CH_ReadProcessMemory
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__Fg_cBeforeAndAfter@@YAXXZ
text$yd	SEGMENT
??__Fg_cBeforeAndAfter@@YAXXZ PROC			; `dynamic atexit destructor for 'g_cBeforeAndAfter'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _g_cBeforeAndAfter
	call	??1CleanUpCrashHandler@@QAE@XZ		; CleanUpCrashHandler::~CleanUpCrashHandler
	pop	ebp
	ret	0
??__Fg_cBeforeAndAfter@@YAXXZ ENDP			; `dynamic atexit destructor for 'g_cBeforeAndAfter''
text$yd	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\crashhandler.cpp
;	COMDAT ??__Eg_cBeforeAndAfter@@YAXXZ
text$yc	SEGMENT
??__Eg_cBeforeAndAfter@@YAXXZ PROC			; `dynamic initializer for 'g_cBeforeAndAfter'', COMDAT

; 116  : static CleanUpCrashHandler g_cBeforeAndAfter ;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _g_cBeforeAndAfter
	call	??0CleanUpCrashHandler@@QAE@XZ		; CleanUpCrashHandler::CleanUpCrashHandler
	push	OFFSET ??__Fg_cBeforeAndAfter@@YAXXZ	; `dynamic atexit destructor for 'g_cBeforeAndAfter''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__Eg_cBeforeAndAfter@@YAXXZ ENDP			; `dynamic initializer for 'g_cBeforeAndAfter''
text$yc	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\crashhandler.cpp
;	COMDAT ??1CleanUpCrashHandler@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CleanUpCrashHandler@@QAE@XZ PROC			; CleanUpCrashHandler::~CleanUpCrashHandler, COMDAT
; _this$ = ecx

; 98   :     {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 99   :         // Is there any outstanding memory allocations?
; 100  :         if ( NULL != g_ahMod )

	cmp	DWORD PTR _g_ahMod, 0
	je	SHORT $LN2@CleanUpCra

; 101  :         {
; 102  :             VERIFY ( HeapFree ( GetProcessHeap ( ) ,

	mov	eax, DWORD PTR _g_ahMod
	push	eax
	push	0
	call	DWORD PTR __imp__GetProcessHeap@0
	push	eax
	call	DWORD PTR __imp__HeapFree@12

; 103  :                                 0                  ,
; 104  :                                 g_ahMod             ) ) ;
; 105  :             g_ahMod = NULL ;

	mov	DWORD PTR _g_ahMod, 0
$LN2@CleanUpCra:

; 106  :         }
; 107  :         if ( NULL != g_pfnOrigFilt )

	cmp	DWORD PTR _g_pfnOrigFilt, 0
	je	SHORT $LN3@CleanUpCra

; 108  :         {
; 109  :             // Set the handler back to what it originally was.
; 110  :             SetUnhandledExceptionFilter ( g_pfnOrigFilt ) ;

	mov	ecx, DWORD PTR _g_pfnOrigFilt
	push	ecx
	call	DWORD PTR __imp__SetUnhandledExceptionFilter@4
$LN3@CleanUpCra:

; 111  :         }
; 112  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
??1CleanUpCrashHandler@@QAE@XZ ENDP			; CleanUpCrashHandler::~CleanUpCrashHandler
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\crashhandler.cpp
;	COMDAT ??0CleanUpCrashHandler@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CleanUpCrashHandler@@QAE@XZ PROC			; CleanUpCrashHandler::CleanUpCrashHandler, COMDAT
; _this$ = ecx

; 94   :     CleanUpCrashHandler ( void )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 95   :     {
; 96   :     }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CleanUpCrashHandler@@QAE@XZ ENDP			; CleanUpCrashHandler::CleanUpCrashHandler
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\crashhandler.cpp
_TEXT	SEGMENT
?CleanupSymEng@@YAXXZ PROC				; CleanupSymEng

; 1194 : {

	push	ebp
	mov	ebp, esp

; 1195 :     if ( TRUE == g_bSymEngInit )

	cmp	DWORD PTR _g_bSymEngInit, 1
	jne	SHORT $LN1@CleanupSym

; 1196 :     {
; 1197 :         VERIFY ( SymCleanup ( (HANDLE)GetCurrentProcessId ( ) ) ) ;

	call	DWORD PTR __imp__GetCurrentProcessId@0
	push	eax
	call	DWORD PTR __imp__SymCleanup@4
$LN1@CleanupSym:

; 1198 :     }
; 1199 :     g_bSymEngInit = FALSE ;

	mov	DWORD PTR _g_bSymEngInit, 0

; 1200 : }

	pop	ebp
	ret	0
?CleanupSymEng@@YAXXZ ENDP				; CleanupSymEng
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\crashhandler.cpp
_TEXT	SEGMENT
_dwOpts$1 = -296					; size = 4
$T2 = -292						; size = 4
$T3 = -288						; size = 4
_hFile$4 = -284						; size = 4
$T5 = -280						; size = 4
_uiCount$6 = -276					; size = 4
_uiCurr$7 = -272					; size = 4
_paMods$8 = -268					; size = 4
_szModName$9 = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
?InitSymEng@@YAXXZ PROC					; InitSymEng

; 1123 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1124 :     if ( FALSE == g_bSymEngInit )

	cmp	DWORD PTR _g_bSymEngInit, 0
	jne	$LN5@InitSymEng

; 1125 :     {
; 1126 :         // Set up the symbol engine.
; 1127 :         DWORD dwOpts = SymGetOptions ( ) ;

	call	DWORD PTR __imp__SymGetOptions@0
	mov	DWORD PTR _dwOpts$1[ebp], eax

; 1128 : 
; 1129 :         // Turn on load lines.
; 1130 :         SymSetOptions ( dwOpts                |
; 1131 :                         SYMOPT_LOAD_LINES      ) ;

	mov	eax, DWORD PTR _dwOpts$1[ebp]
	or	eax, 16					; 00000010H
	push	eax
	call	DWORD PTR __imp__SymSetOptions@4

; 1132 : 
; 1133 :         // Initialize the symbol engine.
; 1134 :         VERIFY ( SymInitialize ( (HANDLE)GetCurrentProcessId ( ) ,
; 1135 :                                  NULL                            ,
; 1136 :                                  FALSE                            ) ) ;

	push	0
	push	0
	call	DWORD PTR __imp__GetCurrentProcessId@0
	push	eax
	call	DWORD PTR __imp__SymInitialize@12

; 1137 :         UINT uiCount ;
; 1138 :         // Find out how many modules there are.
; 1139 :         VERIFY ( GetLoadedModules ( GetCurrentProcessId ( ) ,
; 1140 :                                     0                       ,
; 1141 :                                     NULL                    ,
; 1142 :                                     &uiCount                 ) ) ;

	lea	ecx, DWORD PTR _uiCount$6[ebp]
	push	ecx
	push	0
	push	0
	call	DWORD PTR __imp__GetCurrentProcessId@0
	push	eax
	call	_GetLoadedModules@16

; 1143 :         // Allocate something big enough to hold the list.
; 1144 :         HMODULE * paMods = new HMODULE[ uiCount ] ;

	xor	ecx, ecx
	mov	eax, DWORD PTR _uiCount$6[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR _paMods$8[ebp], eax

; 1145 : 
; 1146 :         // Get the list for real.
; 1147 :         if ( FALSE == GetLoadedModules ( GetCurrentProcessId ( ) ,
; 1148 :                                          uiCount                 ,
; 1149 :                                          paMods                  ,
; 1150 :                                          &uiCount                 ) )

	lea	ecx, DWORD PTR _uiCount$6[ebp]
	push	ecx
	mov	edx, DWORD PTR _paMods$8[ebp]
	push	edx
	mov	eax, DWORD PTR _uiCount$6[ebp]
	push	eax
	call	DWORD PTR __imp__GetCurrentProcessId@0
	push	eax
	call	_GetLoadedModules@16
	test	eax, eax
	jne	SHORT $LN4@InitSymEng

; 1151 :         {
; 1152 :             ASSERT ( FALSE ) ;
; 1153 :             // Free the memory that I allocated earlier.
; 1154 :             delete [] paMods ;

	mov	ecx, DWORD PTR _paMods$8[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1155 :             // There's not much I can do here...
; 1156 :             g_bSymEngInit = FALSE ;

	mov	DWORD PTR _g_bSymEngInit, 0

; 1157 :             return ;

	jmp	$LN6@InitSymEng
$LN4@InitSymEng:

; 1158 :         }
; 1159 :         // The module filename.
; 1160 :         TCHAR szModName [ MAX_PATH ] ;
; 1161 :         for ( UINT uiCurr = 0 ; uiCurr < uiCount ; uiCurr++ )

	mov	DWORD PTR _uiCurr$7[ebp], 0
	jmp	SHORT $LN3@InitSymEng
$LN2@InitSymEng:
	mov	eax, DWORD PTR _uiCurr$7[ebp]
	add	eax, 1
	mov	DWORD PTR _uiCurr$7[ebp], eax
$LN3@InitSymEng:
	mov	ecx, DWORD PTR _uiCurr$7[ebp]
	cmp	ecx, DWORD PTR _uiCount$6[ebp]
	jae	SHORT $LN1@InitSymEng

; 1162 :         {
; 1163 :             // Get the module's filename.
; 1164 :             VERIFY ( GetModuleFileName ( paMods[ uiCurr ]     ,
; 1165 :                                          szModName            ,
; 1166 :                                          sizeof ( szModName )  ) ) ;

	push	260					; 00000104H
	lea	edx, DWORD PTR _szModName$9[ebp]
	push	edx
	mov	eax, DWORD PTR _uiCurr$7[ebp]
	mov	ecx, DWORD PTR _paMods$8[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	DWORD PTR __imp__GetModuleFileNameA@12

; 1167 : 
; 1168 :             // In order to get the symbol engine to work outside a
; 1169 :             //  debugger, it needs a handle to the image.  Yes, this
; 1170 :             //  will leak but the OS will close it down when the process
; 1171 :             //  ends.
; 1172 :             HANDLE hFile = CreateFile ( szModName       ,
; 1173 :                                         GENERIC_READ    ,
; 1174 :                                         FILE_SHARE_READ ,
; 1175 :                                         NULL            ,
; 1176 :                                         OPEN_EXISTING   ,
; 1177 :                                         0               ,
; 1178 :                                         0                ) ;

	push	0
	push	0
	push	3
	push	0
	push	1
	push	-2147483648				; 80000000H
	lea	eax, DWORD PTR _szModName$9[ebp]
	push	eax
	call	DWORD PTR __imp__CreateFileA@28
	mov	DWORD PTR _hFile$4[ebp], eax

; 1179 : 
; 1180 :             VERIFY ( SymLoadModule ( (HANDLE)GetCurrentProcessId ( ) ,
; 1181 :                                      hFile                           ,
; 1182 :                                      szModName                       ,
; 1183 :                                      NULL                            ,
; 1184 :                                      (DWORD)paMods[ uiCurr ]         ,
; 1185 :                                      0                               ));

	push	0
	mov	ecx, DWORD PTR _uiCurr$7[ebp]
	mov	edx, DWORD PTR _paMods$8[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	push	0
	lea	ecx, DWORD PTR _szModName$9[ebp]
	push	ecx
	mov	edx, DWORD PTR _hFile$4[ebp]
	push	edx
	call	DWORD PTR __imp__GetCurrentProcessId@0
	push	eax
	call	DWORD PTR __imp__SymLoadModule@24

; 1186 :         }

	jmp	$LN2@InitSymEng
$LN1@InitSymEng:

; 1187 :         delete [] paMods ;

	mov	eax, DWORD PTR _paMods$8[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@InitSymEng:

; 1188 :     }
; 1189 :     g_bSymEngInit = TRUE ;

	mov	DWORD PTR _g_bSymEngInit, 1
$LN6@InitSymEng:

; 1190 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?InitSymEng@@YAXXZ ENDP					; InitSymEng
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\crashhandler.cpp
_TEXT	SEGMENT
_dwTempDis$1 = -4					; size = 4
_hProcess$ = 8						; size = 4
_dwAddr$ = 12						; size = 4
_pdwDisplacement$ = 16					; size = 4
_Line$ = 20						; size = 4
?InternalSymGetLineFromAddr@@YAHPAXKPAKPAU_IMAGEHLP_LINE@@@Z PROC ; InternalSymGetLineFromAddr

; 1072 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1073 :     // Have I already done the GetProcAddress?
; 1074 :     if ( FALSE == g_bLookedForSymFuncs )

	cmp	DWORD PTR _g_bLookedForSymFuncs, 0
	jne	SHORT $LN6@InternalSy

; 1075 :     {
; 1076 :         g_bLookedForSymFuncs = TRUE ;

	mov	DWORD PTR _g_bLookedForSymFuncs, 1

; 1077 :         g_pfnSymGetLineFromAddr = (PFNSYMGETLINEFROMADDR)
; 1078 :                      GetProcAddress(GetModuleHandle(_T("IMAGEHLP.DLL")),
; 1079 :                                    "SymGetLineFromAddr"               );

	push	OFFSET ??_C@_0BD@HHOPHPBF@SymGetLineFromAddr?$AA@
	push	OFFSET ??_C@_0N@KBGMOMJO@IMAGEHLP?4DLL?$AA@
	call	DWORD PTR __imp__GetModuleHandleA@4
	push	eax
	call	DWORD PTR __imp__GetProcAddress@8
	mov	DWORD PTR _g_pfnSymGetLineFromAddr, eax
$LN6@InternalSy:

; 1080 :     }
; 1081 :     if ( NULL != g_pfnSymGetLineFromAddr )

	cmp	DWORD PTR _g_pfnSymGetLineFromAddr, 0
	je	SHORT $LN5@InternalSy

; 1082 :     {
; 1083 : #ifdef WORK_AROUND_SRCLINE_BUG
; 1084 : 
; 1085 :         // The problem is that the symbol engine only finds those source
; 1086 :         //  line addresses (after the first lookup) that fall exactly on
; 1087 :         //  a zero displacement.  I will walk backwards 100 bytes to
; 1088 :         //  find the line and return the proper displacement.
; 1089 :         DWORD dwTempDis = 0 ;

	mov	DWORD PTR _dwTempDis$1[ebp], 0
$LN4@InternalSy:

; 1090 :         while ( FALSE == g_pfnSymGetLineFromAddr ( hProcess        ,
; 1091 :                                                    dwAddr -
; 1092 :                                                     dwTempDis      ,
; 1093 :                                                    pdwDisplacement ,
; 1094 :                                                    Line             ) )

	mov	eax, DWORD PTR _Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pdwDisplacement$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwAddr$[ebp]
	sub	edx, DWORD PTR _dwTempDis$1[ebp]
	push	edx
	mov	eax, DWORD PTR _hProcess$[ebp]
	push	eax
	call	DWORD PTR _g_pfnSymGetLineFromAddr
	test	eax, eax
	jne	SHORT $LN3@InternalSy

; 1095 :         {
; 1096 :             dwTempDis += 1 ;

	mov	ecx, DWORD PTR _dwTempDis$1[ebp]
	add	ecx, 1
	mov	DWORD PTR _dwTempDis$1[ebp], ecx

; 1097 :             if ( 100 == dwTempDis )

	cmp	DWORD PTR _dwTempDis$1[ebp], 100	; 00000064H
	jne	SHORT $LN2@InternalSy

; 1098 :             {
; 1099 :                 return ( FALSE ) ;

	xor	eax, eax
	jmp	SHORT $LN7@InternalSy
$LN2@InternalSy:

; 1100 :             }
; 1101 :         }

	jmp	SHORT $LN4@InternalSy
$LN3@InternalSy:

; 1102 : 
; 1103 :         // It was found and the source line information is correct so
; 1104 :         //  change the displacement if it was looked up multiple times.
; 1105 :         if ( 0 != dwTempDis )

	cmp	DWORD PTR _dwTempDis$1[ebp], 0
	je	SHORT $LN1@InternalSy

; 1106 :         {
; 1107 :             *pdwDisplacement = dwTempDis ;

	mov	edx, DWORD PTR _pdwDisplacement$[ebp]
	mov	eax, DWORD PTR _dwTempDis$1[ebp]
	mov	DWORD PTR [edx], eax
$LN1@InternalSy:

; 1108 :         }
; 1109 :         return ( TRUE ) ;

	mov	eax, 1
	jmp	SHORT $LN7@InternalSy
$LN5@InternalSy:

; 1110 : 
; 1111 : #else  // WORK_AROUND_SRCLINE_BUG
; 1112 :         return ( g_pfnSymGetLineFromAddr ( hProcess         ,
; 1113 :                                            dwAddr           ,
; 1114 :                                            pdwDisplacement  ,
; 1115 :                                            Line              ) ) ;
; 1116 : #endif
; 1117 :     }
; 1118 :     return ( FALSE ) ;

	xor	eax, eax
$LN7@InternalSy:

; 1119 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InternalSymGetLineFromAddr@@YAHPAXKPAKPAU_IMAGEHLP_LINE@@@Z ENDP ; InternalSymGetLineFromAddr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\crashhandler.cpp
_TEXT	SEGMENT
_bSWRet$2 = -48						; size = 4
_dwDisp$3 = -44						; size = 4
_szRet$ = -40						; size = 4
_dwTemp$ = -36						; size = 4
_pSym$4 = -32						; size = 4
_iCurr$5 = -28						; size = 4
__$SEHRec$ = -24					; size = 24
_dwOpts$ = 8						; size = 4
_pExPtrs$ = 12						; size = 4
?InternalGetStackTraceString@@YGPBDKPAU_EXCEPTION_POINTERS@@@Z PROC ; InternalGetStackTraceString

; 617  : {

	push	ebp
	mov	ebp, esp
	push	-2					; fffffffeH
	push	OFFSET __sehtable$?InternalGetStackTraceString@@YGPBDKPAU_EXCEPTION_POINTERS@@@Z
	push	OFFSET __except_handler4
	mov	eax, DWORD PTR fs:0
	push	eax
	add	esp, -32				; ffffffe0H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	DWORD PTR __$SEHRec$[ebp+16], eax
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$SEHRec$[ebp], esp

; 618  : 
; 619  :     ASSERT ( FALSE == IsBadReadPtr ( pExPtrs                      ,
; 620  :                                      sizeof (EXCEPTION_POINTERS )));
; 621  :     if ( TRUE == IsBadReadPtr ( pExPtrs                      ,
; 622  :                                 sizeof ( EXCEPTION_POINTERS ) ) )

	push	8
	mov	eax, DWORD PTR _pExPtrs$[ebp]
	push	eax
	call	DWORD PTR __imp__IsBadReadPtr@8
	cmp	eax, 1
	jne	SHORT $LN21@InternalGe

; 623  :     {
; 624  :         TRACE0 ( "GetStackTraceString - invalid pExPtrs!\n" ) ;
; 625  :         return ( NULL ) ;

	xor	eax, eax
	jmp	$LN24@InternalGe
$LN21@InternalGe:

; 626  :     }
; 627  : 
; 628  :     // The value that is returned.
; 629  :     LPCTSTR szRet ;
; 630  :     // A temporary for all to use.  This saves stack space.
; 631  :     DWORD dwTemp ;
; 632  : 
; 633  :     __try

	mov	DWORD PTR __$SEHRec$[ebp+20], 0

; 634  :     {
; 635  :         // Initialize the symbol engine in case it is not initialized.
; 636  :         InitSymEng ( ) ;

	call	?InitSymEng@@YAXXZ			; InitSymEng

; 637  : 
; 638  : #ifdef _ALPHA_
; 639  : #define CH_MACHINE IMAGE_FILE_MACHINE_ALPHA
; 640  : #else
; 641  : #define CH_MACHINE IMAGE_FILE_MACHINE_I386
; 642  : #endif
; 643  :         // Note:  If the source and line functions are used, then
; 644  :         //        StackWalk can access violate.
; 645  :         BOOL bSWRet = StackWalk ( CH_MACHINE                        ,
; 646  :                                   (HANDLE)GetCurrentProcessId ( )   ,
; 647  :                                   GetCurrentThread ( )              ,
; 648  :                                   &g_stFrame                        ,
; 649  :                                   pExPtrs->ContextRecord            ,
; 650  :                                   (PREAD_PROCESS_MEMORY_ROUTINE)
; 651  :                                                CH_ReadProcessMemory ,
; 652  :                                   SymFunctionTableAccess            ,
; 653  :                                   SymGetModuleBase                  ,
; 654  :                                   NULL                               ) ;

	push	0
	mov	ecx, DWORD PTR __imp__SymGetModuleBase@8
	push	ecx
	mov	edx, DWORD PTR __imp__SymFunctionTableAccess@8
	push	edx
	push	OFFSET ?CH_ReadProcessMemory@@YGHPAXPBX0KPAK@Z ; CH_ReadProcessMemory
	mov	eax, DWORD PTR _pExPtrs$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	OFFSET _g_stFrame
	call	DWORD PTR __imp__GetCurrentThread@0
	push	eax
	call	DWORD PTR __imp__GetCurrentProcessId@0
	push	eax
	push	332					; 0000014cH
	call	DWORD PTR __imp__StackWalk@36
	mov	DWORD PTR _bSWRet$2[ebp], eax

; 655  :         if ( ( FALSE == bSWRet ) || ( 0 == g_stFrame.AddrFrame.Offset ))

	cmp	DWORD PTR _bSWRet$2[ebp], 0
	je	SHORT $LN18@InternalGe
	cmp	DWORD PTR _g_stFrame+24, 0
	jne	SHORT $LN19@InternalGe
$LN18@InternalGe:

; 656  :         {
; 657  :             szRet = NULL ;

	mov	DWORD PTR _szRet$[ebp], 0

; 658  :             __leave ;

	jmp	$LN20@InternalGe
$LN19@InternalGe:

; 659  :         }
; 660  : 
; 661  :         int iCurr = 0 ;

	mov	DWORD PTR _iCurr$5[ebp], 0

; 662  : 
; 663  :         // At a minimum, put the address in.
; 664  : #ifdef _ALPHA_
; 665  :         iCurr += wsprintf ( g_szBuff + iCurr        ,
; 666  :                             _T ( "0x%08X" )         ,
; 667  :                             g_stFrame.AddrPC.Offset  ) ;
; 668  : #else
; 669  :         iCurr += wsprintf ( g_szBuff + iCurr              ,
; 670  :                             _T ( "%04X:%08X" )            ,
; 671  :                             pExPtrs->ContextRecord->SegCs ,
; 672  :                             g_stFrame.AddrPC.Offset        ) ;

	mov	edx, DWORD PTR _g_stFrame
	push	edx
	mov	eax, DWORD PTR _pExPtrs$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+188]
	push	edx
	push	OFFSET ??_C@_09IOHMHKPC@?$CF04X?3?$CF08X?$AA@
	mov	eax, DWORD PTR _iCurr$5[ebp]
	add	eax, OFFSET _g_szBuff
	push	eax
	call	DWORD PTR __imp__wsprintfA
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _iCurr$5[ebp]
	mov	DWORD PTR _iCurr$5[ebp], eax

; 673  : #endif
; 674  : 
; 675  :         // Do the parameters?
; 676  :         if ( GSTSO_PARAMS == ( dwOpts & GSTSO_PARAMS ) )

	mov	ecx, DWORD PTR _dwOpts$[ebp]
	and	ecx, 1
	je	SHORT $LN17@InternalGe

; 677  :         {
; 678  :             iCurr += wsprintf ( g_szBuff + iCurr          ,
; 679  :                                 _T ( " (0x%08X 0x%08X "\
; 680  :                                       "0x%08X 0x%08X)"  ) ,
; 681  :                                 g_stFrame.Params[ 0 ]     ,
; 682  :                                 g_stFrame.Params[ 1 ]     ,
; 683  :                                 g_stFrame.Params[ 2 ]     ,
; 684  :                                 g_stFrame.Params[ 3 ]      ) ;

	mov	edx, 4
	imul	edx, 3
	mov	eax, DWORD PTR _g_stFrame[edx+52]
	push	eax
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _g_stFrame[ecx+52]
	push	edx
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _g_stFrame[eax+52]
	push	ecx
	mov	edx, 4
	imul	edx, 0
	mov	eax, DWORD PTR _g_stFrame[edx+52]
	push	eax
	push	OFFSET ??_C@_0BP@NDGHPOJN@?5?$CI0x?$CF08X?50x?$CF08X?50x?$CF08X?50x?$CF08X?$CJ?$AA@
	mov	ecx, DWORD PTR _iCurr$5[ebp]
	add	ecx, OFFSET _g_szBuff
	push	ecx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 24					; 00000018H
	add	eax, DWORD PTR _iCurr$5[ebp]
	mov	DWORD PTR _iCurr$5[ebp], eax
$LN17@InternalGe:

; 685  :         }
; 686  : 
; 687  :         if ( GSTSO_MODULE == ( dwOpts & GSTSO_MODULE ) )

	mov	edx, DWORD PTR _dwOpts$[ebp]
	and	edx, 2
	je	$LN16@InternalGe

; 688  :         {
; 689  :             iCurr += wsprintf ( g_szBuff + iCurr  , _T ( " " ) ) ;

	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	mov	eax, DWORD PTR _iCurr$5[ebp]
	add	eax, OFFSET _g_szBuff
	push	eax
	call	DWORD PTR __imp__wsprintfA
	add	esp, 8
	add	eax, DWORD PTR _iCurr$5[ebp]
	mov	DWORD PTR _iCurr$5[ebp], eax

; 690  : 
; 691  :             dwTemp = SymGetModuleBase ( (HANDLE)GetCurrentProcessId ( ),
; 692  :                                         g_stFrame.AddrPC.Offset       );

	mov	ecx, DWORD PTR _g_stFrame
	push	ecx
	call	DWORD PTR __imp__GetCurrentProcessId@0
	push	eax
	call	DWORD PTR __imp__SymGetModuleBase@8
	mov	DWORD PTR _dwTemp$[ebp], eax

; 693  : 
; 694  :             ASSERT ( NULL != dwTemp ) ;
; 695  : 
; 696  :             if ( NULL == dwTemp )

	cmp	DWORD PTR _dwTemp$[ebp], 0
	jne	SHORT $LN15@InternalGe

; 697  :             {
; 698  :                 iCurr += wsprintf ( g_szBuff + iCurr  ,
; 699  :                                     _T ( "<UNKNOWN>" ) ) ;

	push	OFFSET ??_C@_09KOIOCIHC@?$DMUNKNOWN?$DO?$AA@
	mov	edx, DWORD PTR _iCurr$5[ebp]
	add	edx, OFFSET _g_szBuff
	push	edx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 8
	add	eax, DWORD PTR _iCurr$5[ebp]
	mov	DWORD PTR _iCurr$5[ebp], eax

; 700  :             }
; 701  :             else

	jmp	SHORT $LN16@InternalGe
$LN15@InternalGe:

; 702  :             {
; 703  :                 iCurr += BSUGetModuleBaseName ( GetCurrentProcess ( ) ,
; 704  :                                                 (HINSTANCE)dwTemp     ,
; 705  :                                                 g_szBuff + iCurr      ,
; 706  :                                                 BUFF_SIZE - iCurr     );

	mov	eax, 1024				; 00000400H
	sub	eax, DWORD PTR _iCurr$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _iCurr$5[ebp]
	add	ecx, OFFSET _g_szBuff
	push	ecx
	mov	edx, DWORD PTR _dwTemp$[ebp]
	push	edx
	call	DWORD PTR __imp__GetCurrentProcess@0
	push	eax
	call	_BSUGetModuleBaseName@16
	add	eax, DWORD PTR _iCurr$5[ebp]
	mov	DWORD PTR _iCurr$5[ebp], eax
$LN16@InternalGe:

; 707  :             }
; 708  :         }
; 709  : 
; 710  :         ASSERT ( iCurr < BUFF_SIZE ) ;
; 711  :         DWORD dwDisp ;
; 712  : 
; 713  :         if ( GSTSO_SYMBOL == ( dwOpts & GSTSO_SYMBOL ) )

	mov	eax, DWORD PTR _dwOpts$[ebp]
	and	eax, 4
	je	$LN13@InternalGe

; 714  :         {
; 715  : 
; 716  :             // Start looking up the exception address.
; 717  :             //lint -e545
; 718  :             PIMAGEHLP_SYMBOL pSym = (PIMAGEHLP_SYMBOL)&g_stSymbol ;

	mov	DWORD PTR _pSym$4[ebp], OFFSET _g_stSymbol

; 719  :             //lint +e545
; 720  :             ZeroMemory ( pSym , SYM_BUFF_SIZE ) ;

	push	512					; 00000200H
	push	0
	mov	ecx, DWORD PTR _pSym$4[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 721  :             pSym->SizeOfStruct = sizeof ( IMAGEHLP_SYMBOL ) ;

	mov	edx, DWORD PTR _pSym$4[ebp]
	mov	DWORD PTR [edx], 24			; 00000018H

; 722  :             pSym->MaxNameLength = SYM_BUFF_SIZE -
; 723  :                                   sizeof ( IMAGEHLP_SYMBOL ) ;

	mov	eax, DWORD PTR _pSym$4[ebp]
	mov	DWORD PTR [eax+16], 488			; 000001e8H

; 724  : 
; 725  :             if ( TRUE ==
; 726  :                   SymGetSymFromAddr ( (HANDLE)GetCurrentProcessId ( ) ,
; 727  :                                       g_stFrame.AddrPC.Offset         ,
; 728  :                                       &dwDisp                         ,
; 729  :                                       pSym                            ))

	mov	ecx, DWORD PTR _pSym$4[ebp]
	push	ecx
	lea	edx, DWORD PTR _dwDisp$3[ebp]
	push	edx
	mov	eax, DWORD PTR _g_stFrame
	push	eax
	call	DWORD PTR __imp__GetCurrentProcessId@0
	push	eax
	call	DWORD PTR __imp__SymGetSymFromAddr@16
	cmp	eax, 1
	jne	$LN12@InternalGe

; 730  :             {
; 731  :                 iCurr += wsprintf ( g_szBuff + iCurr , _T ( ", " ) ) ;

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	mov	ecx, DWORD PTR _iCurr$5[ebp]
	add	ecx, OFFSET _g_szBuff
	push	ecx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 8
	add	eax, DWORD PTR _iCurr$5[ebp]
	mov	DWORD PTR _iCurr$5[ebp], eax

; 732  : 
; 733  :                 // Copy no more than there is room for.
; 734  :                 dwTemp = lstrlen ( pSym->Name ) ;

	mov	edx, DWORD PTR _pSym$4[ebp]
	add	edx, 20					; 00000014H
	push	edx
	call	DWORD PTR __imp__lstrlenA@4
	mov	DWORD PTR _dwTemp$[ebp], eax

; 735  :                 if ( dwTemp > (DWORD)( BUFF_SIZE - iCurr - 20 ) )

	mov	eax, 1024				; 00000400H
	sub	eax, DWORD PTR _iCurr$5[ebp]
	sub	eax, 20					; 00000014H
	cmp	DWORD PTR _dwTemp$[ebp], eax
	jbe	SHORT $LN11@InternalGe

; 736  :                 {
; 737  :                     lstrcpyn ( g_szBuff + iCurr      ,
; 738  :                                pSym->Name            ,
; 739  :                                BUFF_SIZE - iCurr - 1  ) ;

	mov	ecx, 1024				; 00000400H
	sub	ecx, DWORD PTR _iCurr$5[ebp]
	sub	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _pSym$4[ebp]
	add	edx, 20					; 00000014H
	push	edx
	mov	eax, DWORD PTR _iCurr$5[ebp]
	add	eax, OFFSET _g_szBuff
	push	eax
	call	DWORD PTR __imp__lstrcpynA@12

; 740  :                     // Gotta leave now.
; 741  :                     szRet = g_szBuff ;

	mov	DWORD PTR _szRet$[ebp], OFFSET _g_szBuff

; 742  :                     __leave ;

	jmp	$LN20@InternalGe

; 743  :                 }
; 744  :                 else

	jmp	SHORT $LN10@InternalGe
$LN11@InternalGe:

; 745  :                 {
; 746  :                     if ( dwDisp > 0 )

	cmp	DWORD PTR _dwDisp$3[ebp], 0
	jbe	SHORT $LN9@InternalGe

; 747  :                     {
; 748  :                         iCurr += wsprintf ( g_szBuff + iCurr         ,
; 749  :                                             _T ( "%s()+%d byte(s)" ) ,
; 750  :                                             pSym->Name               ,
; 751  :                                             dwDisp                    );

	mov	ecx, DWORD PTR _dwDisp$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _pSym$4[ebp]
	add	edx, 20					; 00000014H
	push	edx
	push	OFFSET ??_C@_0BA@DKGILEMK@?$CFs?$CI?$CJ?$CL?$CFd?5byte?$CIs?$CJ?$AA@
	mov	eax, DWORD PTR _iCurr$5[ebp]
	add	eax, OFFSET _g_szBuff
	push	eax
	call	DWORD PTR __imp__wsprintfA
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _iCurr$5[ebp]
	mov	DWORD PTR _iCurr$5[ebp], eax

; 752  :                     }
; 753  :                     else

	jmp	SHORT $LN10@InternalGe
$LN9@InternalGe:

; 754  :                     {
; 755  :                         iCurr += wsprintf ( g_szBuff + iCurr ,
; 756  :                                             _T ( "%s" )      ,
; 757  :                                             pSym->Name        ) ;

	mov	ecx, DWORD PTR _pSym$4[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	push	OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
	mov	edx, DWORD PTR _iCurr$5[ebp]
	add	edx, OFFSET _g_szBuff
	push	edx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH
	add	eax, DWORD PTR _iCurr$5[ebp]
	mov	DWORD PTR _iCurr$5[ebp], eax
$LN10@InternalGe:

; 758  :                     }
; 759  :                 }
; 760  :             }
; 761  :             else

	jmp	SHORT $LN13@InternalGe
$LN12@InternalGe:

; 762  :             {
; 763  :                 // If the symbol was not found, the source and line will
; 764  :                 //  not be found either so leave now.
; 765  :                 szRet = g_szBuff ;

	mov	DWORD PTR _szRet$[ebp], OFFSET _g_szBuff

; 766  :                 __leave ;

	jmp	$LN20@InternalGe
$LN13@InternalGe:

; 767  :             }
; 768  : 
; 769  :         }
; 770  : 
; 771  :         if ( GSTSO_SRCLINE == ( dwOpts & GSTSO_SRCLINE ) )

	mov	eax, DWORD PTR _dwOpts$[ebp]
	and	eax, 8
	je	$LN6@InternalGe

; 772  :         {
; 773  :             ZeroMemory ( &g_stLine , sizeof ( IMAGEHLP_LINE ) ) ;

	push	20					; 00000014H
	push	0
	push	OFFSET _g_stLine
	call	_memset
	add	esp, 12					; 0000000cH

; 774  :             g_stLine.SizeOfStruct = sizeof ( IMAGEHLP_LINE ) ;

	mov	DWORD PTR _g_stLine, 20			; 00000014H

; 775  : 
; 776  :             if ( TRUE ==
; 777  :                    InternalSymGetLineFromAddr ( (HANDLE)
; 778  :                                                   GetCurrentProcessId(),
; 779  :                                                 g_stFrame.AddrPC.Offset,
; 780  :                                                 &dwDisp                ,
; 781  :                                                 &g_stLine             ))

	push	OFFSET _g_stLine
	lea	ecx, DWORD PTR _dwDisp$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _g_stFrame
	push	edx
	call	DWORD PTR __imp__GetCurrentProcessId@0
	push	eax
	call	?InternalSymGetLineFromAddr@@YAHPAXKPAKPAU_IMAGEHLP_LINE@@@Z ; InternalSymGetLineFromAddr
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jne	$LN6@InternalGe

; 782  :             {
; 783  :                 iCurr += wsprintf ( g_szBuff + iCurr , _T ( ", " ) ) ;

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	mov	eax, DWORD PTR _iCurr$5[ebp]
	add	eax, OFFSET _g_szBuff
	push	eax
	call	DWORD PTR __imp__wsprintfA
	add	esp, 8
	add	eax, DWORD PTR _iCurr$5[ebp]
	mov	DWORD PTR _iCurr$5[ebp], eax

; 784  : 
; 785  :                 // Copy no more than there is room for.
; 786  :                 dwTemp = lstrlen ( g_stLine.FileName ) ;

	mov	ecx, DWORD PTR _g_stLine+12
	push	ecx
	call	DWORD PTR __imp__lstrlenA@4
	mov	DWORD PTR _dwTemp$[ebp], eax

; 787  :                 if ( dwTemp > (DWORD)( BUFF_SIZE - iCurr - 25 ) )

	mov	edx, 1024				; 00000400H
	sub	edx, DWORD PTR _iCurr$5[ebp]
	sub	edx, 25					; 00000019H
	cmp	DWORD PTR _dwTemp$[ebp], edx
	jbe	SHORT $LN4@InternalGe

; 788  :                 {
; 789  :                     lstrcpyn ( g_szBuff + iCurr      ,
; 790  :                                g_stLine.FileName     ,
; 791  :                                BUFF_SIZE - iCurr - 1  ) ;

	mov	eax, 1024				; 00000400H
	sub	eax, DWORD PTR _iCurr$5[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _g_stLine+12
	push	ecx
	mov	edx, DWORD PTR _iCurr$5[ebp]
	add	edx, OFFSET _g_szBuff
	push	edx
	call	DWORD PTR __imp__lstrcpynA@12

; 792  :                     // Gotta leave now.
; 793  :                     szRet = g_szBuff ;

	mov	DWORD PTR _szRet$[ebp], OFFSET _g_szBuff

; 794  :                     __leave ;

	jmp	SHORT $LN20@InternalGe

; 795  :                 }
; 796  :                 else

	jmp	SHORT $LN6@InternalGe
$LN4@InternalGe:

; 797  :                 {
; 798  :                     if ( dwDisp > 0 )

	cmp	DWORD PTR _dwDisp$3[ebp], 0
	jbe	SHORT $LN2@InternalGe

; 799  :                     {
; 800  :                         iCurr += wsprintf(g_szBuff + iCurr             ,
; 801  :                                           _T ("%s, line %d+%d byte(s)"),
; 802  :                                           g_stLine.FileName            ,
; 803  :                                           g_stLine.LineNumber          ,
; 804  :                                           dwDisp                      );

	mov	eax, DWORD PTR _dwDisp$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _g_stLine+8
	push	ecx
	mov	edx, DWORD PTR _g_stLine+12
	push	edx
	push	OFFSET ??_C@_0BH@PFFLOFO@?$CFs?0?5line?5?$CFd?$CL?$CFd?5byte?$CIs?$CJ?$AA@
	mov	eax, DWORD PTR _iCurr$5[ebp]
	add	eax, OFFSET _g_szBuff
	push	eax
	call	DWORD PTR __imp__wsprintfA
	add	esp, 20					; 00000014H
	add	eax, DWORD PTR _iCurr$5[ebp]
	mov	DWORD PTR _iCurr$5[ebp], eax

; 805  :                     }
; 806  :                     else

	jmp	SHORT $LN6@InternalGe
$LN2@InternalGe:

; 807  :                     {
; 808  :                         iCurr += wsprintf ( g_szBuff + iCurr     ,
; 809  :                                             _T ( "%s, line %d" ) ,
; 810  :                                             g_stLine.FileName    ,
; 811  :                                             g_stLine.LineNumber   ) ;

	mov	ecx, DWORD PTR _g_stLine+8
	push	ecx
	mov	edx, DWORD PTR _g_stLine+12
	push	edx
	push	OFFSET ??_C@_0M@NBILGPDE@?$CFs?0?5line?5?$CFd?$AA@
	mov	eax, DWORD PTR _iCurr$5[ebp]
	add	eax, OFFSET _g_szBuff
	push	eax
	call	DWORD PTR __imp__wsprintfA
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _iCurr$5[ebp]
	mov	DWORD PTR _iCurr$5[ebp], eax
$LN6@InternalGe:

; 812  :                     }
; 813  :                 }
; 814  :             }
; 815  :         }
; 816  : 
; 817  :         szRet = g_szBuff ;

	mov	DWORD PTR _szRet$[ebp], OFFSET _g_szBuff
$LN20@InternalGe:

; 818  :     }

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
	jmp	SHORT $LN28@InternalGe
$LN25@InternalGe:
$LN30@InternalGe:

; 819  :     __except ( EXCEPTION_EXECUTE_HANDLER )

	mov	eax, 1
$LN27@InternalGe:
$LN29@InternalGe:
	ret	0
$LN26@InternalGe:
	mov	esp, DWORD PTR __$SEHRec$[ebp]

; 820  :     {
; 821  :         ASSERT ( FALSE ) ;
; 822  :         szRet = NULL ;

	mov	DWORD PTR _szRet$[ebp], 0

; 823  :     }

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
$LN28@InternalGe:

; 824  :     return ( szRet ) ;

	mov	eax, DWORD PTR _szRet$[ebp]
$LN24@InternalGe:

; 825  : }

	mov	ecx, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?InternalGetStackTraceString@@YGPBDKPAU_EXCEPTION_POINTERS@@@Z ENDP ; InternalGetStackTraceString
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\crashhandler.cpp
_TEXT	SEGMENT
tv64 = -4						; size = 4
_dwExcept$ = 8						; size = 4
?ConvertSimpleException@@YAPBDK@Z PROC			; ConvertSimpleException

; 969  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 970  :     switch ( dwExcept )

	mov	eax, DWORD PTR _dwExcept$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], -1073741819	; c0000005H
	ja	SHORT $LN28@ConvertSim
	cmp	DWORD PTR tv64[ebp], -1073741819	; c0000005H
	je	SHORT $LN23@ConvertSim
	mov	ecx, DWORD PTR tv64[ebp]
	add	ecx, 2147483647				; 7fffffffH
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 3
	ja	$LN1@ConvertSim
	mov	edx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN30@ConvertSim[edx*4]
$LN28@ConvertSim:
	mov	eax, DWORD PTR tv64[ebp]
	add	eax, 1073741818				; 3ffffffaH
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 247		; 000000f7H
	ja	$LN1@ConvertSim
	mov	ecx, DWORD PTR tv64[ebp]
	movzx	edx, BYTE PTR $LN29@ConvertSim[ecx]
	jmp	DWORD PTR $LN31@ConvertSim[edx*4]
$LN23@ConvertSim:

; 971  :     {
; 972  :         case EXCEPTION_ACCESS_VIOLATION         :
; 973  :             return ( _T ( "EXCEPTION_ACCESS_VIOLATION" ) ) ;

	mov	eax, OFFSET ??_C@_0BL@CMOMFGDN@EXCEPTION_ACCESS_VIOLATION?$AA@
	jmp	$LN26@ConvertSim

; 974  :         break ;

	jmp	$LN26@ConvertSim
$LN22@ConvertSim:

; 975  : 
; 976  :         case EXCEPTION_DATATYPE_MISALIGNMENT    :
; 977  :             return ( _T ( "EXCEPTION_DATATYPE_MISALIGNMENT" ) ) ;

	mov	eax, OFFSET ??_C@_0CA@LEJEDDLG@EXCEPTION_DATATYPE_MISALIGNMENT?$AA@
	jmp	$LN26@ConvertSim

; 978  :         break ;

	jmp	$LN26@ConvertSim
$LN21@ConvertSim:

; 979  : 
; 980  :         case EXCEPTION_BREAKPOINT               :
; 981  :             return ( _T ( "EXCEPTION_BREAKPOINT" ) ) ;

	mov	eax, OFFSET ??_C@_0BF@FLLDOCJP@EXCEPTION_BREAKPOINT?$AA@
	jmp	$LN26@ConvertSim

; 982  :         break ;

	jmp	$LN26@ConvertSim
$LN20@ConvertSim:

; 983  : 
; 984  :         case EXCEPTION_SINGLE_STEP              :
; 985  :             return ( _T ( "EXCEPTION_SINGLE_STEP" ) ) ;

	mov	eax, OFFSET ??_C@_0BG@HPCFEJHG@EXCEPTION_SINGLE_STEP?$AA@
	jmp	$LN26@ConvertSim

; 986  :         break ;

	jmp	$LN26@ConvertSim
$LN19@ConvertSim:

; 987  : 
; 988  :         case EXCEPTION_ARRAY_BOUNDS_EXCEEDED    :
; 989  :             return ( _T ( "EXCEPTION_ARRAY_BOUNDS_EXCEEDED" ) ) ;

	mov	eax, OFFSET ??_C@_0CA@JNIHFDGO@EXCEPTION_ARRAY_BOUNDS_EXCEEDED?$AA@
	jmp	$LN26@ConvertSim

; 990  :         break ;

	jmp	$LN26@ConvertSim
$LN18@ConvertSim:

; 991  : 
; 992  :         case EXCEPTION_FLT_DENORMAL_OPERAND     :
; 993  :             return ( _T ( "EXCEPTION_FLT_DENORMAL_OPERAND" ) ) ;

	mov	eax, OFFSET ??_C@_0BP@NMNHALMC@EXCEPTION_FLT_DENORMAL_OPERAND?$AA@
	jmp	$LN26@ConvertSim

; 994  :         break ;

	jmp	$LN26@ConvertSim
$LN17@ConvertSim:

; 995  : 
; 996  :         case EXCEPTION_FLT_DIVIDE_BY_ZERO       :
; 997  :             return ( _T ( "EXCEPTION_FLT_DIVIDE_BY_ZERO" ) ) ;

	mov	eax, OFFSET ??_C@_0BN@PHPNMCML@EXCEPTION_FLT_DIVIDE_BY_ZERO?$AA@
	jmp	$LN26@ConvertSim

; 998  :         break ;

	jmp	$LN26@ConvertSim
$LN16@ConvertSim:

; 999  : 
; 1000 :         case EXCEPTION_FLT_INEXACT_RESULT       :
; 1001 :             return ( _T ( "EXCEPTION_FLT_INEXACT_RESULT" ) ) ;

	mov	eax, OFFSET ??_C@_0BN@KLCBBCKL@EXCEPTION_FLT_INEXACT_RESULT?$AA@
	jmp	$LN26@ConvertSim

; 1002 :         break ;

	jmp	$LN26@ConvertSim
$LN15@ConvertSim:

; 1003 : 
; 1004 :         case EXCEPTION_FLT_INVALID_OPERATION    :
; 1005 :             return ( _T ( "EXCEPTION_FLT_INVALID_OPERATION" ) ) ;

	mov	eax, OFFSET ??_C@_0CA@JJDIIMDB@EXCEPTION_FLT_INVALID_OPERATION?$AA@
	jmp	SHORT $LN26@ConvertSim

; 1006 :         break ;

	jmp	SHORT $LN26@ConvertSim
$LN14@ConvertSim:

; 1007 : 
; 1008 :         case EXCEPTION_FLT_OVERFLOW             :
; 1009 :             return ( _T ( "EXCEPTION_FLT_OVERFLOW" ) ) ;

	mov	eax, OFFSET ??_C@_0BH@LGFBHAFE@EXCEPTION_FLT_OVERFLOW?$AA@
	jmp	SHORT $LN26@ConvertSim

; 1010 :         break ;

	jmp	SHORT $LN26@ConvertSim
$LN13@ConvertSim:

; 1011 : 
; 1012 :         case EXCEPTION_FLT_STACK_CHECK          :
; 1013 :             return ( _T ( "EXCEPTION_FLT_STACK_CHECK" ) ) ;

	mov	eax, OFFSET ??_C@_0BK@COBCCPEI@EXCEPTION_FLT_STACK_CHECK?$AA@
	jmp	SHORT $LN26@ConvertSim

; 1014 :         break ;

	jmp	SHORT $LN26@ConvertSim
$LN12@ConvertSim:

; 1015 : 
; 1016 :         case EXCEPTION_FLT_UNDERFLOW            :
; 1017 :             return ( _T ( "EXCEPTION_FLT_UNDERFLOW" ) ) ;

	mov	eax, OFFSET ??_C@_0BI@CHKFJJC@EXCEPTION_FLT_UNDERFLOW?$AA@
	jmp	SHORT $LN26@ConvertSim

; 1018 :         break ;

	jmp	SHORT $LN26@ConvertSim
$LN11@ConvertSim:

; 1019 : 
; 1020 :         case EXCEPTION_INT_DIVIDE_BY_ZERO       :
; 1021 :             return ( _T ( "EXCEPTION_INT_DIVIDE_BY_ZERO" ) ) ;

	mov	eax, OFFSET ??_C@_0BN@LBLGDPIG@EXCEPTION_INT_DIVIDE_BY_ZERO?$AA@
	jmp	SHORT $LN26@ConvertSim

; 1022 :         break ;

	jmp	SHORT $LN26@ConvertSim
$LN10@ConvertSim:

; 1023 : 
; 1024 :         case EXCEPTION_INT_OVERFLOW             :
; 1025 :             return ( _T ( "EXCEPTION_INT_OVERFLOW" ) ) ;

	mov	eax, OFFSET ??_C@_0BH@HNBKDLPO@EXCEPTION_INT_OVERFLOW?$AA@
	jmp	SHORT $LN26@ConvertSim

; 1026 :         break ;

	jmp	SHORT $LN26@ConvertSim
$LN9@ConvertSim:

; 1027 : 
; 1028 :         case EXCEPTION_PRIV_INSTRUCTION         :
; 1029 :             return ( _T ( "EXCEPTION_PRIV_INSTRUCTION" ) ) ;

	mov	eax, OFFSET ??_C@_0BL@HJPDFKEO@EXCEPTION_PRIV_INSTRUCTION?$AA@
	jmp	SHORT $LN26@ConvertSim

; 1030 :         break ;

	jmp	SHORT $LN26@ConvertSim
$LN8@ConvertSim:

; 1031 : 
; 1032 :         case EXCEPTION_IN_PAGE_ERROR            :
; 1033 :             return ( _T ( "EXCEPTION_IN_PAGE_ERROR" ) ) ;

	mov	eax, OFFSET ??_C@_0BI@BNDIILLI@EXCEPTION_IN_PAGE_ERROR?$AA@
	jmp	SHORT $LN26@ConvertSim

; 1034 :         break ;

	jmp	SHORT $LN26@ConvertSim
$LN7@ConvertSim:

; 1035 : 
; 1036 :         case EXCEPTION_ILLEGAL_INSTRUCTION      :
; 1037 :             return ( _T ( "EXCEPTION_ILLEGAL_INSTRUCTION" ) ) ;

	mov	eax, OFFSET ??_C@_0BO@DLLOIENN@EXCEPTION_ILLEGAL_INSTRUCTION?$AA@
	jmp	SHORT $LN26@ConvertSim

; 1038 :         break ;

	jmp	SHORT $LN26@ConvertSim
$LN6@ConvertSim:

; 1039 : 
; 1040 :         case EXCEPTION_NONCONTINUABLE_EXCEPTION :
; 1041 :             return ( _T ( "EXCEPTION_NONCONTINUABLE_EXCEPTION" ) ) ;

	mov	eax, OFFSET ??_C@_0CD@JGPJMHJA@EXCEPTION_NONCONTINUABLE_EXCEPTI@
	jmp	SHORT $LN26@ConvertSim

; 1042 :         break ;

	jmp	SHORT $LN26@ConvertSim
$LN5@ConvertSim:

; 1043 : 
; 1044 :         case EXCEPTION_STACK_OVERFLOW           :
; 1045 :             return ( _T ( "EXCEPTION_STACK_OVERFLOW" ) ) ;

	mov	eax, OFFSET ??_C@_0BJ@FNEOPPMM@EXCEPTION_STACK_OVERFLOW?$AA@
	jmp	SHORT $LN26@ConvertSim

; 1046 :         break ;

	jmp	SHORT $LN26@ConvertSim
$LN4@ConvertSim:

; 1047 : 
; 1048 :         case EXCEPTION_INVALID_DISPOSITION      :
; 1049 :             return ( _T ( "EXCEPTION_INVALID_DISPOSITION" ) ) ;

	mov	eax, OFFSET ??_C@_0BO@GJKCLCLP@EXCEPTION_INVALID_DISPOSITION?$AA@
	jmp	SHORT $LN26@ConvertSim

; 1050 :         break ;

	jmp	SHORT $LN26@ConvertSim
$LN3@ConvertSim:

; 1051 : 
; 1052 :         case EXCEPTION_GUARD_PAGE               :
; 1053 :             return ( _T ( "EXCEPTION_GUARD_PAGE" ) ) ;

	mov	eax, OFFSET ??_C@_0BF@BLPCMAHP@EXCEPTION_GUARD_PAGE?$AA@
	jmp	SHORT $LN26@ConvertSim

; 1054 :         break ;

	jmp	SHORT $LN26@ConvertSim
$LN2@ConvertSim:

; 1055 : 
; 1056 :         case EXCEPTION_INVALID_HANDLE           :
; 1057 :             return ( _T ( "EXCEPTION_INVALID_HANDLE" ) ) ;

	mov	eax, OFFSET ??_C@_0BJ@BKJLBIPE@EXCEPTION_INVALID_HANDLE?$AA@
	jmp	SHORT $LN26@ConvertSim

; 1058 :         break ;

	jmp	SHORT $LN26@ConvertSim
$LN1@ConvertSim:

; 1059 : 
; 1060 :         default :
; 1061 :             return ( NULL ) ;

	xor	eax, eax
$LN26@ConvertSim:

; 1062 :         break ;
; 1063 :     }
; 1064 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN30@ConvertSim:
	DD	$LN3@ConvertSim
	DD	$LN22@ConvertSim
	DD	$LN21@ConvertSim
	DD	$LN20@ConvertSim
$LN31@ConvertSim:
	DD	$LN8@ConvertSim
	DD	$LN2@ConvertSim
	DD	$LN7@ConvertSim
	DD	$LN6@ConvertSim
	DD	$LN4@ConvertSim
	DD	$LN19@ConvertSim
	DD	$LN18@ConvertSim
	DD	$LN17@ConvertSim
	DD	$LN16@ConvertSim
	DD	$LN15@ConvertSim
	DD	$LN14@ConvertSim
	DD	$LN13@ConvertSim
	DD	$LN12@ConvertSim
	DD	$LN11@ConvertSim
	DD	$LN10@ConvertSim
	DD	$LN9@ConvertSim
	DD	$LN5@ConvertSim
	DD	$LN1@ConvertSim
$LN29@ConvertSim:
	DB	0
	DB	17					; 00000011H
	DB	1
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	2
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	3
	DB	4
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	5
	DB	6
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	16					; 00000010H
?ConvertSimpleException@@YAPBDK@Z ENDP			; ConvertSimpleException
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\crashhandler.cpp
_TEXT	SEGMENT
_hBaseAddr$2 = -40					; size = 4
_bCallIt$3 = -36					; size = 4
_lRet$ = -32						; size = 4
_i$4 = -28						; size = 4
__$SEHRec$ = -24					; size = 24
_pExPtrs$ = 8						; size = 4
?CrashHandlerExceptionFilter@@YGJPAU_EXCEPTION_POINTERS@@@Z PROC ; CrashHandlerExceptionFilter

; 243  : {

	push	ebp
	mov	ebp, esp
	push	-2					; fffffffeH
	push	OFFSET __sehtable$?CrashHandlerExceptionFilter@@YGJPAU_EXCEPTION_POINTERS@@@Z
	push	OFFSET __except_handler4
	mov	eax, DWORD PTR fs:0
	push	eax
	add	esp, -24				; ffffffe8H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	DWORD PTR __$SEHRec$[ebp+16], eax
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$SEHRec$[ebp], esp

; 244  :     LONG lRet = EXCEPTION_CONTINUE_SEARCH ;

	mov	DWORD PTR _lRet$[ebp], 0

; 245  : 
; 246  :     __try

	mov	DWORD PTR __$SEHRec$[ebp+20], 0

; 247  :     {
; 248  : 
; 249  :         if ( NULL != g_pfnCallBack )

	cmp	DWORD PTR _g_pfnCallBack, 0
	je	$LN13@CrashHandl

; 250  :         {
; 251  : 
; 252  :             // The symbol engine has to be initialized here so that
; 253  :             //  I can look up the base module information for the
; 254  :             //  crash address as well as just get the symbol engine
; 255  :             //  ready.
; 256  :             InitSymEng ( ) ;

	call	?InitSymEng@@YAXXZ			; InitSymEng

; 257  : 
; 258  :             // Check the g_ahMod list.
; 259  :             BOOL bCallIt = FALSE ;

	mov	DWORD PTR _bCallIt$3[ebp], 0

; 260  :             if ( 0 == g_uiModCount )

	cmp	DWORD PTR _g_uiModCount, 0
	jne	SHORT $LN11@CrashHandl

; 261  :             {
; 262  :                 bCallIt = TRUE ;

	mov	DWORD PTR _bCallIt$3[ebp], 1

; 263  :             }
; 264  :             else

	jmp	SHORT $LN10@CrashHandl
$LN11@CrashHandl:

; 265  :             {
; 266  :                 HINSTANCE hBaseAddr = (HINSTANCE)
; 267  :                       SymGetModuleBase((HANDLE)GetCurrentProcessId ( ) ,
; 268  :                                        (DWORD)pExPtrs->
; 269  :                                             ExceptionRecord->
; 270  :                                                       ExceptionAddress);

	mov	eax, DWORD PTR _pExPtrs$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	DWORD PTR __imp__GetCurrentProcessId@0
	push	eax
	call	DWORD PTR __imp__SymGetModuleBase@8
	mov	DWORD PTR _hBaseAddr$2[ebp], eax

; 271  :                 if ( NULL != hBaseAddr )

	cmp	DWORD PTR _hBaseAddr$2[ebp], 0
	je	SHORT $LN10@CrashHandl

; 272  :                 {
; 273  :                     for ( UINT i = 0 ; i < g_uiModCount ; i ++ )

	mov	DWORD PTR _i$4[ebp], 0
	jmp	SHORT $LN8@CrashHandl
$LN7@CrashHandl:
	mov	eax, DWORD PTR _i$4[ebp]
	add	eax, 1
	mov	DWORD PTR _i$4[ebp], eax
$LN8@CrashHandl:
	mov	ecx, DWORD PTR _i$4[ebp]
	cmp	ecx, DWORD PTR _g_uiModCount
	jae	SHORT $LN10@CrashHandl

; 274  :                     {
; 275  :                         if ( hBaseAddr == g_ahMod[ i ] )

	mov	edx, DWORD PTR _i$4[ebp]
	mov	eax, DWORD PTR _g_ahMod
	mov	ecx, DWORD PTR _hBaseAddr$2[ebp]
	cmp	ecx, DWORD PTR [eax+edx*4]
	jne	SHORT $LN5@CrashHandl

; 276  :                         {
; 277  :                             bCallIt = TRUE ;

	mov	DWORD PTR _bCallIt$3[ebp], 1

; 278  :                             break ;

	jmp	SHORT $LN10@CrashHandl
$LN5@CrashHandl:

; 279  :                         }
; 280  :                     }

	jmp	SHORT $LN7@CrashHandl
$LN10@CrashHandl:

; 281  :                 }
; 282  :             }
; 283  :             if ( TRUE == bCallIt )

	cmp	DWORD PTR _bCallIt$3[ebp], 1
	jne	SHORT $LN4@CrashHandl

; 284  :             {
; 285  :                 // Check that the filter function still exists in memory
; 286  :                 //  before I call it.  The user might have forgotten to
; 287  :                 //  unregister and the filter function is invalid
; 288  :                 //  because it got unloaded.  Of course, if something
; 289  :                 //  loaded back into the same address, there is not much
; 290  :                 //  I can do.
; 291  :                 if ( FALSE == IsBadCodePtr ( (FARPROC)g_pfnCallBack ) )

	mov	edx, DWORD PTR _g_pfnCallBack
	push	edx
	call	DWORD PTR __imp__IsBadCodePtr@4
	test	eax, eax
	jne	SHORT $LN3@CrashHandl

; 292  :                 {
; 293  :                     lRet = g_pfnCallBack ( pExPtrs ) ;

	mov	eax, DWORD PTR _pExPtrs$[ebp]
	push	eax
	call	DWORD PTR _g_pfnCallBack
	mov	DWORD PTR _lRet$[ebp], eax
$LN3@CrashHandl:

; 294  :                 }
; 295  :             }
; 296  :             else

	jmp	SHORT $LN2@CrashHandl
$LN4@CrashHandl:

; 297  :             {
; 298  :                 // Call the previous filter but only after it checks
; 299  :                 //  out.  I am just being a little paranoid.
; 300  :                 if ( FALSE == IsBadCodePtr ( (FARPROC)g_pfnOrigFilt ) )

	mov	ecx, DWORD PTR _g_pfnOrigFilt
	push	ecx
	call	DWORD PTR __imp__IsBadCodePtr@4
	test	eax, eax
	jne	SHORT $LN2@CrashHandl

; 301  :                 {
; 302  :                     lRet = g_pfnOrigFilt ( pExPtrs ) ;

	mov	edx, DWORD PTR _pExPtrs$[ebp]
	push	edx
	call	DWORD PTR _g_pfnOrigFilt
	mov	DWORD PTR _lRet$[ebp], eax
$LN2@CrashHandl:

; 303  :                 }
; 304  :             }
; 305  :             CleanupSymEng ( ) ;

	call	?CleanupSymEng@@YAXXZ			; CleanupSymEng
$LN13@CrashHandl:

; 306  :         }
; 307  :     }

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
	jmp	SHORT $LN20@CrashHandl
$LN17@CrashHandl:
$LN22@CrashHandl:

; 308  :     __except ( EXCEPTION_EXECUTE_HANDLER )

	mov	eax, 1
$LN19@CrashHandl:
$LN21@CrashHandl:
	ret	0
$LN18@CrashHandl:
	mov	esp, DWORD PTR __$SEHRec$[ebp]

; 309  :     {
; 310  :         lRet = EXCEPTION_CONTINUE_SEARCH ;

	mov	DWORD PTR _lRet$[ebp], 0

; 311  :     }

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
$LN20@CrashHandl:

; 312  :     return ( lRet ) ;

	mov	eax, DWORD PTR _lRet$[ebp]
$LN16@CrashHandl:

; 313  : }

	mov	ecx, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?CrashHandlerExceptionFilter@@YGJPAU_EXCEPTION_POINTERS@@@Z ENDP ; CrashHandlerExceptionFilter
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\crashhandler.cpp
_TEXT	SEGMENT
tv83 = -36						; size = 4
tv79 = -32						; size = 4
_szRet$ = -28						; size = 4
__$SEHRec$ = -24					; size = 24
_pExPtrs$ = 8						; size = 4
_szBuff$ = 12						; size = 4
_uiSize$ = 16						; size = 4
?GetRegisterStringVB@@YGHPAU_EXCEPTION_POINTERS@@PADI@Z PROC ; GetRegisterStringVB

; 939  : {

	push	ebp
	mov	ebp, esp
	push	-2					; fffffffeH
	push	OFFSET __sehtable$?GetRegisterStringVB@@YGHPAU_EXCEPTION_POINTERS@@PADI@Z
	push	OFFSET __except_handler4
	mov	eax, DWORD PTR fs:0
	push	eax
	add	esp, -20				; ffffffecH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	DWORD PTR __$SEHRec$[ebp+16], eax
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$SEHRec$[ebp], esp

; 940  :     ASSERT ( FALSE == IsBadWritePtr ( szBuff , uiSize ) ) ;
; 941  :     if ( TRUE == IsBadWritePtr ( szBuff , uiSize ) )

	mov	eax, DWORD PTR _uiSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szBuff$[ebp]
	push	ecx
	call	DWORD PTR __imp__IsBadWritePtr@8
	cmp	eax, 1
	jne	SHORT $LN3@GetRegiste

; 942  :     {
; 943  :         return ( FALSE ) ;

	xor	eax, eax
	jmp	$LN10@GetRegiste
$LN3@GetRegiste:

; 944  :     }
; 945  : 
; 946  :     LPCTSTR szRet ;
; 947  : 
; 948  :     __try

	mov	DWORD PTR __$SEHRec$[ebp+20], 0

; 949  :     {
; 950  :         szRet = GetRegisterString ( pExPtrs ) ;

	mov	edx, DWORD PTR _pExPtrs$[ebp]
	push	edx
	call	?GetRegisterString@@YGPBDPAU_EXCEPTION_POINTERS@@@Z ; GetRegisterString
	mov	DWORD PTR _szRet$[ebp], eax

; 951  :         if ( NULL == szRet )

	cmp	DWORD PTR _szRet$[ebp], 0
	jne	SHORT $LN1@GetRegiste

; 952  :         {
; 953  :             __leave ;

	jmp	SHORT $LN2@GetRegiste
$LN1@GetRegiste:

; 954  :         }
; 955  :         lstrcpyn ( szBuff   ,
; 956  :                    szRet    ,
; 957  :                    min ( (UINT)lstrlen ( szRet ) + 1 , uiSize ) ) ;

	mov	eax, DWORD PTR _szRet$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrlenA@4
	add	eax, 1
	cmp	eax, DWORD PTR _uiSize$[ebp]
	jae	SHORT $LN6@GetRegiste
	mov	ecx, DWORD PTR _szRet$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenA@4
	add	eax, 1
	mov	DWORD PTR tv79[ebp], eax
	jmp	SHORT $LN7@GetRegiste
$LN6@GetRegiste:
	mov	edx, DWORD PTR _uiSize$[ebp]
	mov	DWORD PTR tv79[ebp], edx
$LN7@GetRegiste:
	mov	eax, DWORD PTR tv79[ebp]
	push	eax
	mov	ecx, DWORD PTR _szRet$[ebp]
	push	ecx
	mov	edx, DWORD PTR _szBuff$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrcpynA@12
$LN2@GetRegiste:

; 958  :     }

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
	jmp	SHORT $LN14@GetRegiste
$LN11@GetRegiste:
$LN16@GetRegiste:

; 959  :     __except ( EXCEPTION_EXECUTE_HANDLER )

	mov	eax, 1
$LN13@GetRegiste:
$LN15@GetRegiste:
	ret	0
$LN12@GetRegiste:
	mov	esp, DWORD PTR __$SEHRec$[ebp]

; 960  :     {
; 961  :         szRet = NULL ;

	mov	DWORD PTR _szRet$[ebp], 0

; 962  :     }

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
$LN14@GetRegiste:

; 963  :     return ( NULL != szRet ) ;

	cmp	DWORD PTR _szRet$[ebp], 0
	je	SHORT $LN8@GetRegiste
	mov	DWORD PTR tv83[ebp], 1
	jmp	SHORT $LN9@GetRegiste
$LN8@GetRegiste:
	mov	DWORD PTR tv83[ebp], 0
$LN9@GetRegiste:
	mov	eax, DWORD PTR tv83[ebp]
$LN10@GetRegiste:

; 964  : 
; 965  : }

	mov	ecx, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetRegisterStringVB@@YGHPAU_EXCEPTION_POINTERS@@PADI@Z ENDP ; GetRegisterStringVB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\crashhandler.cpp
_TEXT	SEGMENT
_pExPtrs$ = 8						; size = 4
?GetRegisterString@@YGPBDPAU_EXCEPTION_POINTERS@@@Z PROC ; GetRegisterString

; 892  : {

	push	ebp
	mov	ebp, esp

; 893  :     // Check the parameter.
; 894  :     ASSERT ( FALSE == IsBadReadPtr ( pExPtrs                      ,
; 895  :                                      sizeof (EXCEPTION_POINTERS  ) ) ) ;
; 896  :     if ( TRUE == IsBadReadPtr ( pExPtrs                      ,
; 897  :                                 sizeof ( EXCEPTION_POINTERS ) ) )

	push	8
	mov	eax, DWORD PTR _pExPtrs$[ebp]
	push	eax
	call	DWORD PTR __imp__IsBadReadPtr@8
	cmp	eax, 1
	jne	SHORT $LN1@GetRegiste

; 898  :     {
; 899  :         TRACE0 ( "GetRegisterString - invalid pExPtrs!\n" ) ;
; 900  :         return ( NULL ) ;

	xor	eax, eax
	jmp	$LN2@GetRegiste
$LN1@GetRegiste:

; 901  :     }
; 902  : 
; 903  : #ifdef _ALPHA_
; 904  :     // Do the ALPHA ones if needed.
; 905  :     ASSERT ( FALSE ) ;
; 906  : #else
; 907  :     // This puts 48 bytes on the stack.  This could be a problem when
; 908  :     //  the stack is blown.
; 909  :     wsprintf ( g_szBuff ,
; 910  :                _T ("EAX=%08X  EBX=%08X  ECX=%08X  EDX=%08X  ESI=%08X\r\n"\
; 911  :                    "EDI=%08X  EBP=%08X  ESP=%08X  EIP=%08X  FLG=%08X\r\n"\
; 912  :                    "CS=%04X   DS=%04X  SS=%04X  ES=%04X   "\
; 913  :                    "FS=%04X  GS=%04X" ) ,
; 914  :                    pExPtrs->ContextRecord->Eax      ,
; 915  :                    pExPtrs->ContextRecord->Ebx      ,
; 916  :                    pExPtrs->ContextRecord->Ecx      ,
; 917  :                    pExPtrs->ContextRecord->Edx      ,
; 918  :                    pExPtrs->ContextRecord->Esi      ,
; 919  :                    pExPtrs->ContextRecord->Edi      ,
; 920  :                    pExPtrs->ContextRecord->Ebp      ,
; 921  :                    pExPtrs->ContextRecord->Esp      ,
; 922  :                    pExPtrs->ContextRecord->Eip      ,
; 923  :                    pExPtrs->ContextRecord->EFlags   ,
; 924  :                    pExPtrs->ContextRecord->SegCs    ,
; 925  :                    pExPtrs->ContextRecord->SegDs    ,
; 926  :                    pExPtrs->ContextRecord->SegSs    ,
; 927  :                    pExPtrs->ContextRecord->SegEs    ,
; 928  :                    pExPtrs->ContextRecord->SegFs    ,
; 929  :                    pExPtrs->ContextRecord->SegGs     ) ;

	mov	ecx, DWORD PTR _pExPtrs$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+140]
	push	eax
	mov	ecx, DWORD PTR _pExPtrs$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+144]
	push	eax
	mov	ecx, DWORD PTR _pExPtrs$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+148]
	push	eax
	mov	ecx, DWORD PTR _pExPtrs$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+200]
	push	eax
	mov	ecx, DWORD PTR _pExPtrs$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+152]
	push	eax
	mov	ecx, DWORD PTR _pExPtrs$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+188]
	push	eax
	mov	ecx, DWORD PTR _pExPtrs$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+192]
	push	eax
	mov	ecx, DWORD PTR _pExPtrs$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+184]
	push	eax
	mov	ecx, DWORD PTR _pExPtrs$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+196]
	push	eax
	mov	ecx, DWORD PTR _pExPtrs$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+180]
	push	eax
	mov	ecx, DWORD PTR _pExPtrs$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+156]
	push	eax
	mov	ecx, DWORD PTR _pExPtrs$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+160]
	push	eax
	mov	ecx, DWORD PTR _pExPtrs$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+168]
	push	eax
	mov	ecx, DWORD PTR _pExPtrs$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+172]
	push	eax
	mov	ecx, DWORD PTR _pExPtrs$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+164]
	push	eax
	mov	ecx, DWORD PTR _pExPtrs$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+176]
	push	eax
	push	OFFSET ??_C@_0JL@GMKFMLIN@EAX?$DN?$CF08X?5?5EBX?$DN?$CF08X?5?5ECX?$DN?$CF08X?5?5ED@
	push	OFFSET _g_szBuff
	call	DWORD PTR __imp__wsprintfA
	add	esp, 72					; 00000048H

; 930  : 
; 931  : #endif
; 932  :     return ( g_szBuff ) ;

	mov	eax, OFFSET _g_szBuff
$LN2@GetRegiste:

; 933  : 
; 934  : }

	pop	ebp
	ret	4
?GetRegisterString@@YGPBDPAU_EXCEPTION_POINTERS@@@Z ENDP ; GetRegisterString
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\crashhandler.cpp
_TEXT	SEGMENT
tv84 = -36						; size = 4
tv80 = -32						; size = 4
_szRet$ = -28						; size = 4
__$SEHRec$ = -24					; size = 24
_dwOpts$ = 8						; size = 4
_pExPtrs$ = 12						; size = 4
_szBuff$ = 16						; size = 4
_uiSize$ = 20						; size = 4
?GetNextStackTraceStringVB@@YGHKPAU_EXCEPTION_POINTERS@@PADI@Z PROC ; GetNextStackTraceStringVB

; 864  : {

	push	ebp
	mov	ebp, esp
	push	-2					; fffffffeH
	push	OFFSET __sehtable$?GetNextStackTraceStringVB@@YGHKPAU_EXCEPTION_POINTERS@@PADI@Z
	push	OFFSET __except_handler4
	mov	eax, DWORD PTR fs:0
	push	eax
	add	esp, -20				; ffffffecH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	DWORD PTR __$SEHRec$[ebp+16], eax
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$SEHRec$[ebp], esp

; 865  :     ASSERT ( FALSE == IsBadWritePtr ( szBuff , uiSize ) ) ;
; 866  :     if ( TRUE == IsBadWritePtr ( szBuff , uiSize ) )

	mov	eax, DWORD PTR _uiSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szBuff$[ebp]
	push	ecx
	call	DWORD PTR __imp__IsBadWritePtr@8
	cmp	eax, 1
	jne	SHORT $LN3@GetNextSta

; 867  :     {
; 868  :         return ( FALSE ) ;

	xor	eax, eax
	jmp	$LN10@GetNextSta
$LN3@GetNextSta:

; 869  :     }
; 870  : 
; 871  :     LPCTSTR szRet ;
; 872  : 
; 873  :     __try

	mov	DWORD PTR __$SEHRec$[ebp+20], 0

; 874  :     {
; 875  :         szRet = GetNextStackTraceString ( dwOpts , pExPtrs ) ;

	mov	edx, DWORD PTR _pExPtrs$[ebp]
	push	edx
	mov	eax, DWORD PTR _dwOpts$[ebp]
	push	eax
	call	?GetNextStackTraceString@@YGPBDKPAU_EXCEPTION_POINTERS@@@Z ; GetNextStackTraceString
	mov	DWORD PTR _szRet$[ebp], eax

; 876  :         if ( NULL == szRet )

	cmp	DWORD PTR _szRet$[ebp], 0
	jne	SHORT $LN1@GetNextSta

; 877  :         {
; 878  :             __leave ;

	jmp	SHORT $LN2@GetNextSta
$LN1@GetNextSta:

; 879  :         }
; 880  :         lstrcpyn ( szBuff   ,
; 881  :                    szRet    ,
; 882  :                    min ( (UINT)lstrlen ( szRet ) + 1 , uiSize ) ) ;

	mov	ecx, DWORD PTR _szRet$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenA@4
	add	eax, 1
	cmp	eax, DWORD PTR _uiSize$[ebp]
	jae	SHORT $LN6@GetNextSta
	mov	edx, DWORD PTR _szRet$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrlenA@4
	add	eax, 1
	mov	DWORD PTR tv80[ebp], eax
	jmp	SHORT $LN7@GetNextSta
$LN6@GetNextSta:
	mov	eax, DWORD PTR _uiSize$[ebp]
	mov	DWORD PTR tv80[ebp], eax
$LN7@GetNextSta:
	mov	ecx, DWORD PTR tv80[ebp]
	push	ecx
	mov	edx, DWORD PTR _szRet$[ebp]
	push	edx
	mov	eax, DWORD PTR _szBuff$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcpynA@12
$LN2@GetNextSta:

; 883  :     }

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
	jmp	SHORT $LN14@GetNextSta
$LN11@GetNextSta:
$LN16@GetNextSta:

; 884  :     __except ( EXCEPTION_EXECUTE_HANDLER )

	mov	eax, 1
$LN13@GetNextSta:
$LN15@GetNextSta:
	ret	0
$LN12@GetNextSta:
	mov	esp, DWORD PTR __$SEHRec$[ebp]

; 885  :     {
; 886  :         szRet = NULL ;

	mov	DWORD PTR _szRet$[ebp], 0

; 887  :     }

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
$LN14@GetNextSta:

; 888  :     return ( NULL != szRet ) ;

	cmp	DWORD PTR _szRet$[ebp], 0
	je	SHORT $LN8@GetNextSta
	mov	DWORD PTR tv84[ebp], 1
	jmp	SHORT $LN9@GetNextSta
$LN8@GetNextSta:
	mov	DWORD PTR tv84[ebp], 0
$LN9@GetNextSta:
	mov	eax, DWORD PTR tv84[ebp]
$LN10@GetNextSta:

; 889  : }

	mov	ecx, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?GetNextStackTraceStringVB@@YGHKPAU_EXCEPTION_POINTERS@@PADI@Z ENDP ; GetNextStackTraceStringVB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\crashhandler.cpp
_TEXT	SEGMENT
tv84 = -36						; size = 4
tv80 = -32						; size = 4
_szRet$ = -28						; size = 4
__$SEHRec$ = -24					; size = 24
_dwOpts$ = 8						; size = 4
_pExPtrs$ = 12						; size = 4
_szBuff$ = 16						; size = 4
_uiSize$ = 20						; size = 4
?GetFirstStackTraceStringVB@@YGHKPAU_EXCEPTION_POINTERS@@PADI@Z PROC ; GetFirstStackTraceStringVB

; 832  : {

	push	ebp
	mov	ebp, esp
	push	-2					; fffffffeH
	push	OFFSET __sehtable$?GetFirstStackTraceStringVB@@YGHKPAU_EXCEPTION_POINTERS@@PADI@Z
	push	OFFSET __except_handler4
	mov	eax, DWORD PTR fs:0
	push	eax
	add	esp, -20				; ffffffecH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	DWORD PTR __$SEHRec$[ebp+16], eax
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$SEHRec$[ebp], esp

; 833  :     ASSERT ( FALSE == IsBadWritePtr ( szBuff , uiSize ) ) ;
; 834  :     if ( TRUE == IsBadWritePtr ( szBuff , uiSize ) )

	mov	eax, DWORD PTR _uiSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szBuff$[ebp]
	push	ecx
	call	DWORD PTR __imp__IsBadWritePtr@8
	cmp	eax, 1
	jne	SHORT $LN3@GetFirstSt

; 835  :     {
; 836  :         return ( FALSE ) ;

	xor	eax, eax
	jmp	$LN10@GetFirstSt
$LN3@GetFirstSt:

; 837  :     }
; 838  : 
; 839  :     LPCTSTR szRet ;
; 840  : 
; 841  :     __try

	mov	DWORD PTR __$SEHRec$[ebp+20], 0

; 842  :     {
; 843  :         szRet = GetFirstStackTraceString ( dwOpts , pExPtrs ) ;

	mov	edx, DWORD PTR _pExPtrs$[ebp]
	push	edx
	mov	eax, DWORD PTR _dwOpts$[ebp]
	push	eax
	call	?GetFirstStackTraceString@@YGPBDKPAU_EXCEPTION_POINTERS@@@Z ; GetFirstStackTraceString
	mov	DWORD PTR _szRet$[ebp], eax

; 844  :         if ( NULL == szRet )

	cmp	DWORD PTR _szRet$[ebp], 0
	jne	SHORT $LN1@GetFirstSt

; 845  :         {
; 846  :             __leave ;

	jmp	SHORT $LN2@GetFirstSt
$LN1@GetFirstSt:

; 847  :         }
; 848  :         lstrcpyn ( szBuff   ,
; 849  :                    szRet    ,
; 850  :                    min ( (UINT)lstrlen ( szRet ) + 1 , uiSize ) ) ;

	mov	ecx, DWORD PTR _szRet$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenA@4
	add	eax, 1
	cmp	eax, DWORD PTR _uiSize$[ebp]
	jae	SHORT $LN6@GetFirstSt
	mov	edx, DWORD PTR _szRet$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrlenA@4
	add	eax, 1
	mov	DWORD PTR tv80[ebp], eax
	jmp	SHORT $LN7@GetFirstSt
$LN6@GetFirstSt:
	mov	eax, DWORD PTR _uiSize$[ebp]
	mov	DWORD PTR tv80[ebp], eax
$LN7@GetFirstSt:
	mov	ecx, DWORD PTR tv80[ebp]
	push	ecx
	mov	edx, DWORD PTR _szRet$[ebp]
	push	edx
	mov	eax, DWORD PTR _szBuff$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcpynA@12
$LN2@GetFirstSt:

; 851  :     }

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
	jmp	SHORT $LN14@GetFirstSt
$LN11@GetFirstSt:
$LN16@GetFirstSt:

; 852  :     __except ( EXCEPTION_EXECUTE_HANDLER )

	mov	eax, 1
$LN13@GetFirstSt:
$LN15@GetFirstSt:
	ret	0
$LN12@GetFirstSt:
	mov	esp, DWORD PTR __$SEHRec$[ebp]

; 853  :     {
; 854  :         szRet = NULL ;

	mov	DWORD PTR _szRet$[ebp], 0

; 855  :     }

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
$LN14@GetFirstSt:

; 856  :     return ( NULL != szRet ) ;

	cmp	DWORD PTR _szRet$[ebp], 0
	je	SHORT $LN8@GetFirstSt
	mov	DWORD PTR tv84[ebp], 1
	jmp	SHORT $LN9@GetFirstSt
$LN8@GetFirstSt:
	mov	DWORD PTR tv84[ebp], 0
$LN9@GetFirstSt:
	mov	eax, DWORD PTR tv84[ebp]
$LN10@GetFirstSt:

; 857  : }

	mov	ecx, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?GetFirstStackTraceStringVB@@YGHKPAU_EXCEPTION_POINTERS@@PADI@Z ENDP ; GetFirstStackTraceStringVB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\crashhandler.cpp
_TEXT	SEGMENT
_dwOpts$ = 8						; size = 4
_pExPtrs$ = 12						; size = 4
?GetNextStackTraceString@@YGPBDKPAU_EXCEPTION_POINTERS@@@Z PROC ; GetNextStackTraceString

; 593  : {

	push	ebp
	mov	ebp, esp

; 594  :     // All error checking is in InternalGetStackTraceString.
; 595  :     // Assume that GetFirstStackTraceString has already initialized the
; 596  :     //  stack frame information.
; 597  :     return ( InternalGetStackTraceString ( dwOpts , pExPtrs ) ) ;

	mov	eax, DWORD PTR _pExPtrs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwOpts$[ebp]
	push	ecx
	call	?InternalGetStackTraceString@@YGPBDKPAU_EXCEPTION_POINTERS@@@Z ; InternalGetStackTraceString

; 598  : }

	pop	ebp
	ret	8
?GetNextStackTraceString@@YGPBDKPAU_EXCEPTION_POINTERS@@@Z ENDP ; GetNextStackTraceString
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\crashhandler.cpp
_TEXT	SEGMENT
_dwOpts$ = 8						; size = 4
_pExPtrs$ = 12						; size = 4
?GetFirstStackTraceString@@YGPBDKPAU_EXCEPTION_POINTERS@@@Z PROC ; GetFirstStackTraceString

; 559  : {

	push	ebp
	mov	ebp, esp

; 560  :     // All of the error checking is in the InternalGetStackTraceString
; 561  :     //  function.
; 562  : 
; 563  :     // Initialize the STACKFRAME structure.
; 564  :     ZeroMemory ( &g_stFrame , sizeof ( STACKFRAME ) ) ;

	push	164					; 000000a4H
	push	0
	push	OFFSET _g_stFrame
	call	_memset
	add	esp, 12					; 0000000cH

; 565  : 
; 566  :     #ifdef _X86_
; 567  :     g_stFrame.AddrPC.Offset       = pExPtrs->ContextRecord->Eip ;

	mov	eax, DWORD PTR _pExPtrs$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+184]
	mov	DWORD PTR _g_stFrame, edx

; 568  :     g_stFrame.AddrPC.Mode         = AddrModeFlat                ;

	mov	DWORD PTR _g_stFrame+8, 3

; 569  :     g_stFrame.AddrStack.Offset    = pExPtrs->ContextRecord->Esp ;

	mov	eax, DWORD PTR _pExPtrs$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+196]
	mov	DWORD PTR _g_stFrame+36, edx

; 570  :     g_stFrame.AddrStack.Mode      = AddrModeFlat                ;

	mov	DWORD PTR _g_stFrame+44, 3

; 571  :     g_stFrame.AddrFrame.Offset    = pExPtrs->ContextRecord->Ebp ;

	mov	eax, DWORD PTR _pExPtrs$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+180]
	mov	DWORD PTR _g_stFrame+24, edx

; 572  :     g_stFrame.AddrFrame.Mode      = AddrModeFlat                ;

	mov	DWORD PTR _g_stFrame+32, 3

; 573  :     #else
; 574  :     g_stFrame.AddrPC.Offset       = (DWORD)pExPtrs->ContextRecord->Fir ;
; 575  :     g_stFrame.AddrPC.Mode         = AddrModeFlat ;
; 576  :     g_stFrame.AddrReturn.Offset   =
; 577  :                                    (DWORD)pExPtrs->ContextRecord->IntRa;
; 578  :     g_stFrame.AddrReturn.Mode     = AddrModeFlat ;
; 579  :     g_stFrame.AddrStack.Offset    =
; 580  :                                    (DWORD)pExPtrs->ContextRecord->IntSp;
; 581  :     g_stFrame.AddrStack.Mode      = AddrModeFlat ;
; 582  :     g_stFrame.AddrFrame.Offset    =
; 583  :                                    (DWORD)pExPtrs->ContextRecord->IntFp;
; 584  :     g_stFrame.AddrFrame.Mode      = AddrModeFlat ;
; 585  :     #endif
; 586  : 
; 587  :     return ( InternalGetStackTraceString ( dwOpts , pExPtrs ) ) ;

	mov	eax, DWORD PTR _pExPtrs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwOpts$[ebp]
	push	ecx
	call	?InternalGetStackTraceString@@YGPBDKPAU_EXCEPTION_POINTERS@@@Z ; InternalGetStackTraceString

; 588  : }

	pop	ebp
	ret	8
?GetFirstStackTraceString@@YGPBDKPAU_EXCEPTION_POINTERS@@@Z ENDP ; GetFirstStackTraceString
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\crashhandler.cpp
_TEXT	SEGMENT
tv83 = -36						; size = 4
tv79 = -32						; size = 4
_szRet$ = -28						; size = 4
__$SEHRec$ = -24					; size = 24
_pExPtrs$ = 8						; size = 4
_szBuff$ = 12						; size = 4
_uiSize$ = 16						; size = 4
?GetFaultReasonVB@@YGHPAU_EXCEPTION_POINTERS@@PADI@Z PROC ; GetFaultReasonVB

; 525  : {

	push	ebp
	mov	ebp, esp
	push	-2					; fffffffeH
	push	OFFSET __sehtable$?GetFaultReasonVB@@YGHPAU_EXCEPTION_POINTERS@@PADI@Z
	push	OFFSET __except_handler4
	mov	eax, DWORD PTR fs:0
	push	eax
	add	esp, -20				; ffffffecH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	DWORD PTR __$SEHRec$[ebp+16], eax
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$SEHRec$[ebp], esp

; 526  :     ASSERT ( FALSE == IsBadWritePtr ( szBuff , uiSize ) ) ;
; 527  :     if ( TRUE == IsBadWritePtr ( szBuff , uiSize ) )

	mov	eax, DWORD PTR _uiSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szBuff$[ebp]
	push	ecx
	call	DWORD PTR __imp__IsBadWritePtr@8
	cmp	eax, 1
	jne	SHORT $LN3@GetFaultRe

; 528  :     {
; 529  :         return ( FALSE ) ;

	xor	eax, eax
	jmp	$LN10@GetFaultRe
$LN3@GetFaultRe:

; 530  :     }
; 531  : 
; 532  :     LPCTSTR szRet ;
; 533  : 
; 534  :     __try

	mov	DWORD PTR __$SEHRec$[ebp+20], 0

; 535  :     {
; 536  : 
; 537  :         szRet = GetFaultReason ( pExPtrs ) ;

	mov	edx, DWORD PTR _pExPtrs$[ebp]
	push	edx
	call	?GetFaultReason@@YGPBDPAU_EXCEPTION_POINTERS@@@Z ; GetFaultReason
	mov	DWORD PTR _szRet$[ebp], eax

; 538  : 
; 539  :         ASSERT ( NULL != szRet ) ;
; 540  :         if ( NULL == szRet )

	cmp	DWORD PTR _szRet$[ebp], 0
	jne	SHORT $LN1@GetFaultRe

; 541  :         {
; 542  :             __leave ;

	jmp	SHORT $LN2@GetFaultRe
$LN1@GetFaultRe:

; 543  :         }
; 544  :         lstrcpyn ( szBuff   ,
; 545  :                    szRet    ,
; 546  :                    min ( (UINT)lstrlen ( szRet ) + 1, uiSize ) ) ;

	mov	eax, DWORD PTR _szRet$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrlenA@4
	add	eax, 1
	cmp	eax, DWORD PTR _uiSize$[ebp]
	jae	SHORT $LN6@GetFaultRe
	mov	ecx, DWORD PTR _szRet$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenA@4
	add	eax, 1
	mov	DWORD PTR tv79[ebp], eax
	jmp	SHORT $LN7@GetFaultRe
$LN6@GetFaultRe:
	mov	edx, DWORD PTR _uiSize$[ebp]
	mov	DWORD PTR tv79[ebp], edx
$LN7@GetFaultRe:
	mov	eax, DWORD PTR tv79[ebp]
	push	eax
	mov	ecx, DWORD PTR _szRet$[ebp]
	push	ecx
	mov	edx, DWORD PTR _szBuff$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrcpynA@12
$LN2@GetFaultRe:

; 547  :     }

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
	jmp	SHORT $LN14@GetFaultRe
$LN11@GetFaultRe:
$LN16@GetFaultRe:

; 548  :     __except ( EXCEPTION_EXECUTE_HANDLER )

	mov	eax, 1
$LN13@GetFaultRe:
$LN15@GetFaultRe:
	ret	0
$LN12@GetFaultRe:
	mov	esp, DWORD PTR __$SEHRec$[ebp]

; 549  :     {
; 550  :         szRet = NULL ;

	mov	DWORD PTR _szRet$[ebp], 0

; 551  :     }

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
$LN14@GetFaultRe:

; 552  :     return ( NULL != szRet ) ;

	cmp	DWORD PTR _szRet$[ebp], 0
	je	SHORT $LN8@GetFaultRe
	mov	DWORD PTR tv83[ebp], 1
	jmp	SHORT $LN9@GetFaultRe
$LN8@GetFaultRe:
	mov	DWORD PTR tv83[ebp], 0
$LN9@GetFaultRe:
	mov	eax, DWORD PTR tv83[ebp]
$LN10@GetFaultRe:

; 553  : }

	mov	ecx, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetFaultReasonVB@@YGHPAU_EXCEPTION_POINTERS@@PADI@Z ENDP ; GetFaultReasonVB
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\crashhandler.cpp
_TEXT	SEGMENT
_szRet$ = -44						; size = 4
_dwDisp$2 = -40						; size = 4
_pSym$3 = -36						; size = 4
_dwTemp$4 = -32						; size = 4
_iCurr$5 = -28						; size = 4
__$SEHRec$ = -24					; size = 24
_pExPtrs$ = 8						; size = 4
?GetFaultReason@@YGPBDPAU_EXCEPTION_POINTERS@@@Z PROC	; GetFaultReason

; 320  : {

	push	ebp
	mov	ebp, esp
	push	-2					; fffffffeH
	push	OFFSET __sehtable$?GetFaultReason@@YGPBDPAU_EXCEPTION_POINTERS@@@Z
	push	OFFSET __except_handler4
	mov	eax, DWORD PTR fs:0
	push	eax
	add	esp, -28				; ffffffe4H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	DWORD PTR __$SEHRec$[ebp+16], eax
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$SEHRec$[ebp], esp

; 321  :     ASSERT ( FALSE == IsBadReadPtr ( pExPtrs ,
; 322  :                                      sizeof(EXCEPTION_POINTERS ) ) ) ;
; 323  :     if ( TRUE == IsBadReadPtr ( pExPtrs ,
; 324  :                                 sizeof ( EXCEPTION_POINTERS ) ) )

	push	8
	mov	eax, DWORD PTR _pExPtrs$[ebp]
	push	eax
	call	DWORD PTR __imp__IsBadReadPtr@8
	cmp	eax, 1
	jne	SHORT $LN17@GetFaultRe

; 325  :     {
; 326  :         TRACE0 ( "Bad parameter to GetFaultReasonA\n" ) ;
; 327  :         return ( NULL ) ;

	xor	eax, eax
	jmp	$LN20@GetFaultRe
$LN17@GetFaultRe:

; 328  :     }
; 329  : 
; 330  :     // The value that holds the return.
; 331  :     LPCTSTR szRet ;
; 332  : 
; 333  :     __try

	mov	DWORD PTR __$SEHRec$[ebp+20], 0

; 334  :     {
; 335  : 
; 336  :         // Initialize the symbol engine in case it is not initialized.
; 337  :         InitSymEng ( ) ;

	call	?InitSymEng@@YAXXZ			; InitSymEng

; 338  : 
; 339  :         // The current position in the buffer.
; 340  :         int iCurr = 0 ;

	mov	DWORD PTR _iCurr$5[ebp], 0

; 341  :         // A temp value holder.  This is to keep the stack usage to a
; 342  :         //  minimum.
; 343  :         DWORD dwTemp ;
; 344  : 
; 345  :         iCurr += BSUGetModuleBaseName ( GetCurrentProcess ( ) ,
; 346  :                                         NULL                  ,
; 347  :                                         g_szBuff              ,
; 348  :                                         BUFF_SIZE              ) ;

	push	1024					; 00000400H
	push	OFFSET _g_szBuff
	push	0
	call	DWORD PTR __imp__GetCurrentProcess@0
	push	eax
	call	_BSUGetModuleBaseName@16
	add	eax, DWORD PTR _iCurr$5[ebp]
	mov	DWORD PTR _iCurr$5[ebp], eax

; 349  : 
; 350  :         iCurr += wsprintf ( g_szBuff + iCurr , _T ( " caused a " ) ) ;

	push	OFFSET ??_C@_0L@BCDENLPN@?5caused?5a?5?$AA@
	mov	ecx, DWORD PTR _iCurr$5[ebp]
	add	ecx, OFFSET _g_szBuff
	push	ecx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 8
	add	eax, DWORD PTR _iCurr$5[ebp]
	mov	DWORD PTR _iCurr$5[ebp], eax

; 351  : 
; 352  :         dwTemp = (DWORD)
; 353  :             ConvertSimpleException(pExPtrs->ExceptionRecord->
; 354  :                                                          ExceptionCode);

	mov	edx, DWORD PTR _pExPtrs$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?ConvertSimpleException@@YAPBDK@Z	; ConvertSimpleException
	add	esp, 4
	mov	DWORD PTR _dwTemp$4[ebp], eax

; 355  : 
; 356  :         if ( NULL != dwTemp )

	cmp	DWORD PTR _dwTemp$4[ebp], 0
	je	SHORT $LN15@GetFaultRe

; 357  :         {
; 358  :             iCurr += wsprintf ( g_szBuff + iCurr ,
; 359  :                                 _T ( "%s" )      ,
; 360  :                                 dwTemp            ) ;

	mov	edx, DWORD PTR _dwTemp$4[ebp]
	push	edx
	push	OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
	mov	eax, DWORD PTR _iCurr$5[ebp]
	add	eax, OFFSET _g_szBuff
	push	eax
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH
	add	eax, DWORD PTR _iCurr$5[ebp]
	mov	DWORD PTR _iCurr$5[ebp], eax

; 361  :         }
; 362  :         else

	jmp	SHORT $LN14@GetFaultRe
$LN15@GetFaultRe:

; 363  :         {
; 364  :             iCurr += (FormatMessage( FORMAT_MESSAGE_IGNORE_INSERTS |
; 365  :                                             FORMAT_MESSAGE_FROM_HMODULE,
; 366  :                                      GetModuleHandle (_T("NTDLL.DLL")) ,
; 367  :                                      pExPtrs->ExceptionRecord->
; 368  :                                                           ExceptionCode,
; 369  :                                      0                                 ,
; 370  :                                      g_szBuff + iCurr                  ,
; 371  :                                      BUFF_SIZE ,
; 372  :                                      0                                 )
; 373  :                       * sizeof ( TCHAR ) ) ;

	push	0
	push	1024					; 00000400H
	mov	ecx, DWORD PTR _iCurr$5[ebp]
	add	ecx, OFFSET _g_szBuff
	push	ecx
	push	0
	mov	edx, DWORD PTR _pExPtrs$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_09KKJFIDEP@NTDLL?4DLL?$AA@
	call	DWORD PTR __imp__GetModuleHandleA@4
	push	eax
	push	2560					; 00000a00H
	call	DWORD PTR __imp__FormatMessageA@28
	add	eax, DWORD PTR _iCurr$5[ebp]
	mov	DWORD PTR _iCurr$5[ebp], eax
$LN14@GetFaultRe:

; 374  :         }
; 375  : 
; 376  :         ASSERT ( iCurr < BUFF_SIZE ) ;
; 377  : 
; 378  :         iCurr += wsprintf ( g_szBuff + iCurr , _T ( " in module " ) ) ;

	push	OFFSET ??_C@_0M@MEHCDCPC@?5in?5module?5?$AA@
	mov	edx, DWORD PTR _iCurr$5[ebp]
	add	edx, OFFSET _g_szBuff
	push	edx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 8
	add	eax, DWORD PTR _iCurr$5[ebp]
	mov	DWORD PTR _iCurr$5[ebp], eax

; 379  : 
; 380  :         dwTemp =
; 381  :             SymGetModuleBase ( (HANDLE)GetCurrentProcessId ( ) ,
; 382  :                                (DWORD)pExPtrs->ExceptionRecord->
; 383  :                                                     ExceptionAddress ) ;

	mov	eax, DWORD PTR _pExPtrs$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	DWORD PTR __imp__GetCurrentProcessId@0
	push	eax
	call	DWORD PTR __imp__SymGetModuleBase@8
	mov	DWORD PTR _dwTemp$4[ebp], eax

; 384  :         ASSERT ( NULL != dwTemp ) ;
; 385  : 
; 386  :         if ( NULL == dwTemp )

	cmp	DWORD PTR _dwTemp$4[ebp], 0
	jne	SHORT $LN13@GetFaultRe

; 387  :         {
; 388  :             iCurr += wsprintf ( g_szBuff + iCurr , _T ( "<UNKNOWN>" ) );

	push	OFFSET ??_C@_09KOIOCIHC@?$DMUNKNOWN?$DO?$AA@
	mov	eax, DWORD PTR _iCurr$5[ebp]
	add	eax, OFFSET _g_szBuff
	push	eax
	call	DWORD PTR __imp__wsprintfA
	add	esp, 8
	add	eax, DWORD PTR _iCurr$5[ebp]
	mov	DWORD PTR _iCurr$5[ebp], eax

; 389  :         }
; 390  :         else

	jmp	SHORT $LN12@GetFaultRe
$LN13@GetFaultRe:

; 391  :         {
; 392  :             iCurr += BSUGetModuleBaseName ( GetCurrentProcess ( ) ,
; 393  :                                             (HINSTANCE)dwTemp     ,
; 394  :                                             g_szBuff + iCurr      ,
; 395  :                                             BUFF_SIZE - iCurr      ) ;

	mov	ecx, 1024				; 00000400H
	sub	ecx, DWORD PTR _iCurr$5[ebp]
	push	ecx
	mov	edx, DWORD PTR _iCurr$5[ebp]
	add	edx, OFFSET _g_szBuff
	push	edx
	mov	eax, DWORD PTR _dwTemp$4[ebp]
	push	eax
	call	DWORD PTR __imp__GetCurrentProcess@0
	push	eax
	call	_BSUGetModuleBaseName@16
	add	eax, DWORD PTR _iCurr$5[ebp]
	mov	DWORD PTR _iCurr$5[ebp], eax
$LN12@GetFaultRe:

; 396  :         }
; 397  : 
; 398  :     #ifdef _ALPHA_
; 399  :         iCurr += wsprintf ( g_szBuff + iCurr    ,
; 400  :                             _T ( " at %08X" )   ,
; 401  :                             pExPtrs->ExceptionRecord->ExceptionAddress);
; 402  :     #else
; 403  :         iCurr += wsprintf ( g_szBuff + iCurr                ,
; 404  :                             _T ( " at %04X:%08X" )          ,
; 405  :                             pExPtrs->ContextRecord->SegCs   ,
; 406  :                             pExPtrs->ExceptionRecord->ExceptionAddress);

	mov	ecx, DWORD PTR _pExPtrs$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _pExPtrs$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+188]
	push	eax
	push	OFFSET ??_C@_0O@DJMCFBM@?5at?5?$CF04X?3?$CF08X?$AA@
	mov	ecx, DWORD PTR _iCurr$5[ebp]
	add	ecx, OFFSET _g_szBuff
	push	ecx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _iCurr$5[ebp]
	mov	DWORD PTR _iCurr$5[ebp], eax

; 407  :     #endif
; 408  : 
; 409  :         ASSERT ( iCurr < BUFF_SIZE ) ;
; 410  : 
; 411  :         // Start looking up the exception address.
; 412  :         //lint -e545
; 413  :         PIMAGEHLP_SYMBOL pSym = (PIMAGEHLP_SYMBOL)&g_stSymbol ;

	mov	DWORD PTR _pSym$3[ebp], OFFSET _g_stSymbol

; 414  :         //lint +e545
; 415  :         FillMemory ( pSym , NULL , SYM_BUFF_SIZE ) ;

	push	0
	push	512					; 00000200H
	mov	edx, DWORD PTR _pSym$3[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 416  :         pSym->SizeOfStruct = sizeof ( IMAGEHLP_SYMBOL ) ;

	mov	eax, DWORD PTR _pSym$3[ebp]
	mov	DWORD PTR [eax], 24			; 00000018H

; 417  :         pSym->MaxNameLength = SYM_BUFF_SIZE - sizeof ( IMAGEHLP_SYMBOL);

	mov	ecx, DWORD PTR _pSym$3[ebp]
	mov	DWORD PTR [ecx+16], 488			; 000001e8H

; 418  : 
; 419  :         DWORD dwDisp ;
; 420  :         if ( TRUE ==
; 421  :               SymGetSymFromAddr ( (HANDLE)GetCurrentProcessId ( )     ,
; 422  :                                   (DWORD)pExPtrs->ExceptionRecord->
; 423  :                                                      ExceptionAddress ,
; 424  :                                   &dwDisp                             ,
; 425  :                                   pSym                                ))

	mov	edx, DWORD PTR _pSym$3[ebp]
	push	edx
	lea	eax, DWORD PTR _dwDisp$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _pExPtrs$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	DWORD PTR __imp__GetCurrentProcessId@0
	push	eax
	call	DWORD PTR __imp__SymGetSymFromAddr@16
	cmp	eax, 1
	jne	$LN11@GetFaultRe

; 426  :         {
; 427  :             iCurr += wsprintf ( g_szBuff + iCurr , _T ( ", " ) ) ;

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	mov	ecx, DWORD PTR _iCurr$5[ebp]
	add	ecx, OFFSET _g_szBuff
	push	ecx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 8
	add	eax, DWORD PTR _iCurr$5[ebp]
	mov	DWORD PTR _iCurr$5[ebp], eax

; 428  : 
; 429  :             // Copy no more than there is room for.
; 430  :             dwTemp = lstrlen ( pSym->Name ) ;

	mov	edx, DWORD PTR _pSym$3[ebp]
	add	edx, 20					; 00000014H
	push	edx
	call	DWORD PTR __imp__lstrlenA@4
	mov	DWORD PTR _dwTemp$4[ebp], eax

; 431  :             if ( (int)dwTemp > ( BUFF_SIZE - iCurr - 20 ) )

	mov	eax, 1024				; 00000400H
	sub	eax, DWORD PTR _iCurr$5[ebp]
	sub	eax, 20					; 00000014H
	cmp	DWORD PTR _dwTemp$4[ebp], eax
	jle	SHORT $LN10@GetFaultRe

; 432  :             {
; 433  :                 lstrcpyn ( g_szBuff + iCurr      ,
; 434  :                            pSym->Name            ,
; 435  :                            BUFF_SIZE - iCurr - 1  ) ;

	mov	ecx, 1024				; 00000400H
	sub	ecx, DWORD PTR _iCurr$5[ebp]
	sub	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _pSym$3[ebp]
	add	edx, 20					; 00000014H
	push	edx
	mov	eax, DWORD PTR _iCurr$5[ebp]
	add	eax, OFFSET _g_szBuff
	push	eax
	call	DWORD PTR __imp__lstrcpynA@12

; 436  :                 // Gotta leave now.
; 437  :                 szRet = g_szBuff ;

	mov	DWORD PTR _szRet$[ebp], OFFSET _g_szBuff

; 438  :                 __leave ;

	jmp	$LN16@GetFaultRe

; 439  :             }
; 440  :             else

	jmp	SHORT $LN9@GetFaultRe
$LN10@GetFaultRe:

; 441  :             {
; 442  :                 if ( dwDisp > 0 )

	cmp	DWORD PTR _dwDisp$2[ebp], 0
	jbe	SHORT $LN8@GetFaultRe

; 443  :                 {
; 444  :                     iCurr += wsprintf ( g_szBuff + iCurr         ,
; 445  :                                         _T ( "%s()+%d byte(s)" ) ,
; 446  :                                         pSym->Name               ,
; 447  :                                         dwDisp                    ) ;

	mov	ecx, DWORD PTR _dwDisp$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _pSym$3[ebp]
	add	edx, 20					; 00000014H
	push	edx
	push	OFFSET ??_C@_0BA@DKGILEMK@?$CFs?$CI?$CJ?$CL?$CFd?5byte?$CIs?$CJ?$AA@
	mov	eax, DWORD PTR _iCurr$5[ebp]
	add	eax, OFFSET _g_szBuff
	push	eax
	call	DWORD PTR __imp__wsprintfA
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _iCurr$5[ebp]
	mov	DWORD PTR _iCurr$5[ebp], eax

; 448  :                 }
; 449  :                 else

	jmp	SHORT $LN9@GetFaultRe
$LN8@GetFaultRe:

; 450  :                 {
; 451  :                     iCurr += wsprintf ( g_szBuff + iCurr ,
; 452  :                                         _T ( "%s " )     ,
; 453  :                                         pSym->Name        ) ;

	mov	ecx, DWORD PTR _pSym$3[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	push	OFFSET ??_C@_03IKGEINEE@?$CFs?5?$AA@
	mov	edx, DWORD PTR _iCurr$5[ebp]
	add	edx, OFFSET _g_szBuff
	push	edx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH
	add	eax, DWORD PTR _iCurr$5[ebp]
	mov	DWORD PTR _iCurr$5[ebp], eax
$LN9@GetFaultRe:

; 454  :                 }
; 455  :             }
; 456  :         }
; 457  :         else

	jmp	SHORT $LN6@GetFaultRe
$LN11@GetFaultRe:

; 458  :         {
; 459  :             // If the symbol was not found, the source and line will not
; 460  :             //  be found either so leave now.
; 461  :             szRet = g_szBuff ;

	mov	DWORD PTR _szRet$[ebp], OFFSET _g_szBuff

; 462  :             __leave ;

	jmp	$LN16@GetFaultRe
$LN6@GetFaultRe:

; 463  :         }
; 464  : 
; 465  :         ASSERT ( iCurr < BUFF_SIZE ) ;
; 466  : 
; 467  :         // Do the source and line lookup.
; 468  :         ZeroMemory ( &g_stLine , sizeof ( IMAGEHLP_LINE ) ) ;

	push	20					; 00000014H
	push	0
	push	OFFSET _g_stLine
	call	_memset
	add	esp, 12					; 0000000cH

; 469  :         g_stLine.SizeOfStruct = sizeof ( IMAGEHLP_LINE ) ;

	mov	DWORD PTR _g_stLine, 20			; 00000014H

; 470  : 
; 471  :         if ( TRUE ==
; 472  :               InternalSymGetLineFromAddr ((HANDLE)
; 473  :                                             GetCurrentProcessId ( )    ,
; 474  :                                           (DWORD)pExPtrs->
; 475  :                                                     ExceptionRecord->
; 476  :                                                       ExceptionAddress ,
; 477  :                                           &dwDisp                      ,
; 478  :                                           &g_stLine                   ))

	push	OFFSET _g_stLine
	lea	eax, DWORD PTR _dwDisp$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _pExPtrs$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	DWORD PTR __imp__GetCurrentProcessId@0
	push	eax
	call	?InternalSymGetLineFromAddr@@YAHPAXKPAKPAU_IMAGEHLP_LINE@@@Z ; InternalSymGetLineFromAddr
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jne	$LN5@GetFaultRe

; 479  :         {
; 480  :             iCurr += wsprintf ( g_szBuff + iCurr , _T ( ", " ) ) ;

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	mov	ecx, DWORD PTR _iCurr$5[ebp]
	add	ecx, OFFSET _g_szBuff
	push	ecx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 8
	add	eax, DWORD PTR _iCurr$5[ebp]
	mov	DWORD PTR _iCurr$5[ebp], eax

; 481  : 
; 482  :             // Copy no more than there is room for.
; 483  :             dwTemp = lstrlen ( g_stLine.FileName ) ;

	mov	edx, DWORD PTR _g_stLine+12
	push	edx
	call	DWORD PTR __imp__lstrlenA@4
	mov	DWORD PTR _dwTemp$4[ebp], eax

; 484  :             if ( (int)dwTemp > ( BUFF_SIZE - iCurr - 25 ) )

	mov	eax, 1024				; 00000400H
	sub	eax, DWORD PTR _iCurr$5[ebp]
	sub	eax, 25					; 00000019H
	cmp	DWORD PTR _dwTemp$4[ebp], eax
	jle	SHORT $LN4@GetFaultRe

; 485  :             {
; 486  :                 lstrcpyn ( g_szBuff + iCurr      ,
; 487  :                            g_stLine.FileName     ,
; 488  :                            BUFF_SIZE - iCurr - 1  ) ;

	mov	ecx, 1024				; 00000400H
	sub	ecx, DWORD PTR _iCurr$5[ebp]
	sub	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _g_stLine+12
	push	edx
	mov	eax, DWORD PTR _iCurr$5[ebp]
	add	eax, OFFSET _g_szBuff
	push	eax
	call	DWORD PTR __imp__lstrcpynA@12

; 489  :                 // Gotta leave now.
; 490  :                 szRet = g_szBuff ;

	mov	DWORD PTR _szRet$[ebp], OFFSET _g_szBuff

; 491  :                 __leave ;

	jmp	SHORT $LN16@GetFaultRe

; 492  :             }
; 493  :             else

	jmp	SHORT $LN5@GetFaultRe
$LN4@GetFaultRe:

; 494  :             {
; 495  :                 if ( dwDisp > 0 )

	cmp	DWORD PTR _dwDisp$2[ebp], 0
	jbe	SHORT $LN2@GetFaultRe

; 496  :                 {
; 497  :                     iCurr += wsprintf ( g_szBuff + iCurr              ,
; 498  :                                         _T ( "%s, line %d+%d byte(s)"),
; 499  :                                         g_stLine.FileName             ,
; 500  :                                         g_stLine.LineNumber           ,
; 501  :                                         dwDisp                        );

	mov	ecx, DWORD PTR _dwDisp$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _g_stLine+8
	push	edx
	mov	eax, DWORD PTR _g_stLine+12
	push	eax
	push	OFFSET ??_C@_0BH@PFFLOFO@?$CFs?0?5line?5?$CFd?$CL?$CFd?5byte?$CIs?$CJ?$AA@
	mov	ecx, DWORD PTR _iCurr$5[ebp]
	add	ecx, OFFSET _g_szBuff
	push	ecx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 20					; 00000014H
	add	eax, DWORD PTR _iCurr$5[ebp]
	mov	DWORD PTR _iCurr$5[ebp], eax

; 502  :                 }
; 503  :                 else

	jmp	SHORT $LN5@GetFaultRe
$LN2@GetFaultRe:

; 504  :                 {
; 505  :                     iCurr += wsprintf ( g_szBuff + iCurr     ,
; 506  :                                         _T ( "%s, line %d" ) ,
; 507  :                                         g_stLine.FileName    ,
; 508  :                                         g_stLine.LineNumber   ) ;

	mov	edx, DWORD PTR _g_stLine+8
	push	edx
	mov	eax, DWORD PTR _g_stLine+12
	push	eax
	push	OFFSET ??_C@_0M@NBILGPDE@?$CFs?0?5line?5?$CFd?$AA@
	mov	ecx, DWORD PTR _iCurr$5[ebp]
	add	ecx, OFFSET _g_szBuff
	push	ecx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 16					; 00000010H
	add	eax, DWORD PTR _iCurr$5[ebp]
	mov	DWORD PTR _iCurr$5[ebp], eax
$LN5@GetFaultRe:

; 509  :                 }
; 510  :             }
; 511  :         }
; 512  :         szRet = g_szBuff ;

	mov	DWORD PTR _szRet$[ebp], OFFSET _g_szBuff
$LN16@GetFaultRe:

; 513  :     }

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
	jmp	SHORT $LN24@GetFaultRe
$LN21@GetFaultRe:
$LN26@GetFaultRe:

; 514  :     __except ( EXCEPTION_EXECUTE_HANDLER )

	mov	eax, 1
$LN23@GetFaultRe:
$LN25@GetFaultRe:
	ret	0
$LN22@GetFaultRe:
	mov	esp, DWORD PTR __$SEHRec$[ebp]

; 515  :     {
; 516  :         ASSERT ( FALSE ) ;
; 517  :         szRet = NULL ;

	mov	DWORD PTR _szRet$[ebp], 0

; 518  :     }

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
$LN24@GetFaultRe:

; 519  :     return ( szRet ) ;

	mov	eax, DWORD PTR _szRet$[ebp]
$LN20@GetFaultRe:

; 520  : }

	mov	ecx, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetFaultReason@@YGPBDPAU_EXCEPTION_POINTERS@@@Z ENDP	; GetFaultReason
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\crashhandler.cpp
_TEXT	SEGMENT
_iRet$ = -28						; size = 4
__$SEHRec$ = -24					; size = 24
_pahMod$ = 8						; size = 4
_uiSize$ = 12						; size = 4
?GetLimitModulesArray@@YGHPAPAUHINSTANCE__@@I@Z PROC	; GetLimitModulesArray

; 209  : {

	push	ebp
	mov	ebp, esp
	push	-2					; fffffffeH
	push	OFFSET __sehtable$?GetLimitModulesArray@@YGHPAPAUHINSTANCE__@@I@Z
	push	OFFSET __except_handler4
	mov	eax, DWORD PTR fs:0
	push	eax
	add	esp, -12				; fffffff4H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	DWORD PTR __$SEHRec$[ebp+16], eax
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$SEHRec$[ebp], esp

; 210  :     int iRet ;
; 211  : 
; 212  :     __try

	mov	DWORD PTR __$SEHRec$[ebp+20], 0

; 213  :     {
; 214  :         ASSERT ( FALSE == IsBadWritePtr ( pahMod ,
; 215  :                                           uiSize * sizeof ( HMODULE ) ) ) ;
; 216  :         if ( TRUE == IsBadWritePtr ( pahMod ,
; 217  :                                      uiSize * sizeof ( HMODULE ) ) )

	mov	eax, DWORD PTR _uiSize$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _pahMod$[ebp]
	push	ecx
	call	DWORD PTR __imp__IsBadWritePtr@8
	cmp	eax, 1
	jne	SHORT $LN2@GetLimitMo

; 218  :         {
; 219  :             iRet = GLMA_BADPARAM ;

	mov	DWORD PTR _iRet$[ebp], -1

; 220  :             __leave ;

	jmp	SHORT $LN3@GetLimitMo
$LN2@GetLimitMo:

; 221  :         }
; 222  : 
; 223  :         if ( uiSize < g_uiModCount )

	mov	edx, DWORD PTR _uiSize$[ebp]
	cmp	edx, DWORD PTR _g_uiModCount
	jae	SHORT $LN1@GetLimitMo

; 224  :         {
; 225  :             iRet = GLMA_BUFFTOOSMALL ;

	mov	DWORD PTR _iRet$[ebp], -2		; fffffffeH

; 226  :             __leave ;

	jmp	SHORT $LN3@GetLimitMo
$LN1@GetLimitMo:

; 227  :         }
; 228  : 
; 229  :         CopyMemory ( pahMod     ,
; 230  :                      g_ahMod    ,
; 231  :                      sizeof ( HMODULE ) * g_uiModCount ) ;

	mov	eax, DWORD PTR _g_uiModCount
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _g_ahMod
	push	ecx
	mov	edx, DWORD PTR _pahMod$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 232  : 
; 233  :         iRet = GLMA_SUCCESS ;

	mov	DWORD PTR _iRet$[ebp], 1
$LN3@GetLimitMo:

; 234  :     }

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
	jmp	SHORT $LN10@GetLimitMo
$LN7@GetLimitMo:
$LN12@GetLimitMo:

; 235  :     __except ( EXCEPTION_EXECUTE_HANDLER )

	mov	eax, 1
$LN9@GetLimitMo:
$LN11@GetLimitMo:
	ret	0
$LN8@GetLimitMo:
	mov	esp, DWORD PTR __$SEHRec$[ebp]

; 236  :     {
; 237  :         iRet = GLMA_FAILURE ;

	mov	DWORD PTR _iRet$[ebp], 0

; 238  :     }

	mov	DWORD PTR __$SEHRec$[ebp+20], -2	; fffffffeH
$LN10@GetLimitMo:

; 239  :     return ( iRet ) ;

	mov	eax, DWORD PTR _iRet$[ebp]
$LN6@GetLimitMo:

; 240  : }

	mov	ecx, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?GetLimitModulesArray@@YGHPAPAUHINSTANCE__@@I@Z ENDP	; GetLimitModulesArray
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\crashhandler.cpp
_TEXT	SEGMENT
?GetLimitModuleCount@@YGIXZ PROC			; GetLimitModuleCount

; 204  : {

	push	ebp
	mov	ebp, esp

; 205  :     return ( g_uiModCount ) ;

	mov	eax, DWORD PTR _g_uiModCount

; 206  : }

	pop	ebp
	ret	0
?GetLimitModuleCount@@YGIXZ ENDP			; GetLimitModuleCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\crashhandler.cpp
_TEXT	SEGMENT
_phTemp$ = -4						; size = 4
_hMod$ = 8						; size = 4
?AddCrashHandlerLimitModule@@YGHPAUHINSTANCE__@@@Z PROC	; AddCrashHandlerLimitModule

; 157  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 158  :     // Check the obvious cases.
; 159  :     ASSERT ( NULL != hMod ) ;
; 160  :     if ( NULL == hMod )

	cmp	DWORD PTR _hMod$[ebp], 0
	jne	SHORT $LN4@AddCrashHa

; 161  :     {
; 162  :         return ( FALSE ) ;

	xor	eax, eax
	jmp	$LN5@AddCrashHa
$LN4@AddCrashHa:

; 163  :     }
; 164  : 
; 165  :     // TODO TODO
; 166  :     //  Do the check that hMod really is a PE module.
; 167  : 
; 168  :     // Allocate a temporary version.  This must be allocated into memory
; 169  :     //  that is guaranteed to be around even if the process is toasting.
; 170  :     //  This means the RTL heap is probably already gone so I do it out
; 171  :     //  of the process heap.
; 172  :     HMODULE * phTemp = (HMODULE*)
; 173  :                     HeapAlloc ( GetProcessHeap ( )                 ,
; 174  :                                 HEAP_ZERO_MEMORY |
; 175  :                                    HEAP_GENERATE_EXCEPTIONS        ,
; 176  :                                 (sizeof(HMODULE)*(g_uiModCount+1))  ) ;

	mov	eax, DWORD PTR _g_uiModCount
	lea	ecx, DWORD PTR [eax*4+4]
	push	ecx
	push	12					; 0000000cH
	call	DWORD PTR __imp__GetProcessHeap@0
	push	eax
	call	DWORD PTR __imp__HeapAlloc@12
	mov	DWORD PTR _phTemp$[ebp], eax

; 177  :     ASSERT ( NULL != phTemp ) ;
; 178  :     if ( NULL == phTemp )

	cmp	DWORD PTR _phTemp$[ebp], 0
	jne	SHORT $LN3@AddCrashHa

; 179  :     {
; 180  :         TRACE0 ( "Serious trouble in the house! - malloc failed!!!\n" );
; 181  :         return ( FALSE ) ;

	xor	eax, eax
	jmp	$LN5@AddCrashHa
$LN3@AddCrashHa:

; 182  :     }
; 183  : 
; 184  :     if ( NULL == g_ahMod )

	cmp	DWORD PTR _g_ahMod, 0
	jne	SHORT $LN2@AddCrashHa

; 185  :     {
; 186  :         g_ahMod = phTemp ;

	mov	edx, DWORD PTR _phTemp$[ebp]
	mov	DWORD PTR _g_ahMod, edx

; 187  :         g_ahMod[ 0 ] = hMod ;

	mov	eax, 4
	imul	eax, 0
	mov	ecx, DWORD PTR _g_ahMod
	mov	edx, DWORD PTR _hMod$[ebp]
	mov	DWORD PTR [ecx+eax], edx

; 188  :         g_uiModCount++ ;

	mov	eax, DWORD PTR _g_uiModCount
	add	eax, 1
	mov	DWORD PTR _g_uiModCount, eax

; 189  :     }
; 190  :     else

	jmp	SHORT $LN1@AddCrashHa
$LN2@AddCrashHa:

; 191  :     {
; 192  :         // Copy the old values.
; 193  :         CopyMemory ( phTemp     ,
; 194  :                      g_ahMod    ,
; 195  :                      sizeof ( HMODULE ) * g_uiModCount ) ;

	mov	ecx, DWORD PTR _g_uiModCount
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _g_ahMod
	push	edx
	mov	eax, DWORD PTR _phTemp$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 196  :         g_ahMod = phTemp ;

	mov	ecx, DWORD PTR _phTemp$[ebp]
	mov	DWORD PTR _g_ahMod, ecx

; 197  :         g_ahMod[ g_uiModCount ] = hMod ;

	mov	edx, DWORD PTR _g_uiModCount
	mov	eax, DWORD PTR _g_ahMod
	mov	ecx, DWORD PTR _hMod$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 198  :         g_uiModCount++ ;

	mov	edx, DWORD PTR _g_uiModCount
	add	edx, 1
	mov	DWORD PTR _g_uiModCount, edx
$LN1@AddCrashHa:

; 199  :     }
; 200  :     return ( TRUE ) ;

	mov	eax, 1
$LN5@AddCrashHa:

; 201  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?AddCrashHandlerLimitModule@@YGHPAUHINSTANCE__@@@Z ENDP	; AddCrashHandlerLimitModule
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\zhitao li\documents\visual studio 2012\projects\freefalcon\crashhandler\crashhandler.cpp
_TEXT	SEGMENT
_pFn$ = 8						; size = 4
?SetCrashHandlerFilter@@YGHP6GJPAU_EXCEPTION_POINTERS@@@Z@Z PROC ; SetCrashHandlerFilter

; 123  : {

	push	ebp
	mov	ebp, esp

; 124  :     // It's OK to have a NULL parameter because this will unhook the
; 125  :     //  callback.
; 126  :     if ( NULL == pFn )

	cmp	DWORD PTR _pFn$[ebp], 0
	jne	SHORT $LN5@SetCrashHa

; 127  :     {
; 128  :         if ( NULL != g_pfnOrigFilt )

	cmp	DWORD PTR _g_pfnOrigFilt, 0
	je	SHORT $LN4@SetCrashHa

; 129  :         {
; 130  :             // Put the original one back.
; 131  :             SetUnhandledExceptionFilter ( g_pfnOrigFilt ) ;

	mov	eax, DWORD PTR _g_pfnOrigFilt
	push	eax
	call	DWORD PTR __imp__SetUnhandledExceptionFilter@4

; 132  :             g_pfnOrigFilt = NULL ;

	mov	DWORD PTR _g_pfnOrigFilt, 0

; 133  :             if ( NULL != g_ahMod )

	cmp	DWORD PTR _g_ahMod, 0
	je	SHORT $LN3@SetCrashHa

; 134  :             {
; 135  :                 free ( g_ahMod ) ;

	mov	ecx, DWORD PTR _g_ahMod
	push	ecx
	call	_free
	add	esp, 4

; 136  :                 g_ahMod = NULL ;

	mov	DWORD PTR _g_ahMod, 0
$LN3@SetCrashHa:

; 137  :             }
; 138  :             g_pfnCallBack = NULL ;

	mov	DWORD PTR _g_pfnCallBack, 0
$LN4@SetCrashHa:

; 139  :         }
; 140  :     }
; 141  :     else

	jmp	SHORT $LN2@SetCrashHa
$LN5@SetCrashHa:

; 142  :     {
; 143  :         g_pfnCallBack = pFn ;

	mov	edx, DWORD PTR _pFn$[ebp]
	mov	DWORD PTR _g_pfnCallBack, edx

; 144  : 
; 145  :         // If this is the first time that CrashHandler has been called
; 146  :         //  set the exception filter and save off the previous handler.
; 147  :         if ( NULL == g_pfnOrigFilt )

	cmp	DWORD PTR _g_pfnOrigFilt, 0
	jne	SHORT $LN2@SetCrashHa

; 148  :         {
; 149  :             g_pfnOrigFilt =
; 150  :                SetUnhandledExceptionFilter(CrashHandlerExceptionFilter);

	push	OFFSET ?CrashHandlerExceptionFilter@@YGJPAU_EXCEPTION_POINTERS@@@Z ; CrashHandlerExceptionFilter
	call	DWORD PTR __imp__SetUnhandledExceptionFilter@4
	mov	DWORD PTR _g_pfnOrigFilt, eax
$LN2@SetCrashHa:

; 151  :         }
; 152  :     }
; 153  :     return ( TRUE ) ;

	mov	eax, 1

; 154  : }

	pop	ebp
	ret	4
?SetCrashHandlerFilter@@YGHP6GJPAU_EXCEPTION_POINTERS@@@Z@Z ENDP ; SetCrashHandlerFilter
_TEXT	ENDS
END
